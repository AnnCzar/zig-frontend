import {
  __commonJS,
  __publicField
} from "./chunk-EQCVQC35.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/verge3d/build/v3d.module.js
var REVISION = "4.9.2";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var BasicShadowMap = 0;
var BilinearShadowMap = 1;
var PCFShadowMap = 2;
var ESMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var TwoPassDoubleSide = 3;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var LogarithmicMaxToneMapping = 6;
var PhysicalMaxToneMapping = 7;
var FilmicBlenderToneMapping = 8;
var AgXBlenderToneMapping = 9;
var PbrNeutralToneMapping = 10;
var ToneMappingLookNone = 0;
var ToneMappingLookAgXPunchy = 1;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var LinearDepthPacking = 3202;
var RGBADistancePacking = 3301;
var ESMDistancePacking = 3302;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var NoColorSpace = "";
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;
var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;
var GLSL1 = "100";
var GLSL3 = "300 es";
var _SRGBAFormat = 1035;
var MOD_SUITE = "ALL";
var V3DL = "__V3DL__0000000000";
var ViewportFitNone = 0;
var ViewportFitVertical = 1;
var ViewportFitHorizontal = 2;
var ViewportFitAuto = 3;
var ViewportFitFill = 4;
var ViewportFitOverscan = 5;
var IBLEnvironmentPMREM = 0;
var IBLEnvironmentProbe = 1;
var IBLEnvironmentNone = 2;
var TweenLinear = 0;
var TweenSpherical = 1;
var ReflectionProbeTypeInfinite = 0;
var ReflectionProbeTypeSphere = 1;
var ReflectionProbeTypeBox = 2;
var NoOIT = 0;
var OITWeighted = 1;
var ConstraintSpaceWorld = 0;
var ConstraintSpaceCustom = 1;
var ConstraintSpaceLocal = 2;
var EventDispatcher = class {
  addEventListener(e, t) {
    void 0 === this._listeners && (this._listeners = {});
    const n = this._listeners;
    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (void 0 === this._listeners) return false;
    const n = this._listeners;
    return void 0 !== n[e] && -1 !== n[e].indexOf(t);
  }
  removeEventListener(e, t) {
    if (void 0 === this._listeners) return;
    const n = this._listeners[e];
    if (void 0 !== n) {
      const e2 = n.indexOf(t);
      -1 !== e2 && n.splice(e2, 1);
    }
  }
  dispatchEvent(e) {
    if (void 0 === this._listeners) return;
    const t = this._listeners[e.type];
    if (void 0 !== t) {
      e.target = this;
      const n = t.slice(0);
      for (let t2 = 0, o = n.length; t2 < o; t2++) n[t2].call(this, e);
      e.target = null;
    }
  }
};
var UUID_PATTERN = new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
function generateUUID() {
  const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, o = 4294967295 * Math.random() | 0;
  return (_lut[255 & e] + _lut[e >> 8 & 255] + _lut[e >> 16 & 255] + _lut[e >> 24 & 255] + "-" + _lut[255 & t] + _lut[t >> 8 & 255] + "-" + _lut[t >> 16 & 15 | 64] + _lut[t >> 24 & 255] + "-" + _lut[63 & n | 128] + _lut[n >> 8 & 255] + "-" + _lut[n >> 16 & 255] + _lut[n >> 24 & 255] + _lut[255 & o] + _lut[o >> 8 & 255] + _lut[o >> 16 & 255] + _lut[o >> 24 & 255]).toLowerCase();
}
function checkUUID(e) {
  return UUID_PATTERN.test(e);
}
function clamp(e, t = 0, n = 1) {
  return Math.max(t, Math.min(n, e));
}
function euclideanModulo(e, t) {
  return (e % t + t) % t;
}
function mapLinear(e, t, n, o, r) {
  return o + (e - t) * (r - o) / (n - t);
}
function inverseLerp(e, t, n) {
  return e !== t ? (n - e) / (t - e) : 0;
}
function lerp(e, t, n) {
  return (1 - n) * e + n * t;
}
function damp(e, t, n, o) {
  return lerp(e, t, 1 - Math.exp(-n * o));
}
function pingpong(e, t = 1) {
  return t - Math.abs(euclideanModulo(e, 2 * t) - t);
}
function smoothstep(e, t, n) {
  return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
}
function smootherstep(e, t, n) {
  return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
}
function randInt(e, t) {
  return e + Math.floor(Math.random() * (t - e + 1));
}
function randFloat(e, t) {
  return e + Math.random() * (t - e);
}
function randFloatSpread(e) {
  return e * (0.5 - Math.random());
}
function seededRandom(e) {
  void 0 !== e && (_seed = e);
  let t = _seed += 1831565813;
  return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(e) {
  return e * DEG2RAD;
}
function radToDeg(e) {
  return e * RAD2DEG;
}
function isPowerOfTwo(e) {
  return !(e & e - 1) && 0 !== e;
}
function ceilPowerOfTwo(e) {
  return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
}
function floorPowerOfTwo(e) {
  return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
}
function setQuaternionFromProperEuler(e, t, n, o, r) {
  const i = Math.cos, a = Math.sin, s = i(n / 2), l = a(n / 2), c = i((t + o) / 2), u = a((t + o) / 2), d = i((t - o) / 2), h = a((t - o) / 2), f = i((o - t) / 2), p = a((o - t) / 2);
  switch (r) {
    case "XYX":
      e.set(s * u, l * d, l * h, s * c);
      break;
    case "YZY":
      e.set(l * h, s * u, l * d, s * c);
      break;
    case "ZXZ":
      e.set(l * d, l * h, s * u, s * c);
      break;
    case "XZX":
      e.set(s * u, l * p, l * f, s * c);
      break;
    case "YXY":
      e.set(l * f, s * u, l * p, s * c);
      break;
    case "ZYZ":
      e.set(l * p, l * f, s * u, s * c);
      break;
    default:
      console.warn("v3d.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function denormalize(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint16Array:
      return e / 65535;
    case Uint8Array:
      return e / 255;
    case Int16Array:
      return Math.max(e / 32767, -1);
    case Int8Array:
      return Math.max(e / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint16Array:
      return Math.round(65535 * e);
    case Uint8Array:
      return Math.round(255 * e);
    case Int16Array:
      return Math.round(32767 * e);
    case Int8Array:
      return Math.round(127 * e);
    default:
      throw new Error("Invalid component type.");
  }
}
function hashString(e) {
  let t = 5381, n = e.length;
  for (; n; ) t = 33 * t ^ e.charCodeAt(--n);
  return t >>> 0;
}
function expAverage(e, t, n, o) {
  let r = Math.exp(-n / o);
  return e * r + (1 - r) * t;
}
function expAverageClamp(e, t, n, o, r) {
  let i = expAverage(e, t, n, o);
  return Math.abs(e - t) < r && (i = t), i;
}
function angleToRange_0_2Pi(e) {
  return clamp(e - 2 * Math.PI * Math.floor(e / (2 * Math.PI)), 0, 2 * Math.PI);
}
function angleToRange_mPi_Pi(e) {
  let t = e + Math.PI;
  return t %= 2 * Math.PI, t += 2 * Math.PI, t %= 2 * Math.PI, t -= Math.PI, t;
}
function clampAngle(e, t, n) {
  let o = angleToRange_0_2Pi(e - t), r = angleToRange_0_2Pi(n - t);
  return o > r && (o = o < r / 2 + Math.PI ? r : 0), o + t;
}
var MathUtils = Object.freeze({ __proto__: null, DEG2RAD, RAD2DEG, angleToRange_0_2Pi, angleToRange_mPi_Pi, ceilPowerOfTwo, checkUUID, clamp, clampAngle, damp, degToRad, denormalize, euclideanModulo, expAverage, expAverageClamp, floorPowerOfTwo, generateUUID, hashString, inverseLerp, isPowerOfTwo, lerp, mapLinear, normalize, pingpong, radToDeg, randFloat, randFloatSpread, randInt, seededRandom, setQuaternionFromProperEuler, smootherstep, smoothstep });
var Vector2 = class _Vector2 {
  constructor(e = 0, t = 0) {
    _Vector2.prototype.isVector2 = true, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, o = e.elements;
    return this.x = o[0] * t + o[3] * n + o[6], this.y = o[1] * t + o[4] * n + o[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), o = Math.sin(t), r = this.x - e.x, i = this.y - e.y;
    return this.x = r * n - i * o + e.x, this.y = r * o + i * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
};
var Matrix3 = class _Matrix3 {
  constructor() {
    _Matrix3.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(e, t, n, o, r, i, a, s, l) {
    const c = this.elements;
    return c[0] = e, c[1] = o, c[2] = a, c[3] = t, c[4] = r, c[5] = s, c[6] = n, c[7] = i, c[8] = l, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, o = t.elements, r = this.elements, i = n[0], a = n[3], s = n[6], l = n[1], c = n[4], u = n[7], d = n[2], h = n[5], f = n[8], p = o[0], m = o[3], g = o[6], _ = o[1], A = o[4], v = o[7], x = o[2], y = o[5], b = o[8];
    return r[0] = i * p + a * _ + s * x, r[3] = i * m + a * A + s * y, r[6] = i * g + a * v + s * b, r[1] = l * p + c * _ + u * x, r[4] = l * m + c * A + u * y, r[7] = l * g + c * v + u * b, r[2] = d * p + h * _ + f * x, r[5] = d * m + h * A + f * y, r[8] = d * g + h * v + f * b, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], o = e[2], r = e[3], i = e[4], a = e[5], s = e[6], l = e[7], c = e[8];
    return t * i * c - t * a * l - n * r * c + n * a * s + o * r * l - o * i * s;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], o = e[2], r = e[3], i = e[4], a = e[5], s = e[6], l = e[7], c = e[8], u = c * i - a * l, d = a * s - c * r, h = l * r - i * s, f = t * u + n * d + o * h;
    if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const p = 1 / f;
    return e[0] = u * p, e[1] = (o * l - c * n) * p, e[2] = (a * n - o * i) * p, e[3] = d * p, e[4] = (c * t - o * s) * p, e[5] = (o * r - a * t) * p, e[6] = h * p, e[7] = (n * s - l * t) * p, e[8] = (i * t - n * r) * p, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, o, r, i, a) {
    const s = Math.cos(r), l = Math.sin(r);
    return this.set(n * s, n * l, -n * (s * i + l * a) + i + e, -o * l, o * s, -o * (-l * i + s * a) + a + t, 0, 0, 1), this;
  }
  scale(e, t) {
    return this.premultiply(_m3.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(_m3.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(_m3.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let e2 = 0; e2 < 9; e2++) if (t[e2] !== n[e2]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var _m3 = new Matrix3();
function arrayMin(e) {
  if (0 === e.length) return 1 / 0;
  let t = e[0];
  for (let n = 1, o = e.length; n < o; ++n) e[n] < t && (t = e[n]);
  return t;
}
function arrayMax(e) {
  if (0 === e.length) return -1 / 0;
  let t = e[0];
  for (let n = 1, o = e.length; n < o; ++n) e[n] > t && (t = e[n]);
  return t;
}
function arrayNeedsUint32(e) {
  for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return true;
  return false;
}
function createElementNS(e) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", e);
}
function isDef(e) {
  return void 0 !== e;
}
function clampArray(e, t, n) {
  for (let o = 0; o < e.length; o++) e[o] = clamp(e[o], t, n);
  return e;
}
function strTitle(e) {
  return e.charAt(0).toUpperCase() + e.slice(1).toLowerCase();
}
function strToCamel(e) {
  return e.toLowerCase().replace(/_([a-zA-Z])/g, function(e2) {
    return e2[1].toUpperCase();
  });
}
function getVerge3DVariantName() {
  return "Ultimate";
}
function parseEngineVersion(e) {
  const t = e.match(/^[a-zA-Z38 ]*(\d+).(\d+).(\d+)(?: (.*))?$/) ?? [];
  let n = Number(t[1]), o = Number(t[2]), r = Number(t[3]);
  n = Number.isNaN(n) ? 0 : n, o = Number.isNaN(o) ? 0 : o, r = Number.isNaN(r) ? 0 : r;
  return { major: n, minor: o, patch: r, pre: t[4] ?? "" };
}
function engineVersionPreToNumber(e) {
  if ("" === e) return 1 / 0;
  const t = e.match(/^pre(\d+)$/) ?? [];
  let n = Number(t[1]);
  return n = Number.isNaN(n) ? 0 : n, n;
}
function engineVersionCmp(e, t, n = 3) {
  const o = parseEngineVersion(e), r = parseEngineVersion(t);
  let i = r.major - o.major;
  return 0 === i && n > 1 && (i = r.minor - o.minor, 0 === i && n > 2 && (i = r.patch - o.patch, 0 === i && n > 3 && (i = engineVersionPreToNumber(r.pre) - engineVersionPreToNumber(o.pre), isNaN(i) && (i = 0)))), Math.sign(i);
}
function shaderFloatStr(e) {
  return `${e % 1 ? e : `${e}.0`}`;
}
function getGlobalScope() {
  return "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
}
var modulesInfo = {};
function findModulePath(e = "") {
  const t = document.getElementsByTagName("script");
  let n = e;
  for (let o = t.length - 1; o >= 0; --o) {
    const r = t[o].src, i = r.search(/\/v3d[\w.]+js/);
    i > -1 && (n = r.substr(0, i) + "/" + e);
  }
  return n;
}
function loadModule(e, t = function(e2) {
}, n = function(e2) {
}) {
  modulesInfo[e] = modulesInfo[e] || { status: 0, loadCallbacks: [], errorCallbacks: [] };
  const o = modulesInfo[e];
  if (4 == o.status) return void t(e);
  if (o.loadCallbacks.push(t), o.errorCallbacks.push(n), o.status > 0) return;
  let r = findModulePath(e);
  const i = document.createElement("script");
  i.type = "text/javascript", i.src = r, function(e2) {
    i.onload = function() {
      modulesInfo[e2].loadCallbacks.forEach(function(t2) {
        t2(e2);
      }), modulesInfo[e2].status = 4;
    }, i.onerror = function() {
      modulesInfo[e2].errorCallbacks.forEach(function(t2) {
        t2(e2);
      }), modulesInfo[e2].status = 0;
    };
  }(e), document.getElementsByTagName("head")[0].appendChild(i), o.status = 3;
}
function arrayForEachPromise(e, t, n = 0) {
  const o = function(e2, o2, r2, i) {
    const a = performance.now();
    return t(e2, o2, r2), a - i > n ? (i = a, new Promise(function(e3) {
      setTimeout(function() {
        e3(i);
      }, 1);
    })) : i;
  };
  let r = Promise.resolve(performance.now());
  return e.forEach(function(e2, t2, n2) {
    r = r.then(o.bind(null, e2, t2, n2));
  }), r;
}
function SRGBToLinear(e) {
  return e < 0.04045 ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
}
function LinearToSRGB(e) {
  return e < 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
var FN = { [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear }, [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB } };
var ColorManagement = { legacyMode: true, get workingColorSpace() {
  return "srgb-linear";
}, set workingColorSpace(e) {
  console.warn("v3d.ColorManagement: .workingColorSpace is readonly.");
}, convert: function(e, t, n) {
  if (this.legacyMode || t === n || !t || !n) return e;
  if (FN[t] && void 0 !== FN[t][n]) {
    const o = FN[t][n];
    return e.r = o(e.r), e.g = o(e.g), e.b = o(e.b), e;
  }
  throw new Error("Unsupported color space conversion.");
}, fromWorkingColorSpace: function(e, t) {
  return this.convert(e, this.workingColorSpace, t);
}, toWorkingColorSpace: function(e, t) {
  return this.convert(e, t, this.workingColorSpace);
} };
var _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
var _rgb$1 = { r: 0, g: 0, b: 0 };
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < 0.5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e;
}
function toComponents(e, t) {
  return t.r = e.r, t.g = e.g, t.b = e.b, t;
}
var Color = class {
  constructor(e, t, n) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = "srgb") {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, ColorManagement.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, o = ColorManagement.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, ColorManagement.toWorkingColorSpace(this, o), this;
  }
  setHSL(e, t, n, o = ColorManagement.workingColorSpace) {
    if (e = euclideanModulo(e, 1), t = clamp(t, 0, 1), n = clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
    else {
      const o2 = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - o2;
      this.r = hue2rgb(r, o2, e + 1 / 3), this.g = hue2rgb(r, o2, e), this.b = hue2rgb(r, o2, e - 1 / 3);
    }
    return ColorManagement.toWorkingColorSpace(this, o), this;
  }
  setStyle(e, t = "srgb") {
    function n(t2) {
      void 0 !== t2 && parseFloat(t2) < 1 && console.warn("v3d.Color: Alpha component of " + e + " will be ignored.");
    }
    let o;
    if (o = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let e2;
      const r = o[1], i = o[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (e2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(e2[1], 10)) / 255, this.g = Math.min(255, parseInt(e2[2], 10)) / 255, this.b = Math.min(255, parseInt(e2[3], 10)) / 255, ColorManagement.toWorkingColorSpace(this, t), n(e2[4]), this;
          if (e2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(e2[1], 10)) / 100, this.g = Math.min(100, parseInt(e2[2], 10)) / 100, this.b = Math.min(100, parseInt(e2[3], 10)) / 100, ColorManagement.toWorkingColorSpace(this, t), n(e2[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (e2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
            const o2 = parseFloat(e2[1]) / 360, r2 = parseFloat(e2[2]) / 100, i2 = parseFloat(e2[3]) / 100;
            return n(e2[4]), this.setHSL(o2, r2, i2, t);
          }
      }
    } else if (o = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const e2 = o[1], n2 = e2.length;
      if (3 === n2) return this.r = parseInt(e2.charAt(0) + e2.charAt(0), 16) / 255, this.g = parseInt(e2.charAt(1) + e2.charAt(1), 16) / 255, this.b = parseInt(e2.charAt(2) + e2.charAt(2), 16) / 255, ColorManagement.toWorkingColorSpace(this, t), this;
      if (6 === n2) return this.r = parseInt(e2.charAt(0) + e2.charAt(1), 16) / 255, this.g = parseInt(e2.charAt(2) + e2.charAt(3), 16) / 255, this.b = parseInt(e2.charAt(4) + e2.charAt(5), 16) / 255, ColorManagement.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = "srgb") {
    const n = _colorKeywords[e.toLowerCase()];
    return void 0 !== n ? this.setHex(n, t) : console.warn("v3d.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = "srgb") {
    return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), e), clamp(255 * _rgb$1.r, 0, 255) << 16 ^ clamp(255 * _rgb$1.g, 0, 255) << 8 ^ clamp(255 * _rgb$1.b, 0, 255);
  }
  getHexString(e = "srgb") {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), t);
    const n = _rgb$1.r, o = _rgb$1.g, r = _rgb$1.b, i = Math.max(n, o, r), a = Math.min(n, o, r);
    let s, l;
    const c = (a + i) / 2;
    if (a === i) s = 0, l = 0;
    else {
      const e2 = i - a;
      switch (l = c <= 0.5 ? e2 / (i + a) : e2 / (2 - i - a), i) {
        case n:
          s = (o - r) / e2 + (o < r ? 6 : 0);
          break;
        case o:
          s = (r - n) / e2 + 2;
          break;
        case r:
          s = (n - o) / e2 + 4;
      }
      s /= 6;
    }
    return e.h = s, e.s = l, e.l = c, e;
  }
  getRGB(e, t = ColorManagement.workingColorSpace) {
    return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), t), e.r = _rgb$1.r, e.g = _rgb$1.g, e.b = _rgb$1.b, e;
  }
  getStyle(e = "srgb") {
    return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), e), "srgb" !== e ? `color(${e} ${_rgb$1.r} ${_rgb$1.g} ${_rgb$1.b})` : `rgb(${255 * _rgb$1.r | 0},${255 * _rgb$1.g | 0},${255 * _rgb$1.b | 0})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(_hslA), _hslA.h += e, _hslA.s += t, _hslA.l += n, this.setHSL(_hslA.h, _hslA.s, _hslA.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(_hslA), e.getHSL(_hslB);
    const n = lerp(_hslA.h, _hslB.h, t), o = lerp(_hslA.s, _hslB.s, t), r = lerp(_hslA.l, _hslB.l, t);
    return this.setHSL(n, o, r), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
var _canvas;
Color.NAMES = _colorKeywords;
var ImageUtils = class {
  static getDataURL(e) {
    if (/^data:/i.test(e.src)) return e.src;
    if ("undefined" == typeof HTMLCanvasElement) return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      void 0 === _canvas && (_canvas = createElementNS("canvas")), _canvas.width = e.width, _canvas.height = e.height;
      const n = _canvas.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = _canvas;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("v3d.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
      const t = createElementNS("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const o = n.getImageData(0, 0, e.width, e.height), r = o.data;
      for (let e2 = 0; e2 < r.length; e2++) r[e2] = 255 * SRGBToLinear(r[e2] / 255);
      return n.putImageData(o, 0, 0), t;
    }
    if (e.data) {
      const t = e.data.slice(0);
      for (let e2 = 0; e2 < t.length; e2++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e2] = Math.floor(255 * SRGBToLinear(t[e2] / 255)) : t[e2] = SRGBToLinear(t[e2]);
      return { data: t, width: e.width, height: e.height };
    }
    return console.warn("v3d.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
};
var _sourceId = 0;
var Source = class {
  constructor(e = null) {
    this.isSource = true, Object.defineProperty(this, "id", { value: _sourceId++ }), this.uuid = generateUUID(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    true === e && this.version++;
  }
};
var textureId = 0;
var Texture = class _Texture extends EventDispatcher {
  constructor(e = _Texture.DEFAULT_IMAGE, t = _Texture.DEFAULT_MAPPING, n = 1001, o = 1001, r = 1006, i = 1008, a = 1023, s = 1009, l = _Texture.DEFAULT_ANISOTROPY, c = 3e3) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: textureId++ }), this.uuid = generateUUID(), this.name = "", this.source = new Source(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = o, this.magFilter = r, this.minFilter = i, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = s, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Matrix3(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (300 !== this.mapping) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
      case 1e3:
        e.x = e.x - Math.floor(e.x);
        break;
      case 1001:
        e.x = e.x < 0 ? 0 : 1;
        break;
      case 1002:
        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
    }
    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
      case 1e3:
        e.y = e.y - Math.floor(e.y);
        break;
      case 1001:
        e.y = e.y < 0 ? 0 : 1;
        break;
      case 1002:
        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
    }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    true === e && (this.version++, this.source.needsUpdate = true);
  }
};
Texture.DEFAULT_IMAGE = null, Texture.DEFAULT_MAPPING = 300, Texture.DEFAULT_ANISOTROPY = 1;
var Vector4 = class _Vector4 {
  constructor(e = 0, t = 0, n = 0, o = 1) {
    _Vector4.prototype.isVector4 = true, this.x = e, this.y = t, this.z = n, this.w = o;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, o) {
    return this.x = e, this.y = t, this.z = n, this.w = o, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, o = this.z, r = this.w, i = e.elements;
    return this.x = i[0] * t + i[4] * n + i[8] * o + i[12] * r, this.y = i[1] * t + i[5] * n + i[9] * o + i[13] * r, this.z = i[2] * t + i[6] * n + i[10] * o + i[14] * r, this.w = i[3] * t + i[7] * n + i[11] * o + i[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, o, r;
    const i = 0.01, a = 0.1, s = e.elements, l = s[0], c = s[4], u = s[8], d = s[1], h = s[5], f = s[9], p = s[2], m = s[6], g = s[10];
    if (Math.abs(c - d) < i && Math.abs(u - p) < i && Math.abs(f - m) < i) {
      if (Math.abs(c + d) < a && Math.abs(u + p) < a && Math.abs(f + m) < a && Math.abs(l + h + g - 3) < a) return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const e2 = (l + 1) / 2, s2 = (h + 1) / 2, _2 = (g + 1) / 2, A = (c + d) / 4, v = (u + p) / 4, x = (f + m) / 4;
      return e2 > s2 && e2 > _2 ? e2 < i ? (n = 0, o = 0.707106781, r = 0.707106781) : (n = Math.sqrt(e2), o = A / n, r = v / n) : s2 > _2 ? s2 < i ? (n = 0.707106781, o = 0, r = 0.707106781) : (o = Math.sqrt(s2), n = A / o, r = x / o) : _2 < i ? (n = 0.707106781, o = 0.707106781, r = 0) : (r = Math.sqrt(_2), n = v / r, o = x / r), this.set(n, o, r, t), this;
    }
    let _ = Math.sqrt((m - f) * (m - f) + (u - p) * (u - p) + (d - c) * (d - c));
    return Math.abs(_) < 1e-3 && (_ = 1), this.x = (m - f) / _, this.y = (u - p) / _, this.z = (d - c) / _, this.w = Math.acos((l + h + g - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
};
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isWebGLRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new Vector4(0, 0, e, t), this.scissorTest = false, this.viewport = new Vector4(0, 0, e, t);
    const o = { width: e, height: t, depth: 1 };
    this.texture = new Texture(o, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0;
  }
  setSize(e, t, n = 1) {
    this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = true;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Source(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var DataArrayTexture = class extends Texture {
  constructor(e = null, t = 1, n = 1, o = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: e, width: t, height: n, depth: o }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
var WebGLArrayRenderTarget = class extends WebGLRenderTarget {
  constructor(e = 1, t = 1, n = 1) {
    super(e, t), this.isWebGLArrayRenderTarget = true, this.depth = n, this.texture = new DataArrayTexture(null, e, t, n), this.texture.isRenderTargetTexture = true;
  }
};
var Data3DTexture = class extends Texture {
  constructor(e = null, t = 1, n = 1, o = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: e, width: t, height: n, depth: o }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
var WebGL3DRenderTarget = class extends WebGLRenderTarget {
  constructor(e = 1, t = 1, n = 1) {
    super(e, t), this.isWebGL3DRenderTarget = true, this.depth = n, this.texture = new Data3DTexture(null, e, t, n), this.texture.isRenderTargetTexture = true;
  }
};
var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
  constructor(e = 1, t = 1, n = 1, o = {}) {
    super(e, t, o), this.isWebGLMultipleRenderTargets = true;
    const r = this.texture;
    this.texture = [];
    for (let e2 = 0; e2 < n; e2++) this.texture[e2] = r.clone(), this.texture[e2].isRenderTargetTexture = true;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let o = 0, r = this.texture.length; o < r; o++) this.texture[o].image.width = e, this.texture[o].image.height = t, this.texture[o].image.depth = n;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = true;
    return this;
  }
};
var Quaternion = class {
  constructor(e = 0, t = 0, n = 0, o = 1) {
    this.isQuaternion = true, this._x = e, this._y = t, this._z = n, this._w = o;
  }
  static slerpFlat(e, t, n, o, r, i, a) {
    let s = n[o + 0], l = n[o + 1], c = n[o + 2], u = n[o + 3];
    const d = r[i + 0], h = r[i + 1], f = r[i + 2], p = r[i + 3];
    if (0 === a) return e[t + 0] = s, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u);
    if (1 === a) return e[t + 0] = d, e[t + 1] = h, e[t + 2] = f, void (e[t + 3] = p);
    if (u !== p || s !== d || l !== h || c !== f) {
      let e2 = 1 - a;
      const t2 = s * d + l * h + c * f + u * p, n2 = t2 >= 0 ? 1 : -1, o2 = 1 - t2 * t2;
      if (o2 > Number.EPSILON) {
        const r3 = Math.sqrt(o2), i2 = Math.atan2(r3, t2 * n2);
        e2 = Math.sin(e2 * i2) / r3, a = Math.sin(a * i2) / r3;
      }
      const r2 = a * n2;
      if (s = s * e2 + d * r2, l = l * e2 + h * r2, c = c * e2 + f * r2, u = u * e2 + p * r2, e2 === 1 - a) {
        const e3 = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
        s *= e3, l *= e3, c *= e3, u *= e3;
      }
    }
    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, n, o, r, i) {
    const a = n[o], s = n[o + 1], l = n[o + 2], c = n[o + 3], u = r[i], d = r[i + 1], h = r[i + 2], f = r[i + 3];
    return e[t] = a * f + c * u + s * h - l * d, e[t + 1] = s * f + c * d + l * u - a * h, e[t + 2] = l * f + c * h + a * d - s * u, e[t + 3] = c * f - a * u - s * d - l * h, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, o) {
    return this._x = e, this._y = t, this._z = n, this._w = o, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const n = e._x, o = e._y, r = e._z, i = e._order, a = Math.cos, s = Math.sin, l = a(n / 2), c = a(o / 2), u = a(r / 2), d = s(n / 2), h = s(o / 2), f = s(r / 2);
    switch (i) {
      case "XYZ":
        this._x = d * c * u + l * h * f, this._y = l * h * u - d * c * f, this._z = l * c * f + d * h * u, this._w = l * c * u - d * h * f;
        break;
      case "YXZ":
        this._x = d * c * u + l * h * f, this._y = l * h * u - d * c * f, this._z = l * c * f - d * h * u, this._w = l * c * u + d * h * f;
        break;
      case "ZXY":
        this._x = d * c * u - l * h * f, this._y = l * h * u + d * c * f, this._z = l * c * f + d * h * u, this._w = l * c * u - d * h * f;
        break;
      case "ZYX":
        this._x = d * c * u - l * h * f, this._y = l * h * u + d * c * f, this._z = l * c * f - d * h * u, this._w = l * c * u + d * h * f;
        break;
      case "YZX":
        this._x = d * c * u + l * h * f, this._y = l * h * u + d * c * f, this._z = l * c * f - d * h * u, this._w = l * c * u - d * h * f;
        break;
      case "XZY":
        this._x = d * c * u - l * h * f, this._y = l * h * u - d * c * f, this._z = l * c * f + d * h * u, this._w = l * c * u + d * h * f;
        break;
      default:
        console.warn("v3d.Quaternion: .setFromEuler() encountered an unknown order: " + i);
    }
    return false !== t && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, o = Math.sin(n);
    return this._x = e.x * o, this._y = e.y * o, this._z = e.z * o, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], o = t[4], r = t[8], i = t[1], a = t[5], s = t[9], l = t[2], c = t[6], u = t[10], d = n + a + u;
    if (d > 0) {
      const e2 = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / e2, this._x = (c - s) * e2, this._y = (r - l) * e2, this._z = (i - o) * e2;
    } else if (n > a && n > u) {
      const e2 = 2 * Math.sqrt(1 + n - a - u);
      this._w = (c - s) / e2, this._x = 0.25 * e2, this._y = (o + i) / e2, this._z = (r + l) / e2;
    } else if (a > u) {
      const e2 = 2 * Math.sqrt(1 + a - n - u);
      this._w = (r - l) / e2, this._x = (o + i) / e2, this._y = 0.25 * e2, this._z = (s + c) / e2;
    } else {
      const e2 = 2 * Math.sqrt(1 + u - n - a);
      this._w = (i - o) / e2, this._x = (r + l) / e2, this._y = (s + c) / e2, this._z = 0.25 * e2;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (0 === n) return this;
    const o = Math.min(1, t / n);
    return this.slerp(e, o), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, o = e._y, r = e._z, i = e._w, a = t._x, s = t._y, l = t._z, c = t._w;
    return this._x = n * c + i * a + o * l - r * s, this._y = o * c + i * s + r * a - n * l, this._z = r * c + i * l + n * s - o * a, this._w = i * c - n * a - o * s - r * l, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (0 === t) return this;
    if (1 === t) return this.copy(e);
    const n = this._x, o = this._y, r = this._z, i = this._w;
    let a = i * e._w + n * e._x + o * e._y + r * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = i, this._x = n, this._y = o, this._z = r, this;
    const s = 1 - a * a;
    if (s <= Number.EPSILON) {
      const e2 = 1 - t;
      return this._w = e2 * i + t * this._w, this._x = e2 * n + t * this._x, this._y = e2 * o + t * this._y, this._z = e2 * r + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l = Math.sqrt(s), c = Math.atan2(l, a), u = Math.sin((1 - t) * c) / l, d = Math.sin(t * c) / l;
    return this._w = i * u + this._w * d, this._x = n * u + this._x * d, this._y = o * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), o = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random();
    return this.set(t * Math.cos(o), n * Math.sin(r), n * Math.cos(r), t * Math.sin(o));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
var Vector3 = class _Vector3 {
  constructor(e = 0, t = 0, n = 0) {
    _Vector3.prototype.isVector3 = true, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, o = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * o, this.y = r[1] * t + r[4] * n + r[7] * o, this.z = r[2] * t + r[5] * n + r[8] * o, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, o = this.z, r = e.elements, i = 1 / (r[3] * t + r[7] * n + r[11] * o + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * o + r[12]) * i, this.y = (r[1] * t + r[5] * n + r[9] * o + r[13]) * i, this.z = (r[2] * t + r[6] * n + r[10] * o + r[14]) * i, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, o = this.z, r = e.x, i = e.y, a = e.z, s = e.w, l = s * t + i * o - a * n, c = s * n + a * t - r * o, u = s * o + r * n - i * t, d = -r * t - i * n - a * o;
    return this.x = l * s + d * -r + c * -a - u * -i, this.y = c * s + d * -i + u * -r - l * -a, this.z = u * s + d * -a + l * -i - c * -r, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, o = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * o, this.y = r[1] * t + r[5] * n + r[9] * o, this.z = r[2] * t + r[6] * n + r[10] * o, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, o = e.y, r = e.z, i = t.x, a = t.y, s = t.z;
    return this.x = o * s - r * a, this.y = r * i - n * s, this.z = n * a - o * i, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (0 === t) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return _vector$c.copy(this).projectOnVector(e), this.sub(_vector$c);
  }
  reflect(e) {
    return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (0 === t) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(clamp(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, o = this.z - e.z;
    return t * t + n * n + o * o;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const o = Math.sin(t) * e;
    return this.x = o * Math.sin(n), this.y = Math.cos(t) * e, this.z = o * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), o = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = o, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = 2 * (Math.random() - 0.5), t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
var _vector$c = new Vector3();
var _quaternion$4 = new Quaternion();
var Box3 = class {
  constructor(e = new Vector3(1 / 0, 1 / 0, 1 / 0), t = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, n = 1 / 0, o = 1 / 0, r = -1 / 0, i = -1 / 0, a = -1 / 0;
    for (let s = 0, l = e.length; s < l; s += 3) {
      const l2 = e[s], c = e[s + 1], u = e[s + 2];
      l2 < t && (t = l2), c < n && (n = c), u < o && (o = u), l2 > r && (r = l2), c > i && (i = c), u > a && (a = u);
    }
    return this.min.set(t, n, o), this.max.set(r, i, a), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, n = 1 / 0, o = 1 / 0, r = -1 / 0, i = -1 / 0, a = -1 / 0;
    for (let s = 0, l = e.count; s < l; s++) {
      const l2 = e.getX(s), c = e.getY(s), u = e.getZ(s);
      l2 < t && (t = l2), c < n && (n = c), u < o && (o = u), l2 > r && (r = l2), c > i && (i = c), u > a && (a = u);
    }
    return this.min.set(t, n, o), this.max.set(r, i, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = _vector$b.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = false) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = false) {
    e.updateWorldMatrix(false, false);
    const n = e.geometry;
    if (void 0 !== n) if (t && null != n.attributes && void 0 !== n.attributes.position) {
      const t2 = n.attributes.position;
      for (let n2 = 0, o2 = t2.count; n2 < o2; n2++) _vector$b.fromBufferAttribute(t2, n2).applyMatrix4(e.matrixWorld), this.expandByPoint(_vector$b);
    } else null === n.boundingBox && n.computeBoundingBox(), _box$4.copy(n.boundingBox), _box$4.applyMatrix4(e.matrixWorld), this.union(_box$4);
    const o = e.children;
    for (let e2 = 0, n2 = o.length; e2 < n2; e2++) this.expandByObject(o[e2], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, _vector$b), _vector$b.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return false;
    this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(e.a, _center), _v1$8.subVectors(e.b, _center), _v2$5.subVectors(e.c, _center), _f0.subVectors(_v1$8, _v0$2), _f1.subVectors(_v2$5, _v1$8), _f2.subVectors(_v0$2, _v2$5);
    let t = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
    return !!satForAxes(t, _v0$2, _v1$8, _v2$5, _extents) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!satForAxes(t, _v0$2, _v1$8, _v2$5, _extents) && (_triangleNormal.crossVectors(_f0, _f1), t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(t, _v0$2, _v1$8, _v2$5, _extents)));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return _vector$b.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = 0.5 * this.getSize(_vector$b).length(), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() || (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_points)), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  scale(e) {
    return this.getCenter(_center), _extents.subVectors(this.max, _center), _extents.multiply(e), this.min.copy(_center).sub(_extents), this.max.copy(_center).add(_extents), this;
  }
};
var _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
var _vector$b = new Vector3();
var _box$4 = new Box3();
var _v0$2 = new Vector3();
var _v1$8 = new Vector3();
var _v2$5 = new Vector3();
var _f0 = new Vector3();
var _f1 = new Vector3();
var _f2 = new Vector3();
var _center = new Vector3();
var _extents = new Vector3();
var _triangleNormal = new Vector3();
var _testAxis = new Vector3();
function satForAxes(e, t, n, o, r) {
  for (let i = 0, a = e.length - 3; i <= a; i += 3) {
    _testAxis.fromArray(e, i);
    const a2 = r.x * Math.abs(_testAxis.x) + r.y * Math.abs(_testAxis.y) + r.z * Math.abs(_testAxis.z), s = t.dot(_testAxis), l = n.dot(_testAxis), c = o.dot(_testAxis);
    if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > a2) return false;
  }
  return true;
}
var _box$3 = new Box3();
var _v1$7 = new Vector3();
var _v2$4 = new Vector3();
var Sphere = class {
  constructor(e = new Vector3(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    void 0 !== t ? n.copy(t) : _box$3.setFromPoints(e).getCenter(n);
    let o = 0;
    for (let t2 = 0, r = e.length; t2 < r; t2++) o = Math.max(o, n.distanceToSquared(e[t2]));
    return this.radius = Math.sqrt(o), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
    _v1$7.subVectors(e, this.center);
    const t = _v1$7.lengthSq();
    if (t > this.radius * this.radius) {
      const e2 = Math.sqrt(t), n = 0.5 * (e2 - this.radius);
      this.center.addScaledVector(_v1$7, n / e2), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (true === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (_v2$4.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(_v1$7.copy(e.center).add(_v2$4)), this.expandByPoint(_v1$7.copy(e.center).sub(_v2$4))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$a = new Vector3();
var _segCenter = new Vector3();
var _segDir = new Vector3();
var _diff = new Vector3();
var _edge1 = new Vector3();
var _edge2 = new Vector3();
var _normal$1 = new Vector3();
var Ray = class {
  constructor(e = new Vector3(), t = new Vector3(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _vector$a)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _vector$a.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.direction).multiplyScalar(t).add(this.origin), _vector$a.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, o) {
    _segCenter.copy(e).add(t).multiplyScalar(0.5), _segDir.copy(t).sub(e).normalize(), _diff.copy(this.origin).sub(_segCenter);
    const r = 0.5 * e.distanceTo(t), i = -this.direction.dot(_segDir), a = _diff.dot(this.direction), s = -_diff.dot(_segDir), l = _diff.lengthSq(), c = Math.abs(1 - i * i);
    let u, d, h, f;
    if (c > 0) if (u = i * s - a, d = i * a - s, f = r * c, u >= 0) if (d >= -f) if (d <= f) {
      const e2 = 1 / c;
      u *= e2, d *= e2, h = u * (u + i * d + 2 * a) + d * (i * u + d + 2 * s) + l;
    } else d = r, u = Math.max(0, -(i * d + a)), h = -u * u + d * (d + 2 * s) + l;
    else d = -r, u = Math.max(0, -(i * d + a)), h = -u * u + d * (d + 2 * s) + l;
    else d <= -f ? (u = Math.max(0, -(-i * r + a)), d = u > 0 ? -r : Math.min(Math.max(-r, -s), r), h = -u * u + d * (d + 2 * s) + l) : d <= f ? (u = 0, d = Math.min(Math.max(-r, -s), r), h = d * (d + 2 * s) + l) : (u = Math.max(0, -(i * r + a)), d = u > 0 ? r : Math.min(Math.max(-r, -s), r), h = -u * u + d * (d + 2 * s) + l);
    else d = i > 0 ? -r : r, u = Math.max(0, -(i * d + a)), h = -u * u + d * (d + 2 * s) + l;
    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), o && o.copy(_segDir).multiplyScalar(d).add(_segCenter), h;
  }
  intersectSphere(e, t) {
    _vector$a.subVectors(e.center, this.origin);
    const n = _vector$a.dot(this.direction), o = _vector$a.dot(_vector$a) - n * n, r = e.radius * e.radius;
    if (o > r) return null;
    const i = Math.sqrt(r - o), a = n - i, s = n + i;
    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return null === n ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    if (0 === t) return true;
    return e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, o, r, i, a, s;
    const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return l >= 0 ? (n = (e.min.x - d.x) * l, o = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, o = (e.min.x - d.x) * l), c >= 0 ? (r = (e.min.y - d.y) * c, i = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c, i = (e.min.y - d.y) * c), n > i || r > o ? null : ((r > n || isNaN(n)) && (n = r), (i < o || isNaN(o)) && (o = i), u >= 0 ? (a = (e.min.z - d.z) * u, s = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u, s = (e.min.z - d.z) * u), n > s || a > o ? null : ((a > n || n != n) && (n = a), (s < o || o != o) && (o = s), o < 0 ? null : this.at(n >= 0 ? n : o, t)));
  }
  intersectsBox(e) {
    return null !== this.intersectBox(e, _vector$a);
  }
  intersectTriangle(e, t, n, o, r) {
    _edge1.subVectors(t, e), _edge2.subVectors(n, e), _normal$1.crossVectors(_edge1, _edge2);
    let i, a = this.direction.dot(_normal$1);
    if (a > 0) {
      if (o) return null;
      i = 1;
    } else {
      if (!(a < 0)) return null;
      i = -1, a = -a;
    }
    _diff.subVectors(this.origin, e);
    const s = i * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (s < 0) return null;
    const l = i * this.direction.dot(_edge1.cross(_diff));
    if (l < 0) return null;
    if (s + l > a) return null;
    const c = -i * _diff.dot(_normal$1);
    return c < 0 ? null : this.at(c / a, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class _Matrix4 {
  constructor() {
    _Matrix4.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(e, t, n, o, r, i, a, s, l, c, u, d, h, f, p, m) {
    const g = this.elements;
    return g[0] = e, g[4] = t, g[8] = n, g[12] = o, g[1] = r, g[5] = i, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = d, g[3] = h, g[7] = f, g[11] = p, g[15] = m, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, o = 1 / _v1$6.setFromMatrixColumn(e, 0).length(), r = 1 / _v1$6.setFromMatrixColumn(e, 1).length(), i = 1 / _v1$6.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * o, t[1] = n[1] * o, t[2] = n[2] * o, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * i, t[9] = n[9] * i, t[10] = n[10] * i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, o = e.y, r = e.z, i = Math.cos(n), a = Math.sin(n), s = Math.cos(o), l = Math.sin(o), c = Math.cos(r), u = Math.sin(r);
    if ("XYZ" === e.order) {
      const e2 = i * c, n2 = i * u, o2 = a * c, r2 = a * u;
      t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = n2 + o2 * l, t[5] = e2 - r2 * l, t[9] = -a * s, t[2] = r2 - e2 * l, t[6] = o2 + n2 * l, t[10] = i * s;
    } else if ("YXZ" === e.order) {
      const e2 = s * c, n2 = s * u, o2 = l * c, r2 = l * u;
      t[0] = e2 + r2 * a, t[4] = o2 * a - n2, t[8] = i * l, t[1] = i * u, t[5] = i * c, t[9] = -a, t[2] = n2 * a - o2, t[6] = r2 + e2 * a, t[10] = i * s;
    } else if ("ZXY" === e.order) {
      const e2 = s * c, n2 = s * u, o2 = l * c, r2 = l * u;
      t[0] = e2 - r2 * a, t[4] = -i * u, t[8] = o2 + n2 * a, t[1] = n2 + o2 * a, t[5] = i * c, t[9] = r2 - e2 * a, t[2] = -i * l, t[6] = a, t[10] = i * s;
    } else if ("ZYX" === e.order) {
      const e2 = i * c, n2 = i * u, o2 = a * c, r2 = a * u;
      t[0] = s * c, t[4] = o2 * l - n2, t[8] = e2 * l + r2, t[1] = s * u, t[5] = r2 * l + e2, t[9] = n2 * l - o2, t[2] = -l, t[6] = a * s, t[10] = i * s;
    } else if ("YZX" === e.order) {
      const e2 = i * s, n2 = i * l, o2 = a * s, r2 = a * l;
      t[0] = s * c, t[4] = r2 - e2 * u, t[8] = o2 * u + n2, t[1] = u, t[5] = i * c, t[9] = -a * c, t[2] = -l * c, t[6] = n2 * u + o2, t[10] = e2 - r2 * u;
    } else if ("XZY" === e.order) {
      const e2 = i * s, n2 = i * l, o2 = a * s, r2 = a * l;
      t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = e2 * u + r2, t[5] = i * c, t[9] = n2 * u - o2, t[2] = o2 * u - n2, t[6] = a * c, t[10] = r2 * u + e2;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_zero, e, _one);
  }
  lookAt(e, t, n) {
    const o = this.elements;
    return _z.subVectors(e, t), 0 === _z.lengthSq() && (_z.z = 1), _z.normalize(), _x.crossVectors(n, _z), 0 === _x.lengthSq() && (1 === Math.abs(n.z) ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(n, _z)), _x.normalize(), _y.crossVectors(_z, _x), o[0] = _x.x, o[4] = _y.x, o[8] = _z.x, o[1] = _x.y, o[5] = _y.y, o[9] = _z.y, o[2] = _x.z, o[6] = _y.z, o[10] = _z.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, o = t.elements, r = this.elements, i = n[0], a = n[4], s = n[8], l = n[12], c = n[1], u = n[5], d = n[9], h = n[13], f = n[2], p = n[6], m = n[10], g = n[14], _ = n[3], A = n[7], v = n[11], x = n[15], y = o[0], b = o[4], C = o[8], S = o[12], M = o[1], E = o[5], T = o[9], I = o[13], w = o[2], R = o[6], L = o[10], B = o[14], P = o[3], N = o[7], D = o[11], O = o[15];
    return r[0] = i * y + a * M + s * w + l * P, r[4] = i * b + a * E + s * R + l * N, r[8] = i * C + a * T + s * L + l * D, r[12] = i * S + a * I + s * B + l * O, r[1] = c * y + u * M + d * w + h * P, r[5] = c * b + u * E + d * R + h * N, r[9] = c * C + u * T + d * L + h * D, r[13] = c * S + u * I + d * B + h * O, r[2] = f * y + p * M + m * w + g * P, r[6] = f * b + p * E + m * R + g * N, r[10] = f * C + p * T + m * L + g * D, r[14] = f * S + p * I + m * B + g * O, r[3] = _ * y + A * M + v * w + x * P, r[7] = _ * b + A * E + v * R + x * N, r[11] = _ * C + A * T + v * L + x * D, r[15] = _ * S + A * I + v * B + x * O, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], o = e[8], r = e[12], i = e[1], a = e[5], s = e[9], l = e[13], c = e[2], u = e[6], d = e[10], h = e[14];
    return e[3] * (+r * s * u - o * l * u - r * a * d + n * l * d + o * a * h - n * s * h) + e[7] * (+t * s * h - t * l * d + r * i * d - o * i * h + o * l * c - r * s * c) + e[11] * (+t * l * u - t * a * h - r * i * u + n * i * h + r * a * c - n * l * c) + e[15] * (-o * a * c - t * s * u + t * a * d + o * i * u - n * i * d + n * s * c);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const o = this.elements;
    return e.isVector3 ? (o[12] = e.x, o[13] = e.y, o[14] = e.z) : (o[12] = e, o[13] = t, o[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], o = e[2], r = e[3], i = e[4], a = e[5], s = e[6], l = e[7], c = e[8], u = e[9], d = e[10], h = e[11], f = e[12], p = e[13], m = e[14], g = e[15], _ = u * m * l - p * d * l + p * s * h - a * m * h - u * s * g + a * d * g, A = f * d * l - c * m * l - f * s * h + i * m * h + c * s * g - i * d * g, v = c * p * l - f * u * l + f * a * h - i * p * h - c * a * g + i * u * g, x = f * u * s - c * p * s - f * a * d + i * p * d + c * a * m - i * u * m, y = t * _ + n * A + o * v + r * x;
    if (0 === y) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const b = 1 / y;
    return e[0] = _ * b, e[1] = (p * d * r - u * m * r - p * o * h + n * m * h + u * o * g - n * d * g) * b, e[2] = (a * m * r - p * s * r + p * o * l - n * m * l - a * o * g + n * s * g) * b, e[3] = (u * s * r - a * d * r - u * o * l + n * d * l + a * o * h - n * s * h) * b, e[4] = A * b, e[5] = (c * m * r - f * d * r + f * o * h - t * m * h - c * o * g + t * d * g) * b, e[6] = (f * s * r - i * m * r - f * o * l + t * m * l + i * o * g - t * s * g) * b, e[7] = (i * d * r - c * s * r + c * o * l - t * d * l - i * o * h + t * s * h) * b, e[8] = v * b, e[9] = (f * u * r - c * p * r - f * n * h + t * p * h + c * n * g - t * u * g) * b, e[10] = (i * p * r - f * a * r + f * n * l - t * p * l - i * n * g + t * a * g) * b, e[11] = (c * a * r - i * u * r - c * n * l + t * u * l + i * n * h - t * a * h) * b, e[12] = x * b, e[13] = (c * p * o - f * u * o + f * n * d - t * p * d - c * n * m + t * u * m) * b, e[14] = (f * a * o - i * p * o - f * n * s + t * p * s + i * n * m - t * a * m) * b, e[15] = (i * u * o - c * a * o + c * n * s - t * u * s - i * n * d + t * a * d) * b, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, o = e.y, r = e.z;
    return t[0] *= n, t[4] *= o, t[8] *= r, t[1] *= n, t[5] *= o, t[9] *= r, t[2] *= n, t[6] *= o, t[10] *= r, t[3] *= n, t[7] *= o, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], o = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, o));
  }
  makeTranslation(e, t, n) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), o = Math.sin(t), r = 1 - n, i = e.x, a = e.y, s = e.z, l = r * i, c = r * a;
    return this.set(l * i + n, l * a - o * s, l * s + o * a, 0, l * a + o * s, c * a + n, c * s - o * i, 0, l * s - o * a, c * s + o * i, r * s * s + n, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, o, r, i) {
    return this.set(1, n, r, 0, e, 1, i, 0, t, o, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const o = this.elements, r = t._x, i = t._y, a = t._z, s = t._w, l = r + r, c = i + i, u = a + a, d = r * l, h = r * c, f = r * u, p = i * c, m = i * u, g = a * u, _ = s * l, A = s * c, v = s * u, x = n.x, y = n.y, b = n.z;
    return o[0] = (1 - (p + g)) * x, o[1] = (h + v) * x, o[2] = (f - A) * x, o[3] = 0, o[4] = (h - v) * y, o[5] = (1 - (d + g)) * y, o[6] = (m + _) * y, o[7] = 0, o[8] = (f + A) * b, o[9] = (m - _) * b, o[10] = (1 - (d + p)) * b, o[11] = 0, o[12] = e.x, o[13] = e.y, o[14] = e.z, o[15] = 1, this;
  }
  decompose(e, t, n) {
    const o = this.elements;
    let r = _v1$6.set(o[0], o[1], o[2]).length();
    const i = _v1$6.set(o[4], o[5], o[6]).length(), a = _v1$6.set(o[8], o[9], o[10]).length();
    this.determinant() < 0 && (r = -r), e.x = o[12], e.y = o[13], e.z = o[14], _m1$2.copy(this);
    const s = 1 / r, l = 1 / i, c = 1 / a;
    return _m1$2.elements[0] *= s, _m1$2.elements[1] *= s, _m1$2.elements[2] *= s, _m1$2.elements[4] *= l, _m1$2.elements[5] *= l, _m1$2.elements[6] *= l, _m1$2.elements[8] *= c, _m1$2.elements[9] *= c, _m1$2.elements[10] *= c, t.setFromRotationMatrix(_m1$2), n.x = r, n.y = i, n.z = a, this;
  }
  makePerspective(e, t, n, o, r, i) {
    const a = this.elements, s = 2 * r / (t - e), l = 2 * r / (n - o), c = (t + e) / (t - e), u = (n + o) / (n - o), d = -(i + r) / (i - r), h = -2 * i * r / (i - r);
    return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = h, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, n, o, r, i) {
    const a = this.elements, s = 1 / (t - e), l = 1 / (n - o), c = 1 / (i - r), u = (t + e) * s, d = (n + o) * l, h = (i + r) * c;
    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -h, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let e2 = 0; e2 < 16; e2++) if (t[e2] !== n[e2]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
  composeE(e, t, n) {
    const o = this.elements;
    this.makeRotationFromEuler(t);
    const r = n.x, i = n.y, a = n.z;
    return o[0] *= r, o[1] *= r, o[2] *= r, o[3] = 0, o[4] *= i, o[5] *= i, o[6] *= i, o[7] = 0, o[8] *= a, o[9] *= a, o[10] *= a, o[11] = 0, o[12] = e.x, o[13] = e.y, o[14] = e.z, o[15] = 1, this;
  }
  decomposeE(e, t, n, o = t.order) {
    const r = this.elements;
    let i = _v1$6.set(r[0], r[1], r[2]).length();
    const a = _v1$6.set(r[4], r[5], r[6]).length(), s = _v1$6.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], _m1$2.copy(this);
    const l = 1 / i, c = 1 / a, u = 1 / s;
    return _m1$2.elements[0] *= l, _m1$2.elements[1] *= l, _m1$2.elements[2] *= l, _m1$2.elements[4] *= c, _m1$2.elements[5] *= c, _m1$2.elements[6] *= c, _m1$2.elements[8] *= u, _m1$2.elements[9] *= u, _m1$2.elements[10] *= u, t.setFromRotationMatrix(_m1$2, o), n.x = i, n.y = a, n.z = s, this;
  }
};
var _v1$6 = new Vector3();
var _m1$2 = new Matrix4();
var _zero = new Vector3(0, 0, 0);
var _one = new Vector3(1, 1, 1);
var _x = new Vector3();
var _y = new Vector3();
var _z = new Vector3();
var _matrix$2 = new Matrix4();
var _quaternion$3 = new Quaternion();
var Euler = class _Euler {
  constructor(e = 0, t = 0, n = 0, o = _Euler.DefaultOrder) {
    this.isEuler = true, this._x = e, this._y = t, this._z = n, this._order = o;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, o = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = o, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = true) {
    const o = e.elements, r = o[0], i = o[4], a = o[8], s = o[1], l = o[5], c = o[9], u = o[2], d = o[6], h = o[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(clamp(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-i, r)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(a, h), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(clamp(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, h), this._z = Math.atan2(-i, l)) : (this._y = 0, this._z = Math.atan2(s, r));
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, h), this._z = Math.atan2(s, r)) : (this._x = 0, this._z = Math.atan2(-i, l));
        break;
      case "YZX":
        this._z = Math.asin(clamp(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, h));
        break;
      case "XZY":
        this._z = Math.asin(-clamp(i, -1, 1)), Math.abs(i) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, h), this._y = 0);
        break;
      default:
        console.warn("v3d.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, true === n && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return _matrix$2.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_matrix$2, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3(e) {
    return console.warn("v3d.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"), e ? e.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
  }
  makeAlternative() {
    var e = "X" === this._order[1] ? -1 : 1, t = "Y" === this._order[1] ? -1 : 1, n = "Z" === this._order[1] ? -1 : 1;
    return this._x = angleToRange_mPi_Pi(e * (this._x + Math.PI)), this._y = angleToRange_mPi_Pi(t * (this._y + Math.PI)), this._z = angleToRange_mPi_Pi(n * (this._z + Math.PI)), this;
  }
  equalsEps(e, t) {
    return Math.abs(this._x - e._x) < t && Math.abs(this._y - e._y) < t && Math.abs(this._z - e._z) < t && this._order === e._order;
  }
};
Euler.DefaultOrder = "XYZ", Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e;
  }
  disable(e) {
    this.mask &= ~(1 << e);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return !!(this.mask & e.mask);
  }
  isEnabled(e) {
    return !!(this.mask & 1 << e);
  }
};
var _object3DId = 0;
var _v1$5 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();
var _position$3 = new Vector3();
var _scale$a = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D = class _Object3D extends EventDispatcher {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _Object3D.DefaultUp.clone();
    const e = new Vector3(), t = new Euler(), n = new Quaternion(), o = new Vector3(1, 1, 1);
    t._onChange(function() {
      n.setFromEuler(t, false);
    }), n._onChange(function() {
      t.setFromQuaternion(n, void 0, false);
    }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e }, rotation: { configurable: true, enumerable: true, value: t }, quaternion: { configurable: true, enumerable: true, value: n }, scale: { configurable: true, enumerable: true, value: o }, modelViewMatrix: { value: new Matrix4() }, normalMatrix: { value: new Matrix3() } }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = _Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.matrixWorldAutoUpdate = _Object3D.DefaultMatrixWorldAutoUpdate, this.layers = new Layers(), this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {}, this.internVisible = true, this.externVisible = true, this.constraints = [], this.disableChildRendering = false, this.hidpiCompositing = false, this.groupNames = [], this.objectIndex = 0, this.objectColor = new Color(), this.objectAlpha = 1;
  }
  set visible(e) {
    this.externVisible = e;
  }
  get visible() {
    return this.internVisible && this.externVisible;
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, true);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.premultiply(_q1), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(_xAxis, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(_yAxis, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(_zAxis, e);
  }
  translateOnAxis(e, t) {
    return _v1$5.copy(e).applyQuaternion(this.quaternion), this.position.add(_v1$5.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(_xAxis, e);
  }
  translateY(e) {
    return this.translateOnAxis(_yAxis, e);
  }
  translateZ(e) {
    return this.translateOnAxis(_zAxis, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? _target.copy(e) : _target.set(e, t, n);
    const o = this.parent;
    this.updateWorldMatrix(true, false), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1), o && (_m1$1.extractRotation(o.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let e2 = 0; e2 < arguments.length; e2++) this.add(arguments[e2]);
      return this;
    }
    return e === this ? (console.error("v3d.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(_addedEvent)) : console.error("v3d.Object3D.add: object not an instance of v3d.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let e2 = 0; e2 < arguments.length; e2++) this.remove(arguments[e2]);
      return this;
    }
    const t = this.children.indexOf(e);
    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(_removedEvent)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return null !== e && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(_removedEvent);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(true, false), _m1$1.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(true, false), _m1$1.multiply(e.parent.matrixWorld)), e.applyMatrix4(_m1$1), this.add(e), e.updateWorldMatrix(false, true), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, o = this.children.length; n < o; n++) {
      const o2 = this.children[n].getObjectByProperty(e, t);
      if (void 0 !== o2) return o2;
    }
  }
  getObjectsByProperty(e, t) {
    let n = [];
    this[e] === t && n.push(this);
    for (let o = 0, r = this.children.length; o < r; o++) {
      const r2 = this.children[o].getObjectsByProperty(e, t);
      r2.length > 0 && (n = n.concat(r2));
    }
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(_position$3, e, _scale$a), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(_position$3, _quaternion$2, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(t[4], t[5], t[6]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, o = t.length; n < o; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (false === this.visible) return;
    e(this);
    const t = this.children;
    for (let n = 0, o = t.length; n < o; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    null !== t && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.updateConstraints(), this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
    const t = this.children;
    for (let n = 0, o = t.length; n < o; n++) {
      const o2 = t[n];
      true !== o2.matrixWorldAutoUpdate && true !== e || o2.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (true === e && null !== n && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === t) {
      const e2 = this.children;
      for (let t2 = 0, n2 = e2.length; t2 < n2; t2++) {
        e2[t2].updateWorldMatrix(false, true);
      }
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = true) {
    this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.disableChildRendering = e.disableChildRendering, this.hidpiCompositing = e.hidpiCompositing, this.objectIndex = e.objectIndex, this.objectColor.copy(e.objectColor), this.objectAlpha = e.objectAlpha, this.constraints = [];
    for (let t2 = 0; t2 < e.constraints.length; t2++) this.constraints.push(e.constraints[t2].clone());
    if (this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), true === t) for (let t2 = 0; t2 < e.children.length; t2++) {
      const n = e.children[t2];
      this.add(n.clone());
    }
    return this;
  }
  copyTransform(e) {
    this.matrix.copy(e.matrixWorld), this.parent && this.matrix.multiplyMatrices(_m1$1.copy(this.parent.matrixWorld).invert(), this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  isVisible() {
    return this.visible;
  }
  updateConstraints() {
    for (let e = 0; e < this.constraints.length; e++) this.constraints[e].update(this);
  }
  getWorldPositionNU(e) {
    return e.setFromMatrixPosition(this.matrixWorld);
  }
  getLocalDirection(e) {
    const t = this.matrix.elements;
    return this.isCamera || this.isLight ? e.set(-t[8], -t[9], -t[10]).normalize() : e.set(t[8], t[9], t[10]).normalize();
  }
  lookAtLocal(e, t, n) {
    e.isVector3 ? _target.copy(e) : _target.set(e, t, n), _position$3.setFromMatrixPosition(this.matrix), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1);
  }
  findRoot() {
    let e = this;
    return this.traverseAncestors(function(t) {
      e = t;
    }), e;
  }
  resolveMultiMaterial() {
    const e = [];
    for (let t = 0; t < this.children.length; t++) {
      const n = this.children[t];
      n.isMesh && n.isMaterialGeneratedMesh && e.push(n);
    }
    return e.length || e.push(this), e;
  }
  getAuxClippingMeshes() {
    const e = [];
    for (let t = 0; t < this.children.length; t++) {
      const n = this.children[t];
      n.isMesh && n.isAuxClippingMesh && e.push(n);
    }
    return e;
  }
  getWorldEuler(e, t = e._order) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decomposeE(_position$3, e, _scale$a, t), e;
  }
};
Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = true, Object3D.DefaultMatrixWorldAutoUpdate = true;
var _v0$1 = new Vector3();
var _v1$4 = new Vector3();
var _v2$3 = new Vector3();
var _v3$1 = new Vector3();
var _vab = new Vector3();
var _vac = new Vector3();
var _vbc = new Vector3();
var _vap = new Vector3();
var _vbp = new Vector3();
var _vcp = new Vector3();
var _v40 = new Vector4();
var _v41 = new Vector4();
var _v42 = new Vector4();
var Triangle = class _Triangle {
  constructor(e = new Vector3(), t = new Vector3(), n = new Vector3()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, o) {
    o.subVectors(n, t), _v0$1.subVectors(e, t), o.cross(_v0$1);
    const r = o.lengthSq();
    return r > 0 ? o.multiplyScalar(1 / Math.sqrt(r)) : o.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, o, r) {
    _v0$1.subVectors(o, t), _v1$4.subVectors(n, t), _v2$3.subVectors(e, t);
    const i = _v0$1.dot(_v0$1), a = _v0$1.dot(_v1$4), s = _v0$1.dot(_v2$3), l = _v1$4.dot(_v1$4), c = _v1$4.dot(_v2$3), u = i * l - a * a;
    if (0 === u) return r.set(0, 0, 0), null;
    const d = 1 / u, h = (l * s - a * c) * d, f = (i * c - a * s) * d;
    return r.set(1 - h - f, f, h);
  }
  static containsPoint(e, t, n, o) {
    return null !== this.getBarycoord(e, t, n, o, _v3$1) && (_v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1);
  }
  static getInterpolation(e, t, n, o, r, i, a, s) {
    return null === this.getBarycoord(e, t, n, o, _v3$1) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(r, _v3$1.x), s.addScaledVector(i, _v3$1.y), s.addScaledVector(a, _v3$1.z), s);
  }
  static getInterpolatedAttribute(e, t, n, o, r, i) {
    return _v40.setScalar(0), _v41.setScalar(0), _v42.setScalar(0), _v40.fromBufferAttribute(e, t), _v41.fromBufferAttribute(e, n), _v42.fromBufferAttribute(e, o), i.setScalar(0), i.addScaledVector(_v40, r.x), i.addScaledVector(_v41, r.y), i.addScaledVector(_v42, r.z), i;
  }
  static isFrontFacing(e, t, n, o) {
    return _v0$1.subVectors(n, t), _v1$4.subVectors(e, t), _v0$1.cross(_v1$4).dot(o) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, o) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[o]), this;
  }
  setFromAttributeAndIndices(e, t, n, o) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, o), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return _v0$1.subVectors(this.c, this.b), _v1$4.subVectors(this.a, this.b), 0.5 * _v0$1.cross(_v1$4).length();
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return _Triangle.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return _Triangle.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, o, r) {
    return _Triangle.getInterpolation(e, this.a, this.b, this.c, t, n, o, r);
  }
  containsPoint(e) {
    return _Triangle.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return _Triangle.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, o = this.b, r = this.c;
    let i, a;
    _vab.subVectors(o, n), _vac.subVectors(r, n), _vap.subVectors(e, n);
    const s = _vab.dot(_vap), l = _vac.dot(_vap);
    if (s <= 0 && l <= 0) return t.copy(n);
    _vbp.subVectors(e, o);
    const c = _vab.dot(_vbp), u = _vac.dot(_vbp);
    if (c >= 0 && u <= c) return t.copy(o);
    const d = s * u - c * l;
    if (d <= 0 && s >= 0 && c <= 0) return i = s / (s - c), t.copy(n).addScaledVector(_vab, i);
    _vcp.subVectors(e, r);
    const h = _vab.dot(_vcp), f = _vac.dot(_vcp);
    if (f >= 0 && h <= f) return t.copy(r);
    const p = h * l - s * f;
    if (p <= 0 && l >= 0 && f <= 0) return a = l / (l - f), t.copy(n).addScaledVector(_vac, a);
    const m = c * f - h * u;
    if (m <= 0 && u - c >= 0 && h - f >= 0) return _vbc.subVectors(r, o), a = (u - c) / (u - c + (h - f)), t.copy(o).addScaledVector(_vbc, a);
    const g = 1 / (m + p + d);
    return i = p * g, a = d * g, t.copy(n).addScaledVector(_vab, i).addScaledVector(_vac, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
};
var materialId = 0;
var Material = class extends EventDispatcher {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: materialId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0, this.depthPrepass = false, this.receiveShadow = false, this.castShadow = false, this.profile = "", this.defines = {}, this.definesFragOnly = /* @__PURE__ */ new Set(), this.DefaultEnvMapAutoAssign = true, this.envMapAutoAssign = this.DefaultEnvMapAutoAssign, this.gtaoVisible = true;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (void 0 !== e) for (const t in e) {
      const n = e[t];
      if (void 0 === n) {
        console.warn("v3d.Material: '" + t + "' parameter is undefined.");
        continue;
      }
      const o = this[t];
      void 0 !== o ? o && o.isColor ? o.set(n) : o && o.isVector3 && n && n.isVector3 ? o.copy(n) : this[t] = n : console.warn("v3d." + this.type + ": '" + t + "' is not a property of this material.");
    }
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (null !== t) {
      const e2 = t.length;
      n = new Array(e2);
      for (let o = 0; o !== e2; ++o) n[o] = t[o].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this.depthPrepass = e.depthPrepass, this.defines = Object.assign({}, e.defines), this.definesFragOnly = new Set(e.definesFragOnly), this.receiveShadow = e.receiveShadow, this.castShadow = e.castShadow, this.profile = e.profile, this.envMapAutoAssign = e.envMapAutoAssign, this.gtaoVisible = e.gtaoVisible, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    true === e && this.version++;
  }
  get needsUpdate() {
    return 0 != this.version;
  }
};
var MeshBasicMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this;
  }
};
var _vector$9 = new Vector3();
var _vector2$1 = new Vector2();
var BufferAttribute = class {
  constructor(e, t, n = false) {
    if (Array.isArray(e)) throw new TypeError("v3d.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    true === e && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let o = 0, r = this.itemSize; o < r; o++) this.array[e + o] = t.array[n + o];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++) _vector2$1.fromBufferAttribute(this, t), _vector2$1.applyMatrix3(e), this.setXY(t, _vector2$1.x, _vector2$1.y);
    else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++) _vector$9.fromBufferAttribute(this, t), _vector$9.applyMatrix3(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++) _vector$9.fromBufferAttribute(this, t), _vector$9.applyMatrix4(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++) _vector$9.fromBufferAttribute(this, t), _vector$9.applyNormalMatrix(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++) _vector$9.fromBufferAttribute(this, t), _vector$9.transformDirection(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = normalize(t, this.array), n = normalize(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, o) {
    return e *= this.itemSize, this.normalized && (t = normalize(t, this.array), n = normalize(n, this.array), o = normalize(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = o, this;
  }
  setXYZW(e, t, n, o, r) {
    return e *= this.itemSize, this.normalized && (t = normalize(t, this.array), n = normalize(n, this.array), o = normalize(o, this.array), r = normalize(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = o, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
};
var Int8BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
};
var Uint8BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
};
var Uint8ClampedBufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
};
var Int16BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
};
var Uint16BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
};
var Int32BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
};
var Float16BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = true;
  }
};
var Float32BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
};
var Float64BufferAttribute = class extends BufferAttribute {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
};
var _id$1 = 0;
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$8 = new Vector3();
var BufferGeometry = class _BufferGeometry extends EventDispatcher {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: _id$1++ }), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.boundsTree = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new BufferAttribute(new (arrayNeedsUint32(e) ? Uint32Array : Uint16Array)(e), 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return void 0 !== this.attributes[e];
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = true);
    const n = this.attributes.normal;
    if (void 0 !== n) {
      const t2 = new Matrix3().getNormalMatrix(e);
      n.applyNormalMatrix(t2), n.needsUpdate = true;
    }
    const o = this.attributes.tangent;
    return void 0 !== o && (o.transformDirection(e), o.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return _m1.makeRotationFromQuaternion(e), this.applyMatrix4(_m1), this;
  }
  rotateX(e) {
    return _m1.makeRotationX(e), this.applyMatrix4(_m1), this;
  }
  rotateY(e) {
    return _m1.makeRotationY(e), this.applyMatrix4(_m1), this;
  }
  rotateZ(e) {
    return _m1.makeRotationZ(e), this.applyMatrix4(_m1), this;
  }
  translate(e, t, n) {
    return _m1.makeTranslation(e, t, n), this.applyMatrix4(_m1), this;
  }
  scale(e, t, n) {
    return _m1.makeScale(e, t, n), this.applyMatrix4(_m1), this;
  }
  lookAt(e) {
    return _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const o2 = e[n];
      t.push(o2.x, o2.y, o2.z || 0);
    }
    return this.setAttribute("position", new Float32BufferAttribute(t, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new Box3());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) return console.error('v3d.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0));
    if (void 0 !== e) {
      if (this.boundingBox.setFromBufferAttribute(e), t) for (let e2 = 0, n = t.length; e2 < n; e2++) {
        const n2 = t[e2];
        _box$2.setFromBufferAttribute(n2), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('v3d.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new Sphere());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) return console.error('v3d.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Vector3(), 1 / 0);
    if (e) {
      const n = this.boundingSphere.center;
      if (_box$2.setFromBufferAttribute(e), t) for (let e2 = 0, n2 = t.length; e2 < n2; e2++) {
        const n3 = t[e2];
        _boxMorphTargets.setFromBufferAttribute(n3), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max));
      }
      _box$2.getCenter(n);
      let o = 0;
      for (let t2 = 0, r = e.count; t2 < r; t2++) _vector$8.fromBufferAttribute(e, t2), o = Math.max(o, n.distanceToSquared(_vector$8));
      if (t) for (let r = 0, i = t.length; r < i; r++) {
        const i2 = t[r], a = this.morphTargetsRelative;
        for (let t2 = 0, r2 = i2.count; t2 < r2; t2++) _vector$8.fromBufferAttribute(i2, t2), a && (_offset.fromBufferAttribute(e, t2), _vector$8.add(_offset)), o = Math.max(o, n.distanceToSquared(_vector$8));
      }
      this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('v3d.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("v3d.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    const n = e.array, o = t.position.array, r = t.normal.array, i = t.uv.array, a = o.length / 3;
    false === this.hasAttribute("tangent") && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * a), 4));
    const s = this.getAttribute("tangent").array, l = [], c = [];
    for (let e2 = 0; e2 < a; e2++) l[e2] = new Vector3(), c[e2] = new Vector3();
    const u = new Vector3(), d = new Vector3(), h = new Vector3(), f = new Vector2(), p = new Vector2(), m = new Vector2(), g = new Vector3(), _ = new Vector3();
    function A(e2, t2, n2) {
      u.fromArray(o, 3 * e2), d.fromArray(o, 3 * t2), h.fromArray(o, 3 * n2), f.fromArray(i, 2 * e2), p.fromArray(i, 2 * t2), m.fromArray(i, 2 * n2), d.sub(u), h.sub(u), p.sub(f), m.sub(f);
      const r2 = 1 / (p.x * m.y - m.x * p.y);
      isFinite(r2) && (g.copy(d).multiplyScalar(m.y).addScaledVector(h, -p.y).multiplyScalar(r2), _.copy(h).multiplyScalar(p.x).addScaledVector(d, -m.x).multiplyScalar(r2), l[e2].add(g), l[t2].add(g), l[n2].add(g), c[e2].add(_), c[t2].add(_), c[n2].add(_));
    }
    let v = this.groups;
    0 === v.length && (v = [{ start: 0, count: n.length }]);
    for (let e2 = 0, t2 = v.length; e2 < t2; ++e2) {
      const t3 = v[e2], o2 = t3.start;
      for (let e3 = o2, r2 = o2 + t3.count; e3 < r2; e3 += 3) A(n[e3 + 0], n[e3 + 1], n[e3 + 2]);
    }
    const x = new Vector3(), y = new Vector3(), b = new Vector3(), C = new Vector3();
    function S(e2) {
      b.fromArray(r, 3 * e2), C.copy(b);
      const t2 = l[e2];
      x.copy(t2), x.sub(b.multiplyScalar(b.dot(t2))).normalize(), y.crossVectors(C, t2);
      const n2 = y.dot(c[e2]) < 0 ? -1 : 1;
      s[4 * e2] = x.x, s[4 * e2 + 1] = x.y, s[4 * e2 + 2] = x.z, s[4 * e2 + 3] = n2;
    }
    for (let e2 = 0, t2 = v.length; e2 < t2; ++e2) {
      const t3 = v[e2], o2 = t3.start;
      for (let e3 = o2, r2 = o2 + t3.count; e3 < r2; e3 += 3) S(n[e3 + 0]), S(n[e3 + 1]), S(n[e3 + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (void 0 !== t) {
      let n = this.getAttribute("normal");
      if (void 0 === n) n = new BufferAttribute(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
      else for (let e2 = 0, t2 = n.count; e2 < t2; e2++) n.setXYZ(e2, 0, 0, 0);
      const o = new Vector3(), r = new Vector3(), i = new Vector3(), a = new Vector3(), s = new Vector3(), l = new Vector3(), c = new Vector3(), u = new Vector3();
      if (e) for (let d = 0, h = e.count; d < h; d += 3) {
        const h2 = e.getX(d + 0), f = e.getX(d + 1), p = e.getX(d + 2);
        o.fromBufferAttribute(t, h2), r.fromBufferAttribute(t, f), i.fromBufferAttribute(t, p), c.subVectors(i, r), u.subVectors(o, r), c.cross(u), a.fromBufferAttribute(n, h2), s.fromBufferAttribute(n, f), l.fromBufferAttribute(n, p), a.add(c), s.add(c), l.add(c), n.setXYZ(h2, a.x, a.y, a.z), n.setXYZ(f, s.x, s.y, s.z), n.setXYZ(p, l.x, l.y, l.z);
      }
      else for (let e2 = 0, a2 = t.count; e2 < a2; e2 += 3) o.fromBufferAttribute(t, e2 + 0), r.fromBufferAttribute(t, e2 + 1), i.fromBufferAttribute(t, e2 + 2), c.subVectors(i, r), u.subVectors(o, r), c.cross(u), n.setXYZ(e2 + 0, c.x, c.y, c.z), n.setXYZ(e2 + 1, c.x, c.y, c.z), n.setXYZ(e2 + 2, c.x, c.y, c.z);
      this.normalizeNormals(), n.needsUpdate = true;
    }
  }
  merge() {
    return console.error("v3d.BufferGeometry.merge() has been removed. Use v3d.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++) _vector$8.fromBufferAttribute(e, t), _vector$8.normalize(), e.setXYZ(t, _vector$8.x, _vector$8.y, _vector$8.z);
  }
  toNonIndexed() {
    function e(e2, t2) {
      const n2 = e2.array, o2 = e2.itemSize, r2 = e2.normalized, i2 = new n2.constructor(t2.length * o2);
      let a = 0, s = 0;
      for (let r3 = 0, l = t2.length; r3 < l; r3++) {
        a = e2.isInterleavedBufferAttribute ? t2[r3] * e2.data.stride + e2.offset : t2[r3] * o2;
        for (let e3 = 0; e3 < o2; e3++) i2[s++] = n2[a++];
      }
      return new BufferAttribute(i2, o2, r2);
    }
    if (null === this.index) return console.warn("v3d.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new _BufferGeometry(), n = this.index.array, o = this.attributes;
    for (const r2 in o) {
      const i2 = e(o[r2], n);
      t.setAttribute(r2, i2);
    }
    const r = this.morphAttributes;
    for (const o2 in r) {
      const i2 = [], a = r[o2];
      for (let t2 = 0, o3 = a.length; t2 < o3; t2++) {
        const o4 = e(a[t2], n);
        i2.push(o4);
      }
      t.morphAttributes[o2] = i2;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const i = this.groups;
    for (let e2 = 0, n2 = i.length; e2 < n2; e2++) {
      const n3 = i[e2];
      t.addGroup(n3.start, n3.count, n3.materialIndex);
    }
    return t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    null !== n && this.setIndex(n.clone(t));
    const o = e.attributes;
    for (const e2 in o) {
      const n2 = o[e2];
      this.setAttribute(e2, n2.clone(t));
    }
    const r = e.morphAttributes;
    for (const e2 in r) {
      const n2 = [], o2 = r[e2];
      for (let e3 = 0, r2 = o2.length; e3 < r2; e3++) n2.push(o2[e3].clone(t));
      this.morphAttributes[e2] = n2;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const i = e.groups;
    for (let e2 = 0, t2 = i.length; e2 < t2; e2++) {
      const t3 = i[e2];
      this.addGroup(t3.start, t3.count, t3.materialIndex);
    }
    const a = e.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    const s = e.boundingSphere;
    return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$4 = new Sphere();
var _vA$2 = new Vector3();
var _vB$2 = new Vector3();
var _vC$2 = new Vector3();
var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();
var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();
var _uvA$2 = new Vector2();
var _uvB$2 = new Vector2();
var _uvC$2 = new Vector2();
var _intersectionPoint$1 = new Vector3();
var _intersectionPointWorld = new Vector3();
var Mesh = class extends Object3D {
  constructor(e = new BufferGeometry(), t = new MeshBasicMaterial()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets(), this.isMaterialGeneratedMesh = false, this.isAuxClippingMesh = false;
  }
  copy(e, t) {
    return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this.isMaterialGeneratedMesh = e.isMaterialGeneratedMesh, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (void 0 !== n) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let e2 = 0, t2 = n.length; e2 < t2; e2++) {
          const t3 = n[e2].name || String(e2);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t3] = e2;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, o = n.attributes.position, r = n.morphAttributes.position, i = n.morphTargetsRelative;
    t.fromBufferAttribute(o, e);
    const a = this.morphTargetInfluences;
    if (r && a) {
      _morphA.set(0, 0, 0);
      for (let n2 = 0, o2 = r.length; n2 < o2; n2++) {
        const o3 = a[n2], s = r[n2];
        0 !== o3 && (_tempA.fromBufferAttribute(s, e), i ? _morphA.addScaledVector(_tempA, o3) : _morphA.addScaledVector(_tempA.sub(t), o3));
      }
      t.add(_morphA);
    }
    return this.isSkinnedMesh && this.boneTransform(e, t), t;
  }
  raycast(e, t) {
    if (this.isAuxClippingMesh) return;
    const n = this.geometry, o = this.material, r = this.matrixWorld;
    if (void 0 === o) return;
    if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere$4.copy(n.boundingSphere), _sphere$4.applyMatrix4(r), false === e.ray.intersectsSphere(_sphere$4)) return;
    if (_inverseMatrix$2.copy(r).invert(), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2), null !== n.boundingBox && false === _ray$2.intersectsBox(n.boundingBox)) return;
    let i;
    const a = n.index, s = n.attributes.position, l = n.morphAttributes.position, c = n.morphTargetsRelative, u = n.attributes.uv, d = n.attributes.uv2, h = n.groups, f = n.drawRange;
    if (null !== a) if (Array.isArray(o)) for (let n2 = 0, r2 = h.length; n2 < r2; n2++) {
      const r3 = h[n2], p = o[r3.materialIndex];
      for (let n3 = Math.max(r3.start, f.start), o2 = Math.min(a.count, Math.min(r3.start + r3.count, f.start + f.count)); n3 < o2; n3 += 3) {
        const o3 = a.getX(n3), h2 = a.getX(n3 + 1), f2 = a.getX(n3 + 2);
        i = checkBufferGeometryIntersection$1(this, p, e, _ray$2, s, l, c, u, d, o3, h2, f2), i && (i.faceIndex = Math.floor(n3 / 3), i.face.materialIndex = r3.materialIndex, t.push(i));
      }
    }
    else {
      for (let n2 = Math.max(0, f.start), r2 = Math.min(a.count, f.start + f.count); n2 < r2; n2 += 3) {
        const r3 = a.getX(n2), h2 = a.getX(n2 + 1), f2 = a.getX(n2 + 2);
        i = checkBufferGeometryIntersection$1(this, o, e, _ray$2, s, l, c, u, d, r3, h2, f2), i && (i.faceIndex = Math.floor(n2 / 3), t.push(i));
      }
    }
    else if (void 0 !== s) if (Array.isArray(o)) for (let n2 = 0, r2 = h.length; n2 < r2; n2++) {
      const r3 = h[n2], a2 = o[r3.materialIndex];
      for (let n3 = Math.max(r3.start, f.start), o2 = Math.min(s.count, Math.min(r3.start + r3.count, f.start + f.count)); n3 < o2; n3 += 3) {
        i = checkBufferGeometryIntersection$1(this, a2, e, _ray$2, s, l, c, u, d, n3, n3 + 1, n3 + 2), i && (i.faceIndex = Math.floor(n3 / 3), i.face.materialIndex = r3.materialIndex, t.push(i));
      }
    }
    else {
      for (let n2 = Math.max(0, f.start), r2 = Math.min(s.count, f.start + f.count); n2 < r2; n2 += 3) {
        i = checkBufferGeometryIntersection$1(this, o, e, _ray$2, s, l, c, u, d, n2, n2 + 1, n2 + 2), i && (i.faceIndex = Math.floor(n2 / 3), t.push(i));
      }
    }
  }
  clone() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  isVisible() {
    return this.isMaterialGeneratedMesh && this.parent ? this.visible && this.parent.visible : this.visible;
  }
};
function checkIntersection$1(e, t, n, o, r, i, a, s) {
  let l;
  if (l = 1 === t.side ? o.intersectTriangle(a, i, r, true, s) : o.intersectTriangle(r, i, a, 0 === t.side, s), null === l) return null;
  _intersectionPointWorld.copy(s), _intersectionPointWorld.applyMatrix4(e.matrixWorld);
  const c = n.ray.origin.distanceTo(_intersectionPointWorld);
  return c < n.near || c > n.far ? null : { distance: c, point: _intersectionPointWorld.clone(), object: e };
}
function checkBufferGeometryIntersection$1(e, t, n, o, r, i, a, s, l, c, u, d) {
  _vA$2.fromBufferAttribute(r, c), _vB$2.fromBufferAttribute(r, u), _vC$2.fromBufferAttribute(r, d);
  const h = e.morphTargetInfluences;
  if (i && h) {
    _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0);
    for (let e2 = 0, t2 = i.length; e2 < t2; e2++) {
      const t3 = h[e2], n2 = i[e2];
      0 !== t3 && (_tempA.fromBufferAttribute(n2, c), _tempB.fromBufferAttribute(n2, u), _tempC.fromBufferAttribute(n2, d), a ? (_morphA.addScaledVector(_tempA, t3), _morphB.addScaledVector(_tempB, t3), _morphC.addScaledVector(_tempC, t3)) : (_morphA.addScaledVector(_tempA.sub(_vA$2), t3), _morphB.addScaledVector(_tempB.sub(_vB$2), t3), _morphC.addScaledVector(_tempC.sub(_vC$2), t3)));
    }
    _vA$2.add(_morphA), _vB$2.add(_morphB), _vC$2.add(_morphC);
  }
  e.isSkinnedMesh && (e.boneTransform(c, _vA$2), e.boneTransform(u, _vB$2), e.boneTransform(d, _vC$2));
  const f = checkIntersection$1(e, t, n, o, _vA$2, _vB$2, _vC$2, _intersectionPoint$1);
  if (f) {
    s && (_uvA$2.fromBufferAttribute(s, c), _uvB$2.fromBufferAttribute(s, u), _uvC$2.fromBufferAttribute(s, d), f.uv = Triangle.getInterpolation(_intersectionPoint$1, _vA$2, _vB$2, _vC$2, _uvA$2, _uvB$2, _uvC$2, new Vector2())), l && (_uvA$2.fromBufferAttribute(l, c), _uvB$2.fromBufferAttribute(l, u), _uvC$2.fromBufferAttribute(l, d), f.uv2 = Triangle.getInterpolation(_intersectionPoint$1, _vA$2, _vB$2, _vC$2, _uvA$2, _uvB$2, _uvC$2, new Vector2()));
    const e2 = { a: c, b: u, c: d, normal: new Vector3(), materialIndex: 0 };
    Triangle.getNormal(_vA$2, _vB$2, _vC$2, e2.normal), f.face = e2;
  }
  return f;
}
var BoxGeometry = class extends BufferGeometry {
  constructor(e = 1, t = 1, n = 1, o = 1, r = 1, i = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: o, heightSegments: r, depthSegments: i };
    const a = this;
    o = Math.floor(o), r = Math.floor(r), i = Math.floor(i);
    const s = [], l = [], c = [], u = [];
    let d = 0, h = 0;
    function f(e2, t2, n2, o2, r2, i2, f2, p, m, g, _) {
      const A = i2 / m, v = f2 / g, x = i2 / 2, y = f2 / 2, b = p / 2, C = m + 1, S = g + 1;
      let M = 0, E = 0;
      const T = new Vector3();
      for (let i3 = 0; i3 < S; i3++) {
        const a2 = i3 * v - y;
        for (let s2 = 0; s2 < C; s2++) {
          const d2 = s2 * A - x;
          T[e2] = d2 * o2, T[t2] = a2 * r2, T[n2] = b, l.push(T.x, T.y, T.z), T[e2] = 0, T[t2] = 0, T[n2] = p > 0 ? 1 : -1, c.push(T.x, T.y, T.z), u.push(s2 / m), u.push(1 - i3 / g), M += 1;
        }
      }
      for (let e3 = 0; e3 < g; e3++) for (let t3 = 0; t3 < m; t3++) {
        const n3 = d + t3 + C * e3, o3 = d + t3 + C * (e3 + 1), r3 = d + (t3 + 1) + C * (e3 + 1), i3 = d + (t3 + 1) + C * e3;
        s.push(n3, o3, i3), s.push(o3, r3, i3), E += 6;
      }
      a.addGroup(h, E, _), h += E, d += M;
    }
    f("z", "y", "x", -1, -1, n, t, e, i, r, 0), f("z", "y", "x", 1, -1, n, t, -e, i, r, 1), f("x", "z", "y", 1, 1, e, n, t, o, i, 2), f("x", "z", "y", 1, -1, e, n, -t, o, i, 3), f("x", "y", "z", 1, -1, e, t, n, o, r, 4), f("x", "y", "z", -1, -1, e, t, -n, o, r, 5), this.setIndex(s), this.setAttribute("position", new BufferAttribute(new Float32Array(l), 3)), this.setAttribute("normal", new BufferAttribute(new Float32Array(c), 3)), this.setAttribute("uv", new BufferAttribute(new Float32Array(u), 2));
  }
};
function cloneUniforms(e) {
  const t = {};
  for (const n in e) {
    t[n] = {};
    for (const o in e[n]) {
      const r = e[n][o];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][o] = r.clone() : Array.isArray(r) ? t[n][o] = r.slice() : t[n][o] = r;
    }
  }
  return t;
}
function mergeUniforms(e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const o = cloneUniforms(e[n]);
    for (const e2 in o) t[e2] = o[e2];
  }
  return t;
}
function cloneUniformsGroups(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) t.push(e[n].clone());
  return t;
}
function getUnlitUniformColorSpace(e) {
  return null === e.getRenderTarget() && 3001 === e.outputEncoding ? "srgb" : "srgb-linear";
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
var default_fragment = "void main() {\ngl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}";
var ShaderMaterial = class extends Material {
  constructor(e) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.customPrepTokens = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.customPrepTokens = Object.assign({}, e.customPrepTokens), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
};
var Camera = class extends Object3D {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4(), this.controlSettings = null, this.viewportFit = { type: 0, initialAspect: 1 }, this.ignoreShadowLayers = false;
  }
  get controls() {
    return console.warn("v3d.Camera.controls replaced by v3d.Camera.controlSettings"), this.controlSettings;
  }
  set controls(e) {
    console.warn("v3d.Camera.controls replaced by v3d.Camera.controlSettings"), this.controlSettings = e;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), e.controlSettings && (this.controlSettings = e.controlSettings.clone()), this.viewportFit.type = e.viewportFit.type, this.viewportFit.initialAspect = e.viewportFit.initialAspect, this.ignoreShadowLayers = e.ignoreShadowLayers, this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
};
var PerspectiveCamera = class extends Camera {
  constructor(e = 50, t = 1, n = 0.1, o = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = o, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = 2 * RAD2DEG * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(0.5 * DEG2RAD * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return 2 * RAD2DEG * Math.atan(Math.tan(0.5 * DEG2RAD * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, o, r, i) {
    this.aspect = e / t, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = o, this.view.width = r, this.view.height = i, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(0.5 * DEG2RAD * this.fov) / this.zoom, n = 2 * t, o = this.aspect * n, r = -0.5 * o;
    const i = this.view;
    if (null !== this.view && this.view.enabled) {
      const e2 = i.fullWidth, a2 = i.fullHeight;
      r += i.offsetX * o / e2, t -= i.offsetY * n / a2, o *= i.width / e2, n *= i.height / a2;
    }
    const a = this.filmOffset;
    0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + o, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
};
var CubeCamera = class extends Object3D {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n;
    const o = new PerspectiveCamera(-90, 1, e, t);
    o.layers = this.layers, o.up.set(0, 1, 0), o.lookAt(1, 0, 0), this.add(o);
    const r = new PerspectiveCamera(-90, 1, e, t);
    r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), this.add(r);
    const i = new PerspectiveCamera(-90, 1, e, t);
    i.layers = this.layers, i.up.set(0, 0, -1), i.lookAt(0, 1, 0), this.add(i);
    const a = new PerspectiveCamera(-90, 1, e, t);
    a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a);
    const s = new PerspectiveCamera(-90, 1, e, t);
    s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(0, 0, 1), this.add(s);
    const l = new PerspectiveCamera(-90, 1, e, t);
    l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, -1), this.add(l);
  }
  update(e, t) {
    null === this.parent && this.updateMatrixWorld();
    const n = this.renderTarget, [o, r, i, a, s, l] = this.children, c = e.getRenderTarget(), u = e.toneMapping, d = e.xr.enabled;
    e.toneMapping = 0, e.xr.enabled = false;
    const h = n.texture.generateMipmaps;
    n.texture.generateMipmaps = false, e.setRenderTarget(n, 0), e.render(t, o), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, i), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, s), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(c), e.toneMapping = u, e.xr.enabled = d, n.texture.needsPMREMUpdate = true;
  }
};
var CubeTexture = class extends Texture {
  constructor(e, t, n, o, r, i, a, s, l, c) {
    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, n, o, r, i, a, s, l, c), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.source.data;
  }
  set images(e) {
    this.source.data = e;
  }
};
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = true;
    const n = { width: e, height: e, depth: 1 }, o = [n, n, n, n, n, n];
    this.texture = new CubeTexture(o, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : 1006;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n                varying vec3 vWorldDirection;\n\n                vec3 transformDirection(in vec3 dir, in mat4 matrix) {\n\n                    return normalize((matrix * vec4(dir, 0.0)).xyz);\n\n                }\n\n                void main() {\n\n                    vWorldDirection = transformDirection(position, modelMatrix);\n\n                    #include <begin_vertex>\n                    #include <project_vertex>\n\n                }\n            ", fragmentShader: "\n\n                uniform sampler2D tEquirect;\n\n                varying vec3 vWorldDirection;\n\n                #include <common>\n\n                void main() {\n\n                    vec3 direction = normalize(vWorldDirection);\n\n                    vec2 sampleUV = equirectUv(direction);\n\n                    gl_FragColor = texture2D(tEquirect, sampleUV);\n\n                }\n            " }, o = new BoxGeometry(5, 5, 5), r = new ShaderMaterial({ name: "CubemapFromEquirect", uniforms: cloneUniforms(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: 1, blending: 0 });
    r.uniforms.tEquirect.value = t;
    const i = new Mesh(o, r), a = t.minFilter;
    1008 === t.minFilter && (t.minFilter = 1006);
    return new CubeCamera(1, 10, this).update(e, i), t.minFilter = a, i.geometry.dispose(), i.material.dispose(), this;
  }
  clear(e, t, n, o) {
    const r = e.getRenderTarget();
    for (let r2 = 0; r2 < 6; r2++) e.setRenderTarget(this, r2), e.clear(t, n, o);
    e.setRenderTarget(r);
  }
};
var Detector = { checkWebGL: function() {
  try {
    const e = document.createElement("canvas");
    return !(!window.WebGLRenderingContext || !e.getContext("webgl") && !e.getContext("experimental-webgl"));
  } catch (e) {
    return false;
  }
}, checkWebGL2: function() {
  try {
    const e = document.createElement("canvas");
    return !(!window.WebGL2RenderingContext || !e.getContext("webgl2"));
  } catch (e) {
    return false;
  }
}, checkWorkers: function() {
  return !!window.Worker;
}, checkFileAPI: function() {
  return window.File && window.FileReader && window.FileList && window.Blob;
}, genWebGLErrorMessage: function(e) {
  const t = document.createElement("div");
  t.setAttribute("class", "v3d-webgl-error-container");
  const n = document.createElement("div");
  n.setAttribute("class", "v3d-webgl-error-image"), t.appendChild(n);
  const o = document.createElement("div");
  return o.setAttribute("class", "v3d-webgl-error"), o.innerHTML = e, t.appendChild(o), t;
}, showWebGLErrorMessage: function(e, t) {
  (e = e || document.body).appendChild(Detector.genWebGLErrorMessage(t));
  const n = document.getElementById("v3d_preloader_container");
  n && (n.style.visibility = "hidden");
}, checkIOS: function() {
  return (/iPad|iPhone|iPod/.test(navigator.platform) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1) && !window.MSStream;
}, checkAndroid: function() {
  return !!navigator.userAgent.match(/Android/i);
}, checkSafari: function() {
  return /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
}, checkFloatTex: function(e, t) {
  const n = e.getContext();
  return !(!e.capabilities.isWebGL2 || !n.getExtension("EXT_color_buffer_float") || t && !n.getExtension("OES_texture_float_linear")) || !(e.capabilities.isWebGL2 || !n.getExtension("OES_texture_float") || t && !n.getExtension("OES_texture_float_linear"));
}, checkHalfFloatTex: function(e, t) {
  const n = e.getContext();
  return !(!e.capabilities.isWebGL2 || !n.getExtension("EXT_color_buffer_float")) || !(e.capabilities.isWebGL2 || !n.getExtension("OES_texture_half_float") || t && !n.getExtension("OES_texture_half_float_linear"));
}, checkHalfFloatReadPixels: function(e) {
  const t = e.getContext(), n = e.capabilities;
  return !/Firefox/.test(navigator.userAgent) && !!(t.getExtension("EXT_color_buffer_half_float") || n.isWebGL2 && t.getExtension("EXT_color_buffer_float"));
}, checkFloatReadPixels: function(e) {
  const t = e.getContext();
  return !!(e.capabilities.isWebGL2 || t.getExtension("OES_texture_float") || t.getExtension("WEBGL_color_buffer_float"));
}, checkDepthTex: function(e) {
  const t = e.getContext();
  return !(!e.capabilities.isWebGL2 && !t.getExtension("WEBGL_depth_texture"));
}, getGPUVendor: function(e) {
  const t = e ? e.getContext() : document.createElement("canvas").getContext("webgl") || document.createElement("canvas").getContext("experimental-webgl");
  if (/Firefox/.test(navigator.userAgent)) return t.getParameter(7936);
  {
    const e2 = t.getExtension("WEBGL_debug_renderer_info");
    return null != e2 ? t.getParameter(e2.UNMASKED_VENDOR_WEBGL) : "";
  }
}, getGPUModel: function(e) {
  const t = e ? e.getContext() : document.createElement("canvas").getContext("webgl") || document.createElement("canvas").getContext("experimental-webgl");
  if (/Firefox/.test(navigator.userAgent)) return t.getParameter(7937);
  {
    const e2 = t.getExtension("WEBGL_debug_renderer_info");
    return null != e2 ? t.getParameter(e2.UNMASKED_RENDERER_WEBGL) : "";
  }
}, checkWebXR: function(e, t, n) {
  "xr" in navigator && navigator.xr.isSessionSupported ? navigator.xr.isSessionSupported(e).then(function(e2) {
    e2 ? t() : n();
  }).catch(n) : n();
}, checkNativeWebXR: function() {
  return false;
}, checkCardboard: function() {
  return false;
}, checkSwiftShader: function(e) {
  return "Google SwiftShader" == this.getGPUModel(e);
}, checkWebAudio: function() {
  return void 0 !== (window.AudioContext || window.webkitAudioContext);
}, isSafariWithMultisamplingBug: function() {
  const e = navigator.userAgent;
  return !(!this.checkSafari() && !e.match("MicroMessenger")) && (e.match("Version/15.4") || e.match(/CPU (OS|iPhone OS) (15_4|15_4_1|15_4_2|15_4_3) like Mac OS X/));
}, isSafariWithUint16Bug: function() {
  const e = navigator.userAgent;
  return !(!this.checkSafari() && !e.match("MicroMessenger")) && e.match(/CPU (OS|iPhone OS) (11_[0-9][0-9_]*|12_[0-9][0-9_]*) like Mac OS X/);
}, isTouchDevice: function() {
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
} };
var _vector1 = new Vector3();
var _vector2 = new Vector3();
var _normalMatrix = new Matrix3();
var Plane = class {
  constructor(e = new Vector3(1, 0, 0), t = 0) {
    this.isPlane = true, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, o) {
    return this.normal.set(e, t, n), this.constant = o, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const o = _vector1.subVectors(n, t).cross(_vector2.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(o, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const n = e.delta(_vector1), o = this.normal.dot(n);
    if (0 === o) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / o;
    return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || _normalMatrix.getNormalMatrix(e), o = this.coplanarPoint(_vector1).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -o.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _sphere$3 = new Sphere();
var _vector$7 = new Vector3();
var Frustum = class {
  constructor(e = new Plane(), t = new Plane(), n = new Plane(), o = new Plane(), r = new Plane(), i = new Plane()) {
    this.planes = [e, t, n, o, r, i];
  }
  set(e, t, n, o, r, i) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(o), a[4].copy(r), a[5].copy(i), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, n = e.elements, o = n[0], r = n[1], i = n[2], a = n[3], s = n[4], l = n[5], c = n[6], u = n[7], d = n[8], h = n[9], f = n[10], p = n[11], m = n[12], g = n[13], _ = n[14], A = n[15];
    return t[0].setComponents(a - o, u - s, p - d, A - m).normalize(), t[1].setComponents(a + o, u + s, p + d, A + m).normalize(), t[2].setComponents(a + r, u + l, p + h, A + g).normalize(), t[3].setComponents(a - r, u - l, p - h, A - g).normalize(), t[4].setComponents(a - i, u - c, p - f, A - _).normalize(), t[5].setComponents(a + i, u + c, p + f, A + _).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return null === t.boundingSphere && t.computeBoundingSphere(), _sphere$3.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$3);
  }
  intersectsSprite(e) {
    return _sphere$3.center.set(0, 0, 0), _sphere$3.radius = 0.7071067811865476, _sphere$3.applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$3);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, o = -e.radius;
    for (let e2 = 0; e2 < 6; e2++) {
      if (t[e2].distanceToPoint(n) < o) return false;
    }
    return true;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const o = t[n];
      if (_vector$7.x = o.normal.x > 0 ? e.max.x : e.min.x, _vector$7.y = o.normal.y > 0 ? e.max.y : e.min.y, _vector$7.z = o.normal.z > 0 ? e.max.z : e.min.z, o.distanceToPoint(_vector$7) < 0) return false;
    }
    return true;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Scene = class extends Object3D {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, this.backgroundToneMapped = true, this.postprocessing = [], this.worldMaterial = null, this.worldEnvMapProbe = null, "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundToneMapped = e.backgroundToneMapped, null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
function WebGLAnimation() {
  let e = null, t = false, n = null, o = null;
  function r(t2, i) {
    n(t2, i), o = e.requestAnimationFrame(r);
  }
  return { start: function() {
    true !== t && null !== n && (o = e.requestAnimationFrame(r), t = true);
  }, stop: function() {
    e.cancelAnimationFrame(o), t = false;
  }, setAnimationLoop: function(e2) {
    n = e2;
  }, setContext: function(t2) {
    e = t2;
  } };
}
function WebGLAttributes(e, t) {
  const n = t.isWebGL2;
  let o = /* @__PURE__ */ new WeakMap();
  return { get: function(e2) {
    return e2.isInterleavedBufferAttribute && (e2 = e2.data), o.get(e2);
  }, remove: function(t2) {
    t2.isInterleavedBufferAttribute && (t2 = t2.data);
    const n2 = o.get(t2);
    n2 && (e.deleteBuffer(n2.buffer), o.delete(t2));
  }, update: function(t2, r) {
    if (t2.isGLBufferAttribute) {
      const e2 = o.get(t2);
      return void ((!e2 || e2.version < t2.version) && o.set(t2, { buffer: t2.buffer, type: t2.type, bytesPerElement: t2.elementSize, version: t2.version }));
    }
    t2.isInterleavedBufferAttribute && (t2 = t2.data);
    const i = o.get(t2);
    void 0 === i ? o.set(t2, function(t3, o2) {
      const r2 = t3.array, i2 = t3.usage, a = e.createBuffer();
      let s;
      if (e.bindBuffer(o2, a), e.bufferData(o2, r2, i2), t3.onUploadCallback(), r2 instanceof Float32Array) s = 5126;
      else if (r2 instanceof Uint16Array) if (t3.isFloat16BufferAttribute) {
        if (!n) throw new Error("v3d.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        s = 5131;
      } else s = 5123;
      else if (r2 instanceof Int16Array) s = 5122;
      else if (r2 instanceof Uint32Array) s = 5125;
      else if (r2 instanceof Int32Array) s = 5124;
      else if (r2 instanceof Int8Array) s = 5120;
      else if (r2 instanceof Uint8Array) s = 5121;
      else {
        if (!(r2 instanceof Uint8ClampedArray)) throw new Error("v3d.WebGLAttributes: Unsupported buffer data format: " + r2);
        s = 5121;
      }
      return { buffer: a, type: s, bytesPerElement: r2.BYTES_PER_ELEMENT, version: t3.version };
    }(t2, r)) : i.version < t2.version && (!function(t3, o2, r2) {
      const i2 = o2.array, a = o2.updateRange;
      e.bindBuffer(r2, t3), -1 === a.count ? e.bufferSubData(r2, 0, i2) : (n ? e.bufferSubData(r2, a.offset * i2.BYTES_PER_ELEMENT, i2, a.offset, a.count) : e.bufferSubData(r2, a.offset * i2.BYTES_PER_ELEMENT, i2.subarray(a.offset, a.offset + a.count)), a.count = -1), o2.onUploadCallback();
    }(i.buffer, t2, r), i.version = t2.version);
  }, dispose: function() {
    o = /* @__PURE__ */ new WeakMap();
  } };
}
var PlaneGeometry = class extends BufferGeometry {
  constructor(e = 1, t = 1, n = 1, o = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: o };
    const r = e / 2, i = t / 2, a = Math.floor(n), s = Math.floor(o), l = a + 1, c = s + 1, u = e / a, d = t / s, h = [], f = [], p = [], m = [];
    for (let e2 = 0; e2 < c; e2++) {
      const t2 = e2 * d - i;
      for (let n2 = 0; n2 < l; n2++) {
        const o2 = n2 * u - r;
        f.push(o2, -t2, 0), p.push(0, 0, 1), m.push(n2 / a), m.push(1 - e2 / s);
      }
    }
    for (let e2 = 0; e2 < s; e2++) for (let t2 = 0; t2 < a; t2++) {
      const n2 = t2 + l * e2, o2 = t2 + l * (e2 + 1), r2 = t2 + 1 + l * (e2 + 1), i2 = t2 + 1 + l * e2;
      h.push(n2, o2, i2), h.push(o2, r2, i2);
    }
    this.setIndex(h), this.setAttribute("position", new BufferAttribute(new Float32Array(f), 3)), this.setAttribute("normal", new BufferAttribute(new Float32Array(p), 3)), this.setAttribute("uv", new BufferAttribute(new Float32Array(m), 2));
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D(alphaMap, vUv).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\nif (diffuseColor.a < alphaTest)\ndiscard;\nelse\ndiffuseColor.a = 1.0;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\nuniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\nfloat ambientOcclusion = (texture2D(aoMap, vUv2).r - 1.0) * aoMapIntensity + 1.0;\nreflectedLight.indirectDiffuse *= ambientOcclusion;\n#if defined(USE_ENVMAP) && defined(STANDARD)\nfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\nreflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.roughness);\n#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\nuniform sampler2D aoMap;\nuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3(position);";
var beginnormal_vertex = "vec3 objectNormal = vec3(normal);\n#ifdef USE_TANGENT\nvec3 objectTangent = vec3(tangent.xyz);\n#endif";
var bsdfs = "vec3 BRDF_Lambert(const in vec3 diffuseColor) {\nreturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick(const in vec3 f0, const in float f90, const in float dotVH) {\nfloat fresnel = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\nreturn f0 * (1.0 - fresnel) + (f90 * fresnel);\n}\nfloat V_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {\nfloat a2 = pow2(alpha);\nfloat gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));\nfloat gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));\nreturn 0.5 / max(gv + gl, EPSILON);\n}\nfloat D_GGX(const in float alpha, const in float dotNH) {\nfloat a2 = pow2(alpha);\nfloat denom = pow2(dotNH) * (a2 - 1.0) + 1.0;\nreturn RECIPROCAL_PI * a2 / pow2(denom);\n}\nvec3 BRDF_GGX(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness) {\nfloat alpha = pow2(clamp(roughness, 0.04, 1.0));\nvec3 halfDir = normalize(lightDir + viewDir);\nfloat dotNL = saturate(dot(normal, lightDir));\nfloat dotNV = saturate(dot(normal, viewDir));\nfloat dotNH = saturate(dot(normal, halfDir));\nfloat dotVH = saturate(dot(viewDir, halfDir));\nvec3 F = F_Schlick(f0, f90, dotVH);\nfloat V = V_GGX_SmithCorrelated(alpha, dotNL, dotNV);\nfloat D = D_GGX(alpha, dotNH);\nreturn F * (V * D);\n}\nvec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness) {\nconst float LUT_SIZE = 64.0;\nconst float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\nconst float LUT_BIAS = 0.5 / LUT_SIZE;\nfloat dotNV = saturate(dot(N, V));\nvec2 uv = vec2(roughness, sqrt(1.0 - dotNV));\nuv = uv * LUT_SCALE + LUT_BIAS;\nreturn uv;\n}\nfloat LTC_ClippedSphereFormFactor(const in vec3 f) {\nfloat l = length(f);\nreturn max((l * l + f.z) / (l + 1.0), 0.0);\n}\nvec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2) {\nfloat x = dot(v1, v2);\nfloat y = abs(x);\nfloat a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;\nfloat b = 3.4175940 + (4.1616724 + y) * y;\nfloat v = a / b;\nfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;\nreturn cross(v1, v2) * theta_sintheta;\n}\nvec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4]) {\nvec3 v1 = rectCoords[1] - rectCoords[0];\nvec3 v2 = rectCoords[3] - rectCoords[0];\nvec3 lightNormal = cross(v1, v2);\nif(dot(lightNormal, P - rectCoords[0]) < 0.0) return vec3(0.0);\nvec3 T1, T2;\nT1 = normalize(V - N * dot(V, N));\nT2 = -cross(N, T1);\nmat3 mat = mInv * transposeMat3(mat3(T1, T2, N));\nvec3 coords[4];\ncoords[0] = mat * (rectCoords[0] - P);\ncoords[1] = mat * (rectCoords[1] - P);\ncoords[2] = mat * (rectCoords[2] - P);\ncoords[3] = mat * (rectCoords[3] - P);\ncoords[0] = normalize(coords[0]);\ncoords[1] = normalize(coords[1]);\ncoords[2] = normalize(coords[2]);\ncoords[3] = normalize(coords[3]);\nvec3 vectorFormFactor = vec3(0.0);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);\nfloat result = LTC_ClippedSphereFormFactor(vectorFormFactor);\nreturn vec3(result);\n}\nvec2 integrateSpecularBRDF(const in float dotNV, const in float roughness) {\nconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;\nreturn vec2(-1.04, 1.04) * a004 + r.zw;\n}\nvec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in vec3 specularColor90, const in float roughness) {\nfloat dotNV = saturate(dot(normal, viewDir));\nvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\nreturn specularColor * brdf.x + specularColor90 * brdf.y;\n}\n#if defined(USE_SHEEN)\nfloat D_Charlie(float roughness, float dotNH) {\nfloat alpha = pow2(roughness);\nfloat invAlpha = 1.0 / alpha;\nfloat cos2h = dotNH * dotNH;\nfloat sin2h = max(1.0 - cos2h, 0.0078125);\nreturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float dotNV, float dotNL) {\nreturn saturate(1.0 / (4.0 * (dotNL + dotNV - dotNL * dotNV)));\n}\nvec3 BRDF_Sheen(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness) {\nvec3 halfDir = normalize(lightDir + viewDir);\nfloat dotNL = saturate(dot(normal, lightDir));\nfloat dotNV = saturate(dot(normal, viewDir));\nfloat dotNH = saturate(dot(normal, halfDir));\nfloat D = D_Charlie(sheenRoughness, dotNH);\nfloat V = V_Neubelt(dotNV, dotNL);\nreturn sheenColor * (D * V);\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx(vUv);\nvec2 dSTdy = dFdy(vUv);\nfloat Hll = bumpScale * texture2D(bumpMap, vUv).x;\nfloat dBx = bumpScale * texture2D(bumpMap, vUv + dSTdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpMap, vUv + dSTdy).x - Hll;\nreturn vec2(dBx, dBy);\n}\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection) {\nvec3 vSigmaX = dFdx(surf_pos.xyz);\nvec3 vSigmaY = dFdy(surf_pos.xyz);\nvec3 vN = surf_norm;\nvec3 R1 = cross(vSigmaY, vN);\nvec3 R2 = cross(vN, vSigmaX);\nfloat fDet = dot(vSigmaX, R1) * faceDirection;\nvec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\nreturn normalize(abs(fDet) * surf_norm - vGrad);\n}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\nvec4 plane;\n#pragma unroll_loop\nfor (int i = 0; i < UNION_CLIPPING_PLANES; i++) {\nplane = clippingPlanes[i];\nif (dot(vClipPosition, plane.xyz) > plane.w) discard;\n}\n#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\nbool clipped = true;\n#pragma unroll_loop\nfor (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i++) {\nplane = clippingPlanes[i];\nclipped = (dot(vClipPosition, plane.xyz) > plane.w) && clipped;\n}\nif (clipped) discard;\n#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\nvarying vec3 vClipPosition;\nuniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\nvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\nvClipPosition = -mvPosition.xyz;\n#endif";
var color_fragment = "#if defined(USE_COLOR_ALPHA)\ndiffuseColor *= vColor;\n#elif defined(USE_COLOR)\ndiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)\nvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR) || defined(USE_INSTANCING_COLOR)\nvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined(USE_COLOR_ALPHA)\nvColor = vec4(1.0);\n#elif defined(USE_COLOR) || defined(USE_INSTANCING_COLOR)\nvColor = vec3(1.0);\n#endif\n#ifdef USE_COLOR\nvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\nvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif\nfloat pow2(const in float x) { return x*x; }\nvec3 pow2(const in vec3 x) { return x*x; }\nfloat pow3(const in float x) { return x*x*x; }\nfloat pow4(const in float x) { float x2 = x*x; return x2*x2; }\nfloat max3(const in vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat average(const in vec3 v) { return dot(v, vec3(0.3333333)); }\nhighp float rand(const in vec2 uv) {\nconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\nhighp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);\nreturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\nfloat precisionSafeLength(vec3 v) { return length(v); }\n#else\nfloat precisionSafeLength(vec3 v) {\nfloat maxComponent = max3(abs(v));\nreturn length(v / maxComponent) * maxComponent;\n}\n#endif\nstruct IncidentLight {\nvec3 color;\nvec3 direction;\nbool visible;\n};\nstruct ReflectedLight {\nvec3 directDiffuse;\nvec3 directSpecular;\nvec3 indirectDiffuse;\nvec3 indirectSpecular;\n};\nstruct GeometricContext {\nvec3 position;\nvec3 normal;\nvec3 viewDir;\nvec3 probeNormal;\n#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection(in vec3 dir, in mat4 matrix) {\nreturn normalize((matrix * vec4(dir, 0.0)).xyz);\n}\nvec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {\nreturn normalize((vec4(dir, 0.0) * matrix).xyz);\n}\nmat3 transposeMat3(const in mat3 m) {\nmat3 tmp;\ntmp[0] = vec3(m[0].x, m[1].x, m[2].x);\ntmp[1] = vec3(m[0].y, m[1].y, m[2].y);\ntmp[2] = vec3(m[0].z, m[1].z, m[2].z);\nreturn tmp;\n}\nfloat linearToRelativeLuminance(const in vec3 color) {\nconst vec3 weights = vec3(0.2126729, 0.7151522, 0.0721750);\nreturn dot(weights, color.rgb);\n}\nbool isPerspectiveMatrix(mat4 m) {\nreturn m[2][3] == -1.0;\n}\nvec2 equirectUv(in vec3 dir) {\nfloat u = atan(dir.z, dir.x) * RECIPROCAL_PI2 + 0.5;\nfloat v = asin(clamp(dir.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nreturn vec2(u, v);\n}\nvec3 octUVToCubeVec(vec2 octUV, vec2 texelSize) {\noctUV = (1.0 + 2.0 * texelSize) * octUV - texelSize;\noctUV = octUV * 2.0 - 1.0;\nfloat x = octUV.x;\nfloat z = -octUV.y;\nfloat absX = abs(x);\nfloat absZ = abs(z);\nvec3 cubeVec = vec3(x, 1.0 - absX - absZ, z);\nif (absX + absZ > 1.0) {\ncubeVec.xz = -(vec2(absZ, absX) - 1.0) * sign(vec2(x, z));\n}\nreturn cubeVec;\n}\nvec2 cubeVecToOctUV(vec3 cubeVec, vec2 texelSize) {\ncubeVec /= dot(vec3(1.0), abs(cubeVec));\nvec2 octUV = vec2(cubeVec.x, -cubeVec.z);\nif (cubeVec.y < 0.0) {\noctUV = sign(octUV) * (1.0 - abs(octUV.ts));\n}\noctUV = (octUV + 1.0) / 2.0;\noctUV = (1.0 - 2.0 * texelSize) * octUV + texelSize;\nreturn octUV;\n}\nvec3 vec3RotateAxisAngle(vec3 vector, vec3 axis, float angle) {\nvec3 axisNorm = normalize(axis);\nfloat x = axisNorm.x, y = axisNorm.y, z = axisNorm.z;\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(\nx * x * (1.0 - c) + c, x * y * (1.0 - c) + z * s, x * z * (1.0 - c) - y * s,\nx * y * (1.0 - c) - z * s, y * y * (1.0 - c) + c, y * z * (1.0 - c) + x * s,\nx * z * (1.0 - c) + y * s, y * z * (1.0 - c) - x * s, z * z * (1.0 - c) + c\n) * vector;\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\nfloat getFace(vec3 direction) {\nvec3 absDirection = abs(direction);\nfloat face = -1.0;\nif (absDirection.x > absDirection.z) {\nif (absDirection.x > absDirection.y) {\nface = direction.x > 0.0 ? 0.0 : 3.0;\n} else {\nface = direction.y > 0.0 ? 1.0 : 4.0;\n}\n} else {\nif (absDirection.z > absDirection.y) {\nface = direction.z > 0.0 ? 2.0 : 5.0;\n} else {\nface = direction.y > 0.0 ? 1.0 : 4.0;\n}\n}\nreturn face;\n}\nvec2 getUV(vec3 direction, float face) {\nvec2 uv;\nif (face == 0.0) {\nuv = vec2(-direction.z, direction.y) / abs(direction.x);\n} else if (face == 1.0) {\nuv = vec2(direction.x, -direction.z) / abs(direction.y);\n} else if (face == 2.0) {\nuv = direction.xy / abs(direction.z);\n} else if (face == 3.0) {\nuv = vec2(direction.z, direction.y) / abs(direction.x);\n} else if (face == 4.0) {\nuv = direction.xz / abs(direction.y);\n} else {\nuv = vec2(-direction.x, direction.y) / abs(direction.z);\n}\nreturn 0.5 * (uv + 1.0);\n}\n#ifndef cubeUV_maxTileSize\n#define cubeUV_maxTileSize 256.0\n#endif\n#define cubeUV_lodIdxMin 0.0\n#define cubeUV_lodIdxLastDownscaled 4.0\n#define cubeUV_lodIdxMax 10.0\n#define cubeUV_minTileSize (cubeUV_maxTileSize / exp2(cubeUV_lodIdxLastDownscaled))\nfloat getLodTileSize(float lodIdx) {\nreturn cubeUV_maxTileSize / exp2(min(lodIdx, cubeUV_lodIdxLastDownscaled));\n}\nfloat getLodFilterLevel(float lodIdx) {\nreturn max(lodIdx - cubeUV_lodIdxLastDownscaled, 0.0);\n}\nvec2 fixCubeUVSeams(vec2 uv, float faceSize) {\nfloat BORDER_WIDTH_PX = max(cubeUV_maxTileSize / 256.0 - 1.0, 0.0);\nfloat scale = (faceSize - BORDER_WIDTH_PX) / faceSize;\nfloat offset = 0.5 * BORDER_WIDTH_PX / faceSize;\nreturn uv * scale + offset;\n}\nvec2 getUVPixels(vec3 direction, float lodIdx) {\nfloat face = getFace(direction);\nfloat faceSize = getLodTileSize(lodIdx);\nfloat filterLevel = getLodFilterLevel(lodIdx);\nvec2 uv = getUV(direction, face);\nuv = fixCubeUVSeams(uv, faceSize);\nuv *= (faceSize - 1.0);\nif (face > 2.0) {\nuv.y += faceSize;\nface -= 3.0;\n}\nuv.x += face * faceSize;\nif (lodIdx > 0.0) {\nuv.y += 2.0 * cubeUV_maxTileSize;\n}\nuv.y += filterLevel * 2.0 * cubeUV_minTileSize;\nuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\nreturn uv;\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float lodIdx) {\nfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\nvec2 uv = getUVPixels(direction, lodIdx);\nvec2 f = fract(uv);\nuv += 0.5 - f;\nuv *= texelSize;\nvec3 tl = texture2D(envMap, uv).rgb;\nuv.x += texelSize;\nvec3 tr = texture2D(envMap, uv).rgb;\nuv.y += texelSize;\nvec3 br = texture2D(envMap, uv).rgb;\nuv.x -= texelSize;\nvec3 bl = texture2D(envMap, uv).rgb;\nvec3 tm = mix(tl, tr, f.x);\nvec3 bm = mix(bl, br, f.x);\nreturn mix(tm, bm, f.y);\n}\nvec3 sampleCubeUV(sampler2D envMap, vec3 direction, float lodIdx) {\nfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\nvec2 uv = getUVPixels(direction, lodIdx);\nuv += 0.5;\nuv *= texelSize;\nreturn texture2D(envMap, uv).rgb;\n}\nfloat roughnessToMip(float roughness) {\nfloat r = roughness;\nfloat r2 = r * r;\nfloat r3 = r2 * r;\nroughness = -1.20278049 * r3 + 1.86860137 * r2 + 0.32478081 * r + 0.0098139;\nreturn roughness * (cubeUV_lodIdxMax - cubeUV_lodIdxMin);\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\nfloat lodIdx = clamp(roughnessToMip(roughness), cubeUV_lodIdxMin, cubeUV_lodIdxMax);\nfloat lodIdxF = fract(lodIdx);\nfloat lodIdxI = floor(lodIdx);\nvec3 color0 = sampleCubeUV(envMap, sampleDir, lodIdxI);\nif (lodIdxF == 0.0) {\nreturn vec4(color0, 1.0);\n} else {\nvec3 color1 = sampleCubeUV(envMap, sampleDir, lodIdxI + 1.0);\nreturn vec4(mix(color0, color1, lodIdxF), 1.0);\n}\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\nmat3 m = mat3(instanceMatrix);\ntransformedNormal /= vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2]));\ntransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\ntransformedNormal = -transformedNormal;\n#endif\n#ifdef USE_TANGENT\nvec3 transformedTangent = (modelViewMatrix * vec4(objectTangent, 0.0)).xyz;\n#ifdef FLIP_SIDED\ntransformedTangent = -transformedTangent;\n#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\nuniform float displacementScale;\nuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\ntransformed += normalize(objectNormal) * (texture2D(displacementMap, vUv).x * displacementScale + displacementBias);\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\nvec4 emissiveColor = texture2D(emissiveMap, vUv);\ntotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\nuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel(gl_FragColor);";
var encodings_pars_fragment = "vec4 LinearToLinear(in vec4 value) {\nreturn value;\n}\nvec4 LinearTosRGB(in vec4 value) {\nreturn vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvec3 cameraToFrag;\nif (isOrthographic) {\ncameraToFrag = normalize(vec3(-viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));\n} else {\ncameraToFrag = normalize(vWorldPosition - cameraPosition);\n}\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec = reflect(cameraToFrag, worldNormal);\n#else\nvec3 reflectVec = refract(cameraToFrag, worldNormal, refractionRatio);\n#endif\n#else\nvec3 reflectVec = vReflect;\n#endif\n#ifdef ENVMAP_TYPE_CUBE\nvec4 envColor = textureCube(envMap, vec3(flipEnvMap * reflectVec.x, reflectVec.yz));\n#else\nvec4 envColor = vec4(0.0);\n#endif\n#ifdef ENVMAP_BLENDING_MULTIPLY\noutgoingLight = mix(outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity);\n#elif defined(ENVMAP_BLENDING_MIX)\noutgoingLight = mix(outgoingLight, envColor.xyz, specularStrength * reflectivity);\n#elif defined(ENVMAP_BLENDING_ADD)\noutgoingLight += envColor.xyz * specularStrength * reflectivity;\n#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\nuniform float envMapIntensity;\nuniform float flipEnvMap;\n#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#else\nuniform sampler2D envMap;\n#endif\n#if defined(ENVMAP_TYPE_CUBE) && defined(NODE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat calcGeometryRoughness(vec3 geometryNormal) {\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nreturn max(max(dxy.x, dxy.y), dxy.z);\n}\nfloat calcCubeUVAdjustedRoughness(float origRoughness, float geomRoughness) {\nreturn min(max(origRoughness, 0.0525) + geomRoughness, 1.0);\n}\n#endif\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(LAMBERT)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(LAMBERT)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\n#else\nvarying vec3 vReflect;\nuniform float refractionRatio;\n#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvWorldPosition = worldPosition.xyz;\n#else\nvec3 cameraToVertex;\nif (isOrthographic) {\ncameraToVertex = normalize(vec3(-viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));\n} else {\ncameraToVertex = normalize(worldPosition.xyz - cameraPosition);\n}\nvec3 worldNormal = inverseTransformDirection(transformedNormal, viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvReflect = reflect(cameraToVertex, worldNormal);\n#else\nvReflect = refract(cameraToVertex, worldNormal, refractionRatio);\n#endif\n#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\nvFogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\nvarying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n#ifdef FOG_EXP2\nfloat fogFactor = 1.0 - exp(-fogDensity * fogDensity * vFogDepth * vFogDepth);\n#else\nfloat fogFactor = smoothstep(fogNear, fogFar, vFogDepth);\n#endif\ngl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\nuniform vec3 fogColor;\nvarying float vFogDepth;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\nvec4 lightMapTexel = texture2D(lightMap, vUv2);\nvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\nreflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\nuniform sampler2D lightMap;\nuniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\nvec3 diffuseColor;\nfloat specularStrength;\n};\nvoid RE_Direct_Lambert(const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\nreflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Lambert(const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\n#define RE_Direct RE_Direct_Lambert\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[9];\nvec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9]) {\nfloat x = normal.x, y = normal.y, z = normal.z;\nvec3 result = shCoefficients[0] * 0.886227;\nresult += shCoefficients[1] * 2.0 * 0.511664 * y;\nresult += shCoefficients[2] * 2.0 * 0.511664 * z;\nresult += shCoefficients[3] * 2.0 * 0.511664 * x;\nresult += shCoefficients[4] * 2.0 * 0.429043 * x * y;\nresult += shCoefficients[5] * 2.0 * 0.429043 * y * z;\nresult += shCoefficients[6] * (0.743125 * z * z - 0.247708);\nresult += shCoefficients[7] * 2.0 * 0.429043 * x * z;\nresult += shCoefficients[8] * 0.429043 * (x * x - y * y);\nreturn result;\n}\nvec3 getLightProbeIrradiance(const in vec3 lightProbe[9], const in vec3 normal) {\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 irradiance = shGetIrradianceAt(worldNormal, lightProbe);\nreturn irradiance;\n}\nvec3 getAmbientLightIrradiance(const in vec3 ambientLightColor) {\nvec3 irradiance = ambientLightColor;\nreturn irradiance;\n}\nfloat getDistanceAttenuation(float lightDistance, const in float cutoffDistance, const in float decayExponent) {\nlightDistance = UNITS_SCALE_FACTOR * lightDistance;\n#ifdef MT_MAYA\nfloat distanceFalloff = 1.0 / pow(lightDistance + 1.0, decayExponent);\n#else\nfloat distanceFalloff = 1.0 / max(pow(lightDistance, decayExponent), 0.01);\n#endif\nif (cutoffDistance > 0.0) {\ndistanceFalloff *= pow2(saturate(1.0 - pow4(lightDistance / (UNITS_SCALE_FACTOR * cutoffDistance))));\n}\nreturn distanceFalloff;\n}\nfloat getSpotAttenuation(const in float coneCosine, const in float penumbraCosine, const in float angleCosine) {\nreturn smoothstep(coneCosine, penumbraCosine, angleCosine);\n}\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight {\nvec3 direction;\nvec3 color;\n};\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\nvoid getDirectionalLightInfo(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light) {\nlight.color = directionalLight.color;\nlight.direction = directionalLight.direction;\nlight.visible = true;\n}\n#endif\n#if NUM_POINT_LIGHTS > 0\nstruct PointLight {\nvec3 position;\nvec3 color;\nfloat distance;\nfloat decay;\n};\nuniform PointLight pointLights[NUM_POINT_LIGHTS];\nvoid getPointLightInfo(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light) {\nvec3 lVector = pointLight.position - geometry.position;\nlight.direction = normalize(lVector);\nfloat lightDistance = length(lVector);\nlight.color = pointLight.color;\nlight.color *= getDistanceAttenuation(lightDistance, pointLight.distance, pointLight.decay);\nlight.visible = (light.color != vec3(0.0));\n}\n#endif\n#if NUM_SPOT_LIGHTS > 0\nstruct SpotLight {\nvec3 position;\nvec3 direction;\nvec3 color;\nfloat distance;\nfloat decay;\nfloat coneCos;\nfloat penumbraCos;\n};\nuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\nvoid getSpotLightInfo(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light) {\nvec3 lVector = spotLight.position - geometry.position;\nlight.direction = normalize(lVector);\nfloat angleCos = dot(light.direction, spotLight.direction);\n#if defined(MT_MAX)\nfloat coneCosDecayed = 2.0 * spotLight.coneCos - spotLight.penumbraCos;\nif (angleCos > coneCosDecayed) {\nfloat spotAttenuation = pow(max(angleCos, 0.0), log(0.5) / log(spotLight.penumbraCos) - 1.0);\nif (angleCos < spotLight.coneCos) {\nfloat decayFac = 1.0 + (spotLight.coneCos - angleCos)\n/ (spotLight.coneCos - spotLight.penumbraCos);\nspotAttenuation *= pow2(decayFac) * (3.0 - 2.0 * decayFac);\n}\nfloat lightDistance = length(lVector);\nlight.color = spotLight.color * spotAttenuation;\nlight.color *= getDistanceAttenuation(lightDistance, spotLight.distance, spotLight.decay);\nlight.visible = true;\n} else {\nlight.color = vec3(0.0);\nlight.visible = false;\n}\n#else\nfloat spotAttenuation = getSpotAttenuation(spotLight.coneCos, spotLight.penumbraCos, angleCos);\nif (spotAttenuation > 0.0) {\nfloat lightDistance = length(lVector);\nlight.color = spotLight.color * spotAttenuation;\nlight.color *= getDistanceAttenuation(lightDistance, spotLight.distance, spotLight.decay);\nlight.visible = true;\n} else {\nlight.color = vec3(0.0);\nlight.visible = false;\n}\n#endif\n}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\nstruct RectAreaLight {\nvec3 color;\nvec3 position;\nvec3 halfWidth;\nvec3 halfHeight;\n};\nuniform sampler2D ltc_1;\nuniform sampler2D ltc_2;\nuniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif\n#if NUM_HEMI_LIGHTS > 0\nstruct HemisphereLight {\nvec3 direction;\nvec3 skyColor;\nvec3 groundColor;\n};\nuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\nvec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight, const in vec3 normal) {\nfloat dotNL = dot(normal, hemiLight.direction);\nfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\nvec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);\nreturn irradiance;\n}\n#endif";
var envmap_physical_pars_fragment = "#if defined(USE_ENVMAP)\n#define ENVMAP_PARALLAX_INFINITE 0\n#define ENVMAP_PARALLAX_SPHERE 1\n#define ENVMAP_PARALLAX_BOX 2\nuniform int envMapParallaxType;\nuniform mat4 envMapParallaxMatrix;\nuniform mat4 envMapParallaxMatrixInv;\nvec3 correctParallax(vec3 directionVecWorld, vec3 posWorld, int parallaxType) {\nvec3 posProbe = (envMapParallaxMatrix * vec4(posWorld, 1.0)).xyz;\nvec3 reflectVecProbe = transformDirection(directionVecWorld, envMapParallaxMatrix);\nif (parallaxType == ENVMAP_PARALLAX_SPHERE) {\nfloat b = 2.0 * dot(reflectVecProbe, posProbe);\nfloat c = dot(posProbe, posProbe) - 1.0;\nfloat D = b * b - 4.0 * c;\nif (D >= 0.0) {\nfloat x = (sqrt(D) - b) / 2.0;\nreflectVecProbe = posProbe + x * reflectVecProbe;\n}\n} else if (parallaxType == ENVMAP_PARALLAX_BOX) {\nvec3 scalePos = (vec3(1.0) - posProbe) / reflectVecProbe;\nvec3 scaleNeg = (vec3(-1.0) - posProbe) / reflectVecProbe;\nvec3 scalePosNeg = mix(scaleNeg, scalePos, step(vec3(0.0), reflectVecProbe));\nfloat x = min(scalePosNeg.x, min(scalePosNeg.y, scalePosNeg.z));\nreflectVecProbe = posProbe + x * reflectVecProbe;\n}\nvec3 directionVecWorldCorrected = transformDirection(reflectVecProbe,\nenvMapParallaxMatrixInv);\nreturn directionVecWorldCorrected;\n}\nvec3 getIBLIrradiance(const in vec3 normal) {\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec4 envMapColor = textureCubeUV(envMap, worldNormal, 1.0);\nreturn PI * envMapColor.rgb * envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\nvec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness, vec3 position) {\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec = reflect(-viewDir, normal);\nreflectVec = inverseTransformDirection(reflectVec, viewMatrix);\nif (envMapParallaxType != ENVMAP_PARALLAX_INFINITE) {\nvec3 posWorld = (invViewMatrix * vec4(position, 1.0)).xyz;\nreflectVec = correctParallax(reflectVec, posWorld, envMapParallaxType);\n}\nvec4 envMapColor = textureCubeUV(envMap, reflectVec, roughness);\nreturn envMapColor.rgb * envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\nvec3 getIBLRefraction(const in vec3 viewDir, const in vec3 normal, const in float roughness, const float refrRatio, vec3 position) {\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 refractVec = refract(-viewDir, normal, refrRatio);\nrefractVec = inverseTransformDirection(refractVec, viewMatrix);\nif (envMapParallaxType != ENVMAP_PARALLAX_INFINITE) {\nvec3 posWorld = (invViewMatrix * vec4(position, 1.0)).xyz;\nrefractVec = correctParallax(refractVec, posWorld, envMapParallaxType);\n}\nvec4 envMapColor = textureCubeUV(envMap, refractVec, roughness);\nreturn envMapColor.rgb * envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * (1.0 - metalnessFactor);\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.roughness = max(roughnessFactor, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\n#ifdef IOR\nmaterial.ior = ior;\n#ifdef SPECULAR\nfloat specularIntensityFactor = specularIntensity;\nvec3 specularColorFactor = specularColor;\n#ifdef USE_SPECULARINTENSITYMAP\nspecularIntensityFactor *= texture2D(specularIntensityMap, vUv).a;\n#endif\n#ifdef USE_SPECULARCOLORMAP\nspecularColorFactor *= texture2D(specularColorMap, vUv).rgb;\n#endif\nmaterial.specularF90 = mix(specularIntensityFactor, 1.0, metalnessFactor);\n#else\nfloat specularIntensityFactor = 1.0;\nvec3 specularColorFactor = vec3(1.0);\nmaterial.specularF90 = 1.0;\n#endif\nmaterial.specularColor = mix(min(pow2((material.ior - 1.0) / (material.ior + 1.0)) * specularColorFactor, vec3(1.0)) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor);\n#else\nmaterial.specularColor = mix(vec3(0.04), diffuseColor.rgb, metalnessFactor);\nmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = clearcoat;\nmaterial.clearcoatRoughness = clearcoatRoughness;\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#ifdef USE_CLEARCOATMAP\nmaterial.clearcoat *= texture2D(clearcoatMap, vUv).x;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nmaterial.clearcoatRoughness *= texture2D(clearcoatRoughnessMap, vUv).y;\n#endif\nmaterial.clearcoat = saturate(material.clearcoat);\nmaterial.clearcoatRoughness = max(material.clearcoatRoughness, 0.0525);\nmaterial.clearcoatRoughness += geometryRoughness;\nmaterial.clearcoatRoughness = min(material.clearcoatRoughness, 1.0);\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\nvec3 diffuseColor;\nfloat roughness;\nvec3 specularColor;\nfloat specularF90;\n#ifdef USE_CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\nvec3 clearcoatF0;\nfloat clearcoatF90;\n#endif\n#ifdef IOR\nfloat ior;\n#endif\n#ifdef USE_TRANSMISSION\nfloat transmission;\nfloat transmissionAlpha;\nfloat thickness;\nfloat attenuationDistance;\nvec3 attenuationColor;\n#endif\n};\nvec3 clearcoatSpecular = vec3(0.0);\nvec2 DFGApprox(const in vec3 normal, const in vec3 viewDir, const in float roughness) {\nfloat dotNV = saturate(dot(normal, viewDir));\nconst vec4 c0 = vec4(- 1, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;\nvec2 fab = vec2(- 1.04, 1.04) * a004 + r.zw;\nreturn fab;\n}\nvec3 EnvironmentBRDF(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness) {\nvec2 fab = DFGApprox(normal, viewDir, roughness);\nreturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {\nvec2 fab = DFGApprox(normal, viewDir, roughness);\nvec3 Fr = specularColor;\nvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\nfloat Ess = fab.x + fab.y;\nfloat Ems = 1.0 - Ess;\nvec3 Favg = Fr + (1.0 - Fr) * 0.047619;\nvec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);\nsingleScatter += FssEss;\nmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\nvoid RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nvec3 normal = geometry.normal;\nvec3 viewDir = geometry.viewDir;\nvec3 position = geometry.position;\nvec3 lightPos = rectAreaLight.position;\nvec3 halfWidth = rectAreaLight.halfWidth;\nvec3 halfHeight = rectAreaLight.halfHeight;\nvec3 lightColor = rectAreaLight.color;\nfloat roughness = material.roughness;\nvec3 rectCoords[4];\nrectCoords[0] = lightPos + halfWidth - halfHeight;\nrectCoords[1] = lightPos - halfWidth - halfHeight;\nrectCoords[2] = lightPos - halfWidth + halfHeight;\nrectCoords[3] = lightPos + halfWidth + halfHeight;\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(ltc_1, uv);\nvec4 t2 = texture2D(ltc_2, uv);\nmat3 mInv = mat3(\nvec3(t1.x, 0, t1.y),\nvec3( 0, 1, 0),\nvec3(t1.z, 0, t1.w)\n);\nvec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);\nreflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);\nreflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);\n}\n#endif\nvoid RE_Direct_Physical(const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifdef USE_CLEARCOAT\nfloat dotNLcc = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nvec3 ccIrradiance = dotNLcc * directLight.color;\nclearcoatSpecular += ccIrradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);\n#endif\nreflectedLight.directSpecular += irradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness);\nreflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Physical(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n#ifdef USE_CLEARCOAT\nclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF(geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);\n#endif\nvec3 singleScattering = vec3(0.0);\nvec3 multiScattering = vec3(0.0);\nvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\ncomputeMultiscattering(geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering);\nvec3 totalScattering = singleScattering + multiScattering;\nvec3 diffuse = material.diffuseColor * (1.0 - max(max(totalScattering.r, totalScattering.g), totalScattering.b));\nreflectedLight.indirectSpecular += radiance * singleScattering;\nreflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\nreflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct RE_Direct_Physical\n#define RE_Direct_RectArea RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\nreturn saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = -vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);\n#ifdef USE_CLEARCOAT\ngeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef PROBE_NORMAL\ngeometry.probeNormal = PROBE_NORMAL;\n#else\ngeometry.probeNormal = normal;\n#endif\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS > 0) && defined(RE_Direct)\nPointLight pointLight;\n#if defined(USE_SHADOWMAP) && NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\npointLight = pointLights[i];\ngetPointLightInfo(pointLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_POINT_LIGHT_SHADOWS)\npointLightShadow = pointLightShadows[i];\ndirectLight.color *= (directLight.visible && receiveShadow) ? getPointShadow(pointLightShadow, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n#endif\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_SPOT_LIGHTS > 0) && defined(RE_Direct)\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP) && NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\nspotLight = spotLights[i];\ngetSpotLightInfo(spotLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_SPOT_LIGHT_SHADOWS)\nspotLightShadow = spotLightShadows[i];\nif (directLight.visible && receiveShadow) {\nif (spotLightShadow.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= getSpotShadow(spotLightShadow, spotShadowMap[i],\nvSpotShadowCoord[i], distWorld);\n} else if (spotLightShadow.shadow == 2) {\ndirectLight.color *= getSpotOmniShadow(spotLightShadow,\nspotShadowMap[i], vSpotShadowCoord[i]);\n}\n}\n#endif\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_DIR_LIGHTS > 0) && defined(RE_Direct)\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS_CSM > 0\nDirectionalLightShadowCSM directionalLightShadowCSM;\nDirectionalLightShadowCascade dirShadowCascade;\nvec2 cascade;\nfloat cascadeCenter;\nfloat closestEdge;\nfloat margin;\nfloat csmx, csmy;\nfloat linearDepth;\nint maxCascadeIdx;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOW_CASCADES_CSM; i++) {\ndirShadowCascade = directionalLightShadowsCSMCascade[i];\n#if defined(LUT_DIR_LIGHT_SHADOWS_CSM)\ndirectionalLightShadowCSM = directionalLightShadowsCSM[LUT_DIR_LIGHT_SHADOWS_CSM[i]];\ndirectionalLight = directionalLights[LUT_DIR_LIGHT_SHADOWS_CSM[i]];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\n#else\nif (dirShadowCascade.csmIdx == 0) {\ndirectionalLightShadowCSM = directionalLightShadowsCSM[0];\ndirectionalLight = directionalLights[0];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\n}\n#if NUM_DIR_LIGHT_SHADOWS_CSM >= 2\nelse if (dirShadowCascade.csmIdx == 1) {\ndirectionalLightShadowCSM = directionalLightShadowsCSM[1];\ndirectionalLight = directionalLights[1];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM >= 3\nelse if (dirShadowCascade.csmIdx == 2) {\ndirectionalLightShadowCSM = directionalLightShadowsCSM[2];\ndirectionalLight = directionalLights[2];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM >= 4\nelse if (dirShadowCascade.csmIdx == 3) {\ndirectionalLightShadowCSM = directionalLightShadowsCSM[3];\ndirectionalLight = directionalLights[3];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM >= 5\nelse if (dirShadowCascade.csmIdx == 4) {\ndirectionalLightShadowCSM = directionalLightShadowsCSM[4];\ndirectionalLight = directionalLights[4];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\n}\n#endif\n#endif\nmaxCascadeIdx = directionalLightShadowCSM.cascadeIdxEnd;\nlinearDepth = (vViewPosition.z) / (directionalLightShadowCSM.shadowFar - directionalLightShadowCSM.cameraNear);\ncascade = dirShadowCascade.cascade;\n#if (i) < NUM_DIR_LIGHT_SHADOWS_CSM_WITH_FADE\ncascadeCenter = (cascade.x + cascade.y) / 2.0;\nclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\nmargin = directionalLightShadowCSM.fade * pow(closestEdge, 2.0);\ncsmx = cascade.x - margin / 2.0;\ncsmy = cascade.y + margin / 2.0;\nif (linearDepth >= csmx && (linearDepth < csmy || (i) == maxCascadeIdx - 1)) {\nfloat dist = min(linearDepth - csmx, csmy - linearDepth);\nfloat ratio = clamp(dist / margin, 0.0, 1.0);\nvec3 prevColor = directLight.color;\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(dirShadowCascade.position\n- directionalLight.direction * dirShadowCascade.shadowCameraNear\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= (directLight.visible && receiveShadow) ?\ngetDirShadowCSM(dirShadowCascade, directionalShadowCSMMap[i], vDirectionalShadowCSMCoord[i], distWorld)\n: 1.0;\nbool shouldFadeLastCascade = (i) == maxCascadeIdx - 1 && linearDepth > cascadeCenter;\ndirectLight.color = mix(prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0);\nReflectedLight prevLight = reflectedLight;\nRE_Direct(directLight, geometry, material, reflectedLight);\nbool shouldBlend = (i) != maxCascadeIdx - 1 || ((i) == maxCascadeIdx - 1 && linearDepth < cascadeCenter);\nfloat blendRatio = shouldBlend ? ratio : 1.0;\nreflectedLight.directDiffuse = mix(prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio);\nreflectedLight.directSpecular = mix(prevLight.directSpecular, reflectedLight.directSpecular, blendRatio);\nreflectedLight.indirectDiffuse = mix(prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio);\nreflectedLight.indirectSpecular = mix(prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio);\n}\n#else\nif (linearDepth >= cascade.x && (linearDepth < cascade.y || (i) == maxCascadeIdx - 1)) {\nif (directLight.visible && receiveShadow) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(dirShadowCascade.position\n- directionalLight.direction * dirShadowCascade.shadowCameraNear\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= getDirShadowCSM(dirShadowCascade, directionalShadowCSMMap[i], vDirectionalShadowCSMCoord[i], distWorld);\n}\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n}\n#endif\n#pragma unroll_loop\nfor (int i = NUM_DIR_LIGHT_SHADOWS_CSM; i < NUM_DIR_LIGHTS; i++) {\ndirectionalLight = directionalLights[i];\ngetDirectionalLightInfo(directionalLight, geometry, directLight);\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\n#if defined(USE_SHADOWMAP) && NUM_RECT_AREA_LIGHT_SHADOWS > 0\nRectAreaLightShadow rectAreaLightShadow;\n#endif\n#pragma unroll_loop\nfor (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {\nrectAreaLight = rectAreaLights[i];\n#if defined(USE_SHADOWMAP) && ((i) < NUM_RECT_AREA_LIGHT_SHADOWS)\nrectAreaLightShadow = rectAreaLightShadows[i];\nrectAreaLight.color *= receiveShadow ?\ngetRectAreaShadow(rectAreaLightShadow, rectAreaShadowMap[i], vRectAreaShadowCoord[i]) : 1.0;\n#endif\nRE_Direct_RectArea(rectAreaLight, geometry, material, reflectedLight);\n}\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 iblIrradiance = vec3(0.0);\nvec3 irradiance = getAmbientLightIrradiance(ambientLightColor);\nirradiance += getLightProbeIrradiance(lightProbe, geometry.probeNormal);\n#if (NUM_HEMI_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\nirradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry.probeNormal);\n}\n#endif\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance = vec3(0.0);\nvec3 clearcoatRadiance = vec3(0.0);\n#endif\n#if defined(RE_Refraction)\nvec3 refraction = vec3(0.0);\n#endif";
var lights_fragment_maps = "#if defined(RE_IndirectDiffuse)\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel = texture2D(lightMap, vUv2);\nvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\nirradiance += lightMapIrradiance;\n#endif\n#if defined(USE_ENVMAP) && (defined(STANDARD) || defined(NODE)) && defined(ENVMAP_TYPE_CUBE_UV)\niblIrradiance += getIBLIrradiance(geometry.probeNormal);\n#endif\n#endif\n#if defined(USE_ENVMAP) && defined(RE_IndirectSpecular)\nradiance += getIBLRadiance(geometry.viewDir, geometry.normal, material.roughness, geometry.position);\n#if defined(USE_SSR) && !defined(USE_SSR_REFRACT)\nradiance = computeSSR(radiance, geometry.normal, 0.0);\n#endif\n#if defined(USE_PLANE_REFLECTION)\nradiance = computePlaneReflection(radiance, material.roughness, geometry.position, geometry.normal, modelMatrix);\n#endif\n#ifdef USE_CLEARCOAT\nclearcoatRadiance += getIBLRadiance(geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, geometry.position);\n#endif\n#endif\n#if defined(USE_ENVMAP) && defined(RE_Refraction)\nrefraction += getIBLRefraction(geometry.viewDir, geometry.normal, material.refractionRoughness, 1.0 / material.refractionIOR, geometry.position);\n#ifdef USE_SSR_REFRACT\nrefraction = computeSSR(refraction, geometry.normal, material.refractionIOR);\n#endif\n#endif";
var lights_fragment_end = "#if defined(RE_IndirectDiffuse)\n#ifdef NODE\nirradiance += iblIrradiance;\n#endif\nRE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);\n#endif\n#if defined(RE_IndirectSpecular)\nRE_IndirectSpecular(radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight);\n#endif\n#if defined(RE_Refraction)\nRE_Refraction(refraction, material, refractedLight);\n#endif";
var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\nuniform float logDepthBufFC;\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#else\nuniform float logDepthBufFC;\n#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + gl_Position.w;\nvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\n#else\nif (isPerspectiveMatrix(projectionMatrix)) {\ngl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC - 1.0;\ngl_Position.z *= gl_Position.w;\n}\n#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\nvec4 sampledDiffuseColor = texture2D(map, vUv);\n#ifdef DECODE_VIDEO_TEXTURE\nsampledDiffuseColor = vec4(mix(pow(sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(sampledDiffuseColor.rgb, vec3(0.04045)))), sampledDiffuseColor.w);\n#endif\ndiffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\nuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined(USE_MAP) || defined(USE_ALPHAMAP)\nvec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy;\n#endif\n#ifdef USE_MAP\ndiffuseColor *= texture2D(map, uv);\n#endif\n#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D(alphaMap, uv).g;\n#endif";
var map_particle_pars_fragment = "#if defined(USE_MAP) || defined(USE_ALPHAMAP)\nuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness = texture2D(metalnessMap, vUv);\nmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\nuniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined(USE_MORPHCOLORS) && defined(MORPHTARGETS_TEXTURE)\nvColor *= morphTargetBaseInfluence;\nfor (int i = 0; i < MORPHTARGETS_COUNT; i++) {\n#if defined(USE_COLOR_ALPHA)\nif (morphTargetInfluences[i] != 0.0) vColor += getMorph(gl_VertexID, i, 2) * morphTargetInfluences[i];\n#elif defined(USE_COLOR)\nif (morphTargetInfluences[i] != 0.0) vColor += getMorph(gl_VertexID, i, 2).rgb * morphTargetInfluences[i];\n#endif\n}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\nobjectNormal *= morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor (int i = 0; i < MORPHTARGETS_COUNT; i++) {\nif (morphTargetInfluences[i] != 0.0) objectNormal += getMorph(gl_VertexID, i, 1).xyz * morphTargetInfluences[i];\n}\n#else\n#if MORPHTARGETS_COUNT > 0\nobjectNormal += morphNormal0 * morphTargetInfluences[0];\n#endif\n#if MORPHTARGETS_COUNT > 1\nobjectNormal += morphNormal1 * morphTargetInfluences[1];\n#endif\n#if MORPHTARGETS_COUNT > 2\nobjectNormal += morphNormal2 * morphTargetInfluences[2];\n#endif\n#if MORPHTARGETS_COUNT > 3\nobjectNormal += morphNormal3 * morphTargetInfluences[3];\n#endif\n#if MORPHTARGETS_COUNT > 4\nobjectNormal += morphNormal4 * morphTargetInfluences[4];\n#endif\n#if MORPHTARGETS_COUNT > 5\nobjectNormal += morphNormal5 * morphTargetInfluences[5];\n#endif\n#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\nuniform float morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nuniform float morphTargetInfluences[MORPHTARGETS_COUNT];\nuniform sampler2DArray morphTargetsTexture;\nuniform ivec2 morphTargetsTextureSize;\nvec4 getMorph(const in int vertexIndex, const in int morphTargetIndex, const in int offset) {\nint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\nint y = texelIndex / morphTargetsTextureSize.x;\nint x = texelIndex - y * morphTargetsTextureSize.x;\nivec3 morphUV = ivec3(x, y, morphTargetIndex);\nreturn texelFetch(morphTargetsTexture, morphUV, 0);\n}\n#else\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[12];\n#else\nuniform float morphTargetInfluences[6];\n#endif\n#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\ntransformed *= morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor (int i = 0; i < MORPHTARGETS_COUNT; i++) {\nif (morphTargetInfluences[i] != 0.0) transformed += getMorph(gl_VertexID, i, 0).xyz * morphTargetInfluences[i];\n}\n#else\n#if MORPHTARGETS_COUNT > 0\ntransformed += morphTarget0 * morphTargetInfluences[0];\n#endif\n#if MORPHTARGETS_COUNT > 1\ntransformed += morphTarget1 * morphTargetInfluences[1];\n#endif\n#if MORPHTARGETS_COUNT > 2\ntransformed += morphTarget2 * morphTargetInfluences[2];\n#endif\n#if MORPHTARGETS_COUNT > 3\ntransformed += morphTarget3 * morphTargetInfluences[3];\n#endif\n#if MORPHTARGETS_COUNT > 4\ntransformed += morphTarget4 * morphTargetInfluences[4];\n#endif\n#if MORPHTARGETS_COUNT > 5\ntransformed += morphTarget5 * morphTargetInfluences[5];\n#endif\n#ifndef USE_MORPHNORMALS\n#if MORPHTARGETS_COUNT > 6\ntransformed += morphTarget6 * morphTargetInfluences[6];\n#endif\n#if MORPHTARGETS_COUNT > 7\ntransformed += morphTarget7 * morphTargetInfluences[7];\n#endif\n#if MORPHTARGETS_COUNT > 8\ntransformed += morphTarget8 * morphTargetInfluences[8];\n#endif\n#if MORPHTARGETS_COUNT > 9\ntransformed += morphTarget9 * morphTargetInfluences[9];\n#endif\n#if MORPHTARGETS_COUNT > 10\ntransformed += morphTarget10 * morphTargetInfluences[10];\n#endif\n#if MORPHTARGETS_COUNT > 11\ntransformed += morphTarget1 * morphTargetInfluences[11];\n#endif\n#endif\n#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n#ifdef FLAT_SHADED\nvec3 fdx = dFdx(vViewPosition);\nvec3 fdy = dFdy(vViewPosition);\nvec3 normal = normalize(cross(fdx, fdy));\n#else\nvec3 normal = normalize(vNormal);\n#ifdef DOUBLE_SIDED\nnormal = normal * faceDirection;\n#endif\n#ifdef USE_TANGENT\nvec3 tangent = normalize(vTangent);\nvec3 bitangent = normalize(vBitangent);\n#ifdef DOUBLE_SIDED\ntangent = tangent * faceDirection;\nbitangent = bitangent * faceDirection;\n#endif\n#if defined(TANGENTSPACE_NORMALMAP) || defined(USE_CLEARCOAT_NORMALMAP)\nmat3 vTBN = mat3(tangent, bitangent, normal);\n#endif\n#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\nnormal = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\n#ifdef FLIP_SIDED\nnormal = -normal;\n#endif\n#ifdef DOUBLE_SIDED\nnormal = normal * faceDirection;\n#endif\nnormal = normalize(normalMatrix * normal);\n#elif defined(TANGENTSPACE_NORMALMAP)\nvec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\nmapN.xy *= normalScale;\n#ifdef USE_TANGENT\nnormal = normalize(vTBN * mapN);\n#else\nnormal = perturbNormal2Arb(-vViewPosition, normal, mapN, faceDirection);\n#endif\n#elif defined(USE_BUMPMAP)\nnormal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd(), faceDirection);\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent = normalize(transformedTangent);\nvBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat3 normalMatrix;\n#endif\n#if !defined (USE_TANGENT) && (defined (TANGENTSPACE_NORMALMAP) || defined (USE_CLEARCOAT_NORMALMAP))\nvec3 perturbNormal2Arb(vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection) {\nvec3 q0 = dFdx(eye_pos.xyz);\nvec3 q1 = dFdy(eye_pos.xyz);\nvec2 st0 = dFdx(vUv.st);\nvec2 st1 = dFdy(vUv.st);\nvec3 N = surf_norm;\nvec3 q1perp = cross(q1, N);\nvec3 q0perp = cross(N, q0);\nvec3 T = q1perp * st0.x + q0perp * st1.x;\nvec3 B = q1perp * st0.y + q0perp * st1.y;\nfloat det = max(dot(T, T), dot(B, B));\nfloat scale = (det == 0.0) ? 0.0 : faceDirection * inversesqrt(det);\nreturn normalize(T * (mapN.x * scale) + B * (mapN.y * scale) + N * mapN.z);\n}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\nvec3 clearcoatMapN = texture2D(clearcoatNormalMap, vUv).xyz * 2.0 - 1.0;\nclearcoatMapN.xy *= clearcoatNormalScale;\n#ifdef USE_TANGENT\nclearcoatNormal = normalize(vTBN * clearcoatMapN);\n#else\nclearcoatNormal = perturbNormal2Arb(-vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection);\n#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\nuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\nuniform sampler2D clearcoatNormalMap;\nuniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);";
var packing = "vec3 packNormalToRGB(const in vec3 normal) {\nreturn normalize(normal) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal(const in vec3 rgb) {\nreturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3(256. * 256. * 256., 256. * 256., 256.);\nconst vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.);\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA(const in float v) {\nvec4 r = vec4(fract(v * PackFactors), v);\nr.yzw -= r.xyz * ShiftRight8;\nreturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth(const in vec4 v) {\nreturn dot(v, UnpackFactors);\n}\nvec2 packDepthToRG(in highp float v) {\nreturn packDepthToRGBA(v).yx;\n}\nfloat unpackRGToDepth(const in highp vec2 v) {\nreturn unpackRGBAToDepth(vec4(v.xy, 0.0, 0.0));\n}\nvec4 pack2HalfToRGBA(vec2 v) {\nvec4 r = vec4(v.x, fract(v.x * 255.0), v.y, fract(v.y * 255.0));\nreturn vec4(r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half(vec4 v) {\nreturn vec2(v.x + (v.y / 255.0), v.z + (v.w / 255.0));\n}\nfloat viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far) {\nreturn (viewZ + near) / (near - far);\n}\nfloat orthographicDepthToViewZ(const in float linearClipZ, const in float near, const in float far) {\nreturn linearClipZ * (near - far) - near;\n}\nfloat viewZToPerspectiveDepth(const in float viewZ, const in float near, const in float far) {\nreturn ((near + viewZ) * far) / ((far - near) * viewZ);\n}\nfloat perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {\nreturn (near * far) / ((far - near) * invClipZ - far);\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\ngl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4(transformed, 1.0);\n#ifdef USE_INSTANCING\nmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if defined(BACKGROUND_DEPTH)\ngl_Position.z = gl_Position.w;\n#endif";
var dithering_fragment = "#ifdef DITHERING\ngl_FragColor.rgb = dithering(gl_FragColor.rgb);\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\nvec3 dithering(vec3 color) {\nfloat grid_position = rand(gl_FragCoord.xy);\nvec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);\ndither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);\nreturn color + dither_shift_RGB;\n}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness = texture2D(roughnessMap, vUv);\nroughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\nuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "\n#define BIAS_FRUSTUM_SCALE_COEFF 30.0\n#define ESM_SPOT_SINGLE_BLUR_COEFF 0.25\n#define PCF_POISSON_SPOT_OMNI_BLUR_COEFF 4.0\n#define PCF_POISSON_POINT_BLUR_COEFF 2.5\n#define ESM_BIAS_COEFF 100.0\n#ifndef ESM_DISTANCE_SCALE\n#define ESM_DISTANCE_SCALE 1.0\n#endif\n#ifdef USE_SHADOWMAP\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\nstruct SpotLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nint shadow;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\nstruct PointLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS > 0\nuniform sampler2D rectAreaShadowMap[NUM_RECT_AREA_LIGHT_SHADOWS];\nvarying vec4 vRectAreaShadowCoord[NUM_RECT_AREA_LIGHT_SHADOWS];\nstruct RectAreaLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform RectAreaLightShadow rectAreaLightShadows[NUM_RECT_AREA_LIGHT_SHADOWS];\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM > 0\nuniform sampler2D directionalShadowCSMMap[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nvarying vec4 vDirectionalShadowCSMCoord[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nstruct DirectionalLightShadowCascade {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nvec2 cascade;\nfloat expBias;\nvec3 position;\nint csmIdx;\n};\nstruct DirectionalLightShadowCSM {\nint cascadeIdxEnd;\nfloat cameraNear;\nfloat shadowFar;\nfloat fade;\n};\nuniform DirectionalLightShadowCSM directionalLightShadowsCSM[NUM_DIR_LIGHT_SHADOWS_CSM];\nuniform DirectionalLightShadowCascade directionalLightShadowsCSMCascade[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\n#endif\nconst vec3 PERMUTE_DIR_X = vec3(1.0, 0.0, 0.0);\nconst vec3 PERMUTE_DIR_Y = vec3(0.0, 1.0, 0.0);\nconst vec3 PERMUTE_DIR_Z = vec3(0.0, 0.0, 1.0);\nconst mat4 POISSON_DISK_0 = mat4(\n0.954845, 0.242214, -0.623893, -0.235473,\n-0.173288, 0.799228, 0.605969, -0.548050,\n-0.560406, 0.327647, -0.448307, -0.774344,\n0.308258, 0.417332, -0.125623, -0.056098\n);\nconst mat4 POISSON_DISK_1 = mat4(\n0.145585, -0.305634, 0.264060, -0.661648,\n0.617942, 0.652121, -0.041412, -0.893582,\n0.463911, 0.039752, 0.212664, 0.810727,\n-0.955989, -0.014390, -0.652588, 0.671204\n);\nfloat texture2DCompare(sampler2D depths, vec2 uv, float compare) {\nreturn step(compare, unpackRGBAToDepth(texture2D(depths, uv)));\n}\nfloat texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare) {\nconst vec2 offset = vec2(0.0, 1.0);\nvec2 texelSize = vec2(1.0) / size;\nvec2 centroidUV = floor(uv * size + 0.5) / size;\nfloat lb = texture2DCompare(depths, centroidUV + texelSize * offset.xx, compare);\nfloat lt = texture2DCompare(depths, centroidUV + texelSize * offset.xy, compare);\nfloat rb = texture2DCompare(depths, centroidUV + texelSize * offset.yx, compare);\nfloat rt = texture2DCompare(depths, centroidUV + texelSize * offset.yy, compare);\nvec2 f = fract(uv * size + 0.5);\nfloat a = mix(lb, lt, f.y);\nfloat b = mix(rb, rt, f.y);\nfloat c = mix(a, b, f.x);\nreturn c;\n}\nvec2 cubeToUV(vec3 v, float texelSizeY) {\nvec3 absV = abs(v);\nfloat scaleToCube = 1.0 / max(absV.x, max(absV.y, absV.z));\nabsV *= scaleToCube;\nv *= scaleToCube * (1.0 - 2.0 * texelSizeY);\nvec2 planar = v.xy;\nfloat almostATexel = 1.5 * texelSizeY;\nfloat almostOne = 1.0 - almostATexel;\nif (absV.z >= almostOne) {\nif (v.z > 0.0)\nplanar.x = 4.0 - v.x;\n} else if (absV.x >= almostOne) {\nfloat signX = sign(v.x);\nplanar.x = v.z * signX + 2.0 * signX;\n} else if (absV.y >= almostOne) {\nfloat signY = sign(v.y);\nplanar.x = v.x + 2.0 * signY + 2.0;\nplanar.y = v.z * signY - 2.0;\n}\nreturn vec2(0.125, 0.25) * planar + vec2(0.375, 0.75);\n}\nfloat texture2DShadowAvgCube(sampler2D depths, vec2 size, vec3 bd3D, float compare) {\nvec2 texelSize = vec2(1.0) / size;\nvec3 dirX = normalize(abs(bd3D.y) < 0.99999 ? vec3(bd3D.z, 0.0, -bd3D.x)\n: vec3(0.0, -bd3D.z, bd3D.y));\nvec3 dirY = cross(bd3D, dirX);\nfloat theta = PI_HALF * texelSize.y;\nvec3 sX = sin(theta) * dirX;\nvec3 sY = sin(theta) * dirY;\nfloat cosT = cos(theta);\nvec3 sampleVec[4];\nsampleVec[0] = bd3D;\nsampleVec[1] = bd3D * cosT + sY;\nsampleVec[2] = bd3D * cosT + sX;\nsampleVec[3] = sampleVec[2] * cosT + sY;\nfloat avg = 0.0;\nfor (int i = 0; i < 4; i++) {\navg += texture2DCompare(depths, cubeToUV(sampleVec[i], texelSize.y), compare);\n}\navg /= 4.0;\nreturn avg;\n}\nfloat getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord,\nfloat expBias, float distWorld) {\nfloat shadow = 1.0;\nshadowCoord.xyz /= shadowCoord.w;\nbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\nbool frustumTest = inFrustum && shadowCoord.z <= 1.0 && shadowCoord.z >= 0.0;\nif (frustumTest) {\n#if defined(SHADOWMAP_TYPE_BILINEAR)\nshadowCoord.z += shadowBias;\nshadow = texture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z);\n#elif defined(SHADOWMAP_TYPE_PCF)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat randAngle = rand(gl_FragCoord.xy) * PI2;\nfloat c = cos(randAngle), s = sin(randAngle);\nmat2 sampleMat = mat2(c, s, -s, c)\n* mat2(shadowRadius * texelSize.x, 0.0, 0.0, shadowRadius * texelSize.y);\nvec2 sampleVec[16];\nsampleVec[0] = POISSON_DISK_0[0].xy;\nsampleVec[1] = POISSON_DISK_0[0].zw;\nsampleVec[2] = POISSON_DISK_0[1].xy;\nsampleVec[3] = POISSON_DISK_0[1].zw;\nsampleVec[4] = POISSON_DISK_0[2].xy;\nsampleVec[5] = POISSON_DISK_0[2].zw;\nsampleVec[6] = POISSON_DISK_0[3].xy;\nsampleVec[7] = POISSON_DISK_0[3].zw;\nsampleVec[8] = POISSON_DISK_1[0].xy;\nsampleVec[9] = POISSON_DISK_1[0].zw;\nsampleVec[10] = POISSON_DISK_1[1].xy;\nsampleVec[11] = POISSON_DISK_1[1].zw;\nsampleVec[12] = POISSON_DISK_1[2].xy;\nsampleVec[13] = POISSON_DISK_1[2].zw;\nsampleVec[14] = POISSON_DISK_1[3].xy;\nsampleVec[15] = POISSON_DISK_1[3].zw;\nshadow = 0.0;\nfor (int i = 0; i < 16; i++) {\nshadow += texture2DCompare(shadowMap, shadowCoord.xy\n+ sampleMat * sampleVec[i], shadowCoord.z);\n}\nshadow /= 16.0;\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow = saturate(exp(expBias * (texture2D(shadowMap, shadowCoord.xy).x\n- length(distWorld) * ESM_DISTANCE_SCALE\n- ESM_BIAS_COEFF * shadowBias)));\n#else\nshadowCoord.z += shadowBias;\nshadow = texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z);\n#endif\n}\nreturn shadow;\n}\nfloat getOmniShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias,\nfloat expBias, float shadowRadius, vec4 shadowCoord,\nfloat shadowCameraNear, float shadowCameraFar) {\nfloat shadow = 1.0;\nvec3 lightToPosition = shadowCoord.xyz;\nfloat dp = (length(lightToPosition) - shadowCameraNear)\n/ (shadowCameraFar - shadowCameraNear);\nbool frustumTest = dp <= 1.0 && dp >= 0.0;\nif (frustumTest) {\nfloat biasScaleCoeff = BIAS_FRUSTUM_SCALE_COEFF\n/ (shadowCameraFar - shadowCameraNear);\ndp += shadowBias * biasScaleCoeff;\nvec3 bd3D = normalize(lightToPosition);\nvec2 texelSize = 1.0 / shadowMapSize;\n#if defined(SHADOWMAP_TYPE_BILINEAR)\nshadow = texture2DShadowAvgCube(shadowMap, shadowMapSize, bd3D, dp);\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow = saturate(exp(expBias * (texture2D(shadowMap,\ncubeVecToOctUV(bd3D, texelSize)).x\n- length(lightToPosition) * ESM_DISTANCE_SCALE\n- ESM_BIAS_COEFF * shadowBias)));\n#elif defined(SHADOWMAP_TYPE_PCF)\nfloat randAngle = rand(gl_FragCoord.xy) * PI2;\nfloat c = cos(randAngle), s = sin(randAngle);\nmat2 sampleMat = mat2(c, s, -s, c)\n* mat2(shadowRadius * texelSize.y, 0.0, 0.0, shadowRadius * texelSize.y);\nvec3 absBd3D = abs(bd3D);\nabsBd3D /= max(absBd3D.x, max(absBd3D.y, absBd3D.z));\nbvec2 isPointingCubeFace = greaterThan(absBd3D.xy, vec2(0.999));\nmat3 permuteMat = mat3(\nisPointingCubeFace.x ? PERMUTE_DIR_Y : PERMUTE_DIR_X,\nisPointingCubeFace.x || isPointingCubeFace.y ? PERMUTE_DIR_Z : PERMUTE_DIR_Y,\nisPointingCubeFace.x ? PERMUTE_DIR_X : isPointingCubeFace.y ? PERMUTE_DIR_Y : PERMUTE_DIR_Z\n);\nvec2 sampleVec[16];\nsampleVec[0] = POISSON_DISK_0[0].xy;\nsampleVec[1] = POISSON_DISK_0[0].zw;\nsampleVec[2] = POISSON_DISK_0[1].xy;\nsampleVec[3] = POISSON_DISK_0[1].zw;\nsampleVec[4] = POISSON_DISK_0[2].xy;\nsampleVec[5] = POISSON_DISK_0[2].zw;\nsampleVec[6] = POISSON_DISK_0[3].xy;\nsampleVec[7] = POISSON_DISK_0[3].zw;\nsampleVec[8] = POISSON_DISK_1[0].xy;\nsampleVec[9] = POISSON_DISK_1[0].zw;\nsampleVec[10] = POISSON_DISK_1[1].xy;\nsampleVec[11] = POISSON_DISK_1[1].zw;\nsampleVec[12] = POISSON_DISK_1[2].xy;\nsampleVec[13] = POISSON_DISK_1[2].zw;\nsampleVec[14] = POISSON_DISK_1[3].xy;\nsampleVec[15] = POISSON_DISK_1[3].zw;\nshadow = 0.0;\nfor (int i = 0; i < 16; i++) {\nshadow += texture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * sampleVec[i], 0.0), texelSize.y), dp);\n}\nshadow /= 16.0;\n#else\nshadow = texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp);\n#endif\n}\nreturn shadow;\n}\n#if NUM_POINT_LIGHT_SHADOWS > 0\nfloat getPointShadow(PointLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nmapSize *= 2.0;\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowRadius *= PCF_POISSON_POINT_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS > 0\nfloat getRectAreaShadow(RectAreaLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nmapSize *= 2.0;\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowRadius *= PCF_POISSON_POINT_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nfloat getSpotOmniShadow(SpotLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowRadius *= PCF_POISSON_SPOT_OMNI_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\nfloat biasLinearNormalizedToNonlinear(float bias, float near, float far,\nfloat projZ, float projW) {\nreturn (bias * (far + near) + 2.0 * projZ) / (bias * (far - near) + 2.0 * projW)\n- projZ / projW;\n}\nfloat getSpotShadow(SpotLightShadow light, sampler2D shadowMap, vec4 shadowCoord,\nfloat distWorld) {\nfloat shadowRadius = light.shadowRadius;\nfloat shadowBias = light.shadowBias;\n#if defined(SHADOWMAP_TYPE_ESM)\nshadowRadius *= ESM_SPOT_SINGLE_BLUR_COEFF;\n#endif\nshadowBias *= BIAS_FRUSTUM_SCALE_COEFF\n/ (light.shadowCameraFar - light.shadowCameraNear);\n#if defined(SHADOWMAP_TYPE_BASIC) || defined(SHADOWMAP_TYPE_BILINEAR) || defined(SHADOWMAP_TYPE_PCF)\nshadowBias = biasLinearNormalizedToNonlinear(shadowBias,\nlight.shadowCameraNear, light.shadowCameraFar, shadowCoord.z,\nshadowCoord.w);\n#endif\nreturn getShadow(shadowMap, light.shadowMapSize, shadowBias, shadowRadius, shadowCoord,\nlight.expBias, distWorld);\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM > 0\nfloat getDirShadowCSM(DirectionalLightShadowCascade light, sampler2D shadowMap,\nvec4 shadowCoord, float distWorld) {\nreturn getShadow(shadowMap, light.shadowMapSize, light.shadowBias, light.shadowRadius, shadowCoord,\nlight.expBias, distWorld);\n}\n#endif\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\nstruct SpotLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nint shadow;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\nstruct PointLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS > 0\nuniform mat4 rectAreaShadowMatrix[NUM_RECT_AREA_LIGHT_SHADOWS];\nvarying vec4 vRectAreaShadowCoord[NUM_RECT_AREA_LIGHT_SHADOWS];\nstruct RectAreaLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform RectAreaLightShadow rectAreaLightShadows[NUM_RECT_AREA_LIGHT_SHADOWS];\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM > 0\nuniform mat4 directionalShadowCSMMatrix[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nvarying vec4 vDirectionalShadowCSMCoord[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\nstruct DirectionalLightShadowCascade {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nvec2 cascade;\nfloat expBias;\nvec3 position;\nint csmIdx;\n};\nstruct DirectionalLightShadowCSM {\nint cascadeIdxEnd;\nfloat cameraNear;\nfloat shadowFar;\nfloat fade;\n};\nuniform DirectionalLightShadowCSM directionalLightShadowsCSM[NUM_DIR_LIGHT_SHADOWS_CSM];\nuniform DirectionalLightShadowCascade directionalLightShadowsCSMCascade[NUM_DIR_LIGHT_SHADOW_CASCADES_CSM];\n#endif\n#endif";
var shadowmap_vertex = "#if defined(USE_SHADOWMAP)\n#if NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 || NUM_RECT_AREA_LIGHT_SHADOWS > 0 || NUM_DIR_LIGHT_SHADOWS_CSM > 0\nvec3 shadowWorldNormal = inverseTransformDirection(transformedNormal, viewMatrix);\nvec4 shadowWorldPosition;\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * spotLightShadows[i].shadowNormalBias, 0);\nvSpotShadowCoord[i] = spotShadowMatrix[i] * shadowWorldPosition;\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * pointLightShadows[i].shadowNormalBias, 0);\nvPointShadowCoord[i] = pointShadowMatrix[i] * shadowWorldPosition;\n}\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_RECT_AREA_LIGHT_SHADOWS; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * rectAreaLightShadows[i].shadowNormalBias, 0);\nvRectAreaShadowCoord[i] = rectAreaShadowMatrix[i] * shadowWorldPosition;\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOW_CASCADES_CSM; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * directionalLightShadowsCSMCascade[i].shadowNormalBias, 0);\nvDirectionalShadowCSMCoord[i] = directionalShadowCSMMatrix[i] * shadowWorldPosition;\n}\n#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\nfloat shadow = 1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {\nspotLight = spotLightShadows[i];\nif (receiveShadow) {\nif (spotLight.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n+ vViewPosition, 0.0)).xyz);\n#endif\nshadow *= getSpotShadow(spotLight, spotShadowMap[i], vSpotShadowCoord[i], distWorld);\n} else if (spotLight.shadow == 2) {\nshadow *= getSpotOmniShadow(spotLight, spotShadowMap[i], vSpotShadowCoord[i]);\n}\n}\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {\npointLight = pointLightShadows[i];\nshadow *= receiveShadow ? getPointShadow(pointLight, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n}\n#endif\n#if NUM_RECT_AREA_LIGHT_SHADOWS > 0\nRectAreaLightShadow rectAreaLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_RECT_AREA_LIGHT_SHADOWS; i++) {\nrectAreaLight = rectAreaLightShadows[i];\nshadow *= receiveShadow ? getRectAreaShadow(rectAreaLight, rectAreaShadowMap[i], vRectAreaShadowCoord[i]) : 1.0;\n}\n#endif\n#if NUM_DIR_LIGHT_SHADOWS_CSM > 0\nDirectionalLightShadowCascade dirShadowCascade;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOW_CASCADES_CSM; i++) {\ndirShadowCascade = directionalLightShadowsCSMCascade[i];\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(dirShadowCascade.position\n+ vViewPosition, 0.0)).xyz);\n#endif\nshadow *= ((vViewPosition.z < dirShadowCascade.shadowCameraFar) && receiveShadow) ?\ngetDirShadowCSM(dirShadowCascade, directionalShadowCSMMap[i], vDirectionalShadowCSMCoord[i], distWorld)\n: 1.0;\n}\n#endif\n#endif\nreturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix(skinIndex.x);\nmat4 boneMatY = getBoneMatrix(skinIndex.y);\nmat4 boneMatZ = getBoneMatrix(skinIndex.z);\nmat4 boneMatW = getBoneMatrix(skinIndex.w);\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\nuniform mat4 bindMatrix;\nuniform mat4 bindMatrixInverse;\nuniform highp sampler2D boneTexture;\nuniform int boneTextureSize;\nmat4 getBoneMatrix(const in float i) {\nfloat j = i * 4.0;\nfloat x = mod(j, float(boneTextureSize));\nfloat y = floor(j / float(boneTextureSize));\nfloat dx = 1.0 / float(boneTextureSize);\nfloat dy = 1.0 / float(boneTextureSize);\ny = dy * (y + 0.5);\nvec4 v1 = texture2D(boneTexture, vec2(dx * (x + 0.5), y));\nvec4 v2 = texture2D(boneTexture, vec2(dx * (x + 1.5), y));\nvec4 v3 = texture2D(boneTexture, vec2(dx * (x + 2.5), y));\nvec4 v4 = texture2D(boneTexture, vec2(dx * (x + 3.5), y));\nmat4 bone = mat4(v1, v2, v3, v4);\nreturn bone;\n}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\nvec4 skinVertex = bindMatrix * vec4(transformed, 1.0);\nvec4 skinned = vec4(0.0);\nskinned += boneMatX * skinVertex * skinWeight.x;\nskinned += boneMatY * skinVertex * skinWeight.y;\nskinned += boneMatZ * skinVertex * skinWeight.z;\nskinned += boneMatW * skinVertex * skinWeight.w;\ntransformed = (bindMatrixInverse * skinned).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\nmat4 skinMatrix = mat4(0.0);\nskinMatrix += skinWeight.x * boneMatX;\nskinMatrix += skinWeight.y * boneMatY;\nskinMatrix += skinWeight.z * boneMatZ;\nskinMatrix += skinWeight.w * boneMatW;\nskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\nobjectNormal = vec4(skinMatrix * vec4(objectNormal, 0.0)).xyz;\n#ifdef USE_TANGENT\nobjectTangent = vec4(skinMatrix * vec4(objectTangent, 0.0)).xyz;\n#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D(specularMap, vUv);\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined(TONE_MAPPING)\ngl_FragColor.rgb = toneMapping(gl_FragColor.rgb);\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingMidTones;\nuniform float toneMappingPhysicalScale;\nuniform float toneMappingBrightness;\nuniform float toneMappingContrast;\nuniform bool toneMappingChromaticAdaptation;\nuniform vec3 toneMappingWhiteColor;\nuniform bool toneMappingColorDifferentiation;\nuniform bool toneMappingExteriorDaylight;\nuniform vec3 toneMappingWhiteBalance;\nuniform float toneMappingHighlights;\nuniform float toneMappingShadows;\nuniform float toneMappingSaturation;\nuniform float toneMappingAperture;\nuniform float toneMappingShutter;\nuniform float toneMappingISO;\nuniform float toneMappingVignetting;\nuniform vec2 toneMappingResolution;\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\nvec3(1.6605, -0.1246, -0.0182),\nvec3(- 0.5876, 1.1329, -0.1006),\nvec3(- 0.0728, -0.0083, 1.1187)\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\nvec3(0.6274, 0.0691, 0.0164),\nvec3(0.3293, 0.9195, 0.0880),\nvec3(0.0433, 0.0113, 0.8956)\n);\n#define TONE_MAPPING_LOOK_NONE 0\n#define TONE_MAPPING_LOOK_AGX_PUNCHY 1\nconst float FILMIC_BLENDER_LOG_MIN = -12.473931188;\nconst float FILMIC_BLENDER_LOG_MAX = 12.526068812;\nconst float FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO = 0.66;\nvec3 LinearToneMapping(vec3 color) {\nreturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\nreturn saturate(color / (vec3(1.0) + color));\n}\nvec3 OptimizedCineonToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\ncolor = max(vec3(0.0), color - 0.004);\nreturn pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\n}\nvec3 RRTAndODTFit(vec3 v) {\nvec3 a = v * (v + 0.0245786) -0.000090537;\nvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\nreturn a / b;\n}\nvec3 ACESFilmicToneMapping(vec3 color) {\nconst mat3 ACESInputMat = mat3(\nvec3(0.59719, 0.07600, 0.02840),\nvec3(0.35458, 0.90834, 0.13383),\nvec3(0.04823, 0.01566, 0.83777)\n);\nconst mat3 ACESOutputMat = mat3(\nvec3( 1.60475, -0.10208, -0.00327),\nvec3(-0.53108, 1.10813, -0.07276),\nvec3(-0.07367, -0.00605, 1.07602)\n);\ncolor *= toneMappingExposure / 0.6;\ncolor = ACESInputMat * color;\ncolor = RRTAndODTFit(color);\ncolor = ACESOutputMat * color;\nreturn saturate(color);\n}\nvec3 agxDefaultContrastApprox(vec3 x) {\nvec3 x2 = x * x;\nvec3 x4 = x2 * x2;\nreturn + 15.5 * x4 * x2\n-40.14 * x4 * x\n+ 31.96 * x4\n-6.868 * x2 * x\n+ 0.4298 * x2\n+ 0.1191 * x\n-0.00232;\n}\nvec3 toneMappingLook(vec3 color, int look) {\nif (look == TONE_MAPPING_LOOK_NONE) {\nreturn color;\n}\nconst vec3 lw = vec3(0.2126, 0.7152, 0.0722);\nfloat luma = dot(color, lw);\nvec3 offset = vec3(0.0);\nvec3 slope = vec3(1.0);\nvec3 power = vec3(1.0);\nfloat sat = 1.0;\nif (look == TONE_MAPPING_LOOK_AGX_PUNCHY) {\nslope = vec3(1.0);\npower = vec3(1.35, 1.35, 1.35);\nsat = 1.4;\n}\ncolor = pow(color * slope + offset, power);\nreturn luma + sat * (color - luma);\n}\nvec3 AgXToneMapping(vec3 color) {\nconst mat3 AgXInsetMatrix = mat3(\nvec3(0.856627153315983, 0.137318972929847, 0.11189821299995),\nvec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903),\nvec3(0.0482516061458583, 0.101439036467562, 0.811302368396859)\n);\nconst mat3 AgXOutsetMatrix = mat3(\nvec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),\nvec3(- 0.11060664309660323, 1.157823702216272, -0.11060664309660294),\nvec3(- 0.016493938717834573, -0.016493938717834257, 1.2519364065950405)\n);\nconst float AgxMinEv = -12.47393;\nconst float AgxMaxEv = 4.026069;\ncolor *= toneMappingExposure;\ncolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\ncolor = AgXInsetMatrix * color;\ncolor = max(color, 1e-10);\ncolor = log2(color);\ncolor = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);\ncolor = clamp(color, 0.0, 1.0);\ncolor = agxDefaultContrastApprox(color);\ncolor = toneMappingLook(color, TONE_MAPPING_LOOK);\ncolor = AgXOutsetMatrix * color;\ncolor = pow(max(vec3(0.0), color), vec3(2.2));\ncolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\ncolor = clamp(color, 0.0, 1.0);\nreturn color;\n}\nvec3 CustomToneMapping(vec3 color) { return color; }\n#define ORDERS_OF_MAG 5.0\n#define PI_TONE 3.14159265359\nfloat toneCalcBrightness(in vec3 color)\n{\nreturn (abs(color.r) * 0.263 + abs(color.g) * 0.655 + abs(color.b) * 0.082);\n}\nfloat toneApproximateScotopicLuminance(vec3 color)\n{\nreturn (0.062 * color.r + 0.608 * color.g + 0.330 * color.b);\n}\nvec3 LogarithmicMaxToneMapping(vec3 color) {\nfloat inputScaleFactor = toneMappingPhysicalScale / PI_TONE;\nfloat brightness = (toneMappingBrightness < 0.0) ? 0.0 : (toneMappingBrightness * 0.7);\nfloat powerBot = toneMappingExteriorDaylight ? 4.0 : 2.0;\nfloat res = 100.0 / ORDERS_OF_MAG;\nfloat mag = floor((50.0 / res));\nfloat power = ((brightness / 20.0 - ORDERS_OF_MAG) - powerBot) + mag;\nfloat stepsize = 9.0 / res;\nfloat step = 50.0 - (mag * res);\nfloat param_c = (0.02 * toneMappingContrast) * 2.0;\nfloat param_b = pow(10.0, power) * (1.0 + (stepsize * step));\nfloat param_a = param_b * (1.0 + param_c);\nparam_c /= pow(2.0, toneMappingMidTones - 1.0);\nparam_b *= PI_TONE;\nvec3 whiteConstancyFactor = toneMappingWhiteColor;\nif (toneMappingChromaticAdaptation) {\nfloat luminance = toneCalcBrightness(whiteConstancyFactor);\nwhiteConstancyFactor.r = (whiteConstancyFactor.r > 0.001) ? luminance / whiteConstancyFactor.r : luminance / 0.001;\nwhiteConstancyFactor.g = (whiteConstancyFactor.g > 0.001) ? luminance / whiteConstancyFactor.g : luminance / 0.001;\nwhiteConstancyFactor.b = (whiteConstancyFactor.b > 0.001) ? luminance / whiteConstancyFactor.b : luminance / 0.001;\n}\nvec3 outColor = inputScaleFactor * color;\nif (toneMappingChromaticAdaptation) {\noutColor *= whiteConstancyFactor.rgb;\n}\nfloat luminance = toneCalcBrightness(outColor);\nif (toneMappingColorDifferentiation && (luminance < 5.62)) {\nfloat sLuminance = toneApproximateScotopicLuminance(outColor);\nif (luminance <= 5.62e-3) {\noutColor = vec3(sLuminance);\n} else {\nfloat w = (luminance - 5.62e-3) / 5.61438;\noutColor = outColor * w + sLuminance * (1.0 - w);\n}\n}\noutColor = outColor * (param_a / (param_b * outColor + param_c));\nreturn outColor;\n}\nfloat maxExposurePhotographic(in vec4 color1, in vec4 color2)\n{\nreturn ((color1.r * color2.r) + (color1.g * color2.g)) + (color1.b * color2.b);\n}\nvec3 PhysicalMaxToneMapping(vec3 color) {\nfloat vignettingInfluence = 1.0;\nif (toneMappingVignetting > 0.0) {\nvec3 vignettingCoords = vec3(0.0, 0.0, 0.0);\nfloat aspect = toneMappingResolution.x / toneMappingResolution.y;\nvignettingCoords.x = gl_FragCoord.x / toneMappingResolution.x - 0.5;\nvignettingCoords.y = (gl_FragCoord.y / toneMappingResolution.y - 0.5) / aspect;\nvignettingCoords.z = 1.0;\nvignettingCoords = normalize(vignettingCoords);\nvignettingInfluence = pow(vignettingCoords.z, toneMappingVignetting);\n}\nfloat inputScaleFactor = toneMappingPhysicalScale / PI_TONE;\nfloat filmISO = toneMappingISO;\nfloat camShutter = 1.0 / toneMappingShutter;\nfloat fNumber = toneMappingAperture;\nfloat cm2 = 1.0;\nfloat burnHighlights = toneMappingHighlights;\nfloat crushBlacks = toneMappingShadows;\nfloat saturation = toneMappingSaturation;\nvec3 whitePointInfluence = toneMappingWhiteBalance;\nif (whitePointInfluence.r > 0.0) {\nwhitePointInfluence.r = 1.0 / whitePointInfluence.r;\n} else {\nwhitePointInfluence.r = 1.0;\n}\nif (whitePointInfluence.g > 0.0) {\nwhitePointInfluence.g = 1.0 / whitePointInfluence.g;\n} else {\nwhitePointInfluence.g = 1.0;\n}\nif (whitePointInfluence.b > 0.0) {\nwhitePointInfluence.b = 1.0 / whitePointInfluence.b;\n} else {\nwhitePointInfluence.b = 1.0;\n}\nvec4 lumFactor = vec4(0.212671, 0.715160, 0.072169, 0.0);\nfloat whiteLumFactor = maxExposurePhotographic(lumFactor, vec4(whitePointInfluence, 0.0));\nwhitePointInfluence.r /= whiteLumFactor;\nwhitePointInfluence.g /= whiteLumFactor;\nwhitePointInfluence.b /= whiteLumFactor;\nfloat isoInfluence = 0.0;\nfloat camShutterInv = 1.0 / camShutter;\nif (filmISO > 0.0) {\nisoInfluence = ((cm2 * 0.169811) * (filmISO * camShutterInv)) / ((15.4 * fNumber) * fNumber);\n} else {\nisoInfluence = cm2;\n}\nvec3 outColor = inputScaleFactor * color;\noutColor.r = outColor.r * whitePointInfluence.r * isoInfluence * vignettingInfluence;\noutColor.g = outColor.g * whitePointInfluence.g * isoInfluence * vignettingInfluence;\noutColor.b = outColor.b * whitePointInfluence.b * isoInfluence * vignettingInfluence;\noutColor.r = (outColor.r * (1.0 + (outColor.r * burnHighlights))) / (1.0 + outColor.r);\noutColor.g = (outColor.g * (1.0 + (outColor.g * burnHighlights))) / (1.0 + outColor.g);\noutColor.b = (outColor.b * (1.0 + (outColor.b * burnHighlights))) / (1.0 + outColor.b);\nfloat lumFactor2 = maxExposurePhotographic(lumFactor, vec4(outColor, 0.0));\nfloat tmpFloat = 1.0 - saturation;\noutColor.r = outColor.r * saturation + lumFactor2 * tmpFloat;\noutColor.g = outColor.g * saturation + lumFactor2 * tmpFloat;\noutColor.b = outColor.b * saturation + lumFactor2 * tmpFloat;\noutColor = max(vec3(0.0), outColor);\nfloat crushBlacksFac = crushBlacks * 2.0 + 1.0;\nfloat crushBlacksFac2 = pow(maxExposurePhotographic(lumFactor, vec4(outColor, 0.0)), 0.5);\ntmpFloat = (1.0 - crushBlacksFac2);\nif (crushBlacksFac2 < 1.0) {\noutColor.r = outColor.r * crushBlacksFac2 + pow(outColor.r, crushBlacksFac) * tmpFloat;\noutColor.g = outColor.g * crushBlacksFac2 + pow(outColor.g, crushBlacksFac) * tmpFloat;\noutColor.b = outColor.b * crushBlacksFac2 + pow(outColor.b, crushBlacksFac) * tmpFloat;\n}\nreturn outColor;\n}\nfloat filmicBlenderDesaturationMinIntensity(vec3 color) {\nfloat maxChannel = max(color.r, max(color.g, color.b));\nfloat x = max(maxChannel, 0.6251);\nreturn (1.2192868 * x - 0.63221059)\n* ((x - 0.65069831) / (abs(x - 0.65069831) + 0.00952982) + 0.73015231);\n}\nvec3 filmicBlenderDesaturationTransform(vec3 color) {\nconst float CURVE_SMOOTHNESS = 0.03;\nfloat minIntensity = filmicBlenderDesaturationMinIntensity(color);\nvec4 x = vec4(color, 1.0) - minIntensity;\nx = pow(x, vec4(2.0)) / (abs(x) + CURVE_SMOOTHNESS);\nreturn (x.rgb - x.a + color + 1.0) / 2.0;\n}\nvec3 filmicBlenderDynamicRangeTransform(vec3 color) {\nreturn pow(\n(0.28882259 * color - 0.15880336)\n/ (pow(color - 0.6229693, vec3(2.0)) + 0.16965022)\n+ 0.20453365 * color + 0.37847142,\nvec3(3.0)\n);\n}\nvec3 FilmicBlenderToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\ncolor = max(color, 0.000175);\ncolor = clamp((log2(color) - FILMIC_BLENDER_LOG_MIN)\n/ (FILMIC_BLENDER_LOG_MAX - FILMIC_BLENDER_LOG_MIN), 0.0, 1.0);\ncolor = filmicBlenderDesaturationTransform(color);\ncolor = clamp(color / FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO, 0.0, 1.0);\ncolor = filmicBlenderDynamicRangeTransform(color);\nreturn color;\n}\nvec3 PbrNeutralToneMapping(vec3 color) {\nconst float startCompression = 0.8 - 0.04;\nconst float desaturation = 0.15;\nfloat x = min(color.r, min(color.g, color.b));\nfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\ncolor -= offset;\nfloat peak = max(color.r, max(color.g, color.b));\nif (peak < startCompression)\nreturn color;\nconst float d = 1.0 - startCompression;\nfloat newPeak = 1.0 - d * d / (peak + d - startCompression);\ncolor *= newPeak / peak;\nfloat g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.);\nreturn mix(color, newPeak * vec3(1, 1, 1), g);\n}";
var transmission_fragment = "#ifdef USE_TRANSMISSION\nmaterial.transmission = transmission;\nmaterial.transmissionAlpha = 1.0;\nmaterial.thickness = thickness;\nmaterial.attenuationDistance = attenuationDistance;\nmaterial.attenuationColor = attenuationColor;\n#ifdef USE_TRANSMISSIONMAP\nmaterial.transmission *= texture2D(transmissionMap, vUv).r;\n#endif\n#ifdef USE_THICKNESSMAP\nmaterial.thickness *= texture2D(thicknessMap, vUv).g;\n#endif\nvec3 pos = vWorldPosition;\nvec3 v = normalize(cameraPosition - pos);\nvec3 n = inverseTransformDirection(normal, viewMatrix);\nvec4 transmission = getIBLVolumeRefraction(\nn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\npos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\nmaterial.attenuationColor, material.attenuationDistance);\nmaterial.transmissionAlpha = mix(material.transmissionAlpha, transmission.a, material.transmission);\ntotalDiffuse = mix(totalDiffuse, transmission.rgb, material.transmission);\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\nuniform float transmission;\nuniform float thickness;\nuniform float attenuationDistance;\nuniform vec3 attenuationColor;\n#ifdef USE_TRANSMISSIONMAP\nuniform sampler2D transmissionMap;\n#endif\n#ifdef USE_THICKNESSMAP\nuniform sampler2D thicknessMap;\n#endif\nuniform vec2 transmissionSamplerSize;\nuniform sampler2D transmissionSamplerMap;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 vWorldPosition;\nvec3 getVolumeTransmissionRay(const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix) {\nvec3 refractionVector = refract(- v, normalize(n), 1.0 / ior);\nvec3 modelScale;\nmodelScale.x = length(vec3(modelMatrix[0].xyz));\nmodelScale.y = length(vec3(modelMatrix[1].xyz));\nmodelScale.z = length(vec3(modelMatrix[2].xyz));\nreturn normalize(refractionVector) * thickness * modelScale;\n}\nfloat applyIorToRoughness(const in float roughness, const in float ior) {\nreturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n}\nvec4 getTransmissionSample(const in vec2 fragCoord, const in float roughness, const in float ior) {\nfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n#ifdef texture2DLodEXT\nreturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n#else\nreturn texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n#endif\n}\nvec3 applyVolumeAttenuation(const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance) {\nif (isinf(attenuationDistance)) {\nreturn radiance;\n} else {\nvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\nvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\nreturn transmittance * radiance;\n}\n}\nvec4 getIBLVolumeRefraction(const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\nconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\nconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\nconst in vec3 attenuationColor, const in float attenuationDistance) {\nvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\nvec3 refractedRayExit = position + transmissionRay;\nvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\nvec2 refractionCoords = ndcPos.xy / ndcPos.w;\nrefractionCoords += 1.0;\nrefractionCoords /= 2.0;\nvec4 transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);\nvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight.rgb, length(transmissionRay), attenuationColor, attenuationDistance);\nvec3 F = EnvironmentBRDF(n, v, specularColor, specularF90, roughness);\nreturn vec4((1.0 - F) * attenuatedColor * diffuseColor, transmittedLight.a);\n}\n#endif";
var uv_pars_fragment = "#if (defined(USE_UV) && !defined(UVS_VERTEX_ONLY))\nvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n#ifdef UVS_VERTEX_ONLY\nvec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\nuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\nvUv = (uvTransform * vec3(uv, 1)).xy;\n#endif";
var uv2_pars_fragment = "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nattribute vec2 uv2;\nvarying vec2 vUv2;\nuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nvUv2 = (uv2Transform * vec3(uv2, 1)).xy;\n#endif";
var webgl1_compat = "float cosh(float x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec2 cosh(vec2 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec3 cosh(vec3 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec4 cosh(vec4 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nfloat sinh(float x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec2 sinh(vec2 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec3 sinh(vec3 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec4 sinh(vec4 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nfloat tanh(float x) {\nfloat exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec2 tanh(vec2 x) {\nvec2 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec3 tanh(vec3 x) {\nvec3 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec4 tanh(vec4 x) {\nvec4 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nfloat trunc(float x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec2 trunc(vec2 x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec3 trunc(vec3 x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec4 trunc(vec4 x) {\nreturn floor(abs(x)) * sign(x);\n}";
var worldpos_vertex = "#if defined(USE_ENVMAP) || defined(DISTANCE) || defined (USE_SHADOWMAP) || defined (USE_TRANSMISSION) || defined(MASK) || defined(NODE)\nvec4 worldPosition = vec4(transformed, 1.0);\n#ifdef USE_INSTANCING\nworldPosition = instanceMatrix * worldPosition;\n#endif\nworldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\nvUv = (uvTransform * vec3(uv, 1)).xy;\ngl_Position = vec4(position.xy, 1.0, 1.0);\n}";
var fragment$g = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\nvec4 texColor = texture2D(t2D, vUv);\n#ifdef DECODE_VIDEO_TEXTURE\ntexColor = vec4(mix(pow(texColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), texColor.rgb * 0.0773993808, vec3(lessThanEqual(texColor.rgb, vec3(0.04045)))), texColor.w);\n#endif\ntexColor.rgb *= backgroundIntensity;\ngl_FragColor = texColor;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z = gl_Position.w;\n}";
var fragment$f = "#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n#ifdef ENVMAP_TYPE_CUBE\nvec4 texColor = textureCube(envMap, vec3(flipEnvMap * vWorldDirection.x, vWorldDirection.yz));\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec4 texColor = textureCubeUV(envMap, vWorldDirection, backgroundBlurriness);\n#else\nvec4 texColor = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ntexColor.rgb *= backgroundIntensity;\ngl_FragColor = texColor;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}";
var vertex$e = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z = gl_Position.w;\n}";
var fragment$e = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\nvec4 texColor = textureCube(tCube, vec3(tFlip * vWorldDirection.x, vWorldDirection.yz));\ngl_FragColor = texColor;\ngl_FragColor.a *= opacity;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}";
var vertex$d = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = mvPosition.xyz;\nvProjectedPosZW = mat2(\nprojectionMatrix[2][2], projectionMatrix[2][3],\nprojectionMatrix[3][2], projectionMatrix[3][3]\n) * mvPosition.zw;\n#ifdef PANCAKE_DEPTH\ngl_Position.z = max(gl_Position.z, -1.0);\n#endif\n}";
var fragment$d = "#if DEPTH_PACKING == 3200\nuniform float opacity;\n#endif\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS = 0.9999999;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\n#if DEPTH_PACKING == 3200\ndiffuseColor.a = opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\n#if DEPTH_PACKING != 3202\nfloat depth = vProjectedPosZW.x / vProjectedPosZW.y;\ndepth = (depth + 1.0) / 2.0;\n#ifdef PANCAKE_DEPTH\ndepth = max(depth, 0.0);\n#endif\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(depth), dFdy(depth)));\nfloat bias = slopeScaledBias * max(dxdy.x, dxdy.y);\ndepth = clamp(depth + max(bias, 1e-6), 0.0, ONE_MINUS_EPS);\n#endif\n#if DEPTH_PACKING == 3200\ngl_FragColor = vec4(vec3(1.0 - depth), opacity);\n#elif DEPTH_PACKING == 3201\ngl_FragColor = packDepthToRGBA(depth);\n#endif\n#else\ngl_FragColor = vec4(vViewPosition.z);\n#endif\n}";
var vertex$c = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#ifdef PANCAKE_DEPTH\nvarying vec4 vMVPPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\nvWorldPosition = worldPosition.xyz;\n#ifdef PANCAKE_DEPTH\nvec4 mvpPosition = projectionMatrix * mvPosition;\ngl_Position.z = max(mvpPosition.z, -1.0);\nvMVPPosition = mvpPosition;\n#endif\n}";
var fragment$c = "#define DISTANCE\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS = 0.9999999;\n#endif\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#ifdef PANCAKE_DEPTH\nvarying vec4 vMVPPosition;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#ifndef DISTANCE_SCALE\n#define DISTANCE_SCALE 1.0\n#endif\nvoid main () {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nfloat dist = length(vWorldPosition - referencePosition);\n#if DISTANCE_PACKING == 3301\ndist = (dist - nearDistance) / (farDistance - nearDistance);\ndist = saturate(dist);\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));\nfloat bias = slopeScaledBias * max(dxdy.x, dxdy.y);\ndist = clamp(dist + bias, 0.0, ONE_MINUS_EPS);\n#endif\ngl_FragColor = packDepthToRGBA(dist);\n#elif DISTANCE_PACKING == 3302\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));\ndist += slopeScaledBias * max(dxdy.x, dxdy.y);\n#endif\n#ifdef PANCAKE_DEPTH\nif (vMVPPosition.z < -1.0) {\ndist = length(vec3(vMVPPosition.x * CAM_WIDTH, vMVPPosition.y * CAM_HEIGHT, nearDistance));\n}\n#endif\ngl_FragColor = vec4(dist * DISTANCE_SCALE, 0.0, 0.0, 1.0);\n#endif\n}";
var vertex$b = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}";
var fragment$b = "uniform sampler2D tEquirect;\nuniform bool invertU;\nuniform float offsetU;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvec3 direction = normalize(vWorldDirection);\nvec2 sampleUV = equirectUv(direction);\nif (invertU)\nsampleUV.x = 1.0 - sampleUV.x;\nsampleUV.x += offsetU;\ngl_FragColor = texture2D(tEquirect, sampleUV);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}";
var vertex$a = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\nvLineDistance = scale * lineDistance;\n#include <color_vertex>\n#include <morphcolor_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nif (mod(vLineDistance, totalSize) > dashSize) {\ndiscard;\n}\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <color_fragment>\noutgoingLight = diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}";
var vertex$9 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <morphcolor_vertex>\n#if defined (USE_ENVMAP) || defined (USE_SKINNING)\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <fog_vertex>\n}";
var fragment$9 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel = texture2D(lightMap, vUv2);\nreflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n#else\nreflectedLight.indirectDiffuse += vec3(1.0);\n#endif\n#include <aomap_fragment>\nreflectedLight.indirectDiffuse *= diffuseColor.rgb;\nvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}";
var vertex$8 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <morphcolor_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = -mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}";
var fragment$8 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#if defined(SHADOWMAP_TYPE_ESM) || defined(USE_ENVMAP)\nuniform mat4 invViewMatrix;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_lambert_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvViewPosition = -mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\ngl_FragColor = vec4(packNormalToRGB(normal), opacity);\n#ifdef OPAQUE\ngl_FragColor.a = 1.0;\n#endif\n}";
var vertex$6 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\nvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <plane_reflection_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <morphcolor_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <plane_reflection_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = -mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_TRANSMISSION\nvWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$6 = "#define STANDARD\n#ifdef PHYSICAL\n#define IOR\n#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\nuniform float ior;\n#endif\n#ifdef SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n#ifdef USE_SPECULARINTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#ifdef USE_SPECULARCOLORMAP\nuniform sampler2D specularColorMap;\n#endif\n#endif\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#if defined(SHADOWMAP_TYPE_ESM) || defined(USE_ENVMAP)\nuniform mat4 invViewMatrix;\n#endif\n#if defined(USE_PLANE_REFLECTION) && !defined(USE_TRANSMISSION)\nuniform mat4 modelMatrix;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <plane_reflection_pars_fragment>\n#include <oit_weighted_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n#include <transmission_fragment>\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.clearcoatNormal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutgoingLight = outgoingLight * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n#include <oit_weighted_fragment>\n}";
var vertex$5 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <color_vertex>\n#include <morphcolor_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\ngl_PointSize = size;\n#ifdef USE_SIZEATTENUATION\nbool isPerspective = isPerspectiveMatrix(projectionMatrix);\nif (isPerspective) gl_PointSize *= (scale / - mvPosition.z);\n#endif\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <fog_vertex>\n}";
var fragment$5 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_particle_fragment>\n#include <color_fragment>\n#include <alphatest_fragment>\noutgoingLight = diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}";
var vertex$4 = "#include <common>\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#endif\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_SHADOWMAP\nvViewPosition = -mvPosition.xyz;\n#endif\n}";
var fragment$4 = "uniform vec3 color;\nuniform float opacity;\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#endif\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\ngl_FragColor = vec4(color, opacity * (1.0 - getShadowMask()));\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}";
var vertex$3 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\nvec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\nvec2 scale;\nscale.x = length(vec3(modelMatrix[0].x, modelMatrix[0].y, modelMatrix[0].z));\nscale.y = length(vec3(modelMatrix[1].x, modelMatrix[1].y, modelMatrix[1].z));\n#ifndef USE_SIZEATTENUATION\nbool isPerspective = isPerspectiveMatrix(projectionMatrix);\nif (isPerspective) scale *= -mvPosition.z;\n#endif\nvec2 alignedPosition = (position.xy - (center - vec2(0.5))) * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\nrotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\nmvPosition.xy += rotatedPosition;\ngl_Position = projectionMatrix * mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\noutgoingLight = diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}";
var vertex$2 = "#define MASK\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform mat4 textureMatrix;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\nvViewPosition = -mvPosition.xyz;\n#include <worldpos_vertex>\nprojTexCoord = textureMatrix * worldPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}";
var fragment$2 = "#define MASK\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform float opacity;\nuniform sampler2D depthTexture;\nuniform vec2 cameraNearFar;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\ndiffuseColor.a = opacity;\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat depth = unpackRGBAToDepth(texture2DProj(depthTexture, projTexCoord));\nfloat viewZ;\nif (isOrthographic)\nviewZ = -orthographicDepthToViewZ(depth,\ncameraNearFar.x, cameraNearFar.y);\nelse\nviewZ = -perspectiveDepthToViewZ(depth,\ncameraNearFar.x, cameraNearFar.y);\nfloat depthTest = (vViewPosition.z > viewZ) ? 1.0 : 0.0;\ngl_FragColor = vec4(0.0, depthTest, 1.0, 0.0);\n}";
var vertex$1 = "#define NODE\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <plane_reflection_pars_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_ENV_SPHERE_MY) || defined(NODE_UV_PROJECTION_AR) || defined(NODE_SUB_TRANSFORM_MX) || defined(NODE_SUB_TRANSFORM_MY)\nvarying vec3 vWorldPosition;\n#endif\n#include <node_pars_vertex>\nvoid main() {\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <plane_reflection_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = -mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_ENV_SPHERE_MY) || defined(NODE_UV_PROJECTION_AR) || defined(NODE_SUB_TRANSFORM_MX) || defined(NODE_SUB_TRANSFORM_MY)\nvWorldPosition = worldPosition.xyz;\n#endif\n#include <node_vertex>\n}";
var fragment$1 = "#define NODE\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#if defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FRESNEL_BL) || defined(NODE_BUMP_BL) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL) || defined(NODE_TANGENT_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_NOISE_MX) || defined(NODE_SUB_TRANSFORM_MX) || defined(NODE_SUB_TRANSFORM_MY) || defined(NODE_SAMPLER_INFO_MY) || defined(NODE_INCIDENT) || defined(NODE_POSITION) || defined(NODE_NORMAL) || defined(USE_OSL) || defined(USE_ENVMAP) || defined(SHADOWMAP_TYPE_ESM) && (defined(NODE_BSDF_DIFFUSE_BL) || defined(NODE_DIFFUSE_BSDF_BL) || defined(NODE_EEVEE_SPECULAR_BL) || defined(NODE_BSDF_GLOSSY_BL) || defined(NODE_BSDF_REFRACTION_BL) || defined(NODE_MATERIAL_MX) || defined(NODE_PHYSICAL_MX) || defined(NODE_STANDARD_SURFACE_AR) || defined(NODE_SHADOW_MATTE_AR))\nuniform mat4 invViewMatrix;\n#endif\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_node_pars_fragment>\n#include <lights_node_gtao_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#if defined(USE_SSR)\nuniform mat4 projectionMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_TANGENT_BL) || defined(NODE_OBJECT_INFO_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_NOISE_MX) || defined(NODE_SAMPLER_INFO_MY) || defined(NODE_TRANSFORM_MY) || defined(USE_OSL) || defined(USE_PLANE_REFLECTION) || defined(NODE_UV_PROJECTION_AR) || defined(NODE_SUB_TRANSFORM_MX) || defined(NODE_SUB_TRANSFORM_MY)\nuniform mat4 modelMatrix;\nuniform mat4 invModelMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_NORMAL_BUMP_MX) || defined(NODE_BUMP_2D_MY) || defined(NODE_SAMPLER_INFO_MY)\nuniform mat4 modelViewMatrix;\n#endif\n#if defined(NODE_TEX_IMAGE_BL)\nuniform mat3 normalMatrix;\n#endif\n#if defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_TANGENT_BL)\nuniform vec3 boundingBoxMin;\nuniform vec3 boundingBoxMax;\n#endif\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_ENV_SPHERE_MY) || defined(NODE_UV_PROJECTION_AR) || defined(NODE_SUB_TRANSFORM_MX) || defined(NODE_SUB_TRANSFORM_MY)\nvarying vec3 vWorldPosition;\n#endif\n#if defined(NODE_TEX_COORD_BL)\nuniform vec2 viewWidthHeight;\n#endif\n#include <ssr_pars_fragment>\n#include <plane_reflection_pars_fragment>\n#include <node_common_frag>\n#include <node_pars_fragment>\n#include <oit_weighted_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\nvec4 outgoingLight = vec4(0.0);\n#include <node_fragment>\n#if WORLD_NODES == 1\noutgoingLight.a = 1.0;\n#endif\n#ifdef USE_ALPHATEST\nif (outgoingLight.a < alphaTest)\ndiscard;\nelse\noutgoingLight.a = 1.0;\n#endif\n#if defined(OPAQUE) && !(defined(NODE_HOLDOUT_BL) || defined(NODE_MATTE_SHADOW_MX) || defined(NODE_SHADOW_MATTE_AR) || defined(NODE_AI_SHADOW_MATTE_MY))\noutgoingLight.a = 1.0;\n#endif\ngl_FragColor = vec4(outgoingLight);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n#include <normal_output_fragment>\n#include <oit_weighted_fragment>\n}";
var lights_node_pars_fragment = "\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct NodeMaterial {\nvec3 diffuseColor;\nfloat roughness;\nvec3 specularColor;\nfloat specularF90;\nvec3 fresnelRefl90;\nvec3 refractionColor;\nfloat refractionRoughness;\nfloat refractionIOR;\n#ifdef USE_CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\nvec3 clearcoatF0;\nfloat clearcoatF90;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenColor;\nfloat sheenRoughness;\n#endif\n};\nvec3 clearcoatSpecular = vec3(0.0);\nvec3 sheenSpecular = vec3(0.0);\nfloat IBLSheenBRDF(const in vec3 normal, const in vec3 viewDir, const in float roughness) {\nfloat dotNV = saturate(dot(normal, viewDir));\nfloat r2 = roughness * roughness;\nfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\nfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\nfloat DG = exp(a * dotNV + b) + (roughness < 0.25 ? 0.0 : 0.1 * (roughness - 0.25));\nreturn saturate(DG * RECIPROCAL_PI);\n}\n#if NUM_RECT_AREA_LIGHTS > 0\nvoid RE_Direct_RectArea_Node(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nvec3 normal = geometry.normal;\nvec3 viewDir = geometry.viewDir;\nvec3 position = geometry.position;\nvec3 lightPos = rectAreaLight.position;\nvec3 halfWidth = rectAreaLight.halfWidth;\nvec3 halfHeight = rectAreaLight.halfHeight;\nvec3 lightColor = rectAreaLight.color;\nfloat roughness = material.roughness;\nvec3 rectCoords[4];\nrectCoords[0] = lightPos + halfWidth - halfHeight;\nrectCoords[1] = lightPos - halfWidth - halfHeight;\nrectCoords[2] = lightPos - halfWidth + halfHeight;\nrectCoords[3] = lightPos + halfWidth + halfHeight;\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(ltc_1, uv);\nvec4 t2 = texture2D(ltc_2, uv);\nmat3 mInv = mat3(\nvec3(t1.x, 0, t1.y),\nvec3( 0, 1, 0),\nvec3(t1.z, 0, t1.w)\n);\nvec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);\nreflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);\nreflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);\n}\n#endif\nvoid RE_Direct_Node(const in IncidentLight directLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifdef USE_CLEARCOAT\nfloat dotNLcc = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nvec3 ccIrradiance = dotNLcc * directLight.color;\nclearcoatSpecular += ccIrradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nsheenSpecular += irradiance * BRDF_Sheen(directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness);\n#endif\nreflectedLight.directSpecular += irradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness);\nreflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Node(const in vec3 irradiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Node(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\n#ifdef USE_CLEARCOAT\nclearcoatSpecular += clearcoatRadiance * BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, vec3(material.clearcoatF90), material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF(geometry.normal, geometry.viewDir, material.sheenRoughness);\n#endif\n#ifdef MT_BLENDER\nvec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.normal, material.specularColor, material.fresnelRefl90, material.roughness);\n#elif defined(MT_MAX)\nfloat alphaEnv = pow2(pow2(material.roughness));\nvec3 specEnv = material.specularColor / (1.0 - alphaEnv + PI * alphaEnv);\n#elif defined(MT_MAYA)\nvec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.normal, material.specularColor, material.fresnelRefl90, material.roughness);\n#else\nvec3 specEnv = vec3(1.0);\n#endif\nreflectedLight.indirectSpecular += radiance * specEnv;\n}\nvoid RE_Refraction_Node(const vec3 refraction, const NodeMaterial material, inout vec3 refractedLight) {\nrefractedLight += refraction * material.refractionColor;\n}\nvoid RE_DirectDiffuseOnly_Node(const in IncidentLight directLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\nreflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Empty(const in vec3 irradiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {}\n#define RE_Direct_RectArea RE_Direct_RectArea_Node";
var lights_node_gtao_pars_fragment = "#ifdef USE_GTAO\nuniform sampler2D gtaoMap;\nuniform vec2 currResolution;\nfloat calcGTAOVisibilityFix(vec3 viewDir, vec3 normal) {\nfloat slopeCoeff = saturate(dot(viewDir, normal));\nreturn pow(2.0 / (slopeCoeff + 1.0), log2(PI) - 1.0);\n}\nfloat calcSolidAngle(float radiusAngle) {\nreturn PI2 * (1.0 - cos(radiusAngle));\n}\nfloat calcSolidAnglesIntersectionApprox(float radiusAngle0, float radiusAngle1,\nfloat distanceAngle) {\nfloat rp = radiusAngle0, rl = radiusAngle1, d = distanceAngle;\nfloat rDiff = abs(rp - rl);\nreturn PI2 * (1.0 - cos(min(rp, rl))) * smoothstep(0.0, 1.0, 1.0 -\n(d - rDiff) / (rp + rl - rDiff));\n}\nfloat calcGTSOVisibility(float aoVisibility, vec3 bentNormal, vec3 viewDir, vec3 normal,\nfloat roughness) {\naoVisibility = saturate(aoVisibility * calcGTAOVisibilityFix(viewDir, normal));\nfloat radiusAngleVisCone = acos(clamp(sqrt(1.0 - aoVisibility), -1.0, 1.0));\nfloat radiusAngleSpecCone = acos(clamp(exp2(-3.32193 * pow2(roughness)), -1.0, 1.0));\nradiusAngleSpecCone = max(0.001, radiusAngleSpecCone);\nvec3 specularConeAxis = -reflect(viewDir, normal);\nfloat distanceAngle = acos(clamp(dot(bentNormal, specularConeAxis), -1.0, 1.0));\nfloat solidAngleIntersection = calcSolidAnglesIntersectionApprox(\nradiusAngleVisCone, radiusAngleSpecCone, distanceAngle);\nfloat solidAngleSpecular = calcSolidAngle(radiusAngleSpecCone);\nfloat specVisibility = solidAngleIntersection / solidAngleSpecular;\nreturn mix(specVisibility, 1.0, aoVisibility);\n}\n#endif";
var lights_fragment_gtso = "#ifdef USE_GTAO\nreflectedLight.indirectSpecular *= calcGTSOVisibility(gtaoVisibility,\ngtaoBentNormal, gtaoViewDir, gtaoNormal, gtaoRoughness);\n#endif";
var normal_output_fragment = "#if NORMAL_OUTPUT == 1\ngl_FragColor = vec4(packNormalToRGB(normal), gl_FragColor.a);\n#endif";
var ssr_pars_fragment = "#ifdef USE_SSR\nuniform sampler2D ssrSourceBuffer;\nuniform sampler2D ssrDepthBuffer;\nuniform sampler2D ssrBackfaceDepthBuffer;\nuniform mat4 invProjectionMatrix;\nuniform vec2 ssrResolution;\nuniform float ssrThickness;\nuniform float ssrStride;\nuniform float ssrJitter;\nuniform float ssrMaxDistance;\n#ifdef USE_SSR_REFRACT\n#define STEPS_FADE_AMOUNT 0.1\n#define SCREEN_FADE_THRESHOLD 0.6\n#else\n#define STEPS_FADE_AMOUNT 1.0\n#define SCREEN_FADE_THRESHOLD 0.4\n#endif\nvec3 deproject(vec3 p) {\nvec4 res = invProjectionMatrix * vec4(p, 1);\nreturn res.xyz / res.w;\n}\nbool doesIntersect(float rayzmax, float rayzmin, vec2 uv) {\nfloat sceneZMin = texture2D(ssrDepthBuffer, uv).r;\n#ifdef USE_SSR_REFRACT\nreturn rayzmin >= (sceneZMin-ssrThickness) && rayzmax <= sceneZMin;\n#else\nfloat sceneZMax = texture2D(ssrBackfaceDepthBuffer, uv).r;\nreturn rayzmin >= sceneZMax && rayzmax <= sceneZMin;\n#endif\n}\nfloat distanceSquared(vec2 a, vec2 b) { a -= b; return dot(a, a); }\nvoid swapIfBigger(inout float a, inout float b) {\nif (a > b) {\nfloat t = a;\na = b;\nb = t;\n}\n}\nbool isOutsideUvBounds(float x) { return x < 0.0 || x > 1.0; }\nbool isOutsideUvBounds(vec2 uv) { return isOutsideUvBounds(uv.x) || isOutsideUvBounds(uv.y); }\nvec3 computeSSR(vec3 color, vec3 normal, float ior) {\nvec2 uv = gl_FragCoord.xy / ssrResolution;\nvec2 screenCoord = uv * 2.0 - vec2(1, 1);\nfloat nearClip = deproject(vec3(0, 0, -1)).z;\nvec3 ray = deproject(vec3(screenCoord, -1));\nray /= ray.z;\nfloat depthSample = -vViewPosition.z;\nvec3 vpos = depthSample * ray;\n#ifdef USE_SSR_REFRACT\nvec3 dir = normalize(refract(normalize(vpos), normalize(normal), 1.0/ior));\n#else\nvec3 dir = normalize(reflect(normalize(vpos), normalize(normal)));\n#endif\nfloat maxDist = ssrMaxDistance;\nfloat rayLength = (vpos.z + dir.z * maxDist) > nearClip ? (nearClip - vpos.z) / dir.z : maxDist;\nvec3 csOrig = vpos;\nvec3 csEndPoint = csOrig + dir * rayLength;\nvec4 H0 = projectionMatrix * vec4(csOrig, 1.0);\nvec4 H1 = projectionMatrix * vec4(csEndPoint, 1.0);\nfloat k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\nvec3 Q0 = csOrig.xyz * k0, Q1 = csEndPoint.xyz * k1;\nvec2 P0 = H0.xy * k0, P1 = H1.xy * k1;\nP0 = P0 * 0.5 + vec2(0.5), P1 = P1 * 0.5 + vec2(0.5);\n#ifndef SSR_SIMPLE_REFRACT\nP0 *= ssrResolution, P1 *= ssrResolution;\nP1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);\nvec2 delta = P1 - P0;\nbool permute = false;\nif (abs(delta.x) < abs(delta.y)) {\npermute = true; delta = delta.yx; P0 = P0.yx; P1 = P1.yx;\n}\nfloat stepDir = sign(delta.x);\nfloat invdx = stepDir / delta.x;\nvec3 dQ = (Q1 - Q0) * invdx;\nfloat dk = (k1 - k0) * invdx;\nvec2 dP = vec2(stepDir, delta.y * invdx);\nfloat pixelStride = ssrStride;\nfloat jitterMod = (gl_FragCoord.x + gl_FragCoord.y) * 0.25;\nvec4 PQK = vec4(P0, Q0.z, k0);\nvec4 dPQK = vec4(dP, dQ.z, dk);\ndPQK *= pixelStride;\nPQK += dPQK * mod(jitterMod, 1.0) * ssrJitter;\nfloat end = P1.x * stepDir;\nfloat prevZMaxEstimate = PQK.z / PQK.w;\nfloat rayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;\nfloat stepped = 0.0;\nvec2 hitUV;\nbool intersected = false;\nfor (float stepCount = 1.0; stepCount <= float(MAX_STEPS); stepCount ++) {\nPQK += dPQK;\nrayZMin = prevZMaxEstimate;\nrayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);\nprevZMaxEstimate = rayZMax;\nswapIfBigger(rayZMax, rayZMin);\nstepped = stepCount;\nhitUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;\nif (isOutsideUvBounds(hitUV)) break;\nintersected = doesIntersect(rayZMax, rayZMin, hitUV);\nif (intersected || (P0.x * stepDir) > end) break;\n}\nif (intersected && pixelStride > 1.0) {\nPQK -= dPQK;\ndPQK /= ssrStride;\nfloat ogStride = pixelStride * 0.5;\nfloat currStride = pixelStride;\nprevZMaxEstimate = PQK.z / PQK.w;\nrayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;\nfor(int j = 0; j < int(BINARY_SEARCH_ITERATIONS); j ++) {\nPQK += dPQK * currStride;\nrayZMin = prevZMaxEstimate;\nrayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);\nprevZMaxEstimate = rayZMax;\nswapIfBigger(rayZMax, rayZMin);\nvec2 newUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;\nogStride *= 0.5;\nif (doesIntersect(rayZMax, rayZMin, newUV)) {\nhitUV = newUV;\ncurrStride = -ogStride;\n} else {\ncurrStride = ogStride;\n}\n}\n}\nvec3 result = color;\n#ifdef USE_SSR_REFRACT\n#endif\nif (intersected) {\nvec4 col = texture2D(ssrSourceBuffer, hitUV);\nvec2 ndc = abs(hitUV * 2.0 - 1.0);\nfloat maxndc = max(ndc.x, ndc.y);\nfloat fadeVal =\n(1.0 - (max(0.0, maxndc - SCREEN_FADE_THRESHOLD) / (1.0 - SCREEN_FADE_THRESHOLD))) *\n(1.0 - STEPS_FADE_AMOUNT * (stepped / float(MAX_STEPS)));\ncol.a = fadeVal;\nresult = mix(result, col.rgb, col.a);\n}\n#else\nvec3 result = texture2D(ssrSourceBuffer, P1).xyz;\n#endif\nreturn result;\n}\n#endif";
var plane_reflection_pars_vertex = "#ifdef USE_PLANE_REFLECTION\nuniform mat4 planeReflTextureMatrix;\nvarying vec4 vPlaneReflUv;\n#endif";
var plane_reflection_pars_fragment = "#ifdef USE_PLANE_REFLECTION\nuniform sampler2D planeReflTexture;\nuniform mat4 planeReflTextureMatrix;\nuniform vec3 planeReflDir;\nuniform vec3 planeReflBoundingBoxMin;\nuniform vec3 planeReflBoundingBoxMax;\nuniform mat4 planeReflInvModelMatrix;\nuniform float planeReflFalloff;\nvarying vec4 vPlaneReflUv;\nvec3 computePlaneReflection(vec3 radiance, float roughness, vec3 position, vec3 normal, mat4 modelMatrix) {\nvec3 posRefl = (planeReflInvModelMatrix * invViewMatrix * vec4(position, 1.0)).xyz;\nif (any(lessThan(posRefl, planeReflBoundingBoxMin)) || any(greaterThan(posRefl, planeReflBoundingBoxMax)))\nreturn radiance;\nvec3 norWorld = transformDirection(normal, invViewMatrix);\nvec3 uvNormalOffsetScale;\nuvNormalOffsetScale.x = length(vec3(modelMatrix[0].xyz));\nuvNormalOffsetScale.y = length(vec3(modelMatrix[1].xyz));\nuvNormalOffsetScale.z = length(vec3(modelMatrix[2].xyz));\nvec4 uvNormalOffset = planeReflTextureMatrix * vec4((norWorld - planeReflDir) * uvNormalOffsetScale, 0.0);\nvec3 result = texture2DProj(planeReflTexture, vPlaneReflUv + uvNormalOffset).rgb;\nfloat falloffFactor;\nif (planeReflFalloff < EPSILON)\nfalloffFactor = 0.0;\nelse if (posRefl.y > 0.0)\nfalloffFactor = 1.0 - clamp((planeReflBoundingBoxMax.y - posRefl.y) / (planeReflBoundingBoxMax.y * (planeReflFalloff)), 0.0, 1.0);\nelse\nfalloffFactor = 1.0 - clamp((planeReflBoundingBoxMin.y - posRefl.y) / (planeReflBoundingBoxMin.y * (planeReflFalloff)), 0.0, 1.0);\nresult = mix(result, radiance, falloffFactor);\nresult = mix(result, radiance, (roughness < 0.0526) ? 0.0 : saturate(10.0*roughness));\nreturn result;\n}\n#endif";
var plane_reflection_vertex = "#ifdef USE_PLANE_REFLECTION\nvPlaneReflUv = planeReflTextureMatrix * modelMatrix * vec4(transformed, 1.0);\n#endif";
var oit_weighted_pars_fragment = "#ifdef USE_OIT_WEIGHTED\nlayout(location = 1) out float outBufferR;\n#endif";
var oit_weighted_fragment = "#ifdef USE_OIT_WEIGHTED\nfloat weight = 1.0 - gl_FragCoord.z;\noutBufferR = gl_FragColor.a * weight;\npc_fragColor = vec4(gl_FragColor.rgb * weight, gl_FragColor.a);\n#endif";
var node_common_frag = "\n#define LUM_WEIGHTS vec3(0.2126, 0.7152, 0.0722)\n#define LUM_WEIGHTS_MAYA vec3(0.3, 0.59, 0.11)\n#define LUMENS_PER_WATT 683.0\n#define MAX_ENV_COORDS_DIR 0\n#define MAX_ENV_COORDS_REFLECT 1\n#define MAX_ENV_COORDS_REFRACT 2\n#if defined(NODE_COLOR_CONVERT_AR) || defined(NODE_COLOR_CORRECT_AR) || defined(NODE_COMBINE_COLOR_BL) || defined(NODE_SEPARATE_COLOR_BL) || defined(NODE_COMBHSV_BL) || defined(NODE_SEPHSV_BL) || defined(NODE_HUE_SAT_BL) || defined(NODE_COLOR_CORRECTION_MX) || defined(NODE_COMPOSITE_LAYER_MX) || defined(NODE_COLOR_CORRECT_MY) || defined(USE_OSL)\n#define HSV_NODES\n#endif\n#define OPENPBR_EMISSION_LUM_FACTOR 0.001\nfloat powCompat(const in float val, const in float power) {\nif (power == 0.0)\nreturn 1.0;\nelse if (val < 0.0) {\nif (mod(-power, 2.0) == 0.0)\nreturn pow(abs(val), power);\nelse\nreturn -pow(abs(val), power);\n} else if (val == 0.0)\nreturn 0.0;\nreturn pow(abs(val), power);\n}\nfloat maxFromRGB(vec3 rgb) {\nreturn max(max(rgb.r, rgb.g), rgb.b);\n}\nvec3 swizzleUpZ(const vec3 vec) {\nreturn vec3(vec[0], -vec[2], vec[1]);\n}\nvec3 swizzleUpY(const vec3 vec) {\nreturn vec3(vec[0], vec[2], -vec[1]);\n}\nfloat getSmoothFactor(float a, float b, float smoothness) {\nreturn max(smoothness - abs(a - b), 0.0) / smoothness;\n}\nfloat smoothMin(float a, float b, float smoothness) {\nfloat smoothFac = getSmoothFactor(a, b, smoothness);\nreturn min(a, b) - smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);\n}\nfloat smoothMax(float a, float b, float smoothness) {\nfloat smoothFac = getSmoothFactor(a, b, smoothness);\nreturn max(a, b) + smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);\n}\nfloat mat3GetDeterminant(mat3 mat) {\nreturn mat[0][0] * mat[1][1] * mat[2][2]\n+ mat[0][2] * mat[1][0] * mat[2][1]\n+ mat[0][1] * mat[1][2] * mat[2][0]\n- mat[0][2] * mat[1][1] * mat[2][0]\n- mat[0][0] * mat[1][2] * mat[2][1]\n- mat[0][1] * mat[1][0] * mat[2][2];\n}\nmat3 mat3RotateX(float angle) {\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(1.0, 0.0, 0.0,\n0.0, c, s,\n0.0, -s, c);\n}\nmat3 mat3RotateY(float angle) {\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(c, 0.0, -s,\n0.0, 1.0, 0.0,\ns, 0.0, c);\n}\nmat3 mat3RotateZ(float angle) {\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(c, s, 0.0,\n-s, c, 0.0,\n0.0, 0.0, 1.0);\n}\nvec3 vec3RotateXAngle(vec3 vector, float angle) {\nreturn mat3RotateX(angle) * vector;\n}\nvec3 vec3RotateYAngle(vec3 vector, float angle) {\nreturn mat3RotateY(angle) * vector;\n}\nvec3 vec3RotateZAngle(vec3 vector, float angle) {\nreturn mat3RotateZ(angle) * vector;\n}\nvec4 eulerToAxisAngle(vec3 euler) {\nfloat c1 = cos(euler.x / 2.0), c2 = cos(euler.y / 2.0), c3 = cos(euler.z / 2.0);\nfloat s1 = sin(euler.x / 2.0), s2 = sin(euler.y / 2.0), s3 = sin(euler.z / 2.0);\nvec4 axisAngle = vec4(\ns1 * c2 * c3 - c1 * s2 * s3,\nc1 * s2 * c3 + s1 * c2 * s3,\nc1 * c2 * s3 - s1 * s2 * c3,\n2.0 * acos(c1 * c2 * c3 + s1 * s2 * s3)\n);\naxisAngle.xyz = length(axisAngle.xyz) > 0.0 ? normalize(axisAngle.xyz) : vec3(1.0, 0.0, 0.0);\nreturn axisAngle;\n}\nmat3 axisAngleToMat3(vec3 axis, float angle) {\nfloat s = sin(angle), c = cos(angle);\nfloat t = 1.0 - c;\nfloat x = axis.x, y = axis.y, z = axis.z;\nfloat tx = t * x, ty = t * y;\nreturn mat3(tx * x + c, tx * y - s * z, tx * z + s * y,\ntx * y + s * z, ty * y + c, ty * z - s * x,\ntx * z - s * y, ty * z + s * x, t * z * z + c);\n}\nmat3 toMat3(mat4 mat) {\nreturn mat3(mat[0][0], mat[0][1], mat[0][2],\nmat[1][0], mat[1][1], mat[1][2],\nmat[2][0], mat[2][1], mat[2][2]);\n}\nmat4 toMat4(mat3 mat) {\nreturn mat4(mat[0][0], mat[0][1], mat[0][2], 0.0,\nmat[1][0], mat[1][1], mat[1][2], 0.0,\nmat[2][0], mat[2][1], mat[2][2], 0.0,\n0.0, 0.0, 0.0, 1.0);\n}\nmat4 translationToMat4(vec3 v) {\nreturn mat4(1.0, 0.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0,\n0.0, 0.0, 1.0, 0.0,\nv.x, v.y, v.z, 1.0);\n}\nmat4 scalingToMat4(vec3 v) {\nreturn mat4(v.x, 0.0, 0.0, 0.0,\n0.0, v.y, 0.0, 0.0,\n0.0, 0.0, v.z, 0.0,\n0.0, 0.0, 0.0, 1.0);\n}\nvec4 nodeTexelToLinear(in vec4 color, in int sourceType) {\nif (sourceType == 1)\nreturn vec4(pow(color.rgb, vec3(2.2)), color.a);\nelse\nreturn color;\n}\nvec3 xyz_to_sRGB(vec3 xyz) {\nmat3 convMat = mat3(\n3.2406, -0.9689, 0.0557,\n-1.5372, 1.8758, -0.2040,\n-0.4986, 0.0415, 1.0570\n);\nreturn convMat * xyz;\n}\nvec3 xyY_to_XYZ(float x, float y, float Y) {\nfloat X = 0.0;\nfloat Z = 0.0;\nif (y != 0.0) {\nX = (Y / y) * x;\nZ = (Y / y) * (1.0 - x - y);\n}\nreturn vec3(X, Y, Z);\n}\n#if defined HSV_NODES\nvoid hsvToRGB(vec4 hsv, out vec4 outCol)\n{\nfloat i, f, p, q, t, h, s, v;\nvec3 rgb;\nh = hsv[0];\ns = hsv[1];\nv = hsv[2];\nif (s == 0.0)\nrgb = vec3(v, v, v);\nelse {\nif (h == 1.0)\nh = 0.0;\nh *= 6.0;\ni = floor(h);\nf = h - i;\nrgb = vec3(f, f, f);\np = v * (1.0 - s);\nq = v * (1.0 - (s * f));\nt = v * (1.0 - (s * (1.0 - f)));\nif (i == 0.0)\nrgb = vec3(v, t, p);\nelse if (i == 1.0)\nrgb = vec3(q, v, p);\nelse if (i == 2.0)\nrgb = vec3(p, v, t);\nelse if (i == 3.0)\nrgb = vec3(p, q, v);\nelse if (i == 4.0)\nrgb = vec3(t, p, v);\nelse\nrgb = vec3(v, p, q);\n}\noutCol = vec4(rgb, hsv.w);\n}\nvoid rgbToHSV(vec4 rgb, out vec4 outCol)\n{\nfloat cmax, cmin, h, s, v, cdelta;\nvec3 c;\ncmax = max(rgb[0], max(rgb[1], rgb[2]));\ncmin = min(rgb[0], min(rgb[1], rgb[2]));\ncdelta = cmax - cmin;\nv = cmax;\nif (cmax != 0.0)\ns = cdelta / cmax;\nelse {\ns = 0.0;\nh = 0.0;\n}\nif (s == 0.0)\nh = 0.0;\nelse {\nc = (vec3(cmax, cmax, cmax) - rgb.xyz) / cdelta;\nif (rgb.x == cmax) h = c[2] - c[1];\nelse if (rgb.y == cmax) h = 2.0 + c[0] - c[2];\nelse h = 4.0 + c[1] - c[0];\nh /= 6.0;\nif (h < 0.0)\nh += 1.0;\n}\noutCol = vec4(h, s, v, rgb.w);\n}\n#endif\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_ENV_SPHERE_MY)\nvec4 sampleEquirectangular(sampler2D map, vec3 reflectVec, mat3 uvTransform, int encoding)\n{\nreflectVec = normalize(reflectVec);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(reflectVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(reflectVec.x, reflectVec.z) * RECIPROCAL_PI2 + 0.5;\nsampleUV.y *= -1.0;\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (reflectVec.x) / seamWidth) *\nclamp (1.0 - reflectVec.z / seamWidth, 0.0, 1.0);\nsampleUV = (uvTransform * vec3(sampleUV, 1.0)).xy;\nreturn texture2D(map, sampleUV, seamBiasFactor * seam);\n}\n#endif\n#if defined(NODE_FRESNEL_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FALLOFF_MX) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL)\nfloat fresnelReflection(const vec3 dir, const vec3 normal, const float ior) {\nfloat cosTheta = clamp(abs(dot(dir, normal)), -1.0, 1.0);\nfloat gSquared = pow2(ior) + pow2(cosTheta) - 1.0;\nif (gSquared < 0.0) return 1.0;\nfloat g = sqrt(gSquared);\nreturn 0.5 * pow2((g - cosTheta) / (g + cosTheta))\n* (1.0 + pow2(\n((g + cosTheta) * cosTheta - 1.0) /\n((g - cosTheta) * cosTheta + 1.0)\n));\n}\n#endif\n#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX)\n#define MAPPING_EXPLICIT_MAP_CHANNEL 1\n#define MAPPING_VERTEX_COLOR_CHANNEL 2\n#define MAPPING_PLANAR_OBJECT_XYZ 3\n#define MAPPING_PLANAR_WORLD_XYZ 4\n#define AXIS_XY 1\n#define AXIS_YZ 2\n#define AXIS_ZX 3\n#endif\n#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_MX) || defined(NODE_GRADIENT_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_PLACE_2D_TEXTURE_MY)\nmat3 calcUvTransform(float uOffset, float vOffset, float uTiling, float vTiling, float wAngle)\n{\nif (abs(uOffset) < EPSILON && abs(vOffset) < EPSILON &&\n(abs(uTiling - 1.0)) < EPSILON && (abs(vTiling - 1.0)) < EPSILON &&\nabs(wAngle) < EPSILON)\nreturn mat3(1.0);\nfloat sx = uTiling;\nfloat sy = vTiling;\nfloat c = cos(-wAngle);\nfloat s = sin(-wAngle);\n#if defined(NODE_PLACE_2D_TEXTURE_MY)\nfloat tx = uOffset;\nfloat ty = vOffset;\nfloat cx = 0.5;\nfloat cy = 0.5;\nreturn mat3(c*sx, s*sx, 0.0,\n-s*sy, c*sy, 0.0,\ns*(ty+sy-cy)+c*(tx-cx)+cx, -c*(ty+sy-cy)+s*(tx-cx)-cy+1.0, 1.0);\n#else\nfloat tx = -uOffset;\nfloat ty = -vOffset;\nfloat cx = uOffset + 0.5;\nfloat cy = vOffset + 0.5;\nreturn mat3(sx * c, -sy * s, 0.0,\nsx * s, sy * c, 0.0,\n-sx * (c * cx + s * cy) + cx + tx, -sy * (- s * cx + c * cy) + cy + ty, 1.0);\n#endif\n}\n#endif\n#if defined(NODE_NOISE_MX)\nmat4 calcXYZTransform(vec3 offset, vec3 tiling, vec3 angle) {\nmat4 rot = mat4(\ncos(angle.y)*cos(angle.z), cos(angle.x)*sin(angle.z)+sin(angle.x)*sin(angle.y)*cos(angle.z), sin(angle.x)*sin(angle.z)-cos(angle.x)*sin(angle.y)*cos(angle.z), 0.0,\n-cos(angle.y)*sin(angle.z), cos(angle.x)*cos(angle.z)-sin(angle.x)*sin(angle.y)*sin(angle.z), cos(angle.x)*sin(angle.y)*sin(angle.z)+sin(angle.x)*cos(angle.z), 0.0,\nsin(angle.y), -sin(angle.x)*cos(angle.y), cos(angle.x)*cos(angle.y), 0.0,\n0.0, 0.0, 0.0, 1.0\n);\nmat4 til = mat4(\ntiling.x, 0.0, 0.0, 0.0,\n0.0, tiling.y, 0.0, 0.0,\n0.0, 0.0, tiling.z, 0.0,\n0.0, 0.0, 0.0, 1.0\n);\nmat4 off = mat4(\n1.0, 0.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0,\n0.0, 0.0, 1.0, 0.0,\noffset.x, offset.y, offset.z, 1.0\n);\nreturn (til * rot * off);\n}\n#endif\n#if defined(NODE_TEX_NOISE_BL) || defined(NODE_TEX_WAVE_BL) || defined(NODE_NOISE_MX) || defined(USE_OSL) || defined(NODE_NOISE_MY)\n#define NOISE_AMP_HACK 0.75\n#define NOISE_BLENDER_MEAN 0.78\n#define NOISE_SCALE_HACK 0.5\n#define noiseModulo(x) (x - floor(x * (1.0 / 289.0)) * 289.0)\nvec4 noisePermute(vec4 x) {\nreturn noiseModulo(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r) {\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat taylorInvSqrt(float r) {\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat noisePerlin(vec3 v) {\nconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\nconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\nvec3 i = floor(v + dot(v, C.yyy));\nvec3 x0 = v - i + dot(i, C.xxx);\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min(g.xyz, l.zxy);\nvec3 i2 = max(g.xyz, l.zxy);\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy;\nvec3 x3 = x0 - D.yyy;\ni = noiseModulo(i);\nvec4 p = noisePermute(noisePermute(noisePermute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\nfloat n_ = 0.142857142857;\nvec3 ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_);\nvec4 x = x_ * ns.x + ns.yyyy;\nvec4 y = y_ * ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\nvec4 b0 = vec4(x.xy, y.xy);\nvec4 b1 = vec4(x.zw, y.zw);\nvec4 s0 = floor(b0) * 2.0 + 1.0;\nvec4 s1 = floor(b1) * 2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\nvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\nvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\nvec3 p0 = vec3(a0.xy, h.x);\nvec3 p1 = vec3(a0.zw, h.y);\nvec3 p2 = vec3(a1.xy, h.z);\nvec3 p3 = vec3(a1.zw, h.w);\nvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\nvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\ndot(p2, x2), dot(p3, x3)));\n}\nvec4 permute(vec4 x) {\nreturn mod(((x*34.0)+1.0)*x, 289.0);\n}\nfloat permute(float x) {\nreturn floor(mod(((x*34.0)+1.0)*x, 289.0));\n}\nvec4 grad4(float j, vec4 ip) {\nconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\nvec4 p,s;\np.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\np.w = 1.5 - dot(abs(p.xyz), ones.xyz);\ns = vec4(lessThan(p, vec4(0.0)));\np.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\nreturn p;\n}\nfloat snoise(vec4 v) {\nconst vec2 C = vec2(0.138196601125010504,\n0.309016994374947451);\nvec4 i = floor(v + dot(v, C.yyyy) );\nvec4 x0 = v - i + dot(i, C.xxxx);\nvec4 i0;\nvec3 isX = step( x0.yzw, x0.xxx );\nvec3 isYZ = step( x0.zww, x0.yyz );\ni0.x = isX.x + isX.y + isX.z;\ni0.yzw = 1.0 - isX;\ni0.y += isYZ.x + isYZ.y;\ni0.zw += 1.0 - isYZ.xy;\ni0.z += isYZ.z;\ni0.w += 1.0 - isYZ.z;\nvec4 i3 = clamp( i0, 0.0, 1.0 );\nvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\nvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\nvec4 x1 = x0 - i1 + 1.0 * C.xxxx;\nvec4 x2 = x0 - i2 + 2.0 * C.xxxx;\nvec4 x3 = x0 - i3 + 3.0 * C.xxxx;\nvec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\ni = mod(i, 289.0);\nfloat j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\nvec4 j1 = permute( permute( permute( permute (\ni.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\nvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\nvec4 p0 = grad4(j0, ip);\nvec4 p1 = grad4(j1.x, ip);\nvec4 p2 = grad4(j1.y, ip);\nvec4 p3 = grad4(j1.z, ip);\nvec4 p4 = grad4(j1.w, ip);\nvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\np4 *= taylorInvSqrt(dot(p4,p4));\nvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\nvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);\nm0 = m0 * m0;\nm1 = m1 * m1;\nreturn 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat noiseBlender(vec3 p) {\nreturn 0.5 * NOISE_AMP_HACK * (noisePerlin(NOISE_SCALE_HACK * vec3(p.x, p.y, p.z))) + 0.5;\n}\nfloat noiseSmooth(vec3 p, float octaveLenPerPixel, float falloffFactor,\nfloat dispersionFactor) {\nfloat mixFac = mix(1.0, smoothstep(0.0, 1.0, octaveLenPerPixel) * falloffFactor,\ndispersionFactor);\nreturn mix(noiseBlender(p), NOISE_BLENDER_MEAN, mixFac);\n}\n#define MAX_OCTAVES_NUM 16\nfloat noiseTurbulence(vec3 p, float octaves, float octaveLenPerPixel,\nfloat falloffFactor, float dispersionFactor) {\nfloat fscale = 1.0;\nfloat amp = 1.0;\nfloat sum = 0.0;\noctaves = clamp(octaves, 0.0, 16.0);\nint octavesInt = int(octaves);\nfor (int i = 0; i <= MAX_OCTAVES_NUM; i++) {\n#if __VERSION__ == 300\nif (i <= octavesInt) {\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nsum += t * amp;\namp *= 0.5;\nfscale *= 2.0;\noctaveLenPerPixel *= 2.0;\n} else {\ni = MAX_OCTAVES_NUM;\n}\n#else\nif (i > octavesInt) break;\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nsum += t * amp;\namp *= 0.5;\nfscale *= 2.0;\noctaveLenPerPixel *= 2.0;\n#endif\n}\nfloat octavesFrac = fract(octaves);\nfloat octavesCoeff = pow(2.0, float(octavesInt));\nif (octavesFrac != 0.0) {\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nfloat sum2 = sum + t * amp;\nsum *= octavesCoeff / (2.0 * octavesCoeff - 1.0);\nsum2 *= 2.0 * octavesCoeff / (4.0 * octavesCoeff - 1.0);\nreturn mix(sum, sum2, octavesFrac);\n} else {\nreturn sum * octavesCoeff / (2.0 * octavesCoeff - 1.0);\n}\n}\n#endif\n#if (defined(USE_OSL) || defined(NODE_WAVELENGTH_BL)) && __VERSION__ == 300\nvec3 cieColorMatch[81] = vec3[](\nvec3(0.0014,0.0000,0.0065), vec3(0.0022,0.0001,0.0105), vec3(0.0042,0.0001,0.0201),\nvec3(0.0076,0.0002,0.0362), vec3(0.0143,0.0004,0.0679), vec3(0.0232,0.0006,0.1102),\nvec3(0.0435,0.0012,0.2074), vec3(0.0776,0.0022,0.3713), vec3(0.1344,0.0040,0.6456),\nvec3(0.2148,0.0073,1.0391), vec3(0.2839,0.0116,1.3856), vec3(0.3285,0.0168,1.6230),\nvec3(0.3483,0.0230,1.7471), vec3(0.3481,0.0298,1.7826), vec3(0.3362,0.0380,1.7721),\nvec3(0.3187,0.0480,1.7441), vec3(0.2908,0.0600,1.6692), vec3(0.2511,0.0739,1.5281),\nvec3(0.1954,0.0910,1.2876), vec3(0.1421,0.1126,1.0419), vec3(0.0956,0.1390,0.8130),\nvec3(0.0580,0.1693,0.6162), vec3(0.0320,0.2080,0.4652), vec3(0.0147,0.2586,0.3533),\nvec3(0.0049,0.3230,0.2720), vec3(0.0024,0.4073,0.2123), vec3(0.0093,0.5030,0.1582),\nvec3(0.0291,0.6082,0.1117), vec3(0.0633,0.7100,0.0782), vec3(0.1096,0.7932,0.0573),\nvec3(0.1655,0.8620,0.0422), vec3(0.2257,0.9149,0.0298), vec3(0.2904,0.9540,0.0203),\nvec3(0.3597,0.9803,0.0134), vec3(0.4334,0.9950,0.0087), vec3(0.5121,1.0000,0.0057),\nvec3(0.5945,0.9950,0.0039), vec3(0.6784,0.9786,0.0027), vec3(0.7621,0.9520,0.0021),\nvec3(0.8425,0.9154,0.0018), vec3(0.9163,0.8700,0.0017), vec3(0.9786,0.8163,0.0014),\nvec3(1.0263,0.7570,0.0011), vec3(1.0567,0.6949,0.0010), vec3(1.0622,0.6310,0.0008),\nvec3(1.0456,0.5668,0.0006), vec3(1.0026,0.5030,0.0003), vec3(0.9384,0.4412,0.0002),\nvec3(0.8544,0.3810,0.0002), vec3(0.7514,0.3210,0.0001), vec3(0.6424,0.2650,0.0000),\nvec3(0.5419,0.2170,0.0000), vec3(0.4479,0.1750,0.0000), vec3(0.3608,0.1382,0.0000),\nvec3(0.2835,0.1070,0.0000), vec3(0.2187,0.0816,0.0000), vec3(0.1649,0.0610,0.0000),\nvec3(0.1212,0.0446,0.0000), vec3(0.0874,0.0320,0.0000), vec3(0.0636,0.0232,0.0000),\nvec3(0.0468,0.0170,0.0000), vec3(0.0329,0.0119,0.0000), vec3(0.0227,0.0082,0.0000),\nvec3(0.0158,0.0057,0.0000), vec3(0.0114,0.0041,0.0000), vec3(0.0081,0.0029,0.0000),\nvec3(0.0058,0.0021,0.0000), vec3(0.0041,0.0015,0.0000), vec3(0.0029,0.0010,0.0000),\nvec3(0.0020,0.0007,0.0000), vec3(0.0014,0.0005,0.0000), vec3(0.0010,0.0004,0.0000),\nvec3(0.0007,0.0002,0.0000), vec3(0.0005,0.0002,0.0000), vec3(0.0003,0.0001,0.0000),\nvec3(0.0002,0.0001,0.0000), vec3(0.0002,0.0001,0.0000), vec3(0.0001,0.0000,0.0000),\nvec3(0.0001,0.0000,0.0000), vec3(0.0001,0.0000,0.0000), vec3(0.0000,0.0000,0.0000)\n);\n#endif\n#if defined(USE_OSL) || defined(NODE_BLACKBODY_BL)\nvec3 colorTempToRGB(float temp)\n{\nvec3 retColor;\ntemp = clamp(temp, 100.0, 40000.0) / 100.0;\nif (temp <= 66.0) {\nretColor.r = 1.0;\nretColor.g = saturate(0.390081578 * log(temp) - 0.631841443);\n} else {\nfloat t = temp - 60.0;\nretColor.r = saturate(1.292936186 * pow(t, -0.133204759));\nretColor.g = saturate(1.129890860 * pow(t, -0.075514849));\n}\nif (temp >= 66.0)\nretColor.b = 1.0;\nelse if (temp <= 19.0)\nretColor.b = 0.0;\nelse\nretColor.b = saturate(0.543206789 * log(temp - 10.0) - 1.196254089);\nretColor.rgb = pow(retColor.rgb, vec3(2.2));\nreturn retColor;\n}\n#endif\n#if (defined(NODE_TEX_WHITE_NOISE_BL) || defined(NODE_TEX_GABOR_BL)) && __VERSION__ == 300\n#define rotUint32(x, k) (((x) << (k)) | ((x) >> (32 - (k))))\n#define mixUint32(a, b, c) { a -= c; a ^= rotUint32(c, 4); c += b; b -= a; b ^= rotUint32(a, 6); a += c; c -= b; c ^= rotUint32(b, 8); b += a; a -= c; a ^= rotUint32(c, 16); c += b; b -= a; b ^= rotUint32(a, 19); a += c; c -= b; c ^= rotUint32(b, 4); b += a; }\n#define finalUint32(a, b, c) { c ^= b; c -= rotUint32(b, 14); a ^= c; a -= rotUint32(c, 11); b ^= a; b -= rotUint32(a, 25); c ^= b; c -= rotUint32(b, 16); a ^= c; a -= rotUint32(c, 4); b ^= a; b -= rotUint32(a, 14); c ^= b; c -= rotUint32(b, 24); }\nuint hashUint(uint x) {\nuint a = 0xdeadbeefu + 17u + x;\nuint b = 0xdeadbeefu + 17u;\nuint c = 0xdeadbeefu + 17u;\nfinalUint32(a, b, c);\nreturn c;\n}\nuint hashUint2(uvec2 vec) {\nuvec3 abc = uvec3(0xdeadbeefu + 21u) + uvec3(vec, 0u);\nfinalUint32(abc.x, abc.y, abc.z);\nreturn abc.z;\n}\nuint hashUint3(uvec3 vec) {\nuvec3 abc = uvec3(0xdeadbeefu + 25u) + vec;\nfinalUint32(abc.x, abc.y, abc.z);\nreturn abc.z;\n}\nuint hashUint4(uvec4 vec) {\nuvec3 abc = uvec3(0xdeadbeefu + 29u) + vec.xyz;\nmixUint32(abc.x, abc.y, abc.z);\nabc.x += vec.w;\nfinalUint32(abc.x, abc.y, abc.z);\nreturn abc.z;\n}\n#undef rotUint32\n#undef mixUint32\n#undef finalUint32\nfloat uintToFloat(uint value) {\nreturn float(value) / float(0xFFFFFFFFu);\n}\nfloat hashFloatToFloat(float value) {\nreturn uintToFloat(hashUint(floatBitsToUint(value)));\n}\nfloat hashVec2ToFloat(vec2 vec) {\nreturn uintToFloat(hashUint2(floatBitsToUint(vec)));\n}\nfloat hashVec3ToFloat(vec3 vec) {\nreturn uintToFloat(hashUint3(floatBitsToUint(vec)));\n}\nfloat hashVec4ToFloat(vec4 vec) {\nreturn uintToFloat(hashUint4(floatBitsToUint(vec)));\n}\nvec2 hashVec3ToVec2(vec3 k) {\nreturn vec2(hashVec3ToFloat(k.xyz), hashVec3ToFloat(k.zxy));\n}\nvec2 hashVec4ToVec2(vec4 k) {\nreturn vec2(hashVec4ToFloat(k.xyzw), hashVec4ToFloat(k.zxwy));\n}\nvec3 hashFloatToVec3(float val) {\nreturn vec3(hashFloatToFloat(val), hashVec2ToFloat(vec2(val, 1.0)),\nhashVec2ToFloat(vec2(val, 2.0)));\n}\nvec3 hashVec2ToVec3(vec2 vec) {\nreturn vec3(hashVec2ToFloat(vec), hashVec3ToFloat(vec3(vec, 1.0)),\nhashVec3ToFloat(vec3(vec, 2.0)));\n}\nvec3 hashVec3ToVec3(vec3 vec) {\nreturn vec3(hashVec3ToFloat(vec), hashVec4ToFloat(vec4(vec, 1.0)),\nhashVec4ToFloat(vec4(vec, 2.0)));\n}\nvec3 hashVec4ToVec3(vec4 vec) {\nreturn vec3(hashVec4ToFloat(vec.xyzw), hashVec4ToFloat(vec.zxwy),\nhashVec4ToFloat(vec.wzyx));\n}\n#endif";
var node_osl_frag = "#ifdef USE_OSL\n#define M_PI PI\n#define M_PI_2 PI / 2.0\n#define M_PI_4 PI / 4.0\n#define M_2_PI 2.0 / PI\n#define M_2PI 2.0 * PI\n#define M_4PI 4.0 * PI\n#define M_2_SQRTPI 2.0 / sqrt(PI)\n#define M_E 2.718281828459\n#define M_LN2 0.69314718056\n#define M_LN10 2.30258509299\n#define M_LOG2E 1.4426950409\n#define M_LOG10E 0.43429448190\n#define M_SQRT2 sqrt(2.0)\n#define M_SQRT1_2 sqrt(0.5)\n#define OSL_ALPHA 33633\n#define OSL_ANISOTROPIC 40205\n#define OSL_AVERAGEALPHA 57701\n#define OSL_AVERAGECOLOR 46077\n#define OSL_BANDWIDTH 37485\n#define OSL_BEZIER 27645\n#define OSL_BLACK 62409\n#define OSL_BSPLINE 16959\n#define OSL_CAMERA 8198\n#define OSL_CAMERA_CLIP 34380\n#define OSL_CAMERA_CLIP_FAR 31933\n#define OSL_CAMERA_CLIP_NEAR 21485\n#define OSL_CAMERA_FOV 60706\n#define OSL_CAMERA_PIXELASPECT 4950\n#define OSL_CAMERA_PROJECTION 29369\n#define OSL_CAMERA_RESOLUTION 39679\n#define OSL_CAMERA_SCREEN_WINDOW 47009\n#define OSL_CAMERA_SHUTTER 7107\n#define OSL_CAMERA_SHUTTER_CLOSE 34406\n#define OSL_CAMERA_SHUTTER_OPEN 40085\n#define OSL_CATMULL_ROM 31642\n#define OSL_CELL 20984\n#define OSL_CHANNELS 8726\n#define OSL_CLAMP 20052\n#define OSL_COLOR 53753\n#define OSL_COMMON 49871\n#define OSL_CONSTANT 25144\n#define OSL_DATAWINDOW 54276\n#define OSL_DEFAULT 54870\n#define OSL_DIFFUSE 40389\n#define OSL_DIRECTION 42220\n#define OSL_DISPLAYWINDOW 30728\n#define OSL_DISTANCE 51337\n#define OSL_DO_FILTER 35765\n#define OSL_EMPTY 9314\n#define OSL_ERRORMESSAGE 38305\n#define OSL_EXISTS 41510\n#define OSL_FILL 39132\n#define OSL_FIRSTCHANNEL 48155\n#define OSL_GABOR 57764\n#define OSL_GEOM_NAME 63686\n#define OSL_GLOSSY 47998\n#define OSL_HASH 49390\n#define OSL_HERMITE 63643\n#define OSL_HIT 48491\n#define OSL_HITDIST 22029\n#define OSL_HSL 49898\n#define OSL_HSV 29073\n#define OSL_IMPULSES 56191\n#define OSL_INDEX 1731\n#define OSL_INTERP 10557\n#define OSL_LINEAR 2182\n#define OSL_MIRROR 64591\n#define OSL_MISSINGALPHA 39755\n#define OSL_MISSINGCOLOR 51667\n#define OSL_NDC 48899\n#define OSL_NORMAL 16520\n#define OSL_OBJECT 59084\n#define OSL_OSL_VERSION 47920\n#define OSL_PERIODIC 8749\n#define OSL_PERLIN 730\n#define OSL_POSITION 43041\n#define OSL_RASTER 2618\n#define OSL_REFLECTION 37621\n#define OSL_REFRACTION 37287\n#define OSL_RESOLUTION 48704\n#define OSL_RGB 26673\n#define OSL_RWRAP 47801\n#define OSL_SCREEN 55875\n#define OSL_SHADER 21066\n#define OSL_SHADER_GROUPNAME 62327\n#define OSL_SHADER_LAYERNAME 51796\n#define OSL_SHADER_SHADERNAME 65123\n#define OSL_SHADOW 60708\n#define OSL_SIMPLEX 61636\n#define OSL_SUBIMAGE 33526\n#define OSL_SUBIMAGES 2366\n#define OSL_SWRAP 4328\n#define OSL_TEXTUREFORMAT 17851\n#define OSL_TIME 52235\n#define OSL_TRACE 62908\n#define OSL_TWRAP 30524\n#define OSL_TYPE 64071\n#define OSL_UPERLIN 65308\n#define OSL_USIMPLEX 11314\n#define OSL_WIDTH 48751\n#define OSL_WORLD 9059\n#define OSL_WORLDTOCAMERA 32273\n#define OSL_WORLDTOSCREEN 33876\n#define OSL_WRAP 58300\n#define OSL_XYY 2228\n#define OSL_XYZ 47351\n#define OSL_YIQ 15839\nvec3 oslGetP(vec3 viewPos) {\n#if WORLD_NODES == 1\nreturn swizzleUpZ((invViewMatrix * vec4(-viewPos, 0.0)).xyz);\n#else\nreturn swizzleUpZ((invViewMatrix * vec4(-viewPos, 1.0)).xyz);\n#endif\n}\nvec3 oslGetI(vec3 viewPos) {\n#if WORLD_NODES == 1\nreturn swizzleUpZ((invViewMatrix * vec4(normalize(-viewPos), 0.0)).xyz);\n#else\nreturn swizzleUpZ((invViewMatrix * vec4(normalize(-viewPos), 0.0)).xyz);\n#endif\n}\nvec3 oslGetN(vec3 viewNorm) {\nreturn swizzleUpZ(normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz);\n}\nvec3 oslBlackbody(float temperatureK) {\nreturn vec4(colorTempToRGB(temperatureK), 1.0).rgb;\n}\nfloat oslDistance(vec3 p0, vec3 p1) {\nreturn distance(p0, p1);\n}\nfloat oslDistance(vec3 p0, vec3 p1, vec3 q) {\nvec3 d = p1 - p0;\nfloat dd = dot(d, d);\nif (dd == 0.0)\nreturn distance(q, p0);\nfloat t = dot(q - p0, d) / dd;\nreturn distance(q, p0 + clamp(t, 0.0, 1.0) * d);\n}\nint oslEndsWith(int name1, int name2) {\nreturn int(name1 == name2);\n}\nint oslFormat(int name1, int name2) {\nreturn name2;\n}\nint oslGetAttribute(int name, out int value) {\nvalue = 0;\nreturn 0;\n}\nint oslGetAttribute(int name, out float value) {\nvalue = 0.0;\nreturn 0;\n}\nint oslGetAttribute(int name, out vec3 vec) {\nvec = vec3(0.0, 0.0, 0.0);\nreturn 0;\n}\nvoid oslGetTextureInfo(int filename, int name, out int value) {\nvalue = 4;\n}\nvoid oslGetTextureInfo(int filename, int name, out int value[2]) {\nvalue[0] = 1024;\nvalue[1] = 1024;\n}\nvec3 oslHSV(float h, float s, float v) {\nvec4 outCol;\nhsvToRGB(vec4(h, s, v, 1.0), outCol);\nreturn outCol.rgb;\n}\nfloat oslHypot(float x, float y) {\nreturn sqrt(x*x + y*y);\n}\nfloat oslHypot(float x, float y, float z) {\nreturn sqrt(x*x + y*y + z*z);\n}\nfloat oslLog2(float x, float y) {\nreturn log(x) / log(y);\n}\nfloat oslLuminance(vec3 color) {\nreturn linearToRelativeLuminance(color);\n}\nfloat oslNoise(int type, vec3 vec, float phase) {\nfloat n = snoise(vec4(vec, phase));\nif (type == OSL_UPERLIN)\nn = n * 0.5 + 0.5;\nreturn n;\n}\nfloat oslNoise(int type, float value, float phase) {\nreturn oslNoise(type, vec3(value), phase);\n}\nfloat oslNoise(int type, vec3 vec) {\nreturn oslNoise(type, vec, 0.0);\n}\nfloat oslNoise(int type, float value) {\nreturn oslNoise(type, vec3(value), 0.0);\n}\nvec3 oslNoise3D(int type, vec3 vec, float phase) {\nfloat x = snoise(vec4(vec, phase));\nfloat y = snoise(vec4(vec.y, vec.x, vec.z, phase));\nfloat z = snoise(vec4(vec.y, vec.z, vec.x, phase));\nvec3 n = vec3(x, y, z);\nif (type == OSL_UPERLIN)\nn = n * 0.5 + 0.5;\nreturn n;\n}\nvec3 oslNoise3D(int type, float value, float phase) {\nreturn oslNoise3D(type, vec3(value), phase);\n}\nvec3 oslNoise3D(int type, vec3 vec) {\nreturn oslNoise3D(type, vec, 0.0);\n}\nvec3 oslNoise3D(int type, float value) {\nreturn oslNoise3D(type, vec3(value), 0.0);\n}\nfloat oslPow(float a, float b) {\nreturn pow(a, b);\n}\nvec3 oslPow(vec3 a, float b) {\nreturn pow(a, vec3(b));\n}\nint oslRayType(int name) {\nif (name == OSL_CAMERA)\n#if LIGHT_PATH_IS_CAM_RAY\nreturn 1;\n#else\nreturn 0;\n#endif\nelse\nreturn 0;\n}\nvec3 oslRotate(vec3 vec, float angle, vec3 p0, vec3 p1) {\nvec3 axis = normalize(p1 - p0);\nfloat c = cos(angle);\nfloat s = sin(angle);\nfloat x = axis[0];\nfloat y = axis[1];\nfloat z = axis[2];\nmat4 mat = mat4(\nx * x + (1.0 - x * x) * c, x * y * (1.0 - c) + z * s, x * z * (1.0 - c) - y * s, 0.0,\nx * y * (1.0 - c) - z * s, y * y + (1.0 - y * y) * c, y * z * (1.0 - c) + x * s, 0.0,\nx * z * (1.0 - c) + y * s, y * z * (1.0 - c) - x * s, z * z + (1.0 - z * z) * c, 0.0,\n0.0, 0.0, 0.0, 1.0\n);\nreturn (mat * vec4((vec - p0), 1.0) + vec4(p0, 1.0)).xyz;\n}\nvec3 oslRotate(vec3 vec, float angle, vec3 axis) {\nreturn oslRotate(vec, angle, vec3(0.0), axis);\n}\nint oslStartsWith(int name1, int name2) {\nreturn int(name1 == name2);\n}\nint oslStrLen(int name) {\nif (name == OSL_EMPTY)\nreturn 0;\nelse\nreturn 1;\n}\nint oslSubStr(int s, int start, int len) {\nreturn s;\n}\nint oslSubStr(int s, int start) {\nreturn s;\n}\nvec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode, int alphaFlag, out float alpha) {\nif (wrapMode == OSL_DEFAULT || wrapMode == OSL_BLACK) {\nif (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)\nreturn vec3(0.0);\n} else if (wrapMode == OSL_CLAMP) {\nu = clamp(u, 0.0, 1.0);\nv = clamp(v, 0.0, 1.0);\n} else if (wrapMode == OSL_PERIODIC) {\nu = mod(u, 1.0);\nv = mod(v, 1.0);\n} else if (wrapMode == OSL_MIRROR) {\nif (mod(floor(u), 2.0) == 0.0)\nu = u - floor(u);\nelse\nu = 1.0 - (u - floor(u));\nif (mod(floor(v), 2.0) == 0.0)\nv = v - floor(v);\nelse\nv = 1.0 - (v - floor(v));\n}\nvec4 colAlpha = texture2D(image, vec2(u, v));\nalpha = colAlpha.a;\nreturn colAlpha.rgb;\n}\nvec3 oslTexture(sampler2D image, float u, float v, int alphaFlag, out float alpha, int wrapModeFlag, int wrapMode) {\nreturn oslTexture(image, u, v, wrapModeFlag, wrapMode, alphaFlag, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v, int alphaFlag, out float alpha) {\nreturn oslTexture(image, u, v, OSL_WRAP, OSL_DEFAULT, alphaFlag, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode) {\nfloat alpha;\nreturn oslTexture(image, u, v, wrapModeFlag, wrapMode, OSL_ALPHA, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v) {\nfloat alpha;\nreturn oslTexture(image, u, v, OSL_WRAP, OSL_DEFAULT, OSL_ALPHA, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode, int colorSpaceFlag, int colorSpace) {\nfloat alpha;\nreturn oslTexture(image, u, v, wrapModeFlag, wrapMode, OSL_ALPHA, alpha);\n}\nvec3 oslTransform(int fromSpace, int toSpace, vec4 vec) {\nif (toSpace == OSL_WORLD || toSpace == OSL_SHADER || toSpace == OSL_COMMON) {\nreturn vec.xyz;\n} else if (toSpace == OSL_OBJECT) {\nvec = vec4(swizzleUpY(vec.xyz), vec.w);\nvec = invModelMatrix * vec;\nreturn swizzleUpZ(vec.xyz);\n} else if (toSpace == OSL_CAMERA) {\nvec = vec4(swizzleUpY(vec.xyz), vec.w);\nreturn (viewMatrix * vec).xyz;\n} else if (toSpace == OSL_SCREEN) {\nreturn vec.xyz;\n} else if (toSpace == OSL_RASTER) {\nreturn gl_FragCoord.xyz;\n} else if (toSpace == OSL_NDC) {\nreturn vec.xyz;\n} else {\nreturn vec.xyz;\n}\n}\nvec3 oslTransform(int fromSpace, int toSpace, vec3 vec) {\nreturn oslTransform(fromSpace, toSpace, vec4(vec, 1.0));\n}\nvec3 oslTransform(int toSpace, vec3 vec) {\nreturn oslTransform(OSL_COMMON, toSpace, vec4(vec, 1.0));\n}\nvec3 oslTransformDir(int fromSpace, int toSpace, vec3 vec) {\nreturn oslTransform(fromSpace, toSpace, vec4(vec, 0.0));\n}\nvec3 oslTransformDir(int toSpace, vec3 vec) {\nreturn oslTransform(OSL_COMMON, toSpace, vec4(vec, 0.0));\n}\nvec3 oslTransformC(int fromSpace, int toSpace, vec3 vec) {\nvec4 outVec = vec4(vec, 1.0);\nif (fromSpace == OSL_HSV && toSpace == OSL_RGB)\nhsvToRGB(vec4(vec, 1.0), outVec);\nelse if (fromSpace == OSL_RGB && toSpace == OSL_HSV)\nrgbToHSV(vec4(vec, 1.0), outVec);\nreturn outVec.rgb;\n}\nvec3 oslTransformC(int toSpace, vec3 vec) {\nreturn oslTransformC(OSL_RGB, toSpace, vec);\n}\nvoid oslError() {}\nvoid oslFPrintf() {}\nvoid oslPrintf() {}\nvoid oslWarning() {}\nvec3 oslWaveLengthColor(float lambdaNM) {\n#if __VERSION__ == 300\nvec3 xyz = vec3(0.0);\nfloat ii = (lambdaNM - 380.0) / 5.0;\nint i = int(ii);\nif (i < 0 || i >= 80)\nreturn xyz;\nii -= float(i);\nvec3 c1 = cieColorMatch[i];\nvec3 c2 = cieColorMatch[i+1];\nxyz = mix(c1, c2, ii);\nreturn xyz_to_sRGB(xyz);\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif";
var node_incident_frag = "void node_incident(vec3 viewPos, out vec3 incident)\n{\n\nvec4 viewDir = vec4(normalize(viewPos), 0.0);\nincident = -swizzleUpZ(viewDir.xyz);\n}";
var node_normal_frag = "void node_normal(vec3 norParam, out vec3 norOut)\n{\n#ifdef MT_BLENDER\n#if WORLD_NODES == 1\nvec4 viewDir = isOrthographic ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-vViewPosition), 0.0);\nviewDir = invViewMatrix * viewDir;\nnorOut = -swizzleUpZ(viewDir.xyz);\n#else\nnorOut = normalize(invViewMatrix * vec4(norParam, 0.0)).xyz;\nnorOut = swizzleUpZ(norOut);\n#endif\n#else\nnorOut = norParam;\n#endif\n}";
var node_position_frag = "void node_position(vec3 posParam, out vec3 posOut)\n{\n#if defined(MT_BLENDER) || defined(MT_MAX)\nposOut = swizzleUpZ(-posParam);\n#else\nposOut = -posParam;\n#endif\n}";
var node_rgb_alpha_frag = "uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb_alpha(vec4 color, out vec3 outColor, out float outAlpha)\n{\noutColor = color.rgb;\noutAlpha = color.a;\n}";
var node_value_frag = "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float value, out float outValue)\n{\noutValue = value;\n}";
var node_u_float_frag = "void node_u_float(vec2 inUv, out float u)\n{\nu = inUv.x;\n}";
var node_abs_ar_frag = "void node_abs(\nvec3 inputVal,\nout vec3 outColor)\n{\noutColor = abs(inputVal);\n}";
var node_add_ar_frag = "void node_add(\nvec3 input1, vec3 input2,\nout vec3 outColor)\n{\noutColor = input1 + input2;\n}";
var node_atan_ar_frag = "void node_atan(\nint units,\nvec3 x, vec3 y,\nout vec3 outColor)\n{\noutColor = atan(y, x);\nif (units == 1)\noutColor = degrees(outColor);\n}";
var node_checkerboard_ar_frag = "void node_checkerboard(\nconst vec2 inUv, vec3 color1, vec3 color2, float uFrequency, float vFrequency, float uOffset, float vOffset, float contrast,\nout vec3 outColor) {\nvec2 uv = -1.0 + 2.0 * inUv;\nfloat fmodResult = mod(floor(uOffset * 2.0 + uFrequency * uv.x) + floor(vOffset * 2.0 + vFrequency * uv.y), 2.0);\nfloat final = max(sign(fmodResult), 0.0);\nvec3 col = vec3(final);\nif (final == 0.0)\ncol = color1;\nelse\ncol = color2;\noutColor = col * vec3(contrast) + vec3(1.0 - contrast);\n}";
var node_clamp_ar_frag = "void node_clamp(\nconst int mode,\nvec3 inputValue, float minValue, float maxValue, vec3 minColor, vec3 maxColor,\nout vec3 outColor, out vec3 outTransparency)\n{\nif (mode == 0)\noutColor = clamp(inputValue, vec3(minValue), vec3(maxValue));\nelse\noutColor = clamp(inputValue, minColor, maxColor);\noutTransparency = outColor;\n}";
var node_color_to_float_ar_frag = "void node_color_to_float(\nconst int mode,\nvec3 inputValue,\nout float outValue)\n{\nif (mode == 0)\noutValue = min(min(inputValue.r, inputValue.g), inputValue.b);\nelse if (mode == 1)\noutValue = max(max(inputValue.r, inputValue.g), inputValue.b);\nelse if (mode == 2)\noutValue = (inputValue.r + inputValue.g + inputValue.b) / 3.0;\nelse if (mode == 3)\noutValue = inputValue.r + inputValue.g + inputValue.b;\nelse if (mode == 4) {\noutValue = dot(inputValue, LUM_WEIGHTS);\n}\nelse if (mode == 5)\noutValue = inputValue.r;\nelse if (mode == 6)\noutValue = inputValue.g;\nelse if (mode == 7)\noutValue = inputValue.b;\n}";
var node_color_convert_ar_frag = "void node_color_convert(\nconst int from, const int to,\nvec3 inputValue,\nout vec3 outColor, out vec3 outTransparency)\n{\nvec4 c;\nif (from == to)\nc = vec4(inputValue, 1.0);\nelse if (from == 0) \nrgbToHSV(vec4(inputValue, 1.0), c);\nelse if (from == 1)\nhsvToRGB(vec4(inputValue, 1.0), c);\noutColor = c.rgb;\noutTransparency = outColor;\n}";
var node_color_correct_ar_frag = "void node_color_correct(\nvec3 inputValue, float mask, float gamma, float hueShift, float saturation, float contrast, float contrastPivot,\nfloat exposure, vec3 multiply, vec3 add, bool invert, bool alphaIsLuminance, float alphaMultiply, float alphaAdd, bool invertAlpha,\nout vec3 outColor, out float outAlpha)\n{ \noutColor = inputValue;\noutColor = invert ? 1.0 - outColor : outColor;\noutColor = vec3(pow(abs(outColor.r), gamma), pow(abs(outColor.g), gamma), pow(abs(outColor.b), gamma));\nvec4 hsv;\nrgbToHSV(vec4(outColor, 1.0), hsv);\nhsv[0] += hueShift / 360.0;\nif (hsv[0] > 1.0)\nhsv[0] -= 1.0;\nelse if (hsv[0] < 0.0)\nhsv[0] += 1.0;\n\nhsv[1] *= (saturation);\nhsv[1] = saturate(hsv[1]);\nhsv[2] += exposure * 2.0;\nvec4 c = hsv;\nhsvToRGB(hsv, c);\nc = ((c - contrastPivot) * contrast + contrastPivot) * vec4(multiply, 1.0) + vec4(add, 1.0);\noutColor = c.rgb;\noutAlpha = 1.0;\n}";
var node_compare_ar_frag = "void node_compare(\nint test,\nfloat input1, float input2,\nout bool outValue)\n{\nif (test == 0)\noutValue = input1 == input2;\nelse if (test == 1)\noutvalue = input1 != input2;\nelse if (test == 2)\noutValue = input1 < input2;\nelse if (test == 3)\noutValue = input1 > input2;\nelse if (test == 4)\noutValue = input1 <= input2;\nelse if (test == 5)\noutValue = input1 >= input2;\n}";
var node_complement_ar_frag = "void node_complement(\nvec3 inputValue,\nout vec3 outColor)\n{\noutColor = 1.0 - inputValue;\n}";
var node_composite_ar_frag = "void node_composite(\nconst int operation, const int alphaOperation,\nvec3 A, vec3 B, float AA, float BA,\nout float outAlpha, out vec3 outColor, out vec3 outTransparency)\n{\nvec4 A1 = vec4(A, AA);\nvec4 B1 = vec4(B, BA);\nvec4 color = vec4(0.0);\nif (operation == 0)\ncolor = A1;\nelse if (operation == 1)\ncolor = B1;\nelse if (operation == 2)\ncolor = A1 * B1.a + B1 * (1.0 - A1.a);\nelse if (operation == 3)\ncolor = (A1 + B1) / 2.0;\nelse if (operation == 4)\ncolor = A1.a > B1.a ? A1 : (A1 + B1 * (1.0 - A1.a) / B1.a);\nelse if (operation == 5)\ncolor = abs(A1 - B1);\nelse if (operation == 6)\ncolor = A1.a + B1.a < 1.0 ? A1 + B1 : A1 + B1 * (1.0 - A1.a) / B1.a;\nelse if (operation == 7)\nfor (int i = 0; i < 4; i++)\ncolor[i] = B1[i] == 0.0 ? 0.0 : (A1[i] / B1[i]);\nelse if (operation == 8)\ncolor = A1 + B1 - 2.0 * A1 * B1;\nelse if (operation == 9)\ncolor = B1 - A1;\nelse if (operation == 10)\ncolor = 2.0 * A1 * B1 / (A1 + B1);\nelse if (operation == 11)\nfor (int i = 0; i < 4; i++)\ncolor[i] = A1[i] < 0.5 ? (A1[i] * B1[i]) : (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);\nelse if (operation == 12)\ncolor = sqrt(A1 * A1 + B1 * B1);\nelse if (operation == 13)\ncolor = A1 * B1.a;\nelse if (operation == 14)\ncolor = B1 * A1.a;\nelse if (operation == 15)\ncolor = A1 * A1.a + B1 * (1.0 - A1.a);\nelse if (operation == 16)\ncolor = max(A1, B1);\nelse if (operation == 17)\ncolor = min(A1, B1);\nelse if (operation == 18)\ncolor = A1 - B1;\nelse if (operation == 19)\ncolor = A1 * B1;\nelse if (operation == 20)\ncolor = A1 * (1.0 - B1.a);\nelse if (operation == 21)\ncolor = A1 + B1 * (1.0 - A1.a);\nelse if (operation == 22)\nfor (int i = 0; i < 4; i++)\ncolor[i] = B1[i] < 0.5 ? (A1[i] * B1[i]) : (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);\nelse if (operation == 23)\ncolor = A1 + B1;\nelse if (operation == 24)\nfor (int i = 0; i < 4; i++)\ncolor[i] = (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);\n\nelse if (operation == 25)\nfor (int i = 0; i < 4; i++)\ncolor[i] = (A1[i] < .75) ? (A1[i] * B1[i]) : (A1[i] >= 0.0 && A1[i] <= 1.0 && B1[i] >= 0.0 && B1[i] <= 1.0) ? (A1[i] + B1[i] - A1[i] * B1[i]) : max(A1[i], B1[i]);\nelse if (operation == 26)\ncolor = B1 * (1.0 - A1.a);\nelse if (operation == 27)\ncolor = A1 * (1.0 - B1.a) + B1;\nelse if (operation == 28)\ncolor = A1 * (1.0 - B1.a) + B1 * (1.0 - A1.a);\nif (alphaOperation == 1)\ncolor.a = AA;\nelse if (alphaOperation ==2)\ncolor.a = BA;\noutColor = color.rgb;\noutAlpha = color.a;\noutTransparency = outColor;\n}";
var node_cross_ar_frag = "void node_cross(\nvec3 input1, vec3 input2,\nout vec3 outValue)\n{\noutValue = cross(input1, input2);\n}";
var node_divide_ar_frag = "void node_divide(\nvec3 input1, vec3 input2,\nout vec3 outColor)\n{\noutColor = input1 / input2;\n}";
var node_dot_ar_frag = "void node_dot(\nvec3 input1, vec3 input2,\nout vec3 outValue)\n{\noutValue = dot(input1, input2);\n}";
var node_exp_ar_frag = "void node_exp(\nvec3 inputVal,\nout vec3 outColor)\n{\noutColor = exp(inputVal);\n}";
var node_facing_ratio_ar_frag = "void node_facing_ratio(\nvec3 viewNorm,\nconst float bias, const float gain, const bool invert, const bool linear,\nout float outValue)\n{\noutValue = dot(normalize(viewNorm), normalize(vViewPosition));\n}";
var node_flat_ar_frag = "void node_flat(vec3 color, out vec3 outColor)\n{\noutColor = color;\n}";
var node_float_to_int_ar_frag = "void node_float_to_int(\nconst int mode, \nfloat inputValue,\nout int outValue)\n{\nif (mode == 0)\noutValue = round(inputValue);\nelse if (mode == 1)\noutValue = trunc(inputValue);\nelse if (mode == 2)\noutValue = floor(inputValue);\nelse if (mode == 3)\noutValue = ceil(inputValue);\n}";
var node_float_to_matrix_ar_frag = "void node_float_to_matrix(\nfloat input00, float input01, float input02, float input03, float input10, float input11, float input12, float input13, float input20, float input21, float input22, float input23, float input30, float input31, float input32, float input33,\nout mat4 outValue)\n{\noutValue = mat4(input00, input01, input02, input03,\ninput10, input11, input12, input13,\ninput20, input21, input22, input23,\ninput30, input31, input32, input33);\n}";
var node_float_to_rgba_ar_frag = "void node_float_to_rgba(\nfloat r, float g, float b, float a,\nout vec4 outColor, out float outAlpha, out vec3 outTransparency)\n{\noutAlpha = a;\noutColor = vec4(r, g, b, a);\noutTransparency = vec3(1.0 - a);\n}";
var node_float_to_rgb_ar_frag = "void node_float_to_rgb(\nfloat r, float g, float b,\nout vec3 outValue)\n{\noutValue = vec3(r, g, b);\n}";
var node_fraction_ar_frag = "void node_fraction(\nvec3 inputValue,\nout vec3 outColor)\n{\noutColor = fract(inputValue);\n}";
var node_is_finite_ar_frag = "void node_is_finite(\nvec3 inputValue,\nout bool outValue)\n{\noutValue = !any(isinf(inputValue));\n}";
var node_image_ar_frag = "\nvoid node_image(sampler2D ima, const int encoding, \nvec3 multiply, vec3 offset, vec2 uvcoords, float soffset, float toffset, float sscale, float tscale, bool sflip, bool tflip, bool swapSt,\nout vec3 outColor, out float outAlpha, out vec3 outTransparency) {\nvec2 uv = vec2(uvcoords.x, uvcoords.y);\nuv += vec2(soffset, toffset);\nuv = mix(uv.xy, uv.yx, float(swapSt));\nvec2 stFlip = vec2(float(sflip), float(tflip));\nuv = mix(uv, 1.0 - uv, stFlip);\nuv *= vec2(sscale, tscale);\nuv.y = 1.0 - uv.y;\nvec4 tex = texture2D(ima, uv);\noutColor = nodeTexelToLinear(tex, encoding).rgb * multiply + offset;\noutAlpha = tex.a;\noutTransparency = outColor.rgb;\n}\nvoid node_image(sampler2D ima, const int encoding,\nvec3 multiply, vec3 offset, vec2 uvcoords, float soffset, float toffset, float sscale, float tscale, bool sflip, bool tflip, bool swapSt, vec2 dUVdx, vec2 dUVdy,\nout vec3 outColor, out float outAlpha, out vec3 outTransparency) {\nvec2 uv = vec2(uvcoords.x, uvcoords.y);\nuv += vec2(soffset, toffset);\nuv = mix(uv.xy, uv.yx, float(swapSt));\nvec2 stFlip = vec2(float(sflip), float(tflip));\nuv = mix(uv, 1.0 - uv, stFlip);\nuv *= vec2(sscale, tscale);\nuv.y = 1.0 - uv.y;\n#ifdef texture2DGradEXT\nvec2 dInvOp = stFlip * (-2.0) + 1.0;\ndUVdx *= vec2(sscale, tscale) * dInvOp;\ndUVdy *= vec2(sscale, tscale) * dInvOp;\nvec4 tex = textureGrad(ima, uv, dUVdx, dUVdy);\n#else\nvec4 tex = texture2D(ima, uv);\n#endif\noutColor = nodeTexelToLinear(tex, encoding).rgb * multiply + offset;\noutAlpha = tex.a;\noutTransparency = outColor.rgb;\n}\nvoid node_image(sampler2D ima, const int encoding, \nvec4 multiply, vec4 offset, vec2 uvcoords, float soffset, float toffset, float sscale, float tscale, bool sflip, bool tflip, bool swapSt,\nout vec4 outColor) {\nvec2 uv = vec2(uvcoords.x, uvcoords.y);\nuv += vec2(soffset, toffset);\nuv = mix(uv.xy, uv.yx, float(swapSt));\nvec2 stFlip = vec2(float(sflip), float(tflip));\nuv = mix(uv, 1.0 - uv, stFlip);\nuv *= vec2(sscale, tscale);\nuv.y = 1.0 - uv.y;\nvec4 tex = texture2D(ima, uv);\noutColor = nodeTexelToLinear(tex, encoding).rgba * multiply + offset;\n}\nvoid node_image(sampler2D ima, const int encoding,\nvec4 multiply, vec4 offset, vec2 uvcoords, float soffset, float toffset, float sscale, float tscale, bool sflip, bool tflip, bool swapSt, vec2 dUVdx, vec2 dUVdy,\nout vec4 outColor) {\nvec2 uv = vec2(uvcoords.x, uvcoords.y);\nuv += vec2(soffset, toffset);\nuv = mix(uv.xy, uv.yx, float(swapSt));\nvec2 stFlip = vec2(float(sflip), float(tflip));\nuv = mix(uv, 1.0 - uv, stFlip);\nuv *= vec2(sscale, tscale);\nuv.y = 1.0 - uv.y;\n#ifdef texture2DGradEXT\nvec2 dInvOp = stFlip * (-2.0) + 1.0;\ndUVdx *= vec2(sscale, tscale) * dInvOp;\ndUVdy *= vec2(sscale, tscale) * dInvOp;\nvec4 tex = textureGrad(ima, uv, dUVdx, dUVdy);\n#else\nvec4 tex = texture2D(ima, uv);\n#endif\noutColor = nodeTexelToLinear(tex, encoding).rgba * multiply + offset;\n}";
var node_lambert_ar_frag = "void node_lambert(\nvec3 geometryNormal,\nfloat base, vec3 baseColor, vec3 normalCamera, vec3 opacity,\nout vec4 outColor, out float outAlpha, out vec3 outTransparency)\n{\nNodeMaterial material;\nmaterial.diffuseColor = base * baseColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 normal = normalCamera;\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutAlpha = average(opacity);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, outAlpha);\noutTransparency = vec3(1.0) - opacity;\n}";
var node_length_ar_frag = "void node_length(\nint mode,\nvec3 inputVec,\nout float outValue)\n{\nif (mode == 0)\noutValue = length(inputVec);\nelse if (mode == 1)\noutValue = dot(inputVec, inputVec);\nelse\noutValue = abs(inputVec.x) + abs(inputVec.y) + abs(inputVec.z);\n}";
var node_log_ar_frag = "void node_log(\nvec3 inputVec, vec3 base,\nout vec3 outColor)\n{\noutColor = log(inputVec) / log(base);\n}";
var node_map_to_mtl_ar_frag = "void node_map_to_mtl(bool opaqueEnabled, vec4 color, out vec4 outColor)\n{\noutColor = vec4(color.rgb, opaqueEnabled ? color.a : 1.0);\n}";
var node_matrix_transform_ar_frag = "\nvoid node_matrix_transform(\nconst int transformOrder, const int rotationType, const int rotationUnits, const int rotationOrder,\nvec3 rotationEuler, vec3 rotationAxis, float rotationAngle, vec3 translation, vec3 scaling, vec3 pivot,\nout mat4 outMatrix)\n{\nmat4 tMat = translationToMat4(translation);\nmat4 sMat = scalingToMat4(scaling);\nmat4 rMat = mat4(1.0);\nif (rotationType == 0) {\nvec3 rot = float(rotationUnits) * radians(rotationEuler) + float(1 - rotationUnits) * rotationEuler;\nmat3 matX = mat3RotateX(rot.x);\nmat3 matY = mat3RotateY(-rot.y);\nmat3 matZ = mat3RotateZ(rot.z);\nmat3 rotMat3;\nif (rotationOrder == 0) {\nrotMat3 = matX * matY * matZ;\n} else if (rotationOrder == 1) {\nrotMat3 = matX * matZ * matY;\n} else if (rotationOrder == 2) {\nrotMat3 = matY * matX * matZ;\n} else if (rotationOrder == 3) {\nrotMat3 = matY * matZ * matX;\n} else if (rotationOrder == 4) {\nrotMat3 = matZ * matX * matY;\n} else if (rotationOrder == 5) {\nrotMat3 = matZ * matY * matX;\n}\nrMat = toMat4(rotMat3);\n} else if (rotationType == 1) {\nfloat angleInRadians = float(rotationUnits) * radians(rotationAngle) + float(1 - rotationUnits) * rotationAngle;\nrotationAxis = normalize(rotationAxis);\nrMat = toMat4(axisAngleToMat3(rotationAxis, angleInRadians));\n}\nif (transformOrder == 0) {\noutMatrix = sMat * rMat * tMat;\n} else if (transformOrder == 1) {\noutMatrix = sMat * tMat * rMat;\n} else if (transformOrder == 2) {\noutMatrix = rMat * sMat * tMat;\n} else if (transformOrder == 3) {\noutMatrix = rMat * tMat * sMat;\n} else if (transformOrder == 4) {\noutMatrix = tMat * sMat * rMat;\n} else if (transformOrder == 5) {\noutMatrix = tMat * rMat * sMat;\n}\nmat4 rotX90 = toMat4(mat3RotateX(PI * 0.5));\nmat4 pivotMat = translationToMat4(pivot);\nmat4 invPivotMat = inverse(pivotMat);\noutMatrix = invPivotMat * outMatrix * pivotMat * rotX90;\n}\nvoid node_matrix_transform(\nconst int transformOrder, const int rotationType, const int rotationUnits, const int rotationOrder,\nvec3 rotationEuler, vec3 rotationAxis, float rotationAngle, vec3 translation, vec3 scaling, vec3 pivot,\nout mat4 outMatrix, out vec3 outTransparency)\n{\nmat4 tMat = translationToMat4(translation);\nmat4 sMat = scalingToMat4(scaling);\nmat4 rMat = mat4(1.0);\nif (rotationType == 0) {\nvec3 rot = mix(rotationEuler, radians(rotationEuler), float(rotationUnits));\nmat3 matX = mat3RotateX(rot.x);\nmat3 matY = mat3RotateY(-rot.y);\nmat3 matZ = mat3RotateZ(rot.z);\nmat3 rotMat3;\nif (rotationOrder == 0) {\nrotMat3 = matX * matY * matZ;\n} else if (rotationOrder == 1) {\nrotMat3 = matX * matZ * matY;\n} else if (rotationOrder == 2) {\nrotMat3 = matY * matX * matZ;\n} else if (rotationOrder == 3) {\nrotMat3 = matY * matZ * matX;\n} else if (rotationOrder == 4) {\nrotMat3 = matZ * matX * matY;\n} else if (rotationOrder == 5) {\nrotMat3 = matZ * matY * matX;\n}\nrMat = toMat4(rotMat3);\n} else if (rotationType == 1) {\nfloat angleInRadians = mix(rotationAngle, radians(rotationAngle), float(rotationUnits));\nrotationAxis = normalize(rotationAxis);\nrMat = toMat4(axisAngleToMat3(rotationAxis, angleInRadians));\n}\noutMatrix = rMat;\nif (transformOrder == 0) {\noutMatrix = sMat * rMat * tMat;\n} else if (transformOrder == 1) {\noutMatrix = sMat * tMat * rMat;\n} else if (transformOrder == 2) {\noutMatrix = rMat * sMat * tMat;\n} else if (transformOrder == 3) {\noutMatrix = rMat * tMat * sMat;\n} else if (transformOrder == 4) {\noutMatrix = tMat * sMat * rMat;\n} else if (transformOrder == 5) {\noutMatrix = tMat * rMat * sMat;\n}\nmat4 pivotMat = translationToMat4(pivot);\nmat4 invPivotMat = inverse(pivotMat);\noutMatrix = invPivotMat * outMatrix * pivotMat;\n}";
var node_max_ar_frag = "void node_max(\nvec3 input1, vec3 input2,\nout vec3 outColor)\n{\noutColor = max(input1, input2);\n}";
var node_min_ar_frag = "void node_min(\nvec3 input1, vec3 input2,\nout vec3 outColor)\n{\noutColor = min(input1, input2);\n}";
var node_mix_shader_ar_frag = "void node_mix_shader(const int mode,\nconst float mixAmt, vec4 shader1, vec4 shader2,\nout vec4 color)\n{\nshader1.rgb *= shader1.a;\nshader2.rgb *= shader2.a;\nif (mode == 0)\ncolor = mix(shader1, shader2, clamp(mixAmt, 0.0, 1.0));\nelse\ncolor = vec4(shader1.rgb + shader2.rgb, min(shader1.a, shader2.a));\ncolor.rgb /= color.a;\n}";
var node_modulo_ar_frag = "void node_modulo(\nvec3 inputVec, vec3 divisor,\nout vec3 outColor)\n{\noutColor = mod(inputVec, divisor);\n}";
var node_multiply_ar_frag = "void node_multiply(\nvec3 input1, vec3 input2,\nout vec3 outColor)\n{\noutColor = input1 * input2;\n}";
var node_negate_ar_frag = "void node_negate(\nvec3 inputVec,\nout vec3 outColor)\n{\noutColor = -inputVec;\n}";
var node_normalize_ar_frag = "void node_normalize(\nvec3 inputVec,\nout vec3 outValue)\n{\noutValue = normalize(inputVec);\n}";
var node_normal_map_ar_frag = "void node_normal_map(\nvec4 tangentParam,\nvec3 inputVal, vec3 normal, float strength, vec3 tangent,\nout vec3 outValue) {\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nvec3 normalTex = inputVal.xyz * 2.0 - 1.0;\nvec3 bitangent = tangentParam.w * cross(normal, tangent);\noutValue = normalize(normalTex.x * tangent + normalTex.y * bitangent + normalTex.z * normal);\noutValue = mix(normal, outValue, strength);\n}";
var node_pow_ar_frag = "void node_pow(\nvec3 base, vec3 exponent,\nout vec3 outColor)\n{\noutColor = pow(base, exponent);\n}";
var node_random_ar_frag = "void node_abs(\nvec3 inputColor,\nout vec3 outColor)\n{\noutColor = inputColor;\n}";
var node_range_ar_frag = "void node_range(\nvec3 inputValue, float inputMin, float inputMax, \nfloat outputMin, float outputMax, bool smoothstep1, \nfloat contrast, float contrastPivot, float bias, float gain,\nout vec3 outColor, out vec3 outTransparency)\n{\n\noutColor = min(max(inputValue, vec3(inputMin)), vec3(inputMax));\noutColor = (outColor - contrastPivot) * contrast + contrastPivot;\nif (smoothstep1 == true) {\nfor (int i = 0; i < 3; i++)\noutColor[i] = smoothstep(outputMin, outputMax, outColor[i]);\n} else\noutColor = min(max(outColor, vec3(outputMin)), vec3(outputMax));\noutTransparency = outColor;\n}";
var node_ray_switch_ar_frag = "void node_ray_switch(vec3 camera, vec3 diffuseReflection, vec3 diffuseTransmission,\nvec3 shadow, vec3 specularReflection, vec3 specularTransmission,\nout vec3 outColor, out float outAlpha)\n{\n#if LIGHT_PATH_IS_CAM_RAY\noutColor = camera;\n#else\noutColor = diffuseReflection;\n#endif\noutAlpha = 1.0;\n}";
var node_reciprocal_ar_frag = "void node_reciprocal(\nvec3 inputVec,\nout vec3 outColor)\n{\noutColor = 1.0 / inputVec;\n}";
var node_rgba_to_float_ar_frag = "void node_rgba_to_float(\nconst int mode,\nvec3 inputValue, float inputA,\nout float outValue, out vec3 outTransparency)\n{\noutTransparency = inputValue + vec3(inputA / 4.0);\nif (mode == 0)\noutValue = min(min(min(inputValue.r, inputValue.g), inputValue.b), inputA);\nelse if (mode == 1)\noutValue = max(max(max(inputValue.r, inputValue.g), inputValue.b), inputA);\nelse if (mode == 2)\noutValue = (inputValue.r + inputValue.g + inputValue.b + inputA) / 4.0;\nelse if (mode == 3)\noutValue = inputValue.r + inputValue.g + inputValue.b + inputA;\nelse if (mode == 4) {\noutValue = dot(inputValue, LUM_WEIGHTS);\n}\nelse if (mode == 5)\noutValue = inputValue.r;\nelse if (mode == 6)\noutValue = inputValue.g;\nelse if (mode == 7)\noutValue = inputValue.b;\n}";
var node_rgb_to_float_ar_frag = "void node_rgb_to_float(\nconst int mode,\nvec3 inputValue,\nout float outValue)\n{\nif (mode == 0)\noutValue = min(min(inputValue.r, inputValue.g), inputValue.b);\nelse if (mode == 1)\noutValue = max(max(inputValue.r, inputValue.g), inputValue.b);\nelse if (mode == 2)\noutValue = (inputValue.r + inputValue.g + inputValue.b) / 3.0;\nelse if (mode == 3)\noutValue = inputValue.r + inputValue.g + inputValue.b;\nelse if (mode == 4) {\noutValue = dot(inputValue, LUM_WEIGHTS);\n}\nelse if (mode == 5)\noutValue = inputValue.r;\nelse if (mode == 6)\noutValue = inputValue.g;\nelse if (mode == 7)\noutValue = inputValue.b;\n}";
var node_rgb_to_vector_ar_frag = "void node_rgb_to_vector(\nconst int mode, \nvec3 inputValue,\nout vec3 outValue)\n{\n\noutValue = inputValue;\n}";
var node_shadow_matte_ar_frag = "#include <shadowmask_pars_fragment>\nvoid node_shadow_matte(\nvec3 normal,\nvec3 shadowColor, float backlighting, float shadowOpacity,\nout vec4 outColor, out float outAlpha) {\nfloat shadow = getShadowMask();\noutColor = vec4(shadowColor, shadowOpacity * (1.0 - shadow));\noutAlpha = outColor.a;\n}";
var node_shuffle_ar_frag = "\nvoid node_shuffle(const int channelR, const int channelG, const int channelB, const int channelA,\nvec3 color, float alpha, bool negateR, bool negateG, bool negateB, bool negateA,\nout vec3 outColor, out float outAlpha)\n{\noutColor = vec3(0.0);\nvec4 choose = vec4(color, alpha);\noutAlpha = 1.0;\n#if __VERSION__ == 100\noutColor.r = choose[0];\noutColor.g = choose[1];\noutColor.b = choose[2];\noutAlpha = choose[3];\n#else\noutColor.r = choose[channelR];\noutColor.g = choose[channelG];\noutColor.b = choose[channelB];\noutAlpha = choose[channelA];\n#endif\nif (negateR)\noutColor.r = -outColor.r;\nif (negateG)\noutColor.g = -outColor.g;\nif (negateB)\noutColor.b = -outColor.b;\nif (negateA)\noutAlpha = -outAlpha;\n}\nvoid node_shuffle(const int channelR, const int channelG, const int channelB, const int channelA,\nvec4 color, float alpha, bool negateR, bool negateG, bool negateB, bool negateA,\nout vec4 outColor)\n{\noutColor = vec4(0.0);\nvec4 choose = vec4(color.rgb, alpha);\n#if __VERSION__ == 100\noutColor.r = choose[0];\noutColor.g = choose[1];\noutColor.b = choose[2];\noutColor.a = choose[3];\n#else\noutColor.r = choose[channelR];\noutColor.g = choose[channelG];\noutColor.b = choose[channelB];\noutColor.a = choose[channelA];\n#endif\nif (negateR)\noutColor.r = -outColor.r;\nif (negateG)\noutColor.g = -outColor.g;\nif (negateB)\noutColor.b = -outColor.b;\nif (negateA)\noutColor.a = -outColor.a;\n}";
var node_sign_ar_frag = "void node_sign(\nvec3 inputVec,\nout vec3 outColor)\n{\noutColor = sign(inputVec);\n}";
var node_skydome_light_ar_frag = "void node_skydome_light(vec3 color, float intensity,\nout vec4 outgoingLight)\n{\noutgoingLight = vec4(color * intensity, 1.0);\n}";
var node_sqrt_ar_frag = "void node_sqrt(\nvec3 inputVec,\nout vec3 outColor)\n{\noutColor = sqrt(inputVec);\n}";
var node_standard_surface_ar_frag = "void node_standard_surface(\nvec3 geometryNormal, const bool thinWalled,\nconst float base, const vec3 baseColor, const float diffuseRoughness,\nconst float metalness, const float specular, const vec3 specularColor,\nconst float specularRoughness, const float trans, const vec3 transColor,\nconst float transDepth, const vec3 transScatter, const float transExtraRoughness,\nconst float subsurface, const vec3 subsurfaceColor, const vec3 subsurfaceRadius,\nconst float clearcoat, const vec3 clearcoatColor, const float clearcoatRoughness,\nconst float sheen, const vec3 sheenColor, const float sheenRoughness,\nconst float emission, const vec3 emissionColor, const vec3 opacity,\nconst vec3 normal, const vec3 clearcoatNormal, const float specularIOR,\nout vec4 outColor, out vec3 outTransparency)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = base * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - metalness) * (1.0 - trans);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = saturate(sheen * sheenColor);\nmaterial.sheenRoughness = clamp(sheenRoughness, 0.0, 1.0);\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.roughness = max(specularRoughness, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\nvec3 specularColorWeighted = specular * specularColor;\nvec3 dielRefl = pow2((1.0 - specularIOR) / (1.0 + specularIOR)) * specularColorWeighted;\nmaterial.specularColor = mix(dielRefl, baseColorWeighted, metalness);\nmaterial.fresnelRefl90 = mix(specularColorWeighted, vec3(1.0), metalness);\nmaterial.specularF90 = average(material.fresnelRefl90);\nmaterial.refractionColor = pow(trans * (1.0 - metalness) * transColor.rgb, vec3(2.0));\nmaterial.refractionIOR = specularIOR;\nmaterial.refractionRoughness = material.roughness;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance = emission * emissionColor;\nvec3 outSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\noutSpecular + totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp = 1.0 - 0.157 * max3(material.sheenColor);\noutColor3 = outColor3 * sheenEnergyComp + sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = average(opacity) * (1.0 - saturate(trans) + maxFromRGB(outSpecular) * saturate(trans));\n} else {\noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha));\noutTransparency = outColor3;\n}\nvoid node_standard_surface(\nvec3 geometryNormal, const bool thinWalled,\nconst float base, const vec3 baseColor, const float diffuseRoughness,\nconst float metalness, const float specular, const vec3 specularColor,\nconst float specularRoughness, const float trans, const vec3 transColor,\nconst float transDepth, const vec3 transScatter, const float transExtraRoughness,\nconst float subsurface, const vec3 subsurfaceColor, const vec3 subsurfaceRadius,\nconst float clearcoat, const vec3 clearcoatColor, const float clearcoatRoughness,\nconst float sheen, const vec3 sheenColor, const float sheenRoughness,\nconst float emission, const vec3 emissionColor, const vec3 opacity,\nconst vec3 normal, const vec3 clearcoatNormal,\nout vec4 outColor, out vec3 outTransparency)\n{\nnode_standard_surface(\ngeometryNormal, thinWalled,\nbase, baseColor, diffuseRoughness,\nmetalness, specular, specularColor,\nspecularRoughness, trans, transColor,\ntransDepth, transScatter, transExtraRoughness,\nsubsurface, subsurfaceColor, subsurfaceRadius,\nclearcoat, clearcoatColor, clearcoatRoughness,\nsheen, sheenColor, sheenRoughness,\nemission, emissionColor, opacity,\nnormal, clearcoatNormal, 1.5,\noutColor, outTransparency);\n}";
var node_subtract_ar_frag = "void node_subtract(\nvec3 input1, vec3 input2,\nout vec3 outColor)\n{\noutColor = input1 - input2;\n}";
var node_trigo_ar_frag = "void node_trigo(\nconst int function, const int units,\nvec3 inputVec, float frequency, float phase,\nout vec3 outColor)\n{\nif (units == 1 && function >= 0 && function <=2)\ninputVec = radians(inputVec);\nif (function == 0)\noutColor = cos(inputVec * frequency + phase);\nelse if (function == 1)\noutColor = sin(inputVec * frequency + phase);\nelse if (function == 2)\noutColor = tan(inputVec * frequency + phase);\nelse if (function == 3)\noutColor = acos(inputVec * frequency + phase);\nelse if (function == 4)\noutColor = asin(inputVec * frequency + phase);\nelse if (function == 5)\noutColor = atan(inputVec * frequency + phase);\nelse if (function == 6)\noutColor = cosh(inputVec * frequency + phase);\nelse if (function == 7)\noutColor = sinh(inputVec * frequency + phase);\nelse\noutColor = tanh(inputVec * frequency + phase);\nif (units == 1 && function >= 3 && function <=5)\noutColor = degrees(outColor);\n}";
var node_triplanar_ar_frag = "\nvoid node_triplanar(\nconst int coordSpace, const bool inputPerAxis, const bool flipOnOppositeDirection, const float blendFactor,\nvec4 inputColor, vec4 inputColorY, vec4 inputColorZ, vec3 scaling, vec3 rotation, vec3 offset, vec3 normal,\nout vec4 outColor)\n{\nif (inputPerAxis == true) {\nvec3 barycentric = abs(normal);\nbarycentric /= barycentric.x + barycentric.y + barycentric.z;\nvec3 edgeShape = min(min(barycentric.yzx, barycentric.zxy),\n(blendFactor - 1.0) / (blendFactor - 3.0));\nvec3 edgeValue = (1.0 - blendFactor) * (1.0 - edgeShape) / 2.0;\nvec3 weight = max((barycentric - edgeValue) / (1.0 - edgeValue), EPSILON);\nweight /= (weight.x + weight.y + weight.z);\noutColor = weight.x * inputColor + weight.y * inputColorY + weight.z * inputColorZ;\n} else {\noutColor = inputColor;\n}\n}\nvoid node_triplanar(\nconst int coordSpace, const bool inputPerAxis, const bool flipOnOppositeDirection, const float blendFactor,\nvec3 inputColor, vec3 inputColorY, vec3 inputColorZ, vec3 scaling, vec3 rotation, vec3 offset, vec3 normal,\nout vec3 outColor)\n{\nif (inputPerAxis == true) {\nvec3 barycentric = abs(normal);\nbarycentric /= barycentric.x + barycentric.y + barycentric.z;\nvec3 edgeShape = min(min(barycentric.yzx, barycentric.zxy),\n(blendFactor - 1.0) / (blendFactor - 3.0));\nvec3 edgeValue = (1.0 - blendFactor) * (1.0 - edgeShape) / 2.0;\nvec3 weight = max((barycentric - edgeValue) / (1.0 - edgeValue), EPSILON);\nweight /= (weight.x + weight.y + weight.z);\noutColor = weight.x * inputColor + weight.y * inputColorY + weight.z * inputColorZ;\n} else {\noutColor = inputColor;\n}\n}";
var node_triplanar_uv_ar_frag = "\nfloat screenSpaceDither12(vec2 vScreenPos) {\nfloat vDither = dot(vec2(171.0, 231.0), vScreenPos.xy);\nreturn fract(vDither / 103.0);\n}\nvec3 smoothContrast(vec3 alpha, float contrast) {\nvec3 powAlpha = pow(alpha, vec3(contrast));\nreturn powAlpha / (powAlpha.x + powAlpha.y + powAlpha.z);\n}\nvoid node_triplanar_uv(\nconst bool flipOnOppositeDirection, const float blendFactor,\nvec3 vector, vec3 normal,\nout vec2 outUV, out vec2 dUVdx, out vec2 dUVdy)\n{\nvec3 norm = normal;\nfloat fp = float(flipOnOppositeDirection);\nvec2 xFac = mix(vec2(1.0), vec2(-sign(norm.x), 1.0), fp);\nvec2 uvX = vec2(vector.z, vector.y) * xFac + 0.5;\nvec2 yFac = mix(vec2(1.0), vec2(1.0, -sign(norm.y)), fp);\nvec2 uvY = vec2(vector.x, vector.z) * yFac + 0.5;\nvec2 zFac = vec2(mix(1.0, sign(norm.z), fp), 1.0);\nvec2 uvZ = vec2(vector.x, vector.y) * zFac + 0.5;\n#ifdef texture2DGradEXT\nvec3 alpha = abs(norm);\nfloat contrast = mix(20.0, 1.0, blendFactor);\nalpha = smoothContrast(alpha, contrast);\nfloat dither = screenSpaceDither12(gl_FragCoord.xy);\ndither = clamp(dither, 0.01, 0.99);\nvec3 duvwdx = dFdx(vector);\nvec3 duvwdy = dFdy(vector);\nif (alpha.x > dither) {\noutUV = uvX;\ndUVdx = duvwdx.yz * xFac;\ndUVdy = duvwdy.yz * xFac;\n} else if (1.-alpha.z > dither) {\noutUV = uvY;\ndUVdx = duvwdx.xz * yFac;\ndUVdy = duvwdy.xz * yFac;\n} else {\noutUV = uvZ;\ndUVdx = duvwdx.xy * zFac;\ndUVdy = duvwdy.xy * zFac;\n}\n#else\nvec3 absNorm = abs(norm);\nvec3 faceMask = step(absNorm.yzx, absNorm) * step(absNorm.zxy, absNorm);\noutUV = faceMask.x * uvX + faceMask.y * uvY + faceMask.z * uvZ;\n#endif\n}\nvoid node_triplanar_uv(\nconst bool flipOnOppositeDirection, const int projectionAxis,\nvec3 vector, vec3 normal,\nout vec2 outUV)\n{\nvec3 norm = normal;\nfloat fp = float(flipOnOppositeDirection);\nif (projectionAxis == 0) {\nvec2 xFac = mix(vec2(1.0), vec2(-sign(norm.x), 1.0), fp);\noutUV = vec2(vector.z, vector.y) * xFac + 0.5;\n} else if (projectionAxis == 1) {\nvec2 yFac = mix(vec2(1.0), vec2(1.0, -sign(norm.y)), fp);\noutUV = vec2(vector.x, vector.z) * yFac + 0.5;\n} else if (projectionAxis == 2) {\nvec2 zFac = vec2(mix(1.0, sign(norm.z), fp), 1.0);\noutUV = vec2(vector.x, vector.y) * zFac + 0.5;\n} else if (projectionAxis == 3) {\nvec2 xFac = mix(vec2(1.0), vec2(-sign(norm.x), 1.0), fp);\nvec2 uvX = vec2(vector.z, vector.y) * xFac + 0.5;\nvec2 yFac = mix(vec2(1.0), vec2(1.0, -sign(norm.y)), fp);\nvec2 uvY = vec2(vector.x, vector.z) * yFac + 0.5;\nvec2 zFac = vec2(mix(1.0, sign(norm.z), fp), 1.0);\nvec2 uvZ = vec2(vector.x, vector.y) * zFac + 0.5;\nvec3 absNorm = abs(norm);\nvec3 faceMask = step(absNorm.yzx, absNorm) * step(absNorm.zxy, absNorm);\noutUV = faceMask.x * uvX + faceMask.y * uvY + faceMask.z * uvZ;\n}\n}";
var node_two_sided_ar_frag = "void node_two_sided(\nfloat frontFacing,\nvec3 front, vec3 back,\nout vec3 outColor)\n{\noutColor = (frontFacing > 0.0) ? front : back;\n}";
var node_user_data_color_ar_frag = "void node_user_data_color(vec4 color, \nout vec3 outColor, out float outAlpha)\n{\noutColor = color.rgb;\noutAlpha = color.a;\n}";
var node_uv_projection_ar_frag = "#define TEX_PROJ_PLANAR 0\n#define TEX_PROJ_SPHERICAL 1\n#define TEX_PROJ_CYLINDRICAL 2\n#define TEX_PROJ_BALL 3\n#define TEX_PROJ_CUBIC 4\n#define TEX_PROJ_SHRINK_WRAP 5\n#define COORD_WORLD_SPACE 0\n#define COORD_OBJECT_SPACE 1\nvoid node_uv_projection(\nconst int projectionType, const int coordSpace,\nvec3 projectionColor, float uAngleDegrees, float vAngleDegrees, mat4 matrix,\nout vec2 outUV)\n{\nvec3 vector = vWorldPosition.xyz;\nif (coordSpace == COORD_OBJECT_SPACE) {\nvector = (invModelMatrix * vec4(vector, 1.0)).xyz;\n}\nvector = (matrix * vec4(vector, 1.0)).xyz;\nif (projectionType == TEX_PROJ_PLANAR) {\noutUV = vector.xy * 0.5 + 0.5;\n} else if (projectionType == TEX_PROJ_SPHERICAL) {\nvector = normalize(vector);\nfloat uAngle = radians(uAngleDegrees);\nfloat vAngle = radians(vAngleDegrees);\nfloat theta = atan(vector.x, vector.z) / (uAngle);\ntheta = theta * 0.5 + 0.5;\nfloat vAngleNormalized = vAngle * 2.0 / PI;\nfloat phi = (acos(-vector.y) / PI - 0.5) / vAngleNormalized + 0.5;\noutUV = vec2(theta, phi);\n} else if (projectionType == TEX_PROJ_CYLINDRICAL) {\nvector.xz = normalize(vector).xz;\nfloat uAngle = radians(uAngleDegrees);\nvec2 uv = vec2((atan(vector.x, vector.z)) / (uAngle), (vector.y) / 2.0);\noutUV = uv + 0.5;\n} else if (projectionType == TEX_PROJ_BALL) {\nvec3 normal = normalize(vector);\nnormal.z += 1.0;\nnormal /= (2.0 * sqrt(max(0.5 * normal.z, 0.0)));\noutUV = clamp(0.5 * normal.xy + 0.5, 0.0, 1.0);\n} else if (projectionType == TEX_PROJ_CUBIC) {\nvec2 uvX = vec2(vector.z, vector.y) / abs(vector.x);\nvec2 uvY = vec2(vector.x, vector.z) / abs(vector.y);\nvec2 uvZ = vec2(vector.x, vector.y) / abs(vector.z);\nvec3 absVec = abs(vector);\nvec3 faceMask = step(absVec.yzx, absVec) * step(absVec.zxy, absVec);\nvec2 uv = faceMask.x * uvX + faceMask.y * uvY + faceMask.z * uvZ;\nuv = uv * 0.5 + 0.5;\noutUV = uv;\n} else if (projectionType == TEX_PROJ_SHRINK_WRAP) {\nvector = normalize(vector);\noutUV = normalize(vector.xz) * acos(vector.y) / PI;\noutUV = outUV * 0.5 + 0.5;\n}\n}";
var node_vector_to_rgb_ar_frag = "void node_vector_to_rgb(\nconst int mode, \nvec3 inputValue,\nout vec3 outColor)\n{\nif (mode == 0)\noutColor = inputValue;\nelse if (mode == 1)\noutColor = normalize(inputValue);\nelse if (mode == 2)\noutColor = inputValue;\n}";
var node_add_shader_bl_frag = "void node_add_shader(vec4 color1, vec4 color2, out vec4 outColor) {\noutColor.rgb = color1.rgb + color2.rgb;\noutColor.a = clamp(color1.a + color2.a, 0.0, 1.0);\n}";
var node_ambient_occlusion_bl_frag = "void node_ambient_occlusion(vec4 color, float distance, vec3 normal,\nout vec4 outColor, out float outAO) {\noutColor = color;\noutAO = 1.0;\n}";
var node_attribute_bl_frag = "void node_attribute(vec4 paramAttr,\nout vec4 outColor, out vec3 outVector, out float outFac, out float outAlpha) {\noutColor = vec4(paramAttr.xyz, 1.0);\noutVector = paramAttr.xyz;\noutFac = average(paramAttr.xyz);\noutAlpha = paramAttr.w;\n}";
var node_background_bl_frag = "void node_background(vec4 color, float strength, out vec4 outColor)\n{\noutColor = strength * color;\n}";
var node_bevel_bl_frag = "void node_bevel(float radius, vec3 normal, out vec3 outNormal) {\noutNormal = normal;\n}";
var node_blackbody_bl_frag = "void node_blackbody(float temp, out vec4 outColor)\n{\noutColor = vec4(colorTempToRGB(temp), 1.0);\n}";
var node_brightcontrast_bl_frag = "void node_brightcontrast(vec4 color, float bright, float contrast, out vec4 outColor)\n{\nfloat bminc = bright - contrast * 0.5;\noutColor.r = max((1.0 + contrast) * color.r + bminc, 0.0);\noutColor.g = max((1.0 + contrast) * color.g + bminc, 0.0);\noutColor.b = max((1.0 + contrast) * color.b + bminc, 0.0);\noutColor.a = color.a;\n}";
var node_bsdf_anisotropic_bl_frag = "void node_bsdf_anisotropic(\nvec4 color, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,\nout vec4 outColor)\n{\noutColor = color;\n}";
var node_bsdf_diffuse_bl_frag = "\nvoid node_bsdf_diffuse(\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\n#endif\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}";
var node_bsdf_glass_bl_frag = "void node_bsdf_glass(\nvec3 geometryNormal,\nvec4 color, float roughness, float ior, vec3 normal,\nout vec4 outColor) {\nnormal = normalize(normal);\nnormal = swizzleUpY(normal);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.specularColor = vec3(1.0);\nmaterial.fresnelRefl90 = vec3(1.0);\nmaterial.roughness = clamp(roughness, 0.0, 1.0);\nmaterial.refractionColor = vec3(1.0);\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0),\nvec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 viewWorld;\nif (isOrthographic)\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\noutColor = vec4(color.rgb * mix(refractedLight, reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular, fresnel), 1.0);\n}";
var node_bsdf_glossy_bl_frag = "void node_bsdf_glossy(\nvec3 geometryNormal,\nvec4 color, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = normalize((viewMatrix * vec4(normal.xyz, 0.0)).xyz);\nNodeMaterial material;\nmaterial.specularColor = vec3(1.0);\nmaterial.fresnelRefl90 = vec3(1.0);\nmaterial.roughness = clamp(roughness, 0.0, 1.0);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\noutColor = vec4(color.rgb * (reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular), 1.0);\n}\nvoid node_bsdf_glossy(\nvec3 geometryNormal,\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnode_bsdf_glossy(geometryNormal, color, roughness, 0.0, 0.0, normal, vec3(0.0), outColor);\n}";
var node_bsdf_hair_bl_frag = "void node_bsdf_hair(vec4 color, float offset, float roughnessU, float roughnessV, vec3 tangent, out vec4 outColor)\n{\noutColor = color;\n}";
var node_bsdf_metallic_bl_frag = "#define BSDF_METALLIC_BECKMANN 0\n#define BSDF_METALLIC_GGX 1\n#define BSDF_METALLIC_MULTI_GGX 2\nvec3 fresnelConductor(float cosi, vec3 eta, vec3 k) {\nvec3 cosiSqr = vec3(cosi * cosi);\nvec3 tmpF = (eta * eta) + (k * k);\nvec3 tmp2EtaCosI = 2.0 * eta * vec3(cosi);\nvec3 tmp = tmpF * cosiSqr;\nvec3 rparl2 = (tmp - tmp2EtaCosI + vec3(1.0)) / (tmp + tmp2EtaCosI + vec3(1.0));\nvec3 rperp2 = (tmpF - tmp2EtaCosI + cosiSqr) / (tmpF + tmp2EtaCosI + cosiSqr);\nreturn (rparl2 + rperp2) * 0.5;\n}\nvoid node_bsdf_metallic(\nvec3 geometryNormal, const int distribution, const bool usePhysicalConductor,\nvec4 baseColor, vec4 edgeTint, vec3 ior, vec3 extinction, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = normalize((viewMatrix * vec4(normal.xyz, 0.0)).xyz);\nNodeMaterial material;\nif (usePhysicalConductor) {\nmaterial.specularColor = saturate(fresnelConductor(1.0, ior, extinction));\nmaterial.fresnelRefl90 = saturate(fresnelConductor(1.0 / 7.0, ior, extinction));\n} else {\nmaterial.specularColor = saturate(baseColor.rgb);\nmaterial.fresnelRefl90 = saturate(edgeTint.rgb);\n}\nmaterial.specularF90 = average(material.fresnelRefl90);\nmaterial.roughness = saturate(roughness);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Empty\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular, 1.0);\n}";
var node_bsdf_principled_bl_frag = "\nvec3 tintFromColor(vec3 color) {\nfloat lum = dot(color, vec3(0.3, 0.6, 0.1));\nreturn lum > 0.0 ? color / lum : vec3(1.0);\n}\nvec3 fresnelBlend(float ior, float fresnel, vec3 fresnelColor) {\nfloat fresnelFac = fresnelReflection(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), ior);\nfloat mixFac = saturate((fresnel - fresnelFac) / max(1e-8, 1.0 - fresnelFac));\nreturn mix(fresnelColor, vec3(1.0), mixFac);\n}\nfloat iorToF0(float eta) {\nfloat A = (eta - 1.0) / (eta + 1.0);\nreturn A * A;\n}\n#ifdef USE_SHEEN_BLENDER\nfloat principledSheen(float NV, float rough) {\nfloat den = 35.6694 * rough * rough - 24.4269 * rough * NV - 0.1405 * NV * NV + 6.1211 * rough + 0.28105 * NV - 0.1405;\nfloat num = 58.5299 * rough * rough - 85.0941 * rough * NV + 9.8955 * NV * NV + 1.9250 * rough + 74.2268 * NV - 0.2246;\nreturn saturate(den / num);\n}\n#elif defined(USE_SHEEN_BLENDER_OLD)\nfloat principledSheen(float NV) {\nfloat f = 1.0 - NV;\nfloat sheen = f * f * f * 0.077 + f * 0.01 + 0.00026;\nreturn sheen;\n}\n#endif\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float metallic, float roughness, float ior, float alpha, vec3 normal, float diffuseRoughness,\nfloat subsurface, vec3 subsurfaceRadius, float subsurfaceScale, float subsurfaceIOR,\nfloat subsurfaceAnisotropy,\nfloat specularIORLevel, vec4 specularTint,\nfloat anisotropic, float anisotropicRotation, vec3 tangent,\nfloat transmission,\nfloat clearcoat, float clearcoatRoughness, float clearcoatIOR, vec4 clearcoatTint,\nvec3 clearcoatNormal,\nfloat sheen, float sheenRoughness, vec4 sheenTint,\nvec4 emission, float emissionStrength,\nfloat thinFilmThickness, float thinFilmIOR,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat dielectric = 1.0 - metallic;\ntransmission *= dielectric;\nmaterial.diffuseColor = baseColor.rgb * dielectric;\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#endif\n#ifdef USE_SHEEN_BLENDER\nfloat dotNVsh = dot(normal, (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition));\nmaterial.diffuseColor += sheen * sheenTint.rgb * principledSheen(dotNVsh, sheenRoughness);\n#endif\nmaterial.roughness = clamp(roughness, 0.0, 1.0);\nvec3 viewWorld;\nif (isOrthographic)\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat f0d = iorToF0(ior);\nif (specularIORLevel != 0.5)\nf0d *= 2.0 * specularIORLevel;\nvec3 F0d = vec3(f0d) * specularTint.rgb;\nF0d = clamp(F0d, vec3(0.0), vec3(1.0));\nvec3 F90d = vec3(1.0);\nmaterial.specularColor = mix(F0d, baseColor.rgb, metallic);\nmaterial.fresnelRefl90 = mix(F90d, specularTint.rgb, metallic);\nmaterial.specularF90 = average(material.fresnelRefl90);\nmaterial.refractionColor = baseColor.rgb;\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\nclearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));\nclearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#ifdef USE_CLEARCOAT\nclearcoatSpecular += clearcoatRadiance * BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, vec3(material.clearcoatF90), material.clearcoatRoughness);\n#endif\nirradiance += iblIrradiance;\nvec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.normal, material.specularColor, material.fresnelRefl90, material.roughness);\nreflectedLight.indirectSpecular += radiance * specEnv;\nfloat weight = 1.0;\nweight *= max((1.0 - max3(specEnv)), 0.0);\nmaterial.diffuseColor *= weight;\nRE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);\nRE_Refraction(refraction, material, refractedLight);\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\nvec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * (1.0 - transmission)\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular\n+ refractedLight * transmission * (1.0 - fresnel)\n+ emission.rgb * emissionStrength;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\noutColor = vec4(outColor3, alpha);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float metallic, float roughness, float ior, float alpha, vec3 normal,\nfloat subsurface, vec3 subsurfaceRadius, float subsurfaceScale, float subsurfaceIOR,\nfloat subsurfaceAnisotropy,\nfloat specularIORLevel, vec4 specularTint,\nfloat anisotropic, float anisotropicRotation, vec3 tangent,\nfloat transmission,\nfloat clearcoat, float clearcoatRoughness, float clearcoatIOR, vec4 clearcoatTint,\nvec3 clearcoatNormal,\nfloat sheen, float sheenRoughness, vec4 sheenTint,\nvec4 emission, float emissionStrength,\nfloat thinFilmThickness, float thinFilmIOR,\nout vec4 outColor) {\nnode_bsdf_principled(geometryNormal, baseColor, metallic, roughness, ior, alpha, normal, 0.0, subsurface, subsurfaceRadius, subsurfaceScale, subsurfaceIOR, subsurfaceAnisotropy, specularIORLevel, specularTint, anisotropic, anisotropicRotation, tangent, transmission, clearcoat, clearcoatRoughness, clearcoatIOR, clearcoatTint, clearcoatNormal, sheen, sheenRoughness, sheenTint, emission, emissionStrength, 0.0, 0.0, outColor);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float metallic, float roughness, float ior, float alpha, vec3 normal,\nfloat subsurface, vec3 subsurfaceRadius, float subsurfaceScale, float subsurfaceIOR,\nfloat subsurfaceAnisotropy,\nfloat specularIORLevel, vec4 specularTint,\nfloat anisotropic, float anisotropicRotation, vec3 tangent,\nfloat transmission,\nfloat clearcoat, float clearcoatRoughness, float clearcoatIOR, vec4 clearcoatTint,\nvec3 clearcoatNormal,\nfloat sheen, float sheenRoughness, vec4 sheenTint,\nvec4 emission, float emissionStrength,\nout vec4 outColor) {\nnode_bsdf_principled(geometryNormal, baseColor, metallic, roughness, ior, alpha, normal, subsurface, subsurfaceRadius, subsurfaceScale, subsurfaceIOR, subsurfaceAnisotropy, specularIORLevel, specularTint, anisotropic, anisotropicRotation, tangent, transmission, clearcoat, clearcoatRoughness, clearcoatIOR, clearcoatTint, clearcoatNormal, sheen, sheenRoughness, sheenTint, emission, emissionStrength, 0.0, 0.0, outColor);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float subsurface, vec3 subsurfaceRadius, vec4 subsurfaceColor,\nfloat subsurfaceIOR, float subsurfaceAnisotropy,\nfloat metallic, float specular, float specularTint, float roughness,\nfloat anisotropic, float anisotropicRotation, float sheen, float sheenTint,\nfloat clearcoat, float clearcoatRoughness, float ior,\nfloat transmission, float transmissionRoughness, vec4 emission,\nfloat emissionStrength, float alpha, vec3 normal, vec3 clearcoatNormal,\nvec3 tangent,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat dielectric = 1.0 - metallic;\ntransmission *= dielectric;\nmaterial.diffuseColor = baseColor.rgb * dielectric;\n#ifndef USE_CLEARCOAT\nfloat dielReflCoeff = 0.08;\n#else\nfloat dielReflCoeff = 0.16;\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#endif\n#if defined(USE_SHEEN_BLENDER_OLD)\nfloat dotNVsh = dot(normal, (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition));\nvec3 sheenColor = mix(vec3(1.0), tintFromColor(baseColor.rgb), sheenTint);\nmaterial.diffuseColor += sheen * sheenColor * principledSheen(dotNVsh);\n#endif\nvec3 dielRefl = dielReflCoeff * specular\n* mix(vec3(1.0), tintFromColor(baseColor.rgb), specularTint);\nmaterial.specularColor = mix(dielRefl, baseColor.rgb, metallic);\nmaterial.roughness = clamp(roughness, 0.0, 1.0);\nvec3 viewWorld;\nif (isOrthographic)\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\nvec3 fresnelColor = mix(vec3(1.0), baseColor.rgb, specularTint);\nmaterial.specularColor = mix(material.specularColor,\nfresnelBlend(ior, fresnel, fresnelColor) * fresnel, transmission);\nfloat isStrictDielectric = step(0.0, -length(vec4(subsurface, clearcoat,\ntransmission, float(metallic == 1.0))));\nmaterial.fresnelRefl90 = mix(vec3(1.0), material.specularColor,\n(1.0 - specular) * metallic * (1.0 - isStrictDielectric));\nmaterial.specularF90 = average(material.fresnelRefl90);\nmaterial.refractionColor = baseColor.rgb;\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\nclearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));\nclearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * (1.0 - transmission)\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular\n+ refractedLight * transmission * (1.0 - fresnel)\n+ emission.rgb * emissionStrength;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\noutColor = vec4(outColor3, alpha);\n}";
var node_bsdf_refraction_bl_frag = "#define BSDF_REFRACTION_GGX 0\n#define BSDF_REFRACTION_BECKMANN 1\n#define BSDF_REFRACTION_SHARP 2\nvoid node_bsdf_refraction(\nvec3 geometryNormal, const int distribution,\nvec4 color, float roughness, float ior, vec3 normal,\nout vec4 outColor) {\nnormal = swizzleUpY(normal);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.refractionColor = color.rgb;\nmaterial.refractionIOR = ior;\nif (distribution == BSDF_REFRACTION_SHARP) {\nmaterial.refractionRoughness = 0.0;\n} else {\nmaterial.refractionRoughness = pow2(roughness);\n}\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Refraction\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutColor = vec4(refractedLight, 1.0);\n}";
var node_bsdf_sheen_bl_frag = "\nvoid node_bsdf_sheen(vec4 color, float roughness, vec3 normal, out vec4 outColor)\n{\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}";
var node_bsdf_toon_bl_frag = "void node_bsdf_toon(\nvec4 color, float size, float smoothFac, vec3 normal,\nout vec4 outColor)\n{\noutColor = color;\n}";
var node_bsdf_translucent_bl_frag = "void node_bsdf_translucent(vec4 color, vec3 normal, out vec4 outColor) {\nnormal = -vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}";
var node_bsdf_transparent_bl_frag = "void node_bsdf_transparent(vec4 color, out vec4 outColor)\n{\nfloat alpha = saturate(1.0 - dot(color.rgb, vec3(0.333333)));\noutColor = vec4(0.0, 0.0, 0.0, alpha);\n}";
var node_bsdf_velvet_bl_frag = "\nvoid node_bsdf_velvet(vec4 color, float sigma, vec3 normal, out vec4 outColor)\n{\noutColor = color;\n}";
var node_bump_bl_frag = "void node_bump(\nconst bool invert,\nfloat strength, float bumpDist, float height, vec3 normal,\nout vec3 outNormal) {\nvec3 position = swizzleUpZ(vWorldPosition);\nif (invert)\nbumpDist *= -1.0;\nvec3 dPdx = dFdx(position);\nvec3 dPdy = dFdy(position);\nfloat dHdx = dFdx(height);\nfloat dHdy = dFdy(height);\nvec3 tanX = cross(dPdy, normal);\nvec3 tanY = cross(normal, dPdx);\nvec3 surfaceGrad = dHdx * tanX + dHdy * tanY;\nfloat dotPosTanX = dot(dPdx, tanX);\noutNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * bumpDist * sign(dotPosTanX));\noutNormal = normalize(mix(normal, outNormal, max(0.0, strength)));\n}\nvoid node_bump(const bool invert,\nfloat strength, float bumpDist, float height, float height_dx, float height_dy, vec3 normal,\nout vec3 outNormal) {\nnode_bump(invert, strength, bumpDist, height, normal, outNormal);\n}";
var node_camera_bl_frag = "void node_camera(\nvec3 viewPos, const bool invCamZ,\nout vec3 outViewVector, out float outViewZDepth, out float outViewDistance)\n{\nviewPos = -viewPos;\nif (invCamZ)\nviewPos.z = -viewPos.z;\noutViewVector = normalize(viewPos);\noutViewZDepth = abs(viewPos.z);\noutViewDistance = length(viewPos);\n}";
var node_clamp_bl_frag = "void node_clamp(bool clampRange, float value, float minVal, float maxVal, out float result) {\nif (clampRange)\nresult = (maxVal > minVal) ? clamp(value, minVal, maxVal) : clamp(value, maxVal, minVal);\nelse\nresult = min(max(value, minVal), maxVal);\n}";
var node_combhsv_bl_frag = "\nvoid node_combhsv(float h, float s, float v, out vec4 col)\n{\nhsvToRGB(vec4(h, s, v, 1.0), col);\n}";
var node_combine_color_bl_frag = "#define NODE_COMB_COL_RGB 0\n#define NODE_COMB_COL_HSV 1\n#define NODE_COMB_COL_HSL 2\nvoid hslToRGB(vec3 hsl, out vec3 outCol)\n{\nfloat nr, ng, nb, chroma;\nfloat h, s, l;\nh = hsl[0];\ns = hsl[1];\nl = hsl[2];\nnr = abs(h * 6.0 - 3.0) - 1.0;\nng = 2.0 - abs(h * 6.0 - 2.0);\nnb = 2.0 - abs(h * 6.0 - 4.0);\nnr = clamp(nr, 0.0, 1.0);\nnb = clamp(nb, 0.0, 1.0);\nng = clamp(ng, 0.0, 1.0);\nchroma = (1.0 - abs(2.0 * l - 1.0)) * s;\noutCol = vec3((nr - 0.5) * chroma + l, (ng - 0.5) * chroma + l, (nb - 0.5) * chroma + l);\n}\nvoid node_combine_color(int mode, float r, float g, float b, out vec4 col)\n{\nif (mode == NODE_COMB_COL_RGB) {\ncol = vec4(r, g, b, 1.0);\n} else if (mode == NODE_COMB_COL_HSV) {\nhsvToRGB(vec4(r, g, b, 1.0), col);\n} else {\nvec3 col3;\nhslToRGB(vec3(r, g, b), col3);\ncol = vec4(col3, 1.0);\n}\n}";
var node_combrgb_bl_frag = "\nvoid node_combrgb(float r, float g, float b, out vec4 col)\n{\ncol = vec4(r, g, b, 1.0);\n}";
var node_combxyz_bl_frag = "void node_combxyz(float x, float y, float z, out vec3 outVector)\n{\noutVector = vec3(x, y, z);\n}";
var node_curve_float_bl_frag = "void node_curve_float(sampler2D curveData, float fac, float value, out float outValue)\n{\noutValue = texture2D(curveData, vec2((value + 1.0) * 0.5, 0.0)).x;\noutValue = mix(value, outValue * 2.0 - 1.0, fac);\n}";
var node_curve_rgb_bl_frag = "void node_curve_rgb(sampler2D curveData, float fac, vec4 col, out vec4 outCol)\n{\noutCol.r = texture2D(curveData, vec2(texture2D(curveData, vec2(col.r, 0.0)).a, 0.0)).r;\noutCol.g = texture2D(curveData, vec2(texture2D(curveData, vec2(col.g, 0.0)).a, 0.0)).g;\noutCol.b = texture2D(curveData, vec2(texture2D(curveData, vec2(col.b, 0.0)).a, 0.0)).b;\noutCol = mix(col, outCol, fac);\noutCol.a = col.a;\n}";
var node_curve_vec_bl_frag = "void node_curve_vec(sampler2D curveData, float fac, vec3 vec, out vec3 outVec)\n{\noutVec.x = texture2D(curveData, vec2((vec.x + 1.0) * 0.5, 0.0)).x;\noutVec.y = texture2D(curveData, vec2((vec.y + 1.0) * 0.5, 0.0)).y;\noutVec.z = texture2D(curveData, vec2((vec.z + 1.0) * 0.5, 0.0)).z;\noutVec = mix(vec, outVec * 2.0 - vec3(1.0), fac);\n}";
var node_diffuse_bsdf_bl_frag = "void node_diffuse_bsdf(\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\n#endif\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}";
var node_displacement_bl_frag = "void node_displacement(float height, float midlevel, float scale, vec3 normal, out vec3 outDisplacement) {\noutDisplacement = vec3(0.0);\n}";
var node_eevee_specular_bl_frag = "void node_eevee_specular(\nvec3 geometryNormal,\nvec4 baseColor, vec4 specular, float roughness, vec4 emissiveColor,\nfloat transparency, vec3 normal, float clearcoat, float clearcoatRoughness,\nvec3 clearcoatNormal, float ambientOcclusion,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = baseColor.rgb;\nmaterial.specularColor = specular.rgb;\nmaterial.roughness = clamp(roughness, 0.0, 1.0);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\n#endif\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\nclearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));\nclearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular) * ambientOcclusion\n+ emissiveColor.rgb;\noutColor = vec4(outColor3, 1.0 - transparency);\n}";
var node_emission_bl_frag = "void node_emission(vec4 color, float strength, out vec4 outColor)\n{\noutColor = vec4(strength * color.rgb, 1.0);\n}";
var node_fresnel_bl_frag = "void node_fresnel(vec3 viewPos, float IOR, vec3 normal, out float fac)\n{\nvec3 worldDir;\nif (isOrthographic)\nworldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nelse\nworldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;\nworldDir = normalize(swizzleUpZ(worldDir));\nfloat eta = max(IOR, 0.00001);\nfac = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);\n}";
var node_gamma_bl_frag = "void node_gamma(vec4 col, float gamma, out vec4 outCol)\n{\noutCol = col;\nif (col.r > 0.0)\noutCol.r = powCompat(col.r, gamma);\nif (col.g > 0.0)\noutCol.g = powCompat(col.g, gamma);\nif (col.b > 0.0)\noutCol.b = powCompat(col.b, gamma);\n}";
var node_hair_info_bl_frag = "\nvoid node_hair_info(out float isStrand, out float intercept, out float len, out float thickness,\nout vec3 tangentNormal, out float random) {\nisStrand = 0.0;\nintercept = 0.0;\nlen = 0.0;\nthickness = 0.0;\ntangentNormal = vec3(0.0);\nrandom = 1.0;\n}\nvoid node_hair_info(out float isStrand, out float intercept, out float thickness,\nout vec3 tangentNormal, out float random) {\nfloat len;\nnode_hair_info(isStrand, intercept, len, thickness, tangentNormal, random);\n}";
var node_holdout_bl_frag = "void node_holdout(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}";
var node_hue_sat_bl_frag = "void node_hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outCol)\n{\nvec4 hsv;\nrgbToHSV(col, hsv);\nhsv[0] += (fract(hue) - 0.5);\nif (hsv[0] > 1.0) hsv[0] -= 1.0; else if (hsv[0] < 0.0) hsv[0] += 1.0;\nhsv[1] *= sat;\nif (hsv[1] > 1.0) hsv[1] = 1.0; else if (hsv[1] < 0.0) hsv[1] = 0.0;\nhsv[2] *= value;\nhsvToRGB(hsv, outCol);\noutCol = mix(col, outCol, fac);\n}";
var node_invert_bl_frag = "void node_invert(float fac, vec4 col, out vec4 outCol)\n{\noutCol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\noutCol.w = col.w;\n}";
var node_layer_weight_bl_frag = "void node_layer_weight(vec3 viewPos, float blend, vec3 normal, out float fresnel, out float facing)\n{\nvec3 worldDir;\nif (isOrthographic)\nworldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nelse\nworldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;\nworldDir = normalize(swizzleUpZ(worldDir));\nfloat eta = max(1.0 - blend, EPSILON);\nfresnel = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? 1.0 / eta : eta);\nfacing = abs(dot(worldDir, normal));\nif (blend != 0.5) {\nblend = clamp(blend, 0.0, 1.0 - EPSILON);\nblend = (blend < 0.5) ? blend * 2.0 : 0.5 / (1.0 - blend);\nfacing = pow(facing, blend);\n}\nfacing = 1.0 - facing;\n}";
var node_light_falloff_bl_frag = "void node_light_falloff(\nfloat strength, float inSmooth,\nout float quadratic, out float linear, out float constant)\n{\nquadratic = 1.0;\nlinear = 1.0;\nconstant = 1.0;\n}";
var node_light_path_bl_frag = "void node_light_path(\nout float isCameraRay, out float isShadowRay, out float isDiffuseRay, \nout float isGlossyRay, out float isSingularRay, out float isReflectionRay,\nout float isTransmissionRay, out float rayLength, out float rayDepth, \nout float diffuseDepth, out float glossyDepth, out float transparentDepth, \nout float transmissionDepth)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay = 1.0;\n#else\nisCameraRay = 0.0;\n#endif\nisShadowRay = 0.0;\nisDiffuseRay = 0.0;\nisGlossyRay = 0.0;\nisSingularRay = 0.0;\nisReflectionRay = 0.0;\nisTransmissionRay = 0.0;\nrayLength = 1.0;\nrayDepth = 1.0;\ndiffuseDepth = 1.0;\nglossyDepth = 1.0;\ntransparentDepth = 1.0; \ntransmissionDepth = 1.0;\n}";
var node_mapping_bl_frag = "#define NODE_MAPPING_POINT 1\n#define NODE_MAPPING_TEXTURE 2\n#define NODE_MAPPING_VECTOR 3\n#define NODE_MAPPING_NORMAL 4\nmat3 rotationMatrix(float angleX, float angleY, float angleZ) {\nfloat cx = cos(angleX);\nfloat sx = sin(angleX);\nfloat cy = cos(angleY);\nfloat sy = sin(angleY);\nfloat cz = cos(angleZ);\nfloat sz = sin(angleZ);\nmat3 mat;\nmat[0][0] = cy * cz;\nmat[0][1] = cy * sz;\nmat[0][2] = -sy;\nmat[1][0] = sy * sx * cz - cx * sz;\nmat[1][1] = sy * sx * sz + cx * cz;\nmat[1][2] = cy * sx;\nmat[2][0] = sy * cx * cz + sx * sz;\nmat[2][1] = sy * cx * sz - sx * cz;\nmat[2][2] = cy * cx;\nreturn mat;\n}\nmat3 mat3GetInverseTransposed(mat3 mat) {\nfloat det = mat3GetDeterminant(mat);\nfloat a00 = (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) / det;\nfloat a01 = - (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) / det;\nfloat a02 = (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]) / det;\nfloat a10 = - (mat[0][1] * mat[2][2] - mat[0][2] * mat[2][1]) / det;\nfloat a11 = (mat[0][0] * mat[2][2] - mat[0][2] * mat[2][0]) / det;\nfloat a12 = - (mat[0][0] * mat[2][1] - mat[0][1] * mat[2][0]) / det;\nfloat a20 = (mat[0][1] * mat[1][2] - mat[0][2] * mat[1][1]) / det;\nfloat a21 = - (mat[0][0] * mat[1][2] - mat[0][2] * mat[1][0]) / det;\nfloat a22 = (mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0]) / det;\nreturn mat3(\na00, a01, a02,\na10, a11, a12,\na20, a21, a22\n);\n}\nvoid node_mapping(int type, vec3 vec, vec3 loc, vec3 rot, vec3 scale, out vec3 outVec)\n{\nif (type == NODE_MAPPING_POINT)\noutVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale) + loc;\nelse if (type == NODE_MAPPING_TEXTURE)\noutVec = transposeMat3(rotationMatrix(rot.x, rot.y, rot.z)) * (vec - loc) / scale;\nelse if (type == NODE_MAPPING_VECTOR)\noutVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale);\nelse {\nmat3 rot = rotationMatrix(rot.x, rot.y, rot.z) * mat3(\nscale[0], 0.0, 0.0,\n0.0, scale[1], 0.0,\n0.0, 0.0, scale[2]\n);\noutVec = normalize(mat3GetInverseTransposed(rot) * vec);\n}\n}";
var node_map_range_bl_frag = "#define NODE_MAP_RANGE_INTERP_LINEAR 0\n#define NODE_MAP_RANGE_INTERP_STEPPED 1\n#define NODE_MAP_RANGE_INTERP_SMOOTHSTEP 2\n#define NODE_MAP_RANGE_INTERP_SMOOTHERSTEP 3\n#define NODE_MAP_RANGE_TYPE_FLOAT 0\n#define NODE_MAP_RANGE_TYPE_FLOAT_VECTOR 1\nfloat smootherstep(float edge0, float edge1, float x) {\nfloat t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\nreturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nvec3 smootherstep(vec3 x) {\nvec3 t = clamp(x, 0.0, 1.0);\nreturn (t * (t * 6.0 - 15.0) + 10.0) * t * t * t;\n}\nvoid node_map_range(const int interpolation, bool inClamp, float value, float fromMin, float fromMax,\nfloat toMin, float toMax, float steps, out float result) {\nif (fromMax == fromMin) {\nresult = 0.0;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_LINEAR) {\nresult = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_STEPPED) {\nfloat fac = (value - fromMin) / (fromMax - fromMin);\nfac = (steps > 0.0) ? floor(fac * (steps + 1.0)) / steps : 0.0;\nresult = fac * (toMax - toMin) + toMin;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_SMOOTHSTEP) {\nfloat fac = (fromMin > fromMax) ?\n1.0 - smoothstep(fromMax, fromMin, value) :\nsmoothstep(fromMin, fromMax, value);\nresult = fac * (toMax - toMin) + toMin;\n} else {\nfloat fac = (fromMin > fromMax) ?\n1.0 - smootherstep(fromMax, fromMin, value) :\nsmootherstep(fromMin, fromMax, value);\nresult = fac * (toMax - toMin) + toMin;\n}\nif (inClamp && interpolation <= NODE_MAP_RANGE_INTERP_STEPPED) {\nresult = clamp(result, toMin, toMax);\n}\n}\nvoid node_map_range(const int dataType, const int interpolation, bool inClamp, float value,\nfloat fromMin, float fromMax, float toMin, float toMax, float steps, vec3 valueVec,\nvec3 fromMinVec, vec3 fromMaxVec, vec3 toMinVec, vec3 toMaxVec, vec3 stepsVec,\nout float result, out vec3 resultVec) {\nif (dataType == NODE_MAP_RANGE_TYPE_FLOAT) {\nif (fromMax == fromMin) {\nresult = 0.0;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_LINEAR) {\nresult = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_STEPPED) {\nfloat fac = (value - fromMin) / (fromMax - fromMin);\nfac = (steps > 0.0) ? floor(fac * (steps + 1.0)) / steps : 0.0;\nresult = fac * (toMax - toMin) + toMin;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_SMOOTHSTEP) {\nfloat fac = (fromMin > fromMax) ?\n1.0 - smoothstep(fromMax, fromMin, value) :\nsmoothstep(fromMin, fromMax, value);\nresult = fac * (toMax - toMin) + toMin;\n} else {\nfloat fac = (fromMin > fromMax) ?\n1.0 - smootherstep(fromMax, fromMin, value) :\nsmootherstep(fromMin, fromMax, value);\nresult = fac * (toMax - toMin) + toMin;\n}\n} else if (dataType == NODE_MAP_RANGE_TYPE_FLOAT_VECTOR) {\nvec3 deltaVec = fromMaxVec - fromMinVec;\nvec3 fac = vec3(\ndeltaVec.x == 0.0 ? 0.0 : (valueVec.x - fromMinVec.x) / deltaVec.x,\ndeltaVec.y == 0.0 ? 0.0 : (valueVec.y - fromMinVec.y) / deltaVec.y,\ndeltaVec.z == 0.0 ? 0.0 : (valueVec.z - fromMinVec.z) / deltaVec.z\n);\nif (interpolation == NODE_MAP_RANGE_INTERP_LINEAR) {\nresultVec = fac * (toMaxVec - toMinVec) + toMinVec;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_STEPPED) {\nfac.x = stepsVec.x == 0.0 ? 0.0 : floor(fac.x * (stepsVec.x + 1.0)) / stepsVec.x;\nfac.y = stepsVec.y == 0.0 ? 0.0 : floor(fac.y * (stepsVec.y + 1.0)) / stepsVec.y;\nfac.z = stepsVec.z == 0.0 ? 0.0 : floor(fac.z * (stepsVec.z + 1.0)) / stepsVec.z;\nresultVec = fac * (toMaxVec - toMinVec) + toMinVec;\n} else if (interpolation == NODE_MAP_RANGE_INTERP_SMOOTHSTEP) {\nfac = clamp(fac, 0.0, 1.0);\nfac = fac * fac * (3.0 - 2.0 * fac);\nresultVec = fac * (toMaxVec - toMinVec) + toMinVec;\n} else {\nresultVec = smootherstep(fac) * (toMaxVec - toMinVec) + toMinVec;\n}\nif (inClamp && interpolation <= NODE_MAP_RANGE_INTERP_STEPPED) {\nvec3 sumVec = toMinVec + toMaxVec;\ntoMaxVec = max(toMaxVec, toMinVec);\ntoMinVec = sumVec - toMaxVec;\nresultVec = clamp(resultVec, toMinVec, toMaxVec);\n}\n}\n}";
var node_math_bl_frag = "void node_math_add(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 + val2;\n}\nvoid node_math_subtract(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 - val2;\n}\nvoid node_math_multiply(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 * val2;\n}\nvoid node_math_divide(float val1, float val2, float val3, out float outVal)\n{\nif (val2 == 0.0)\noutVal = 0.0;\nelse\noutVal = val1 / val2;\n}\nvoid node_math_sine(float val, float val2, float val3, out float outVal)\n{\noutVal = sin(val);\n}\nvoid node_math_cosine(float val, float val2, float val3, out float outVal)\n{\noutVal = cos(val);\n}\nvoid node_math_tangent(float val, float val2, float val3, out float outVal)\n{\noutVal = tan(val);\n}\nvoid node_math_arcsine(float val, float val2, float val3, out float outVal)\n{\nif (val <= 1.0 && val >= -1.0)\noutVal = asin(val);\nelse\noutVal = 0.0;\n}\nvoid node_math_arccosine(float val, float val2, float val3, out float outVal)\n{\nif (val <= 1.0 && val >= -1.0)\noutVal = acos(val);\nelse\noutVal = 0.0;\n}\nvoid node_math_arctangent(float val, float val2, float val3, out float outVal)\n{\noutVal = atan(val);\n}\nvoid node_math_arctan2(float val, float val2, float val3, out float outVal)\n{\noutVal = atan(val, val2);\n}\nvoid node_math_power(float val1, float val2, float val3, out float outVal)\n{\nif (val1 >= 0.0)\noutVal = powCompat(val1, val2);\nelse {\nfloat val2_mod_1 = mod(abs(val2), 1.0);\nif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\noutVal = powCompat(val1, floor(val2 + 0.5));\nelse\noutVal = 0.0;\n}\n}\nvoid node_math_logarithm(float val1, float val2, float val3, out float outVal)\n{\nif (val1 > 0.0 && val2 > 0.0)\noutVal = log2(val1) / log2(val2);\nelse\noutVal = 0.0;\n}\nvoid node_math_sqrt(float val1, float val2, float val3, out float outVal)\n{\noutVal = sqrt(val1);\n}\nvoid node_math_maximum(float val1, float val2, float val3, out float outVal)\n{\noutVal = max(val1, val2);\n}\nvoid node_math_minimum(float val1, float val2, float val3, out float outVal)\n{\noutVal = min(val1, val2);\n}\nvoid node_math_round(float val1, float val2, float val3, out float outVal)\n{\noutVal = floor(val1 + 0.5);\n}\nvoid node_math_floor(float val1, float val2, float val3, out float outVal)\n{\noutVal = floor(val1);\n}\nvoid node_math_ceil(float val1, float val2, float val3, out float outVal)\n{\noutVal = ceil(val1);\n}\nvoid node_math_fract(float val1, float val2, float val3, out float outVal)\n{\noutVal = fract(val1);\n}\nvoid node_math_less_than(float val1, float val2, float val3, out float outVal)\n{\nif (val1 < val2)\noutVal = 1.0;\nelse\noutVal = 0.0;\n}\nvoid node_math_greater_than(float val1, float val2, float val3, out float outVal)\n{\nif (val1 > val2)\noutVal = 1.0;\nelse\noutVal = 0.0;\n}\nvoid node_math_modulo(float val1, float val2, float val3, out float outVal)\n{\nif (val2 == 0.0)\noutVal = 0.0;\nelse\noutVal = mod(val1, val2);\noutVal = (val1 > 0.0) ? outVal : outVal - val2;\n}\nvoid node_math_absolute(float val1, float val2, float val3, out float outVal)\n{\noutVal = abs(val1);\n}\nvoid node_math_compare(float val1, float val2, float val3, out float outVal) {\noutVal = step(abs(val1 - val2), val3);\n}\nvoid node_math_cosh(float val1, float val2, float val3, out float outVal) {\noutVal = cosh(val1);\n}\nvoid node_math_degrees(float val1, float val2, float val3, out float outVal) {\noutVal = val1 / PI * 180.0;\n}\nvoid node_math_exponent(float val1, float val2, float val3, out float outVal) {\noutVal = exp(val1);\n}\nvoid node_math_inverse_sqrt(float val1, float val2, float val3, out float outVal) {\nif (val1 >= 0.0) {\noutVal = 1.0 / sqrt(val1);\n} else {\noutVal = 0.0;\n}\n}\nvoid node_math_multiply_add(float val1, float val2, float val3, out float outVal) {\noutVal = val1 * val2 + val3;\n}\nvoid node_math_pingpong(float val1, float val2, float val3, out float outVal) {\nif (val2 == 0.0) {\noutVal = 0.0;\n} else {\nfloat absVal2 = abs(val2);\nfloat rem = mod(val1, absVal2);\noutVal = mix(rem, absVal2 - rem, mod(floor(val1 / absVal2), 2.0));\n}\n}\nvoid node_math_radians(float val1, float val2, float val3, out float outVal) {\noutVal = val1 / 180.0 * PI;\n}\nvoid node_math_sign(float val1, float val2, float val3, out float outVal) {\noutVal = sign(val1);\n}\nvoid node_math_sinh(float val1, float val2, float val3, out float outVal) {\noutVal = sinh(val1);\n}\nvoid node_math_smooth_max(float val1, float val2, float val3, out float outVal) {\noutVal = smoothMax(val1, val2, val3);\n}\nvoid node_math_smooth_min(float val1, float val2, float val3, out float outVal) {\noutVal = smoothMin(val1, val2, val3);\n}\nvoid node_math_snap(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5 * sign(val2);\nfloat quot = val1 / val2;\noutVal = floor(quot) * val2;\n}\nvoid node_math_tanh(float val1, float val2, float val3, out float outVal) {\noutVal = tanh(val1);\n}\nvoid node_math_trunc(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5;\noutVal = trunc(val1);\n}\nvoid node_math_wrap(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5;\noutVal = mod(val1 - val3, val2 - val3) + val3;\n}";
var node_mix_bl_frag = "void node_mix_rgba_mix(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_add(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 + col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_multiply(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 * col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_screen(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_overlay(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (outCol.r < 0.5)\noutCol.r *= facm + 2.0 * fac * col2.r;\nelse\noutCol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outCol.r);\nif (outCol.g < 0.5)\noutCol.g *= facm + 2.0 * fac * col2.g;\nelse\noutCol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outCol.g);\nif (outCol.b < 0.5)\noutCol.b *= facm + 2.0 * fac * col2.b;\nelse\noutCol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outCol.b);\n}\nvoid node_mix_rgba_exclusion(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = max(mix(col1, col1 + col2 - 2.0 * col1 * col2, fac), 0.0);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_subtract(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 - col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_divide(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (col2.r != 0.0) outCol.r = facm * outCol.r + fac * outCol.r / col2.r;\nif (col2.g != 0.0) outCol.g = facm * outCol.g + fac * outCol.g / col2.g;\nif (col2.b != 0.0) outCol.b = facm * outCol.b + fac * outCol.b / col2.b;\n}\nvoid node_mix_rgba_difference(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, abs(col1 - col2), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_darken(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = mix(col1.rgb, min(col1.rgb, col2.rgb), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_lighten(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = mix(col1.rgb, max(col1.rgb, col2.rgb), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgba_dodge(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1;\nif (outCol.r != 0.0) {\nfloat tmp = 1.0 - fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 1.0;\nelse if ((tmp = outCol.r / tmp) > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\n}\nif (outCol.g != 0.0) {\nfloat tmp = 1.0 - fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 1.0;\nelse if ((tmp = outCol.g / tmp) > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\n}\nif (outCol.b != 0.0) {\nfloat tmp = 1.0 - fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 1.0;\nelse if ((tmp = outCol.b / tmp) > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n}\nvoid node_mix_rgba_burn(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat tmp, facm = 1.0 - fac;\noutCol = col1;\ntmp = facm + fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.r) / tmp)) < 0.0)\noutCol.r = 0.0;\nelse if (tmp > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\ntmp = facm + fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.g) / tmp)) < 0.0)\noutCol.g = 0.0;\nelse if (tmp > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\ntmp = facm + fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.b) / tmp)) < 0.0)\noutCol.b = 0.0;\nelse if (tmp > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n#ifdef HSV_NODES\nvoid node_mix_rgba_hue(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\nvoid node_mix_rgba_saturation(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2;\nrgbToHSV(outCol, hsv);\nif (hsv.y != 0.0) {\nrgbToHSV(col2, hsv2);\nhsv.y = facm * hsv.y + fac * hsv2.y;\nhsvToRGB(hsv, outCol);\n}\n}\nvoid node_mix_rgba_value(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 hsv, hsv2;\nrgbToHSV(col1, hsv);\nrgbToHSV(col2, hsv2);\nhsv.z = facm * hsv.z + fac * hsv2.z;\nhsvToRGB(hsv, outCol);\n}\nvoid node_mix_rgba_color(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsv.y = hsv2.y;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\n#endif\nvoid node_mix_rgba_soft_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 one = vec4(1.0);\nvec4 scr = one - (one - col2) * (one - col1);\noutCol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);\n}\nvoid node_mix_rgba_linear_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1 + fac * (2.0 * (col2 - vec4(0.5)));\n}\nvoid node_mix_vector_uniform(float fac, vec3 facVec, vec3 v1, vec3 v2, out vec3 outVec)\n{\nfac = clamp(fac, 0.0, 1.0);\noutVec = mix(v1, v2, fac);\n}\nvoid node_mix_vector_non_uniform(float fac, vec3 facVec, vec3 v1, vec3 v2, out vec3 outVec)\n{\nfacVec = clamp(facVec, 0.0, 1.0);\noutVec = mix(v1, v2, facVec);\n}\nvoid node_mix_float(float fac, float val1, float val2, out float outVal)\n{\nfac = clamp(fac, 0.0, 1.0);\noutVal = mix(val1, val2, fac);\n}";
var node_mix_rgb_bl_frag = "\nvoid node_mix_rgb_mix(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_add(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 + col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_multiply(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 * col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_screen(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_overlay(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (outCol.r < 0.5)\noutCol.r *= facm + 2.0 * fac * col2.r;\nelse\noutCol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outCol.r);\nif (outCol.g < 0.5)\noutCol.g *= facm + 2.0 * fac * col2.g;\nelse\noutCol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outCol.g);\nif (outCol.b < 0.5)\noutCol.b *= facm + 2.0 * fac * col2.b;\nelse\noutCol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outCol.b);\n}\nvoid node_mix_rgb_subtract(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 - col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_divide(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (col2.r != 0.0) outCol.r = facm * outCol.r + fac * outCol.r / col2.r;\nif (col2.g != 0.0) outCol.g = facm * outCol.g + fac * outCol.g / col2.g;\nif (col2.b != 0.0) outCol.b = facm * outCol.b + fac * outCol.b / col2.b;\n}\nvoid node_mix_rgb_difference(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, abs(col1 - col2), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_darken(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = mix(col1.rgb, min(col1.rgb, col2.rgb), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_lighten(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = max(col1.rgb, col2.rgb * fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_dodge(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1;\nif (outCol.r != 0.0) {\nfloat tmp = 1.0 - fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 1.0;\nelse if ((tmp = outCol.r / tmp) > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\n}\nif (outCol.g != 0.0) {\nfloat tmp = 1.0 - fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 1.0;\nelse if ((tmp = outCol.g / tmp) > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\n}\nif (outCol.b != 0.0) {\nfloat tmp = 1.0 - fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 1.0;\nelse if ((tmp = outCol.b / tmp) > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n}\nvoid node_mix_rgb_burn(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat tmp, facm = 1.0 - fac;\noutCol = col1;\ntmp = facm + fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.r) / tmp)) < 0.0)\noutCol.r = 0.0;\nelse if (tmp > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\ntmp = facm + fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.g) / tmp)) < 0.0)\noutCol.g = 0.0;\nelse if (tmp > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\ntmp = facm + fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.b) / tmp)) < 0.0)\noutCol.b = 0.0;\nelse if (tmp > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n#ifdef HSV_NODES\nvoid node_mix_rgb_hue(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\nvoid node_mix_rgb_saturation(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2;\nrgbToHSV(outCol, hsv);\nif (hsv.y != 0.0) {\nrgbToHSV(col2, hsv2);\nhsv.y = facm * hsv.y + fac * hsv2.y;\nhsvToRGB(hsv, outCol);\n}\n}\nvoid node_mix_rgb_value(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 hsv, hsv2;\nrgbToHSV(col1, hsv);\nrgbToHSV(col2, hsv2);\nhsv.z = facm * hsv.z + fac * hsv2.z;\nhsvToRGB(hsv, outCol);\n}\nvoid node_mix_rgb_color(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsv.y = hsv2.y;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\n#endif\nvoid node_mix_rgb_soft_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 one = vec4(1.0);\nvec4 scr = one - (one - col2) * (one - col1);\noutCol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);\n}\nvoid node_mix_rgb_linear_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1 + fac * (2.0 * (col2 - vec4(0.5)));\n}";
var node_mix_shader_bl_frag = "void node_mix_shader(int transpShaderNum,\nfloat fac, vec4 color1, vec4 color2, out vec4 outColor)\n{\nif (transpShaderNum == 0)\ncolor1.rgb = color2.rgb;\nelse if (transpShaderNum == 1)\ncolor2.rgb = color1.rgb;\noutColor = mix(color1, color2, clamp(fac, 0.0, 1.0));\n}";
var node_new_geometry_bl_frag = "void node_new_geometry(\nfloat frontFacing, vec3 viewPos, vec3 viewNorm,\nout vec3 position, out vec3 normal, out vec3 tangent,\nout vec3 trueNormal, out vec3 incoming, out vec3 parametric,\nout float backfacing, out float pointiness, out float randomPerIsland)\n{\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nposition = swizzleUpZ(posWorld.xyz);\nvec4 viewDir = isOrthographic ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-viewPos), 0.0);\nviewDir = invViewMatrix * viewDir;\nvec3 incomingVec = -swizzleUpZ(viewDir.xyz);\n#if WORLD_NODES == 1\nnormal = incomingVec;\ntangent = vec3(0.0);\n#else\nvec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;\nnormal = swizzleUpZ(norWorld);\nvec4 posLocal = invModelMatrix * posWorld;\nvec3 posLocalDelta = posLocal.xyz - boundingBoxMin;\nvec3 bbDelta = boundingBoxMax - boundingBoxMin;\nvec3 posOrco = vec3(\nbbDelta.x < 1e-5 ? -sign(posLocal.y) : posLocalDelta.x / bbDelta.x,\n0.0,\nbbDelta.z < 1e-5 ? sign(posLocal.y) : posLocalDelta.z / bbDelta.z\n);\nposOrco -= 0.5;\nvec3 tangWorld = (modelMatrix * vec4(posOrco.z, 0.0, -posOrco.x, 0.0)).xyz;\ntangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));\ntangent = swizzleUpZ(tangWorld);\n#endif\ntrueNormal = normal;\nincoming = incomingVec;\nparametric = vec3(0.0);\nbackfacing = (frontFacing > 0.0) ? 0.0 : 1.0;\n#if WORLD_NODES == 1\npointiness = 0.0;\n#else\npointiness = 0.5;\n#endif\nrandomPerIsland = 0.0;\n}";
var node_normal_bl_frag = "void node_normal(vec3 norParam, vec3 norIn, out vec3 norOut, out float dotOut)\n{\nnorOut = norParam;\ndotOut = dot(normalize(norIn), norParam);\n}";
var node_normal_map_bl_frag = "void node_normal_map(vec4 tangent, vec3 normal, float strength, vec4 normalColor, out vec3 normalOut)\n{\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nif (all(lessThan(abs(tangent.xyz), vec3(EPSILON)))) {\nnormalOut = normal;\n} else {\nvec3 normalTex = (normalColor.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\nnormalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent\n+ normalTex.z * normal);\nnormalOut = mix(normal, normalOut, strength);\n}\nnormalOut = normalize((invViewMatrix * vec4(normalOut, 0.0)).xyz);\nnormalOut = swizzleUpZ(normalOut);\n}";
var node_object_info_bl_frag = "uniform int objectIndex;\nuniform vec4 objectColor;\nuniform int materialIndex;\nuniform float objectRandom;\nvoid node_object_info(out vec3 location, out vec4 color, out float alpha, out float objIndex,\nout float matIndex, out float random) {\n#if WORLD_NODES == 1\nlocation = vec3(0.0);\ncolor = vec4(1.0);\nalpha = 1.0;\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.0;\n#else\nlocation = swizzleUpZ(modelMatrix[3].xyz);\ncolor = vec4(objectColor.rgb, 1.0);\nalpha = objectColor.a;\nobjIndex = float(objectIndex);\nmatIndex = float(materialIndex);\nrandom = float(objectRandom);\n#endif\n}\nvoid node_object_info(out vec3 location, out vec4 color, out float objIndex,\nout float matIndex, out float random) {\nfloat alpha;\nnode_object_info(location, color, alpha, objIndex, matIndex, random);\n}";
var node_output_lamp_bl_frag = "void node_output_lamp(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}";
var node_output_material_bl_frag = "void node_output_material(vec4 surface, vec4 volume, vec3 displacement, float thickness, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}\nvoid node_output_material(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {\nnode_output_material(surface, volume, displacement, 0.0, outgoingLight);\n}";
var node_output_world_bl_frag = "void node_output_world(vec4 surface, vec4 volume, out vec4 outgoingLight)\n{\noutgoingLight = surface;\n}";
var node_particle_info_bl_frag = "void node_particle_info(out float index, out float random, out float age,\nout float lifeTime, out vec3 location, out float size, out vec3 velocity,\nout vec3 angularVelocity) {\n#if WORLD_NODES == 1\nindex = 0.0;\nrandom = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#else\nindex = 0.0;\nrandom = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#endif\n}";
var node_point_info_bl_frag = "void node_point_info(out vec3 position, out float radius, out float random) {\nposition = vec3(0.0);\nradius = 0.0;\nrandom = 0.0;\n}";
var node_principled_volume_bl_frag = "void node_principled_volume(vec4 color, float colorAttribute, float density,\nfloat densityAttribute, float anisotropy, vec4 absorptionColor,\nfloat emissionStrength, vec4 emissionColor, float blackbodyIntensity,\nvec4 blackbodyTint, float temperature, float temperatureAttribute,\nout vec4 volume) {\nvolume = vec4(0.0);\n}";
var node_rgb_bl_frag = "uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}";
var node_rgbtobw_bl_frag = "void node_rgbtobw(vec4 color, out float outVal) {\noutVal = linearToRelativeLuminance(color.rgb);\n}";
var node_script_bl_frag = "void node_script(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}";
var node_sephsv_bl_frag = "\nvoid node_sephsv(vec4 col, out float h, out float s, out float v)\n{\nvec4 hsv;\nrgbToHSV(col, hsv);\nh = hsv[0];\ns = hsv[1];\nv = hsv[2];\n}";
var node_separate_color_bl_frag = "#define NODE_SEP_COL_RGB 0\n#define NODE_SEP_COL_HSV 1\n#define NODE_SEP_COL_HSL 2\nvoid rgbToHSL(vec3 rgb, out vec3 outCol)\n{\nfloat cMax, cMin;\nfloat h, s, l;\ncMax = max(rgb[0], max(rgb[1], rgb[2]));\ncMin = min(rgb[0], min(rgb[1], rgb[2]));\nl = min(1.0, (cMax + cMin) / 2.0);\nif (cMax == cMin) {\nh = s = 0.0;\n} else {\nfloat cdelta = cMax - cMin;\ns = l > 0.5 ? cdelta / (2.0 - cMax - cMin) : cdelta / (cMax + cMin);\nif (cMax == rgb[0]) {\nh = (rgb[1] - rgb[2]) / cdelta + (rgb[1] < rgb[2] ? 6.0 : 0.0);\n} else if (cMax == rgb[1]) {\nh = (rgb[2] - rgb[0]) / cdelta + 2.0;\n} else {\nh = (rgb[0] - rgb[1]) / cdelta + 4.0;\n}\n}\nh /= 6.0;\noutCol = vec3(h, s, l);\n}\nvoid node_separate_color(int mode, vec4 color, out float r, out float g, out float b)\n{\nif (mode == NODE_SEP_COL_RGB) {\nr = color.r;\ng = color.g;\nb = color.b;\n} else if (mode == NODE_SEP_COL_HSV) {\nvec4 hsv;\nrgbToHSV(color, hsv);\nr = hsv[0];\ng = hsv[1];\nb = hsv[2];\n} else {\nvec3 hsl;\nrgbToHSL(color.rgb, hsl);\nr = hsl[0];\ng = hsl[1];\nb = hsl[2];\n}\n}";
var node_seprgb_bl_frag = "\nvoid node_seprgb(vec4 col, out float r, out float g, out float b)\n{\nr = col.r;\ng = col.g;\nb = col.b;\n}";
var node_sepxyz_bl_frag = "void node_sepxyz(vec3 vector, out float x, out float y, out float z)\n{\nx = vector.x;\ny = vector.y;\nz = vector.z;\n}";
var node_shadertorgb_bl_frag = "void node_shadertorgb(vec4 shader, out vec4 color, out float alpha) {\ncolor = vec4(shader.rgb, 1.0);\nalpha = shader.a;\n}";
var node_squeeze_bl_frag = "void node_squeeze(float val, float width, float center, out float outVal)\n{\noutVal = 1.0 / (1.0 + pow(2.71828183, -((val - center) * width)));\n}";
var node_subsurface_scattering_bl_frag = "void node_subsurface_scattering(\nvec4 color, float scale, vec3 radius, float sharpen, float textureBlur, vec3 normal,\nout vec4 outColor)\n{\noutColor = color;\n}";
var node_tangent_bl_frag = "#define TANGENT_AXIS_X 0\n#define TANGENT_AXIS_Y 1\n#define TANGENT_AXIS_Z 2\nvoid node_tangent(int axis, vec3 viewPos, vec3 viewNorm, out vec3 outTangent) {\noutTangent = vec3(0.0);\n#if WORLD_NODES == 0\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nvec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;\nvec3 posLocal = (invModelMatrix * posWorld).xyz;\nvec3 posOrco = (posLocal - boundingBoxMin)\n/ (boundingBoxMax - boundingBoxMin) - 0.5;\nvec4 posOrcoPermuted;\nif (axis == TANGENT_AXIS_X) {\nposOrcoPermuted = vec4(0.0, -posOrco.z, posOrco.y, 0.0);\n} else if (axis == TANGENT_AXIS_Y) {\nposOrcoPermuted = vec4(-posOrco.y, posOrco.x, 0.0, 0.0);\n} else if (axis == TANGENT_AXIS_Z) {\nposOrcoPermuted = vec4(posOrco.z, 0.0, -posOrco.x, 0.0);\n}\nvec3 tangWorld = (modelMatrix * posOrcoPermuted).xyz;\ntangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));\noutTangent = swizzleUpZ(tangWorld);\n#endif\n}\nvoid node_tangent(vec4 tangent, out vec3 outTangent) {\n#if WORLD_NODES == 0\noutTangent = normalize((modelMatrix * vec4(tangent.xyz, 0.0)).xyz);\noutTangent = swizzleUpZ(outTangent);\n#endif\n}";
var node_tex_brick_bl_frag = "float integer_noise(int rowCount, int brickCount)\n{\n#if __VERSION__ == 300\nint n = (rowCount << 16) + (brickCount & 0xFFFF);\nn = (n + 1013) & 0x7fffffff;\nn = (n >> 13) ^ n;\nint nn = (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;\nreturn 0.5 * (float(nn) / 1073741824.0);\n#else\nconst int RAND_MAX = 32767;\nint next = ((123456 * rowCount) + brickCount) * 1103515245 + 12345;\nreturn (mod(float(next/65536), float(RAND_MAX + 1))) / float(RAND_MAX);\n#endif\n}\nvoid node_tex_brick(\nfloat offset, int offsetFrequency, float squash, int squashFrequency, \nvec3 vector, vec4 color1, vec4 color2, vec4 mortar, float scale,\nfloat mortarSize, float mortarSmooth, float bias, float brickWidth,\nfloat rowHeight,\nout vec4 outColor, out float outFac)\n{\nfloat x, y;\nvec3 p = vector * scale;\nfloat rowCount = floor(p.y / rowHeight);\nif (offsetFrequency != 0 && squashFrequency != 0) {\nbrickWidth *= mod(rowCount, float(squashFrequency)) > 0.5 ? 1.0 : squash;\noffset = mod(rowCount, float(offsetFrequency)) > 0.5 ? 0.0 : (brickWidth * offset);\n} \nint brickCount = int((p.x + offset) / brickWidth); \nfloat tint = clamp((integer_noise(int(rowCount), brickCount) + bias), 0.0, 1.0);\n\nx = abs((p.x + offset) - brickWidth * float(brickCount));\ny = abs(p.y - rowHeight * rowCount);\nfloat min_dist = min(min(x, y), min(brickWidth - x, rowHeight - y));\n\nfloat f = step(min_dist, mortarSize);\nif (mortarSmooth > 0.0) {\nmin_dist = 1.0 - min_dist / mortarSize;\nf *= smoothstep(0.0, mortarSmooth, min_dist);\n}\noutColor = mix(mix(color1, color2, tint), mortar, f);\noutFac = f;\n}";
var node_tex_checker_bl_frag = "void node_tex_checker(vec3 vector, vec4 color1, vec4 color2, float scale, \nout vec4 outColor, out float outFac)\n{\nvec3 p = vector * scale;\np = (p + 0.00001) * 0.99999;\nfloat cx = floor(p.x);\nfloat cy = floor(p.y);\nfloat cz = floor(p.z);\nfloat result = sign(mod(cx + cy + cz, 2.0));\noutFac = max(result, 0.0);\noutColor = mix(color2, color1, outFac);\n}";
var node_tex_coord_bl_frag = "uniform mat4 nodeTexCoordObjectMatrices[NODE_TEX_COORD_NUM];\nvoid node_tex_coord(\nmat4 objectMat, vec3 viewPos, vec3 viewNorm, vec2 uv,\nout vec3 outGenerated, out vec3 outNormal, out vec3 outUV, out vec3 outObject,\nout vec3 outCamera, out vec3 outWindow, out vec3 outReflection)\n{\nvec4 view = vec4(-viewPos, 1.0);\nvec4 posWorld = invViewMatrix * view;\nvec3 loc = swizzleUpZ((invModelMatrix * posWorld).xyz);\n#if WORLD_NODES == 1\nloc = normalize(loc);\n#endif\n#if WORLD_NODES == 1\noutGenerated = loc;\n#else\nvec3 boxMin = vec3(boundingBoxMin.x, -boundingBoxMax.z, boundingBoxMin.y);\nvec3 boxMax = vec3(boundingBoxMax.x, -boundingBoxMin.z, boundingBoxMax.y);\nvec3 boxSize = boxMax - boxMin;\nif (abs(boxSize.x) < 0.001) {\noutGenerated.x = 0.5;\n} else {\noutGenerated.x = (loc.x - boxMin.x) / boxSize.x;\n}\nif (abs(boxSize.y) < 0.001) {\noutGenerated.y = 0.5;\n} else {\noutGenerated.y = (loc.y - boxMin.y) / boxSize.y;\n}\nif (abs(boxSize.z) < 0.001) {\noutGenerated.z = 0.5;\n} else {\noutGenerated.z = (loc.z - boxMin.z) / boxSize.z;\n}\n#endif\n#if WORLD_NODES == 1\noutNormal = -loc;\n#else\noutNormal = normalize(invModelMatrix * invViewMatrix * vec4(viewNorm, 0.0)).rgb;\noutNormal = swizzleUpZ(outNormal);\n#endif\n#if WORLD_NODES == 1\noutUV = vec3(0.0);\n#else\nuv.y = 1.0 - uv.y;\noutUV = vec3(uv, 0.0);\n#endif\n#if WORLD_NODES == 1\noutObject = loc;\n#else\noutObject = swizzleUpZ((objectMat * posWorld).xyz);\n#endif\noutCamera = vec3(view.xy, -view.z);\n#if WORLD_NODES == 1\noutWindow = vec3(0.0);\n#else\noutWindow = vec3(gl_FragCoord.xy / viewWidthHeight, 0.0);\n#endif\n#if WORLD_NODES == 1\noutReflection = -loc;\n#else\nvec4 reflection = (invViewMatrix * vec4(reflect(view.xyz, normalize(viewNorm)), 0.0));\noutReflection = normalize(swizzleUpZ(reflection.xyz));\n#endif\n}";
var node_tex_environment_bl_frag = "#define TEX_PROJ_EQUIRECTANGULAR 0\n#define TEX_PROJ_MIRROR_BALL 1\nvoid node_tex_environment(sampler2D tex, const int encoding, const int projection, vec3 vector, out vec4 outColor) {\nvec2 uv;\nfloat bias;\nif (projection == TEX_PROJ_EQUIRECTANGULAR) {\nvec3 direction = swizzleUpY(vector);\nif (length(direction) == 0.0) {\ndirection = vec3(0.0, 1.0, 0.0);\n} else {\ndirection = normalize(direction);\n}\nuv = equirectUv(direction);\n#if WORLD_NODES == 1\nbias = -16.0;\n#else\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (direction.z) / seamWidth) *\nclamp (1.0 - direction.x / seamWidth, 0.0, 1.0);\nbias = seamBiasFactor * seam;\n#endif\n} else {\nvec3 normal = normalize(vector);\nnormal.y -= 1.0;\nnormal /= (2.0 * sqrt(max(-0.5 * normal.y, 0.0)));\nuv = clamp(0.5 * normal.xz + 0.5, 0.0, 1.0);\nbias = 0.0;\n}\nuv.y = 1.0 - uv.y;\noutColor = texture2D(tex, uv, bias);\noutColor = nodeTexelToLinear(outColor, encoding);\n}";
var node_tex_environment_none_bl_frag = "void node_tex_environment_none(vec3 vector, out vec4 outColor) {\noutColor = vec4(1.0, 0.0, 1.0, 1.0);\n}";
var node_tex_gabor_bl_frag = "#define TEX_GABOR_2D 0\n#define TEX_GABOR_3D 1\n#define IMPULSES_COUNT 8\n#if __VERSION__ == 300\nvec2 compute2DGaborKernel(vec2 position, float frequency, float orientation) {\nfloat distanceSq = dot(position, position);\nfloat hannWindow = 0.5 + 0.5 * cos(PI * distanceSq);\nfloat gaussianEnvelop = exp(-PI * distanceSq);\nfloat windowedGaussianEnvelope = gaussianEnvelop * hannWindow;\nvec2 frequencyVector = frequency * vec2(cos(orientation), sin(orientation));\nfloat angle = 2.0 * PI * dot(position, frequencyVector);\nvec2 phasor = vec2(cos(angle), sin(angle));\nreturn windowedGaussianEnvelope * phasor;\n}\nfloat compute2DGaborStandardDeviation() {\nfloat integralOfGaborSq = 0.25;\nfloat secondMoment = 0.5;\nreturn sqrt(float(IMPULSES_COUNT) * secondMoment * integralOfGaborSq);\n}\nvec2 compute2DGaborNoiseCell(vec2 cell, vec2 position, float frequency, float isotropy, float baseOrientation) {\nvec2 noise = vec2(0.0);\nfor (int i = 0; i < IMPULSES_COUNT; ++i) {\nvec3 seedForOrientation = vec3(cell, i * 3);\nvec3 seedForKernelCenter = vec3(cell, i * 3 + 1);\nvec3 seedForWeight = vec3(cell, i * 3 + 2);\nfloat random_orientation = (hashVec3ToFloat(seedForOrientation) - 0.5) * PI;\nfloat orientation = baseOrientation + random_orientation * isotropy;\nvec2 kernelCenter = hashVec3ToVec2(seedForKernelCenter);\nvec2 positionInKernelSpace = position - kernelCenter;\nif (dot(positionInKernelSpace, positionInKernelSpace) >= 1.0)\ncontinue;\nfloat weight = hashVec3ToFloat(seedForWeight) < 0.5 ? -1.0 : 1.0;\nnoise += weight * compute2DGaborKernel(positionInKernelSpace, frequency, orientation);\n}\nreturn noise;\n}\nvec2 compute2DGaborNoise(vec2 coordinates, float frequency, float isotropy, float baseOrientation) {\nvec2 cellPosition = floor(coordinates);\nvec2 localPosition = coordinates - cellPosition;\nvec2 sum = vec2(0.0);\nfor (int j = -1; j <= 1; j++) {\nfor (int i = -1; i <= 1; i++) {\nvec2 cellOffset = vec2(i, j);\nvec2 currCellPosition = cellPosition + cellOffset;\nvec2 positionInCellSpace = localPosition - cellOffset;\nsum += compute2DGaborNoiseCell(\ncurrCellPosition, positionInCellSpace, frequency, isotropy, baseOrientation);\n}\n}\nreturn sum;\n}\nvec2 compute3DGaborKernel(vec3 position, float frequency, vec3 orientation) {\nfloat distanceSq = dot(position, position);\nfloat hannWindow = 0.5 + 0.5 * cos(PI * distanceSq);\nfloat gaussianEnvelop = exp(-PI * distanceSq);\nfloat windowedGaussianEnvelope = gaussianEnvelop * hannWindow;\nvec3 frequencyVector = frequency * orientation;\nfloat angle = 2.0 * PI * dot(position, frequencyVector);\nvec2 phasor = vec2(cos(angle), sin(angle));\nreturn windowedGaussianEnvelope * phasor;\n}\nfloat compute3DGaborStandardDeviation() {\nfloat integralOfGaborSq = 1.0 / (4.0 * sqrt(2.0));\nfloat secondMoment = 0.5;\nreturn sqrt(float(IMPULSES_COUNT) * secondMoment * integralOfGaborSq);\n}\nvec3 compute3DOrientation(vec3 orientation, float isotropy, vec4 seed) {\nif (isotropy == 0.0)\nreturn orientation;\nfloat inclination = acos(orientation.z);\nfloat azimuth = sign(orientation.y) * acos(orientation.x / length(orientation.xy));\nvec2 randomAngles = hashVec4ToVec2(seed) * PI;\ninclination += randomAngles.x * isotropy;\nazimuth += randomAngles.y * isotropy;\nreturn vec3(sin(inclination) * cos(azimuth), sin(inclination) * sin(azimuth), cos(inclination));\n}\nvec2 compute3DGaborNoiseCell(vec3 cell, vec3 position, float frequency, float isotropy, vec3 baseOrientation) {\nvec2 noise = vec2(0.0);\nfor (int i = 0; i < IMPULSES_COUNT; ++i) {\nvec4 seedForOrientation = vec4(cell, i * 3);\nvec4 seedForKernelCenter = vec4(cell, i * 3 + 1);\nvec4 seedForWeight = vec4(cell, i * 3 + 2);\nvec3 orientation = compute3DOrientation(baseOrientation, isotropy, seedForOrientation);\nvec3 kernelCenter = hashVec4ToVec3(seedForKernelCenter);\nvec3 positionInKernelSpace = position - kernelCenter;\nif (dot(positionInKernelSpace, positionInKernelSpace) >= 1.0)\ncontinue;\nfloat weight = hashVec4ToFloat(seedForWeight) < 0.5 ? -1.0 : 1.0;\nnoise += weight * compute3DGaborKernel(positionInKernelSpace, frequency, orientation);\n}\nreturn noise;\n}\nvec2 compute3DGaborNoise(vec3 coordinates, float frequency, float isotropy, vec3 baseOrientation) {\nvec3 cellPosition = floor(coordinates);\nvec3 localPosition = coordinates - cellPosition;\nvec2 sum = vec2(0.0);\nfor (int k = -1; k <= 1; k++) {\nfor (int j = -1; j <= 1; j++) {\nfor (int i = -1; i <= 1; i++) {\nvec3 cellOffset = vec3(i, j, k);\nvec3 currCellPosition = cellPosition + cellOffset;\nvec3 positionInCellSpace = localPosition - cellOffset;\nsum += compute3DGaborNoiseCell(currCellPosition, positionInCellSpace, frequency, isotropy, baseOrientation);\n}\n}\n}\nreturn sum;\n}\nvoid node_tex_gabor(\nint gaborType,\nvec3 vector, float scale, float frequency, float anisotropy, float orientation2D, vec3 orientation3D,\nout float outValue, out float outPhase, out float outIntensity) {\nvec3 scaledVector = vector * scale;\nfloat isotropy = 1.0 - clamp(anisotropy, 0.0, 1.0);\nfrequency = max(0.001, frequency);\nvec2 phasor = vec2(0.0);\nfloat standard_deviation = 1.0;\nif (gaborType == TEX_GABOR_2D) {\nphasor = compute2DGaborNoise(scaledVector.xy, frequency, isotropy, orientation2D);\nstandard_deviation = compute2DGaborStandardDeviation();\n} else {\nvec3 orientation = normalize(orientation3D);\nphasor = compute3DGaborNoise(scaledVector, frequency, isotropy, orientation);\nstandard_deviation = compute3DGaborStandardDeviation();\n}\nfloat normalizationFactor = 6.0 * standard_deviation;\noutValue = (phasor.y / normalizationFactor) * 0.5 + 0.5;\noutPhase = (atan(phasor.y, phasor.x) + PI) / (2.0 * PI);\noutIntensity = length(phasor) / normalizationFactor;\n}\n#else\nvoid node_tex_gabor(\nint gaborType,\nvec3 vector, float scale, float frequency, float anisotropy, float orientation2D, vec3 orientation3D,\nout float outValue, out float outPhase, out float outIntensity) {\noutValue = 0.0;\noutPhase = 0.0;\noutIntensity = 0.0;\n}\n#endif";
var node_tex_gradient_bl_frag = "#define TEX_GRAD_LINEAR 0\n#define TEX_GRAD_QUADRATIC 1\n#define TEX_GRAD_EASING 2\n#define TEX_GRAD_DIAGONAL 3\n#define TEX_GRAD_SPHERICAL 4\n#define TEX_GRAD_QUADRATIC_SPHERE 5\n#define TEX_GRAD_RADIAL 6\nvoid node_tex_gradient(const int type, vec3 vector, out vec4 outColor, out float outFac)\n{\nfloat x, y, z, r;\nx = vector.x;\ny = vector.y;\nz = vector.z;\nif (type == TEX_GRAD_LINEAR) {\noutFac = x;\n} else if (type == TEX_GRAD_QUADRATIC) {\nr = max(x, 0.0);\noutFac = pow2(r);\n} else if (type == TEX_GRAD_EASING) {\nr = min(max(x, 0.0), 1.0);\noutFac = (3.0 * pow2(r) - 2.0 * pow3(r));\n} else if (type == TEX_GRAD_DIAGONAL) {\noutFac = (x + y) * 0.5;\n} else if (type == TEX_GRAD_RADIAL) {\noutFac = atan(y, x) / PI2 + 0.5;\n} else {\nr = max(0.99999 - sqrt(x * x + y * y + z * z), 0.0);\nif (type == TEX_GRAD_QUADRATIC_SPHERE) {\noutFac = pow2(r);\n} else if (type == TEX_GRAD_SPHERICAL) {\noutFac = r;\n}\n}\noutFac = clamp(outFac, 0.0, 1.0);\noutColor = vec4(outFac, outFac, outFac, 1.0);\n}";
var node_tex_ies_bl_frag = "void node_tex_ies(vec3 vector, float strength, out float fac) {\nfac = 0.0;\n}";
var node_tex_image_bl_frag = "#define TEX_PROJ_FLAT 0\n#define TEX_PROJ_BOX 1\n#define TEX_PROJ_SPHERE 2\n#define TEX_PROJ_TUBE 3\n#define TEX_ALPHA_CLEAR 0\n#define TEX_ALPHA_PREMUL 1\n#define TEX_ALPHA_UNPREMUL 2\n#define TEX_ALPHA_ONE 3\nvec4 applyAlphaMode(vec4 color, const int alphaMode) {\nif (alphaMode == TEX_ALPHA_CLEAR) {\n} else if (alphaMode == TEX_ALPHA_PREMUL) {\ncolor.rgb = color.rgb * color.a;\n} else if (alphaMode == TEX_ALPHA_UNPREMUL) {\nfloat alpha = color.a;\ncolor.rgb = clamp(color.rgb, 0.0, alpha);\nif (alpha == 0.0)\ncolor.rgb = vec3(0.0);\nelse\ncolor.rgb /= alpha;\n}\nreturn color;\n}\nvoid node_tex_image(sampler2D ima, const int encoding, const int alphaMode, vec3 viewNorm,\nconst int projection, const float projectionBlend, const bool clampToEdgeNoExtend,\nvec3 vector,\nout vec4 outColor, out float outAlpha) {\nif (projection == TEX_PROJ_FLAT) {\nvec2 uv = vector.xy;\nuv.y = 1.0 - uv.y;\nif (clampToEdgeNoExtend && (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)) {\noutColor = vec4(0.0);\noutAlpha = 0.0;\n} else {\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\n}\noutColor = nodeTexelToLinear(outColor, encoding);\n} else if (projection == TEX_PROJ_BOX) {\nvec3 norm = normalize(viewNorm * normalMatrix);\nvector = swizzleUpY(vector);\nvec2 uvX = vec2(-sign(norm.x) * vector.z, -vector.y);\nvec2 uvY = vec2(sign(norm.y) * vector.z, -vector.x);\nvec2 uvZ = vec2(sign(norm.z) * vector.x, -vector.y);\nvec4 colX = nodeTexelToLinear(texture2D(ima, uvX), encoding);\nvec4 colY = nodeTexelToLinear(texture2D(ima, uvY), encoding);\nvec4 colZ = nodeTexelToLinear(texture2D(ima, uvZ), encoding);\nvec3 barycentric = abs(norm);\nbarycentric /= barycentric.x + barycentric.y + barycentric.z;\nvec3 edgeShape = min(min(barycentric.yzx, barycentric.zxy),\n(projectionBlend - 1.0) / (projectionBlend - 3.0));\nvec3 edgeValue = (1.0 - projectionBlend) * (1.0 - edgeShape) / 2.0;\nvec3 weight = max((barycentric - edgeValue) / (1.0 - edgeValue), EPSILON);\nweight /= (weight.x + weight.y + weight.z);\noutColor = weight.x * colX + weight.y * colY + weight.z * colZ;\noutAlpha = outColor.a;\n} else if (projection == TEX_PROJ_SPHERE) {\nvector = normalize(vector * 2.0 - 1.0);\nvector = swizzleUpY(vector);\nvec2 uv = vec2(atan(vector.x, vector.z) / PI2, acos(vector.y) / PI);\nuv.x = mod(uv.x, 1.0);\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\noutColor = nodeTexelToLinear(outColor, encoding);\n} else if (projection == TEX_PROJ_TUBE) {\nvector = vector * 2.0 - 1.0;\nvector = swizzleUpY(vector);\nvec2 uv = vec2(atan(vector.x, vector.z) / PI2, (1.0 - vector.y) / 2.0);\nuv.x = mod(uv.x, 1.0);\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\noutColor = nodeTexelToLinear(outColor, encoding);\n}\noutColor = applyAlphaMode(outColor, alphaMode);\nif (alphaMode == TEX_ALPHA_ONE)\noutAlpha = 1.0;\n}";
var node_tex_image_none_bl_frag = "void node_tex_image_none(vec3 vector, out vec4 color, out float alpha)\n{\ncolor = vec4(1.0, 0.0, 1.0, 1.0);\nalpha = 1.0;\n}";
var node_tex_magic_bl_frag = "void node_tex_magic(vec3 vector, float scale, float distortion,\nout vec4 outColor, out float outFac)\n{\noutColor = vec4(0.0);\noutFac = 0.0;\n}";
var node_tex_musgrave_bl_frag = "\nvoid node_tex_musgrave(vec3 vector, float w, float scale, float detail,\nfloat dimension, float lacunarity, float offset, float gain,\nout float outFac) {\noutFac = 0.0;\n}";
var node_tex_noise_bl_frag = "#define TEX_NOISE_MULTIFRACTAL 0\n#define TEX_NOISE_RIDGED_MULTIFRACTAL 1\n#define TEX_NOISE_HYBRID_MULTIFRACTAL 2\n#define TEX_NOISE_FBM 3\n#define TEX_NOISE_HETERO_TERRAIN 4\nvoid node_tex_noise(\nint noiseType, float falloffFactor, float dispersionFactor,\nvec3 vector, float w, float scale, float detail, float roughness,\nfloat lacunarity, float offset, float gain, float distortion, out float outFac, out vec4 outColor) {\nvec3 p = vector * scale;\nvec3 dx = dFdx(p);\nvec3 dy = dFdy(p);\nfloat octaveLenPerPixel = (length(dx) + length(dy)) / 4.0;\nif (distortion != 0.0) {\nvec3 r, offset = vec3(13.5, 13.5, 13.5);\nr.x = noiseSmooth(p + offset, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\nr.y = noiseSmooth(p, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\nr.z = noiseSmooth(p - offset, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\np += r;\n}\noutFac = noiseTurbulence(p, detail, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nvec3 color = vec3(outFac,\nnoiseTurbulence(vec3(p.y, p.x, p.z), detail, octaveLenPerPixel,\nfalloffFactor, dispersionFactor),\nnoiseTurbulence(vec3(p.y, p.z, p.x), detail, octaveLenPerPixel,\nfalloffFactor, dispersionFactor)\n);\noutColor = vec4(color, 1.0);\n}\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float w, float scale, float detail, float roughness,\nfloat lacunarity, float distortion, out float outFac, out vec4 outColor) {\nnode_tex_noise(TEX_NOISE_FBM, falloffFactor, dispersionFactor, vector, w, scale, detail, roughness,\nlacunarity, 0.0, 1.0, distortion, outFac, outColor);\n}\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float w, float scale, float detail, float roughness,\nfloat distortion, out float outFac, out vec4 outColor) {\nnode_tex_noise(falloffFactor, dispersionFactor, vector, w, scale, detail, roughness,\n2.0, distortion, outFac, outColor);\n}";
var node_tex_pointdensity_bl_frag = "void node_tex_pointdensity(\nvec3 vector,\nout vec4 outColor, out float outDensity)\n{\noutColor = vec4(0.0);\noutDensity = 0.0;\n}";
var node_tex_sky_bl_frag = "\n#define TEX_SKY_PREETHAM 0\n#define TEX_SKY_HOSEK_WILKIE 1\n#define TEX_SKY_NISHITA 2\n#define Km 683.0\nvoid node_tex_sky(const int skyType, vec3 param0, vec3 param1, vec3 param2,\nvec3 param3, vec3 param4, vec3 param5, vec3 param6, vec3 param7,\nvec3 param8, vec3 radiance, vec3 sunDirection, vec3 vectorIn,\nout vec4 outColor) {\nif (length(vectorIn) == 0.0) {\nvectorIn = vec3(0.0, 1.0, 0.0);\n} else {\nvectorIn = normalize(vectorIn);\n}\nvectorIn = swizzleUpY(vectorIn);\nsunDirection = swizzleUpY(sunDirection);\nfloat cosGamma = clamp(dot(vectorIn, sunDirection), -1.0, 1.0);\nfloat cosTheta = clamp(vectorIn.y, 0.0, 1.0);\nif (skyType == TEX_SKY_PREETHAM) {\nvec3 radInternal = (1.0 + param0 * exp(param1 / cosTheta)) * (\n1.0 + param2 * exp(param3 * acos(cosGamma))\n+ param4 * pow(cosGamma, 2.0)\n);\nvec3 XYZ = xyY_to_XYZ(radInternal.y * radiance.y,\nradInternal.z * radiance.z, radInternal.x * radiance.x);\noutColor = vec4(max(xyz_to_sRGB(XYZ), 0.0), 1.0);\n} else if (skyType == TEX_SKY_HOSEK_WILKIE) {\nfloat cosGammaSq = pow(cosGamma, 2.0);\nvec3 chi = (1.0 + cosGammaSq) / pow(1.0 + pow(param8, vec3(2.0))\n- 2.0 * param8 * cosGamma, vec3(1.5));\nvec3 radInternal = (1.0 + param0 * exp(param1 / (cosTheta + 0.01))) * (\nparam2 + param3 * exp(param4 * acos(cosGamma))\n+ param5 * cosGammaSq + param6 * chi + param7 * sqrt(cosTheta)\n);\noutColor = vec4(max(xyz_to_sRGB(radInternal * radiance), 0.0) * PI2/Km, 1.0);\n} else {\noutColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}";
var node_tex_voronoi_bl_frag = "#define DISTANCE_EUCLIDEAN 0\n#define DISTANCE_MANHATTAN 1\n#define DISTANCE_CHEBYCHEV 2\n#define DISTANCE_MINKOWSKI 3\n#define FEATURE_F1 0\n#define FEATURE_F2 1\n#define FEATURE_SMOOTH_F1 2\n#define FEATURE_DISTANCE_TO_EDGE 3\n#define FEATURE_N_SPHERE_RADIUS 4\nstruct VoronoiGridData {\nvec3 point;\nvec3 randVec;\nvec3 toClosest;\nfloat dist;\n};\nhighp vec3 rand3(const in vec3 v) {\nconst highp float c = 43758.5453;\nconst highp mat3 coeffs = mat3(\n165.15, 253.34, 323.22,\n241.49, 329.07, 147.79,\n376.31, 143.45, 281.63\n);\nhighp vec3 sn = mod(coeffs * v, PI);\nreturn fract(sin(sn) * c);\n}\nfloat worleyLength(vec3 vec, int distance, float exponent) {\nif (distance == DISTANCE_EUCLIDEAN) {\nreturn length(vec);\n} else if (distance == DISTANCE_MANHATTAN) {\nreturn abs(vec.x) + abs(vec.y) + abs(vec.z);\n} else if (distance == DISTANCE_CHEBYCHEV) {\nreturn max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n} else if (distance == DISTANCE_MINKOWSKI) {\nreturn pow(pow(abs(vec.x), exponent)\n+ pow(abs(vec.y), exponent)\n+ pow(abs(vec.z), exponent), 1.0 / exponent);\n}\nreturn 0.0;\n}\nvoid worleyNoise(vec3 pos, int distance, float exponent, int feature,\nfloat smoothness, float randomness, out float outDist, out vec4 outColor,\nout vec3 outPosition, out float outW, out float outRadius) {\nconst highp float RAND_FIX_ZERO = 0.125;\nvec3 posI = floor(pos);\nvec3 posF = fract(pos);\nVoronoiGridData vgd[27];\n#pragma unroll_loop\nfor (int i = 0; i <= 2; i++) {\n#pragma unroll_loop\nfor (int j = 0; j <= 2; j++) {\n#pragma unroll_loop\nfor (int k = 0; k <= 2; k++) {\nvec3 point = vec3((i), (j), (k)) - 1.0;\nvec3 randVec = rand3(posI + point + RAND_FIX_ZERO);\nvec3 toClosest = point + randomness * randVec - posF;\nconst int counter = (i) + (j) * 3 + (k) * 9;\nvgd[counter].point = point;\nvgd[counter].randVec = randVec;\nvgd[counter].toClosest = toClosest;\nvgd[counter].dist = worleyLength(toClosest, distance, exponent);\n}\n}\n}\nfloat f1 = 1e10;\nfloat f2 = 1e10;\nvec3 edgeToClosest = vec3(0.0);\nfloat distToEdge = 1e10;\nvec3 randColF1 = vec3(0.0);\nvec3 randColF2 = vec3(0.0);\nvec3 toClosestF1 = vec3(0.0);\nvec3 toClosestF2 = vec3(0.0);\nvec3 radPoint = vec3(0.0);\nvec3 radToClosest = vec3(0.0);\n#pragma unroll_loop\nfor (int i = 0; i < 27; i++) {\nif (feature == FEATURE_F1) {\nif (vgd[i].dist < f1) {\nf1 = vgd[i].dist;\nrandColF1 = vgd[i].randVec;\ntoClosestF1 = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_F2) {\nif (vgd[i].dist < f1) {\nf2 = f1;\nf1 = vgd[i].dist;\nrandColF2 = randColF1;\nrandColF1 = vgd[i].randVec;\ntoClosestF2 = toClosestF1;\ntoClosestF1 = vgd[i].toClosest;\n} else if (vgd[i].dist < f2) {\nf2 = vgd[i].dist;\nrandColF2 = vgd[i].randVec;\ntoClosestF2 = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_SMOOTH_F1) {\nf1 = smoothMin(f1, vgd[i].dist, smoothness);\n} else if (feature == FEATURE_DISTANCE_TO_EDGE) {\nfloat dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);\nif (dist < f1) {\nf1 = dist;\nedgeToClosest = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_N_SPHERE_RADIUS) {\nfloat dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);\nif (dist < f1) {\nf1 = dist;\nradPoint = vgd[i].point;\nradToClosest = vgd[i].toClosest;\n}\n}\n}\nif (feature == FEATURE_F1) {\noutDist = f1;\noutColor = vec4(randColF1, 1.0);\noutPosition = pos + toClosestF1;\n} else if (feature == FEATURE_F2) {\noutDist = f2;\noutColor = vec4(randColF2, 1.0);\noutPosition = pos + toClosestF2;\n} else if (feature == FEATURE_SMOOTH_F1) {\noutDist = f1;\nvec3 avgCol = vec3(0.0);\nvec3 avgOff = vec3(0.0);\nfloat sumWeightsCol = 0.0;\nfloat sumWeightsOff = 0.0;\n#pragma unroll_loop\nfor (int i = 0; i < 27; i++) {\nfloat smoothFac = getSmoothFactor(f1, vgd[i].dist, smoothness);\nfloat weightOff = smoothFac * smoothFac * smoothFac;\nfloat weightCol = weightOff * smoothFac;\navgCol += vgd[i].randVec * weightCol;\navgOff += vgd[i].toClosest * weightOff;\nsumWeightsCol += weightCol;\nsumWeightsOff += weightOff;\n}\noutColor = vec4(avgCol / sumWeightsCol, 1.0);\noutPosition = pos + avgOff / sumWeightsOff;\n} else if (feature == FEATURE_DISTANCE_TO_EDGE) {\n#pragma unroll_loop\nfor (int i = 0; i < 27; i++) {\nif (vgd[i].toClosest != edgeToClosest) {\nfloat dist = dot(0.5 * (edgeToClosest + vgd[i].toClosest),\nnormalize(vgd[i].toClosest - edgeToClosest));\ndistToEdge = min(distToEdge, dist);\n}\n}\noutDist = distToEdge;\n} else if (feature == FEATURE_N_SPHERE_RADIUS) {\nfloat diam = 1e10;\n#pragma unroll_loop\nfor (int i = 0; i <= 2; i++) {\n#pragma unroll_loop\nfor (int j = 0; j <= 2; j++) {\n#pragma unroll_loop\nfor (int k = 0; k <= 2; k++) {\nvec3 localPoint = vec3((i), (j), (k)) - 1.0;\nif (length(localPoint) > 0.0) {\nvec3 point = localPoint + radPoint;\nvec3 randVec = rand3(posI + point + RAND_FIX_ZERO);\nvec3 toClosest = point + randomness * randVec - posF;\ndiam = min(diam, length(toClosest - radToClosest));\n}\n}\n}\n}\noutRadius = diam / 2.0;\n}\n}\n#define VORONOI_SMOOTH_COEFF 0.74\nvoid node_tex_voronoi(\nint distance, int feature,\nvec3 vector, float w, float scale, float detail, float roughness, float lacunarity,\nfloat smoothness, float exponent, float randomness,\nout float outDistance, out vec4 outColor, out vec3 outPosition,\nout float outW, out float outRadius) {\nvector = scale * (vector - 0.0001);\nsmoothness = clamp(smoothness, 1e-3, 1.0);\nsmoothness *= VORONOI_SMOOTH_COEFF;\nworleyNoise(vector, distance, exponent, feature, smoothness, randomness,\noutDistance, outColor, outPosition, outW, outRadius);\noutPosition /= scale;\n}\nvoid node_tex_voronoi(\nint distance, int feature,\nvec3 vector, float w, float scale,\nfloat smoothness, float exponent, float randomness,\nout float outDistance, out vec4 outColor, out vec3 outPosition,\nout float outW, out float outRadius) {\nnode_tex_voronoi(\ndistance, feature, vector, w, scale, 0.0, 0.5, 2.0, smoothness, exponent, randomness,\noutDistance, outColor, outPosition, outW, outRadius);\n}\n#define FEATURE_F3 5\n#define FEATURE_F4 6\n#define FEATURE_F2F1 7\n#define COLORING_INTENSITY 0\n#define COLORING_CELLS 1\nstruct VoronoiClosest {\nvec4 closestDists;\nvec4 closestInds;\n};\nvoid updateVoronoiClosest(inout VoronoiClosest vf, vec3 newDistances,\nvec3 newIndices) {\n#pragma unroll_loop\nfor (int i = 0; i < 3; i++) {\nfloat currDist = newDistances[i];\nfloat currIdx = newIndices[i];\n#pragma unroll_loop\nfor (int j = 0; j < 4; j++) {\nif (currDist < vf.closestDists[j]) {\nfloat tmp = vf.closestDists[j];\nvf.closestDists[j] = currDist;\ncurrDist = tmp;\ntmp = vf.closestInds[j];\nvf.closestInds[j] = currIdx;\ncurrIdx = tmp;\n}\n}\n}\n}\nvec3 worleyPermute(vec3 x) {\nreturn mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 worleyDist(vec3 x, vec3 y, vec3 z, int distance, float exponent) {\nif (distance == DISTANCE_EUCLIDEAN) {\nreturn x * x + y * y + z * z;\n} else if (distance == DISTANCE_MANHATTAN) {\nreturn abs(x) + abs(y) + abs(z);\n} else if (distance == DISTANCE_CHEBYCHEV) {\nreturn max(max(abs(x), abs(y)), abs(z));\n} else if (distance == DISTANCE_MINKOWSKI) {\nvec3 expVec = vec3(exponent);\nreturn pow(pow(abs(x), expVec)\n+ pow(abs(y), expVec)\n+ pow(abs(z), expVec), 1.0 / expVec);\n}\nreturn vec3(0.0);\n}\nVoronoiClosest worleyClosest(vec3 P, float jitter, int distance, float exponent) {\nfloat K = 0.142857142857;\nfloat Ko = 0.428571428571;\nfloat K2 = 0.020408163265306;\nfloat Kz = 0.166666666667;\nfloat Kzo = 0.416666666667;\nvec3 Pi = mod(floor(P), 289.0);\nvec3 Pf = fract(P) - 0.5;\nvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\nvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\nvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\nvec3 p = worleyPermute(Pi.x + vec3(-1.0, 0.0, 1.0));\nvec3 p1 = worleyPermute(p + Pi.y - 1.0);\nvec3 p2 = worleyPermute(p + Pi.y);\nvec3 p3 = worleyPermute(p + Pi.y + 1.0);\nvec3 p11 = worleyPermute(p1 + Pi.z - 1.0);\nvec3 p12 = worleyPermute(p1 + Pi.z);\nvec3 p13 = worleyPermute(p1 + Pi.z + 1.0);\nvec3 p21 = worleyPermute(p2 + Pi.z - 1.0);\nvec3 p22 = worleyPermute(p2 + Pi.z);\nvec3 p23 = worleyPermute(p2 + Pi.z + 1.0);\nvec3 p31 = worleyPermute(p3 + Pi.z - 1.0);\nvec3 p32 = worleyPermute(p3 + Pi.z);\nvec3 p33 = worleyPermute(p3 + Pi.z + 1.0);\nvec3 ox11 = fract(p11*K) - Ko;\nvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\nvec3 oz11 = floor(p11*K2)*Kz - Kzo;\nvec3 ox12 = fract(p12*K) - Ko;\nvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\nvec3 oz12 = floor(p12*K2)*Kz - Kzo;\nvec3 ox13 = fract(p13*K) - Ko;\nvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\nvec3 oz13 = floor(p13*K2)*Kz - Kzo;\nvec3 ox21 = fract(p21*K) - Ko;\nvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\nvec3 oz21 = floor(p21*K2)*Kz - Kzo;\nvec3 ox22 = fract(p22*K) - Ko;\nvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\nvec3 oz22 = floor(p22*K2)*Kz - Kzo;\nvec3 ox23 = fract(p23*K) - Ko;\nvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\nvec3 oz23 = floor(p23*K2)*Kz - Kzo;\nvec3 ox31 = fract(p31*K) - Ko;\nvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\nvec3 oz31 = floor(p31*K2)*Kz - Kzo;\nvec3 ox32 = fract(p32*K) - Ko;\nvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\nvec3 oz32 = floor(p32*K2)*Kz - Kzo;\nvec3 ox33 = fract(p33*K) - Ko;\nvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\nvec3 oz33 = floor(p33*K2)*Kz - Kzo;\nvec3 dx11 = Pfx + jitter*ox11;\nvec3 dy11 = Pfy.x + jitter*oy11;\nvec3 dz11 = Pfz.x + jitter*oz11;\nvec3 dx12 = Pfx + jitter*ox12;\nvec3 dy12 = Pfy.x + jitter*oy12;\nvec3 dz12 = Pfz.y + jitter*oz12;\nvec3 dx13 = Pfx + jitter*ox13;\nvec3 dy13 = Pfy.x + jitter*oy13;\nvec3 dz13 = Pfz.z + jitter*oz13;\nvec3 dx21 = Pfx + jitter*ox21;\nvec3 dy21 = Pfy.y + jitter*oy21;\nvec3 dz21 = Pfz.x + jitter*oz21;\nvec3 dx22 = Pfx + jitter*ox22;\nvec3 dy22 = Pfy.y + jitter*oy22;\nvec3 dz22 = Pfz.y + jitter*oz22;\nvec3 dx23 = Pfx + jitter*ox23;\nvec3 dy23 = Pfy.y + jitter*oy23;\nvec3 dz23 = Pfz.z + jitter*oz23;\nvec3 dx31 = Pfx + jitter*ox31;\nvec3 dy31 = Pfy.z + jitter*oy31;\nvec3 dz31 = Pfz.x + jitter*oz31;\nvec3 dx32 = Pfx + jitter*ox32;\nvec3 dy32 = Pfy.z + jitter*oy32;\nvec3 dz32 = Pfz.y + jitter*oz32;\nvec3 dx33 = Pfx + jitter*ox33;\nvec3 dy33 = Pfy.z + jitter*oy33;\nvec3 dz33 = Pfz.z + jitter*oz33;\nvec3 d11 = worleyDist(dx11, dy11, dz11, distance, exponent);\nvec3 d12 = worleyDist(dx12, dy12, dz12, distance, exponent);\nvec3 d13 = worleyDist(dx13, dy13, dz13, distance, exponent);\nvec3 d21 = worleyDist(dx21, dy21, dz21, distance, exponent);\nvec3 d22 = worleyDist(dx22, dy22, dz22, distance, exponent);\nvec3 d23 = worleyDist(dx23, dy23, dz23, distance, exponent);\nvec3 d31 = worleyDist(dx31, dy31, dz31, distance, exponent);\nvec3 d32 = worleyDist(dx32, dy32, dz32, distance, exponent);\nvec3 d33 = worleyDist(dx33, dy33, dz33, distance, exponent);\nVoronoiClosest vf = VoronoiClosest(vec4(1e10), vec4(0.0));\nupdateVoronoiClosest(vf, d11, p11);\nupdateVoronoiClosest(vf, d12, p12);\nupdateVoronoiClosest(vf, d13, p13);\nupdateVoronoiClosest(vf, d21, p21);\nupdateVoronoiClosest(vf, d22, p22);\nupdateVoronoiClosest(vf, d23, p23);\nupdateVoronoiClosest(vf, d31, p31);\nupdateVoronoiClosest(vf, d32, p32);\nupdateVoronoiClosest(vf, d33, p33);\nreturn vf;\n}\nvoid node_tex_voronoi(int coloring, int distance, int feature, vec3 vector,\nfloat scale, float exponent, out vec4 outColor, out float outFac) {\nvector = scale * (vector - 0.0001);\nVoronoiClosest vf = worleyClosest(vector, 1.0, distance, exponent);\nvec4 vorColorData;\nif (coloring == COLORING_INTENSITY) {\nvorColorData = vf.closestDists;\n} else if (coloring == COLORING_CELLS) {\nvorColorData = vf.closestInds;\n}\nfloat vorColorFac;\nif (feature == FEATURE_F1) {\nvorColorFac = vorColorData.x;\n} else if (feature == FEATURE_F2) {\nvorColorFac = vorColorData.y;\n} else if (feature == FEATURE_F3) {\nvorColorFac = vorColorData.z;\n} else if (feature == FEATURE_F4) {\nvorColorFac = vorColorData.w;\n} else if (feature == FEATURE_F2F1) {\nvorColorFac = vorColorData.y - vorColorData.x;\n}\nif (coloring == COLORING_INTENSITY) {\noutFac = vorColorFac;\noutColor = vec4(vec3(outFac), 1.0);\n} else if (coloring == COLORING_CELLS) {\nvorColorFac += 1e-3;\nfloat r = rand(vec2(vorColorFac / 289.0));\nfloat g = rand(vec2(vorColorFac / 23535.0));\nfloat b = rand(vec2(vorColorFac / 4353.0));\noutFac = (r + g + b) / 3.0;\noutColor = vec4(r, g, b, 1.0);\n}\n}";
var node_tex_wave_bl_frag = "#define TEX_WAVE_TYPE_BANDS 0\n#define TEX_WAVE_TYPE_RINGS 1\n#define TEX_WAVE_PROFILE_SIN 0\n#define TEX_WAVE_PROFILE_SAW 1\n#define TEX_WAVE_PROFILE_TRI 2\n#define TEX_WAVE_BANDS_DIR_X 0\n#define TEX_WAVE_BANDS_DIR_Y 1\n#define TEX_WAVE_BANDS_DIR_Z 2\n#define TEX_WAVE_BANDS_DIR_DIAGONAL 3\n#define TEX_WAVE_RINGS_DIR_X 0\n#define TEX_WAVE_RINGS_DIR_Y 1\n#define TEX_WAVE_RINGS_DIR_Z 2\n#define TEX_WAVE_RINGS_DIR_SPHERICAL 3\nvoid node_tex_wave(\nint waveType, int waveProfile, int bandsDirection, int ringsDirection,\nvec3 vector, float scale, float distortion, float detail, float detailScale,\nfloat detailRoughness, float phaseOffset,\nout vec4 outColor, out float outFac) {\nvec3 coScaled = vector * scale;\nfloat waveFac;\nvec3 waveVec = coScaled;\nif (waveType == TEX_WAVE_TYPE_BANDS) {\nconst float BANDS_AXIS_SCALE = 2.0 / 3.0;\nif (bandsDirection == TEX_WAVE_BANDS_DIR_X) {\nwaveVec = waveVec.xxx * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Y) {\nwaveVec = waveVec.yyy * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Z) {\nwaveVec = waveVec.zzz * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_DIAGONAL) {\n}\nwaveFac = (waveVec.x + waveVec.y + waveVec.z) * 10.0;\n} else {\nif (ringsDirection == TEX_WAVE_RINGS_DIR_X) {\nwaveVec.x = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Y) {\nwaveVec.y = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Z) {\nwaveVec.z = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_SPHERICAL) {\n}\nwaveFac = length(waveVec) * 20.0;\n}\nif (distortion != 0.0) {\nwaveFac += distortion * noiseTurbulence(coScaled * detailScale, detail,\n0.0, 0.0, 1.0);\n}\nif (waveProfile == TEX_WAVE_PROFILE_SIN) {\nwaveFac = 0.5 + 0.5 * sin(waveFac - PI_HALF + phaseOffset);\n} else if (waveProfile == TEX_WAVE_PROFILE_SAW) {\nwaveFac = fract((waveFac + phaseOffset + 1e-4) / PI2);\n} else if (waveProfile == TEX_WAVE_PROFILE_TRI) {\nwaveFac = abs(2.0 * fract((waveFac + PI + phaseOffset) / PI2) - 1.0);\n}\noutColor = vec4(waveFac, waveFac, waveFac, 1.0);\noutFac = waveFac;\n}";
var node_tex_white_noise_bl_frag = "#if __VERSION__ == 300\nvoid node_tex_white_noise_1d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = hashFloatToFloat(w);\noutColor = vec4(hashFloatToVec3(w), 1.0);\n}\nvoid node_tex_white_noise_2d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = hashVec2ToFloat(vector.xy);\noutColor = vec4(hashVec2ToVec3(vector.xy), 1.0);\n}\nvoid node_tex_white_noise_3d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = hashVec3ToFloat(vector);\noutColor = vec4(hashVec3ToVec3(vector), 1.0);\n}\nvoid node_tex_white_noise_4d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = hashVec4ToFloat(vec4(vector, w));\noutColor = vec4(hashVec4ToVec3(vec4(vector, w)), 1.0);\n}\n#else\nvoid node_tex_white_noise_1d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = 0.0;\noutColor = vec4(0.0);\n}\nvoid node_tex_white_noise_2d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = 0.0;\noutColor = vec4(0.0);\n}\nvoid node_tex_white_noise_3d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = 0.0;\noutColor = vec4(0.0);\n}\nvoid node_tex_white_noise_4d(vec3 vector, float w, out float outValue,\nout vec4 outColor)\n{\noutValue = 0.0;\noutColor = vec4(0.0);\n}\n#endif";
var node_uvmap_bl_frag = "void node_uvmap(vec2 uv, out vec3 outUV) {\n#if WORLD_NODES == 1\noutUV = vec3(0.0);\n#else\nuv.y = 1.0 - uv.y;\noutUV = vec3(uv, 0.0);\n#endif\n}";
var node_valtorgb_bl_frag = "void node_valtorgb(sampler2D colormap, float fac, out vec4 colOut, out float alphaOut)\n{\ncolOut = texture2D(colormap, vec2(fac, 0.0));\nalphaOut = colOut.a;\n}";
var node_value_bl_frag = "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float value, out float outValue)\n{\noutValue = value;\n}";
var node_vect_math_bl_frag = "void node_vect_math_add(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 + v2;\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 - v2;\n}\nvoid node_vect_math_multiply(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = v1 * v2;\n}\nvoid node_vect_math_divide(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec.x = v2.x == 0.0 ? 0.0 : v1.x / v2.x;\noutVec.y = v2.y == 0.0 ? 0.0 : v1.y / v2.y;\noutVec.z = v2.z == 0.0 ? 0.0 : v1.z / v2.z;\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = cross(v1, v2);\n}\nvoid node_vect_math_project(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nfloat d = dot(v2, v2);\noutVec = (d != 0.0) ? (dot(v1, v2) / d) * v2 : vec3(0.0);\n}\nvoid node_vect_math_reflect(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nif (v2 != vec3(0.0)) {\nv2 = normalize(v2);\n}\noutVec = reflect(v1, v2);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVal = dot(v1, v2);\n}\nvoid node_vect_math_distance(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVal = distance(v1, v2);\n}\nvoid node_vect_math_length(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVal = length(v1);\n}\nvoid node_vect_math_scale(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 * val;\n}\nvoid node_vect_math_normalize(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\nif (v1 != vec3(0.0)) {\nv1 = normalize(v1);\n}\noutVec = v1;\n}\nvoid node_vect_math_snap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec.x = v2.x == 0.0 ? 0.0 : floor(v1.x / v2.x) * v2.x;\noutVec.y = v2.y == 0.0 ? 0.0 : floor(v1.y / v2.y) * v2.y;\noutVec.z = v2.z == 0.0 ? 0.0 : floor(v1.z / v2.z) * v2.z;\n}\nvoid node_vect_math_floor(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = floor(v1);\n}\nvoid node_vect_math_ceil(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = ceil(v1);\n}\nvoid node_vect_math_modulo(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nvec3 signProduct = sign(v1) * sign(v2);\nv1 += 1e-5 * signProduct;\noutVec.x = signProduct.x > 0.0 ? mod(v1.x, abs(v2.x)) : 0.0;\noutVec.y = signProduct.y > 0.0 ? mod(v1.y, abs(v2.y)) : 0.0;\noutVec.z = signProduct.z > 0.0 ? mod(v1.z, abs(v2.z)) : 0.0;\n}\nvoid node_vect_math_fraction(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = fract(v1);\n}\nvoid node_vect_math_absolute(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = abs(v1);\n}\nvoid node_vect_math_minimum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = min(v1, v2);\n}\nvoid node_vect_math_maximum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = max(v1, v2);\n}\nvoid node_vect_math_cosine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = cos(v1);\n}\nvoid node_vect_math_sine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = sin(v1);\n}\nvoid node_vect_math_tangent(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = tan(v1);\n}\nvoid node_vect_math_wrap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nv1 += 1e-5;\noutVec.x = v2.x == v3.x ? v2.x : mod(v1.x - v3.x, v2.x - v3.x) + v3.x;\noutVec.y = v2.y == v3.y ? v2.y : mod(v1.y - v3.y, v2.y - v3.y) + v3.y;\noutVec.z = v2.z == v3.z ? v2.z : mod(v1.z - v3.z, v2.z - v3.z) + v3.z;\n}\nvoid node_vect_math_faceforward(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = dot(v2, v3) < 0.0 ? v1 : -v1;\n}\nvoid node_vect_math_multiply_add(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = v1 * v2 + v3;\n}\nvoid node_vect_math_refract(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\nif (v2 != vec3(0.0)) {\nv2 = normalize(v2);\n}\noutVec = refract(v1, v2, val);\n}";
var node_vect_transform_bl_frag = "#define VEC_TRANS_NONE 0\n#define VEC_TRANS_W_O 1\n#define VEC_TRANS_W_C 2\n#define VEC_TRANS_O_W 3\n#define VEC_TRANS_O_C 4\n#define VEC_TRANS_C_W 5\n#define VEC_TRANS_C_O 6\n#define VEC_TRANS_W_O_DIR 7\n#define VEC_TRANS_W_C_DIR 8\n#define VEC_TRANS_O_W_DIR 9\n#define VEC_TRANS_O_C_DIR 10\n#define VEC_TRANS_C_W_DIR 11\n#define VEC_TRANS_C_O_DIR 12\nvoid node_vect_transform(const int vecTransType, const bool invCamZ, vec3 vIn, out vec3 vOut)\n{\nif (vecTransType == VEC_TRANS_NONE)\nvOut = vIn;\nelse {\nvec4 vec;\nif (vecTransType < VEC_TRANS_W_O_DIR)\nvec = vec4(vIn.xyz, 1.0);\nelse\nvec = vec4(vIn.xyz, 0.0);\nif (vecTransType == VEC_TRANS_W_O || vecTransType == VEC_TRANS_W_O_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = invModelMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_W_C || vecTransType == VEC_TRANS_W_C_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = viewMatrix * vec;\nif (invCamZ)\nvec[2] = -vec[2];\n} else if (vecTransType == VEC_TRANS_O_W || vecTransType == VEC_TRANS_O_W_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = modelMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_O_C || vecTransType == VEC_TRANS_O_C_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = modelViewMatrix * vec;\nif (invCamZ)\nvec[2] = -vec[2];\n} else if (vecTransType == VEC_TRANS_C_W || vecTransType == VEC_TRANS_C_W_DIR) {\nif (invCamZ)\nvec[2] = -vec[2];\nvec = invViewMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_C_O || vecTransType == VEC_TRANS_C_O_DIR) {\nif (invCamZ)\nvec[2] = -vec[2];\nvec = invModelMatrix * invViewMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n}\nvOut = vec.xyz;\n}\n}";
var node_vector_displacement_bl_frag = "void node_vector_displacement(vec4 vector, float midLevel, float scale,\nout vec3 displacement) {\ndisplacement = vec3(0.0);\n}";
var node_vector_rotate_bl_frag = "void node_vector_rotate_axis_angle(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nif (length(axis) > 0.0) {\nvector -= center;\noutVector = vec3RotateAxisAngle(vector, axis, invert * angle);\noutVector += center;\n} else {\noutVector = vector;\n}\n}\nvoid node_vector_rotate_euler_xyz(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvec4 axisAngle = eulerToAxisAngle(rotation);\nvector -= center;\noutVector = vec3RotateAxisAngle(vector, axisAngle.xyz, invert * axisAngle.w);\noutVector += center;\n}\nvoid node_vector_rotate_x_axis(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvector -= center;\noutVector = vec3RotateXAngle(vector, invert * angle);\noutVector += center;\n}\nvoid node_vector_rotate_y_axis(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvector -= center;\noutVector = vec3RotateYAngle(vector, invert * angle);\noutVector += center;\n}\nvoid node_vector_rotate_z_axis(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvector -= center;\noutVector = vec3RotateZAngle(vector, invert * angle);\noutVector += center;\n}";
var node_vertex_color_bl_frag = "void node_vertex_color(vec4 color, out vec4 outColor, out float outAlpha) {\noutColor = color;\noutAlpha = color.a;\n}";
var node_volume_absorption_bl_frag = "void node_volume_absorption(vec4 color, float density, out vec4 outColor)\n{\noutColor = color;\n}";
var node_volume_info_bl_frag = "void node_volume_info(out vec4 color, out float density, out float flame,\nout float temperature) {\ncolor = vec4(vec3(0.0), 1.0);\ndensity = 0.0;\nflame = 0.0;\ntemperature = 0.0;\n}";
var node_volume_scatter_bl_frag = "void node_volume_scatter(vec4 color, float density, float anisotropy, out vec4 outColor)\n{\noutColor = vec4(color);\n}";
var node_wavelength_bl_frag = "void node_wavelength(float wavelength, out vec4 outColor)\n{\noutColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if __VERSION__ == 300\nvec3 xyz = vec3(0.0);\nfloat ii = (wavelength - 380.0) / 5.0;\nint i = int(ii);\nif (i < 0 || i >= 80) {\nreturn;\n}\nii -= float(i);\nvec3 c1 = cieColorMatch[i];\nvec3 c2 = cieColorMatch[i+1];\nxyz = mix(c1, c2, ii);\noutColor = vec4(xyz_to_sRGB(xyz), 1.0);\n#endif\n}";
var node_wireframe_bl_frag = "void node_wireframe(float size, out float outFac)\n{\noutFac = 0.0;\n}";
var node_bitmap_none_mx_frag = "void node_bitmap_none(out vec4 color)\n{\ncolor = vec4(1.0);\n}";
var node_bitmap_env_mx_frag = "void node_bitmap_env(sampler2D envMap, int reflectMode, float IOR,\nconst int encoding, const bool alphaAsMono, const bool alphaAsRGB,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle, vec3 normal,\nout vec4 color, out float value)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec = normalize(cameraToVertex);\n#else\nif (reflectMode == MAX_ENV_COORDS_REFLECT)\nreflectVec = reflect(cameraToVertex, worldNormal);\nelse {\nfloat refrRatio = 1.0 / IOR;\nreflectVec = refract(cameraToVertex, worldNormal, refrRatio);\n}\n#endif\nmat3 uvTransform = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle);\ncolor = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\nif (alphaAsMono)\nvalue = color.a;\nelse\nvalue = average(color.rgb);\nif (alphaAsRGB)\ncolor = vec4(color.a);\n}";
var node_bitmap_mx_frag = "void node_bitmap(sampler2D map, const vec2 uvIn, const int mapping, const int axis,\nconst ivec2 clampToEdgeNoExtend,\nconst int encoding, const bool alphaAsMono, const bool alphaAsRGB,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 color, out float value)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nvec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\ncolor = vec4(0.0, 0.0, 0.0, 1.0);\n} else {\ncolor = texture2D(map, uv);\ncolor = nodeTexelToLinear(color, encoding);\n}\nif (alphaAsMono)\nvalue = color.a;\nelse\nvalue = average(color.rgb);\nif (alphaAsRGB)\ncolor = vec4(color.a);\n}";
var node_bump_mx_frag = "void node_bump(sampler2D bumpMap, const vec3 eyePos, const vec3 normal, const vec2 uvIn,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec3 normalOut)\n{\nvec3 coordsIn;\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nvec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);\nvec2 dSTdx = dFdx(uv);\nvec2 dSTdy = dFdy(uv);\nif (any(equal(dSTdx, vec2(0.0))) || any(equal(dSTdy, vec2(0.0)))) {\nnormalOut = normal;\n} else {\nconst float bumpScale = 1.0;\nvec3 vSigmaX = vec3(dFdx(eyePos.x), dFdx(eyePos.y), dFdx(eyePos.z));\nvec3 vSigmaY = vec3(dFdy(eyePos.x), dFdy(eyePos.y), dFdy(eyePos.z));\nvec3 vN = normal;\nvec3 R1 = cross(vSigmaY, vN);\nvec3 R2 = cross(vN, vSigmaX);\nfloat fDet = dot(vSigmaX, R1);\nfloat Hll = bumpScale * texture2D(bumpMap, uv).x;\nfloat dBx = bumpScale * texture2D(bumpMap, uv + dSTdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpMap, uv + dSTdy).x - Hll;\nvec2 dHdxy = vec2(dBx, dBy);\nvec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\nnormalOut = normalize(abs(fDet) * normal - vGrad);\n}\n}";
var node_blend_mx_frag = "void node_blend(\nconst bool useCurve, const float curveLower, const float curveUpper,\nconst vec4 color1, const vec4 color2, float mask,\nout vec4 color)\n{\nif (useCurve)\nmask = smoothstep(curveLower, curveUpper, mask);\nelse\nmask = clamp(mask, 0.0, 1.0);\ncolor = mix(color1, color2, mask);\n}";
var node_color_correction_mx_frag = "#define REWIRE_RED 0\n#define REWIRE_GREEN 1\n#define REWIRE_BLUE 2\n#define REWIRE_ALPHA 3\n#define REWIRE_RED_INV 4\n#define REWIRE_GREEN_INV 5\n#define REWIRE_BLUE_INV 6\n#define REWIRE_ALPHA_INV 7\n#define REWIRE_MONOCHROME 8\n#define REWIRE_ONE 9\n#define REWIRE_ZERO 10\nfloat rewireChannel(int type, vec4 color)\n{\nif (type == REWIRE_RED)\nreturn color.r;\nelse if (type == REWIRE_GREEN)\nreturn color.g;\nelse if (type == REWIRE_BLUE)\nreturn color.b;\nelse if (type == REWIRE_ALPHA)\nreturn color.a;\nelse if (type == REWIRE_RED_INV)\nreturn 1.0-color.r;\nelse if (type == REWIRE_GREEN_INV)\nreturn 1.0-color.g;\nelse if (type == REWIRE_BLUE_INV)\nreturn 1.0-color.b;\nelse if (type == REWIRE_ALPHA_INV)\nreturn 1.0-color.a;\nelse if (type == REWIRE_MONOCHROME)\nreturn average(color.rgb);\nelse if (type == REWIRE_ONE)\nreturn 1.0;\nelse\nreturn 0.0;\n}\nvec3 gainPivotGammaLift(vec3 color, float gain, float pivot, float gamma, float lift, int exposureMode, float printerLights)\n{\ngain = gain / 100.0;\nif (exposureMode == 0) {\ncolor = color * gain / pivot;\n} else if (exposureMode == 1) {\ncolor = color * pow(2.0, gain) / pivot;\n} else {\ncolor = color * pow(printerLights, gain) / pivot;\n}\nvec3 tmp = pivot * pow(color, vec3(1.0 / gamma));\nreturn step(0.00001, color) * tmp + lift;\n}\nfloat gainPivotGammaLift(float value, float gain, float pivot, float gamma, float lift, int exposureMode, float printerLights)\n{\ngain = gain / 100.0;\nif (exposureMode == 0) {\nvalue = value * gain / pivot;\n} else if (exposureMode == 1) {\nvalue = value * pow(2.0, gain) / pivot;\n} else {\nvalue = value * pow(printerLights, gain) / pivot;\n}\nfloat tmp = pivot * pow(value, 1.0 / gamma);\nreturn step(0.00001, value) * tmp + lift;\n}\nvoid node_color_correction(const ivec4 rewire,\nconst vec4 color, const float hueShift, const float saturation,\nconst vec4 tint, const float tintStrength,\nconst float brightness, const float contrast,\nout vec4 outColor)\n{\nif (all(equal(rewire, ivec4(REWIRE_RED, REWIRE_GREEN, REWIRE_BLUE, REWIRE_ALPHA)))) {\noutColor = color;\n} else {\noutColor.r = rewireChannel(rewire.x, color);\noutColor.g = rewireChannel(rewire.y, color);\noutColor.b = rewireChannel(rewire.z, color);\noutColor.a = rewireChannel(rewire.w, color);\n}\nvec4 hsv;\nrgbToHSV(outColor, hsv);\nhsv[0] += hueShift / 360.0;\nif (hsv[0] > 1.0)\nhsv[0] -= 1.0;\nelse if (hsv[0] < 0.0)\nhsv[0] += 1.0;\nhsv[1] *= (saturation / 100.0 + 1.0);\nhsv[1] = saturate(hsv[1]);\nif (tintStrength > 0.0) {\nvec4 hsvTint;\nrgbToHSV(tint, hsvTint);\nhsv[0] = hsv[0] + (hsvTint[0] - hsv[0]) * tintStrength / 100.0;\n}\nhsvToRGB(hsv, outColor);\noutColor = (outColor - 0.5) * (contrast / 100.0 + 1.0) + 0.5 + brightness / 100.0;\noutColor = max(outColor, 0.0);\n}\nvoid node_color_correction(const ivec4 rewire, const mat4 params,\nbool enableR, bool enableG, bool enableB, int exposureMode, float printerLights,\nconst vec4 color, const float hueShift, const float saturation,\nconst vec4 tint, const float tintStrength,\nout vec4 outColor)\n{\nif (all(equal(rewire, ivec4(REWIRE_RED, REWIRE_GREEN, REWIRE_BLUE, REWIRE_ALPHA)))) {\noutColor = color;\n} else {\noutColor.r = rewireChannel(rewire.x, color);\noutColor.g = rewireChannel(rewire.y, color);\noutColor.b = rewireChannel(rewire.z, color);\noutColor.a = rewireChannel(rewire.w, color);\n}\nvec4 hsv;\nrgbToHSV(outColor, hsv);\nhsv[0] += hueShift / 360.0;\nif (hsv[0] > 1.0)\nhsv[0] -= 1.0;\nelse if (hsv[0] < 0.0)\nhsv[0] += 1.0;\nhsv[1] *= (saturation / 100.0 + 1.0);\nhsv[1] = saturate(hsv[1]);\nif (tintStrength > 0.0) {\nvec4 hsvTint;\nrgbToHSV(tint, hsvTint);\nhsv[0] = hsv[0] + (hsvTint[0] - hsv[0]) * tintStrength / 100.0;\n}\nhsvToRGB(hsv, outColor);\noutColor.rgb = gainPivotGammaLift(outColor.rgb, params[0][0], params[0][1], params[0][2], params[0][3],\nexposureMode, printerLights);\nif (enableR)\noutColor.r = gainPivotGammaLift(outColor.r, params[1][0], params[1][1], params[1][2], params[1][3],\nexposureMode, printerLights);\nif (enableG)\noutColor.g = gainPivotGammaLift(outColor.g, params[2][0], params[2][1], params[2][2], params[2][3],\nexposureMode, printerLights);\nif (enableB)\noutColor.b = gainPivotGammaLift(outColor.b, params[3][0], params[3][1], params[3][2], params[3][3],\nexposureMode, printerLights);\noutColor = max(outColor, 0.0);\n}";
var node_color_map_mx_frag = "void node_color_map(const bool reverseGamma,\nconst vec4 color, const float gamma, const float gain,\nout vec4 outColor)\n{\nfloat p = reverseGamma ? gamma : 1.0 / gamma;\nfloat g = reverseGamma ? (gain > EPSILON ? 1.0 / gain : 1.0) : gain;\noutColor = vec4(g * pow(abs(color.rgb), vec3(p)), color.a);\n}";
var node_composite_layer_mx_frag = "#define COMP_BLEND_NORMAL 0\n#define COMP_BLEND_AVERAGE 1\n#define COMP_BLEND_ADD 2\n#define COMP_BLEND_SUBTRACT 3\n#define COMP_BLEND_DARKEN 4\n#define COMP_BLEND_MULTIPLY 5\n#define COMP_BLEND_COLORBURN 6\n#define COMP_BLEND_LINEARBURN 7\n#define COMP_BLEND_LIGHTEN 8\n#define COMP_BLEND_SCREEN 9\n#define COMP_BLEND_COLORDODGE 10\n#define COMP_BLEND_LINEARDODGE 11\n#define COMP_BLEND_SPOT 12\n#define COMP_BLEND_SPOTBLEND 13\n#define COMP_BLEND_OVERLAY 14\n#define COMP_BLEND_SOFTLIGHT 15\n#define COMP_BLEND_HARDLIGHT 16\n#define COMP_BLEND_PINLIGHT 17\n#define COMP_BLEND_HARDMIX 18\n#define COMP_BLEND_DIFFERENCE 19\n#define COMP_BLEND_EXCLUSION 20\n#define COMP_BLEND_HUE 21\n#define COMP_BLEND_SATURATION 22\n#define COMP_BLEND_COLOR 23\n#define COMP_BLEND_VALUE 24\nvec4 calcBlending(const vec4 colorBG, const vec4 colorFG, const int blendMode) {\nif (blendMode == COMP_BLEND_NORMAL)\nreturn colorFG;\nelse if (blendMode == COMP_BLEND_AVERAGE)\nreturn (colorFG + colorBG) / 2.0;\nelse if (blendMode == COMP_BLEND_ADD)\nreturn colorBG + colorFG;\nelse if (blendMode == COMP_BLEND_SUBTRACT)\nreturn colorBG - colorFG;\nelse if (blendMode == COMP_BLEND_DARKEN)\nreturn min(colorFG, colorBG);\nelse if (blendMode == COMP_BLEND_MULTIPLY)\nreturn colorBG * colorFG;\nelse if (blendMode == COMP_BLEND_COLORBURN) {\nif (colorFG.r == 0.0 && colorFG.g == 0.0 && colorFG.b == 0.0)\nreturn vec4(0.0, 0.0, 0.0, 1.0);\nelse\nreturn max(1.0 - (1.0 - colorBG) / colorFG, 0.0);\n} else if (blendMode == COMP_BLEND_LINEARBURN)\nreturn max(colorFG + colorBG - 1.0, 0.0);\nelse if (blendMode == COMP_BLEND_LIGHTEN)\nreturn max(colorFG, colorBG);\nelse if (blendMode == COMP_BLEND_SCREEN)\nreturn colorFG + colorBG - colorFG * colorBG;\nelse if (blendMode == COMP_BLEND_COLORDODGE) {\nif (colorFG.r == 1.0 && colorFG.g == 1.0 && colorFG.b == 1.0)\nreturn vec4(1.0);\nelse\nreturn min(colorBG / (1.0 - colorFG), 1.0);\n} else if (blendMode == COMP_BLEND_LINEARDODGE)\nreturn min(colorFG + colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_SPOT)\nreturn min(2.0 * colorFG * colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_SPOTBLEND)\nreturn min(colorFG * colorBG + colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_OVERLAY) {\nif (colorBG.r <= 0.5 && colorBG.g <= 0.5 && colorBG.b <= 0.5)\nreturn saturate(2.0 * colorFG * colorBG);\nelse\nreturn saturate(1.0 - 2.0 * (1.0-colorFG) * (1.0-colorBG));\n} else if (blendMode == COMP_BLEND_SOFTLIGHT) {\nif (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)\nreturn saturate(colorBG * (colorBG + 2.0 * colorFG * (1.0 - colorBG)));\nelse\nreturn saturate(colorBG + (2.0 * colorFG - 1.0) * (sqrt(colorBG) - colorBG));\n} else if (blendMode == COMP_BLEND_HARDLIGHT) {\nif (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)\nreturn saturate(2.0 * colorFG * colorBG);\nelse\nreturn saturate(1.0 - 2.0*(1.0 - colorFG)*(1.0 - colorBG));\n} else if (blendMode == COMP_BLEND_PINLIGHT) {\nif (((colorFG.r > 0.5 && colorFG.g > 0.5 && colorFG.b > 0.5) && all(greaterThan(colorFG, colorBG))) ||\n((colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5) && all(lessThan(colorFG, colorBG))))\nreturn colorFG;\nelse\nreturn colorBG;\n} else if (blendMode == COMP_BLEND_HARDMIX) {\nif (colorFG.r + colorBG.r <= 1.0 && colorFG.g + colorBG.g <= 1.0 && colorFG.b + colorBG.b <= 1.0)\nreturn vec4(0.0, 0.0, 0.0, 1.0);\nelse\nreturn vec4(1.0);\n} else if (blendMode == COMP_BLEND_DIFFERENCE)\nreturn abs(colorFG - colorBG);\nelse if (blendMode == COMP_BLEND_EXCLUSION)\nreturn colorFG + colorBG - 2.0 * colorFG * colorBG;\n}\nvec4 calcBlendingHSV(const vec4 colorBG, const vec4 colorFG, const int blendMode)\n{\nvec4 hsvBG, hsvFG;\nvec4 outColor;\nif (blendMode == COMP_BLEND_HUE) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvFG[0], hsvBG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_SATURATION) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvBG[0], hsvFG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_COLOR) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvFG[0], hsvFG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_VALUE) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvBG[0], hsvBG[1], hsvFG[2], 1.0), outColor);\n}\nreturn outColor;\n}\nvoid node_composite_layer(const int blendMode, const float opacity, \nconst vec4 colorBG, const vec4 colorFG, const vec4 mask,\nout vec4 outColor)\n{\nfloat fac = saturate(opacity * average(mask.rgb));\nif (blendMode < COMP_BLEND_HUE)\noutColor = calcBlending(colorBG, colorFG, blendMode);\nelse\noutColor = calcBlendingHSV(colorBG, colorFG, blendMode);\noutColor = mix(colorBG, outColor, fac);\n}";
var node_falloff_mx_frag = "#define FALLOFF_TYPE_TOWARDS_AWAY 0\n#define FALLOFF_TYPE_PERP_PARALL 1\n#define FALLOFF_TYPE_FRESHNEL 2\n#define FALLOFF_TYPE_SHADOW_LIGHT 3\n#define FALLOFF_TYPE_DIST_BLEND 4\nvoid node_falloff(const vec3 viewPos, const float IOR, const int falloffType,\nconst vec4 color1, const vec4 color2, const vec3 normal, out vec4 color)\n{\nvec3 dir = normalize(viewPos);\nfloat fac;\nif (falloffType == FALLOFF_TYPE_TOWARDS_AWAY) {\nfac = 1.0 - (0.5 * (abs(dot(dir, normal)) + 1.0));\n} else if (falloffType == FALLOFF_TYPE_PERP_PARALL) {\nfac = 1.0 - abs(dot(dir, normal));\n} else if (falloffType == FALLOFF_TYPE_FRESHNEL) {\nfloat eta = max(IOR, 0.00001);\nfac = fresnelReflection(dir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);\n} else {\nfac = 0.0;\n}\ncolor = mix(color1, color2, fac);\n}\nvoid node_falloff(const vec3 viewPos, bool extrapolateOn, float nearDistance, float farDistance,\nconst vec4 color1, const vec4 color2, const vec3 normal, out vec4 color)\n{\nfloat dist = length(viewPos);\nfloat fac;\nif (!extrapolateOn && dist <= nearDistance) {\nfac = 1.0;\n} else if (!extrapolateOn && dist > farDistance) {\nfac = 0.0;\n} else {\nfac = ((farDistance - nearDistance) != 0.0) ? ((farDistance - dist) / (farDistance - nearDistance)) : 10000.0;\n}\ncolor = mix(color1, color2, fac);\n}";
var node_gradient_mx_frag = "#define GRAD_TYPE_LINEAR 0\n#define GRAD_TYPE_RADIAL 1\nvoid node_gradient(\nfloat color2Pos, int gradientType, vec2 uvIn, vec3 viewPos, int mapping, int axis, ivec2 clampToEdgeNoExtend,\nvec3 color1, vec3 color2, vec3 color3, float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 outCol)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-viewPos, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nfloat coord = uvIn.x;\nuvIn = coordsOut.xy;\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\noutCol = vec4(0.0, 0.0, 0.0, 1.0);\nreturn;\n}\nuvIn = fract(uvIn);\nif (gradientType == GRAD_TYPE_LINEAR) {\ncoord = uvIn.y;\n} else {\ncoord = length(uvIn - vec2(0.5)) * 2.0;\nif (coord > 1.0)\ncoord = 1.0;\n}\nif (coord < color2Pos) {\ncoord = coord / color2Pos;\noutCol = vec4(color3 * (1.0 - coord) + color2 * coord, 1.0);\n} else if (coord > color2Pos) {\ncoord = (coord - color2Pos) / (1.0 - color2Pos);\noutCol = vec4(color2 * (1.0 - coord) + color1 * coord, 1.0);\n} else {\noutCol = vec4(color2, 1.0);\n}\n}";
var node_gradient_ramp_mx_frag = "#define GRAD_TYPE_4_CORNER 0\n#define GRAD_TYPE_BOX 1\n#define GRAD_TYPE_DIAGONAL 2\n#define GRAD_TYPE_LIGHTING 3\n#define GRAD_TYPE_LINEAR 4\n#define GRAD_TYPE_MAPPED 5\n#define GRAD_TYPE_NORMAL 6\n#define GRAD_TYPE_PONG 7\n#define GRAD_TYPE_RADIAL 8\n#define GRAD_TYPE_SPIRAL 9\n#define GRAD_TYPE_SWEEP 10\n#define GRAD_TYPE_TARTAN 11\nvoid node_gradient_ramp(\nsampler2D gradientData, int gradientType, vec2 uvIn, vec3 geometryNormal,\nvec3 viewPos, int mapping, int axis, ivec2 clampToEdgeNoExtend,\nvec4 sourceMap, float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 outCol)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-viewPos, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nfloat coord = uvIn.x;\nuvIn = coordsOut.xy;\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\noutCol = vec4(0.0, 0.0, 0.0, 1.0);\nreturn;\n}\nuvIn = fract(uvIn);\nif (gradientType == GRAD_TYPE_4_CORNER) {\ncoord = pow(uvIn.x, 2.0);\n} else if (gradientType == GRAD_TYPE_BOX) {\nvec2 boxUv = abs(uvIn - vec2(0.5)) * 2.0;\ncoord = max(boxUv.x, boxUv.y);\n} else if (gradientType == GRAD_TYPE_DIAGONAL) {\ncoord = abs(uvIn.x - uvIn.y) * sqrt(2.0);\n} else if (gradientType == GRAD_TYPE_LIGHTING) {\nIncidentLight directLight;\nGeometricContext geometry;\ngeometry.position = -viewPos;\nvec3 irr = vec3(0.0);\n#if (NUM_POINT_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\ngetPointLightInfo(pointLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#endif\n#if (NUM_SPOT_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\ngetSpotLightInfo(spotLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#endif\n#if (NUM_DIR_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ngetDirectionalLightInfo(directionalLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#endif\nirr /= PI;\nvec3 ambIrr = getAmbientLightIrradiance(ambientLightColor);\nirr += ambIrr;\ncoord = (irr.x + irr.y + irr.z) / 3.0;\n} else if (gradientType == GRAD_TYPE_LINEAR) {\ncoord = uvIn.x;\n} else if (gradientType == GRAD_TYPE_MAPPED) {\ncoord = (sourceMap.x + sourceMap.y + sourceMap.z) / 3.0;\n} else if (gradientType == GRAD_TYPE_NORMAL) {\nfloat angle = acos(clamp(dot(geometryNormal, normalize(viewPos)), -1.0, 1.0));\nfloat k = 100.0;\ncoord = 1.0 - sin(pow2(k) - k * sqrt(pow2(k) - pow2(angle)));\n} else if (gradientType == GRAD_TYPE_PONG) {\nfloat y = min(uvIn.y, uvIn.x);\nfloat x = max(uvIn.y, uvIn.x);\ncoord = y / x;\n} else if (gradientType == GRAD_TYPE_RADIAL) {\ncoord = length(uvIn - vec2(0.5)) * 2.0;\n} else if (gradientType == GRAD_TYPE_SPIRAL) {\nvec2 uvSpiral = mat2(0.0, 1.0, -1.0, 0.0) * (uvIn - vec2(0.5));\ncoord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;\n} else if (gradientType == GRAD_TYPE_SWEEP) {\ncoord = atan(uvIn.x, uvIn.y) / PI_HALF;\n} else if (gradientType == GRAD_TYPE_TARTAN) {\nvec2 uvTartan = abs(uvIn - vec2(0.5));\ncoord = 1.0 - min(uvTartan.x, uvTartan.y) * 2.0;\n}\noutCol = texture2D(gradientData, vec2(coord, 0.0));\n}";
var node_map_mx_frag = "\nvoid node_map(const vec4 colorIn, out vec4 color)\n{\ncolor = colorIn;\n}";
var node_mask_mx_frag = "void node_mask(const bool maskInverted,\nconst vec4 color, vec4 mask,\nout vec4 outColor)\n{\nmask = maskInverted ? vec4(vec3(1.0) - mask.rgb, mask.a) : mask;\noutColor = color * mask;\n}";
var node_material_mx_frag = "void node_material(\nfloat reflectionRatio, const float refractionRatio,\nconst bool selfIllumColorOn,\nconst vec4 ambientColor, const vec4 diffuseColor, const vec4 specularColor,\nconst float glossiness, const float specularLevel, const vec4 selfIllum,\nconst float opacity, const vec4 filterColor, const vec3 normal,\nconst vec4 reflection, const vec4 refraction, const float displacement,\nout vec4 outColor)\n{\nvec3 diffuse, specular;\nNodeMaterial material;\nfloat ior = 1.5;\nfloat facing = pow2((1.0 - ior) / (1.0 + ior));\nfloat edge = 1.0;\nfloat slope = 5.0;\nfloat cosTheta = saturate(dot(normal, normalize(vViewPosition)));\nfloat fresnelRefl = (facing + (edge - facing) * pow(1.0 - cosTheta, slope)) * saturate(specularLevel);\nfloat kd = 1.0 - fresnelRefl;\nmaterial.diffuseColor = diffuseColor.rgb * kd;\nmaterial.specularColor = mix(vec3(0.0), specularColor.rgb, fresnelRefl);\nmaterial.roughness = 1.0 - glossiness;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\ndiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nif (selfIllumColorOn) {\ndiffuse += selfIllum.rgb;\n} else {\ndiffuse = mix(diffuse, material.diffuseColor, selfIllum[0]);\n}\nspecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\noutColor = vec4(saturate(diffuse + specular), 1.0);\nfloat alpha = opacity - saturate(maxFromRGB(specular)) * (opacity - 1.0);\noutColor += reflection * specularColor * reflectionRatio;\noutColor += refraction * refractionRatio;\nalpha += saturate(maxFromRGB(reflection.rgb) * maxFromRGB(specularColor.rgb)) * reflectionRatio;\nalpha += saturate(maxFromRGB(refraction.rgb)) * refractionRatio;\noutColor.a = alpha;\n}";
var node_matte_shadow_mx_frag = "#include <shadowmask_pars_fragment>\nvoid node_matte_shadow(\nvec3 normal, bool receiveShadow, float shadowBrightness, vec3 color,\nout vec4 outColor) {\nfloat shadow = getShadowMask();\noutColor = vec4(color, 1.0 - (shadowBrightness + (1.0 - shadowBrightness) * shadow));\n}";
var node_mix_mx_frag = "void node_mix(const vec4 color1, const vec4 color2, const float amount, out vec4 color)\n{\ncolor = mix(color1, color2, clamp(amount, 0.0, 1.0));\n}";
var node_noise_mx_frag = "#define NOISE_REGULAR 0\n#define NOISE_FRACTAL 1\n#define NOISE_TURBULENCE 2\nfloat noise(vec3 vec, const int noiseType, const float size, const float thresholdLow, const float thresholdHigh, const float levels, float phase) {\nvec /= size;\nfloat n = 0.0;\nif (noiseType == NOISE_REGULAR) {\nn = (1.0 + snoise(vec4(vec, phase))) * 0.5;\n} else if (noiseType == NOISE_FRACTAL) {\nfloat l, f = 1.0;\n#if __VERSION__ == 100\nfor (float l = 3.0; l >= 1.0; l-=1.0) {\n#else\nfor (l = levels; l >= 1.0; l-=1.0) {\n#endif\nn += snoise(vec4(vec * f, phase)) / f;\nf *= 2.0;\n}\nif (l > 0.0)\nn += l * snoise(vec4(vec * f, phase)) / f;\nn = 0.5 * (n + 1.0);\n} else {\nfloat l, f = 1.0;\nfloat ml = levels;\n#if __VERSION__ == 100\nfor (float l = 3.0; l >= 1.0; l-=1.0) {\n#else\nfor (l = levels; l >= 1.0; l-=1.0, ml-=1.0) {\n#endif\nn += abs(snoise(vec4(vec * f, phase))) / f;\nf *= 2.0;\n}\nif (l > 0.0)\nn += l * abs(snoise(vec4(vec * f, phase))) / f;\n}\nreturn clamp(smoothstep(thresholdLow, thresholdHigh, n), 0.0, 1.0);\n}\nvoid node_noise(const vec2 uv, const int noiseType, const int coordType,\nconst vec3 color1, const vec3 color2, const float size,\nconst float thresholdLow, const float thresholdHigh, const float levels,\nconst float phase, const vec3 offset, const vec3 tiling, const vec3 angle,\nout vec4 color) {\nvec3 vec = (calcXYZTransform(offset, tiling, angle) * vec4(uv.x, 1.0 - uv.y, 1.0, 1.0)).xyz;\ncolor = vec4(mix(color1, color2, noise(vec, noiseType, size, thresholdLow, thresholdHigh, levels, phase)), 1.0);\n}\nvoid node_noise(const vec3 viewPos, const int noiseType, const int coordType,\nconst vec3 color1, const vec3 color2, const float size,\nconst float thresholdLow, const float thresholdHigh, const float levels,\nconst float phase, const vec3 offset, const vec3 tiling, const vec3 angle,\nout vec4 color) {\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nvec3 vec;\nif (coordType == 0)\nvec = (invModelMatrix * posWorld).xyz;\nelse\nvec = posWorld.xyz;\nvec = (calcXYZTransform(offset, tiling, angle) * vec4(swizzleUpZ(vec), 1.0)).xyz;\ncolor = vec4(mix(color1, color2, noise(vec, noiseType, size, thresholdLow, thresholdHigh, levels, phase)), 1.0);\n}";
var node_normal_bump_mx_frag = "void node_normal_bump(const vec4 tangent, const vec3 normal, ivec2 flip,\nvec4 normalColor, vec3 additionalBump, float normalMult, float addBumpMult,\nout vec3 normalOut)\n{\nif (flip[0] == 1)\nnormalColor.x = 1.0 - normalColor.x;\nif (flip[1] == 0)\nnormalColor.y = 1.0 - normalColor.y;\nvec3 normalTex = (normalColor.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize(modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz, tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\nnormalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal);\nnormalOut = mix(normal, normalOut, normalMult);\nadditionalBump = mix(normal, additionalBump, addBumpMult);\nnormalOut = normalize(normalOut + additionalBump);\n}";
var node_openpbr_surface_mx_frag = "void node_openpbr_surface(\nvec3 geometryNormal, const bool thinWalled,\nconst float baseWeight, const vec3 baseColor, const float baseMetalness,\nconst float baseDiffuseRoughness,\nconst float specularWeight, const vec3 specularColor,\nconst float specularRoughness, const float specularIOR,\nconst float transmissionWeight, const vec3 transmissionColor, const float transmissionDepth,\nconst float coatWeight, const vec3 coatColor, const float coatRoughness,\nconst float fuzzWeight, const vec3 fuzzColor, const float fuzzRoughness,\nconst float emissionWeight, const vec3 emissionColor, const float emissionLuminance,\nconst float geometryOpacity,\nconst vec3 normal, const vec3 clearcoatNormal,\nout vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = baseWeight * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - baseMetalness) * (1.0 - transmissionWeight);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = saturate(coatWeight);\nmaterial.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = saturate(fuzzWeight * fuzzColor);\nmaterial.sheenRoughness = clamp(fuzzRoughness, 0.0, 1.0);\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.roughness = max(specularRoughness, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\nvec3 specularColorWeighted = specularWeight * specularColor;\nvec3 dielRefl = pow2((1.0 - specularIOR) / (1.0 + specularIOR)) * specularColorWeighted;\nmaterial.specularColor = mix(dielRefl, baseColorWeighted, baseMetalness);\nmaterial.fresnelRefl90 = mix(specularColorWeighted, vec3(1.0), baseMetalness);\nmaterial.specularF90 = average(material.fresnelRefl90);\nmaterial.refractionColor = pow(transmissionWeight * (1.0 - baseMetalness) * transmissionColor.rgb, vec3(2.0));\nmaterial.refractionIOR = specularIOR;\nmaterial.refractionRoughness = material.roughness;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance = emissionWeight * emissionColor * emissionLuminance * OPENPBR_EMISSION_LUM_FACTOR;\nvec3 outSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\noutSpecular + totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp = 1.0 - 0.157 * max3(material.sheenColor);\noutColor3 = outColor3 * sheenEnergyComp + sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = geometryOpacity * (1.0 - saturate(transmissionWeight) + maxFromRGB(outSpecular) * saturate(transmissionWeight));\n} else {\noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha));\n}";
var node_output_map_mx_frag = "vec4 processOutputColor(vec4 color, const bool invert, const bool clampColor, const bool alphaFromRGB,\nconst float rgbLevel, const float rgbOffset, const float outputAmount)\n{\nvec3 color3 = color.rgb;\ncolor3 = clampColor ? saturate(color3) : color3;\ncolor3 = color3 * rgbLevel + vec3(rgbOffset);\ncolor3 = invert ? (vec3(1.0) - color3) : color3;\ncolor = outputAmount * vec4(color3, color.a);\ncolor.a = alphaFromRGB ? average(color.rgb) : color.a;\nreturn color;\n}\nvoid node_output_map(\nconst bool invert, const bool clampColor, const bool alphaFromRGB,\nconst vec4 color, const float rgbLevel, const float rgbOffset,\nconst float outputAmount, const float bumpAmount,\nout vec4 outColor)\n{\noutColor = processOutputColor(color, invert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);\n}\nvoid node_output_map(\nconst bool invert, const bool clampColor, const bool alphaFromRGB, sampler2D colormap,\nvec4 color, const float rgbLevel, const float rgbOffset,\nconst float outputAmount, const float bumpAmount,\nout vec4 outColor)\n{\nfloat r = texture2D(colormap, vec2(color.r, 0.0)).r;\nfloat g = texture2D(colormap, vec2(color.g, 0.0)).g;\nfloat b = texture2D(colormap, vec2(color.b, 0.0)).b;\noutColor = processOutputColor(vec4(r, g, b, color.a),\ninvert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);\n}";
var node_output_mx_frag = "void node_output(vec4 color, out vec4 outgoingLight)\n{\noutgoingLight = color;\n}";
var node_physical_mx_frag = "#define DEFAULT_REFLECTION_EDGE 1.0\n#define DEFAULT_REFLECTION_SLOPE 5.0\nvoid node_physical(\nvec3 geometryNormal, const float emitLuminance, const bool useCustomReflCurve,\nconst float reflFacing, const float reflEdge, const float reflSlope,\nconst bool roughnessInv, const bool transRoughnessLock, const bool transRoughnessInv,\nconst bool thinWalled,\nconst float base, const vec4 baseColor, const float reflectivity,\nconst vec4 reflColor, const float roughness, const float metalness,\nconst float diffRoughness, const float anisotropy, const float anisoangle,\nconst float transparency, const vec4 transColor, const float transRoughness,\nconst float ior, const float scattering, const vec4 sssColor,\nconst float sssScale, const float emission, const vec4 emitColor,\nconst float clearcoat, const vec4 clearcoatColor, const float clearcoatRoughness,\nconst vec3 normal, const vec3 clearcoatNormal, const float displacement,\nconst float opacity,\nout vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = base * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - transparency);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#endif\nfloat facing, edge, slope;\nif (useCustomReflCurve) {\nfacing = reflFacing;\nedge = reflEdge;\nslope = reflSlope;\n} else {\nfacing = pow2((1.0 - ior) / (1.0 + ior));\nedge = DEFAULT_REFLECTION_EDGE;\nslope = DEFAULT_REFLECTION_SLOPE;\n}\nfloat cosTheta = saturate(dot(normal, normalize(vViewPosition)));\nfloat fresnelRefl = (facing + (edge - facing) * pow(1.0 - cosTheta, slope))\n* saturate(reflectivity + metalness);\nfloat kd = 1.0 - (metalness * (1.0 - fresnelRefl) + fresnelRefl);\nmaterial.specularColor = mix(metalness * baseColorWeighted, reflColor.rgb, fresnelRefl);\nmaterial.diffuseColor *= kd;\nmaterial.specularF90 = 1.0;\nmaterial.roughness = clamp(roughnessInv ? (1.0 - roughness) : roughness, 0.0, 1.0);\nmaterial.refractionColor = pow(transparency * (1.0 - metalness) * transColor.rgb, vec3(2.0));\nmaterial.refractionIOR = ior;\nfloat tRough;\nif (transRoughnessLock) {\ntRough = roughnessInv ? 1.0 - roughness : roughness;\n} else {\ntRough = transRoughnessInv ? 1.0 - transRoughness : transRoughness;\n}\nmaterial.refractionRoughness = pow2(tRough);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.roughness = calcCubeUVAdjustedRoughness(\nmaterial.roughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef USE_CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance = emitLuminance / LUMENS_PER_WATT * emission * emitColor.rgb;\nvec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nspecular + totalEmissiveRadiance;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = 1.0 - saturate(transparency) + maxFromRGB(specular) * saturate(transparency);\n} else {\noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha) * opacity);\n}";
var node_phy_sun_sky_env_mx_frag = "vec3 perezSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,\nvec3 radiance, vec3 sunDirection, vec3 direction)\n{\nfloat cosGamma = clamp(dot(direction, sunDirection), -1.0, 1.0);\nfloat cosTheta = clamp(direction.y, 0.0, 1.0);\nvec3 radInternal = (1.0 + paramA * exp(paramB / cosTheta)) * (\n1.0 + paramC * exp(paramD * acos(cosGamma))\n+ paramE * pow(cosGamma, 2.0)\n);\nfloat ciex = radInternal.y * radiance.y;\nfloat ciey = radInternal.z * radiance.z;\nfloat cieY = clamp(radInternal.x * radiance.x, 0.0, 1000000.0);\nvec3 XYZ = xyY_to_XYZ(ciex, ciey, cieY);\nreturn max(xyz_to_sRGB(XYZ), 0.0);\n}\n#define GROUND_SKY_SAMPLES 16\nvec3 groundSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE, vec3 radiance, vec3 sunDirection, vec3 sunIlluminance)\n{\nconst int horizSamples = GROUND_SKY_SAMPLES;\nconst int vertSamples = GROUND_SKY_SAMPLES / 2;\nvec3 result = vec3(0.0);\nfor (int horizSampleIdx = 0; horizSampleIdx < horizSamples; horizSampleIdx++) {\nfloat horizSample = float(horizSampleIdx) / float(horizSamples);\nfloat horizAngle = PI2 * horizSample;\nfor (int vertSampleIdx = 0; vertSampleIdx < vertSamples; vertSampleIdx++) {\nfloat vertSample = float(vertSampleIdx) / float(vertSamples);\nfloat y = 1.0 - vertSample;\nfloat x = sqrt(1.0 - y*y) * cos(horizAngle);\nfloat z = -sqrt(1.0 - y*y) * sin(horizAngle);\nvec3 direction = vec3(x, y, z);\nvec3 sampleColor = perezSky(paramA, paramB, paramC, paramD, paramE,\nradiance, sunDirection, direction);\n\nresult += direction.y * sampleColor;\n}\n}\nresult /= float(horizSamples * vertSamples);\nresult += (sunIlluminance * sunDirection.y) / PI;\nreturn result;\n}\nvoid node_phy_sun_sky_env(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,\nvec3 radiance, vec3 sunDirection, vec3 sunIlluminance, vec3 sunLuminance, \nfloat globalIntensity, vec4 groundColor,\nout vec4 outColor) \n{\nvec3 dir = vWorldPosition;\nif (length(dir) == 0.0) {\ndir = vec3(0.0, 0.0, -1.0);\n} else {\ndir = normalize(dir);\n}\nif (dir.y < 0.0) {\noutColor = groundColor * vec4(groundSky(paramA, paramB, paramC, paramD, paramE, radiance, sunDirection, sunIlluminance), 1.0);\n} else {\noutColor = vec4(perezSky(paramA, paramB, paramC, paramD, paramE,\nradiance, sunDirection, dir), 1.0);\n}\noutColor = globalIntensity * outColor;\n}";
var node_reflect_refract_mx_frag = "void node_reflect_refract(sampler2D envMap,\nint reflectMode, const float IOR, const int encoding,\nvec3 normal, out vec4 color)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec;\nif (reflectMode == MAX_ENV_COORDS_REFLECT)\nreflectVec = reflect(cameraToVertex, worldNormal);\nelse {\nfloat refrRatio = 1.0 / IOR;\nreflectVec = refract(cameraToVertex, worldNormal, refrRatio);\n}\nreflectVec = normalize(reflectVec);\ncolor = sampleEquirectangular(envMap, reflectVec, mat3(1.0), encoding);\n}";
var node_reflect_refract_color_mx_frag = "void node_reflect_refract_color(const vec4 colorIn, out vec4 color)\n{\ncolor = vec4(colorIn);\n}";
var node_rgb_multiply_mx_frag = "void node_rgb_multiply(const vec4 color1, const vec4 color2, out vec4 color)\n{\ncolor = color1 * color2;\n}";
var node_rgb_tint_mx_frag = "void node_rgb_tint(const vec4 color, const vec4 red, const vec4 green, const vec4 blue,\nout vec4 outColor)\n{\nmat3 tintMatrix = mat3(red.rgb, green.rgb, blue.rgb);\noutColor = vec4(tintMatrix * color.rgb, color.a);\n}";
var node_rgb_mx_frag = "uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}";
var node_shellac_mx_frag = "void node_shellac(const vec4 color1, const vec4 color2, const float amount,\nout vec4 color)\n{\ncolor = mix(color1, color2, clamp(amount, 0.0, 1.0));\n}";
var node_sub_transform_mx_frag = "#define COORD_WORLD_SPACE 0\n#define COORD_OBJECT_SPACE 1\nvoid node_sub_transform(\nconst int coordSpace,\nvec3 scale, vec3 rotate, vec3 offset,\nout vec3 outVector, out vec3 outNormal)\n{\nvec3 norm = vNormal;\nnorm = (invViewMatrix * vec4(norm, 0.0)).xyz;\nvec3 vector = vWorldPosition.xyz;\nif (coordSpace == COORD_OBJECT_SPACE) {\nvector = (invModelMatrix * vec4(vector, 1.0)).xyz;\nnorm = (invModelMatrix * vec4(norm, 0.0)).xyz;\n}\nvector -= swizzleUpY(offset.xyz);\nvector *= scale.xzy;\nmat3 rotX90 = mat3RotateX(PI * 0.5);\nmat3 rotX = mat3RotateX(radians(rotate.x));\nmat3 rotY = mat3RotateY(radians(-rotate.y));\nmat3 rotZ = mat3RotateZ(radians(rotate.z));\nmat3 rotMat = rotX * rotY * rotZ * rotX90;\nvector = rotMat * vector;\nnorm = rotMat * norm;\noutVector = vector;\noutNormal = normalize(norm);\n}";
var node_value_mx_frag = "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float value, out float outValue)\n{\noutValue = value;\n}";
var node_vertex_color_mx_frag = "void node_vertex_color(vec3 color, out vec4 outColor)\n{\noutColor = vec4(color, 1.0);\n}";
var node_add_double_linear_my_frag = "void node_add_double_linear(\nfloat input1, float input2,\nout float outValue) {\noutValue = input1 + input2;\n}";
var node_add_matrix_my_frag = "void node_add_matrix(\nmat4 matrixIn1,\nout mat4 matrixSum)\n{\nmatrixSum = matrixIn1;\n}\nvoid node_add_matrix(\nmat4 matrixIn1, mat4 matrixIn2,\nout mat4 matrixSum)\n{\nmatrixSum = matrixIn1 + matrixIn2;\n}\nvoid node_add_matrix(\nmat4 matrixIn1, mat4 matrixIn2, mat4 matrixIn3,\nout mat4 matrixSum)\n{\nmatrixSum = matrixIn1 + matrixIn2 + matrixIn3;\n}";
var node_anim_curve_ta_my_frag = "#ifndef NODE_VALUE\nuniform float nodeValue[NODE_VALUE_NUM];\n#endif\nvoid node_anim_curve_ta(float val, out float outVal)\n{\noutVal = val;\n}";
var node_anim_curve_tu_my_frag = "#ifndef NODE_VALUE\nuniform float nodeValue[NODE_VALUE_NUM];\n#endif\nvoid node_anim_curve_tu(float val, out float outVal)\n{\noutVal = val;\n}";
var node_blend_colors_my_frag = "void node_blend_colors(float blender, vec3 color1, vec3 color2, out vec3 outColor)\n{\nblender = clamp(blender, 0.0, 1.0);\noutColor = mix(color1, color2, 1.0 - blender);\n}\nvoid node_blend_colors(float blender, vec4 color1, vec4 color2, out vec4 outColor)\n{\nblender = clamp(blender, 0.0, 1.0);\noutColor = mix(color1, color2, 1.0 - blender);\n}";
var node_blinn_my_frag = "void node_blinn(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,\nfloat eccentricity, vec3 specularColor, float specularRollOff, float translucence,\nvec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color;\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.roughness = max(eccentricity, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\nmaterial.specularColor = specularColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);\n}";
var node_bulge_my_frag = "void node_bulge(\nfloat uWidth, float vWidth, vec2 uvCoord,\nout float outAlpha, out vec3 outColor) {\nuvCoord = 2.0 * fract(uvCoord); \nfloat bulge = 0.0;\nif (uvCoord.x > uWidth && uvCoord.x < 2.0 - uWidth &&\nuvCoord.y > vWidth && uvCoord.y < 2.0 - vWidth) {\nuvCoord.x = (uvCoord.x - uWidth) / (1.0 - uWidth);\nuvCoord.y = (uvCoord.y - vWidth) / (1.0 - vWidth);\nbulge = uvCoord.x * (2.0 - uvCoord.x) * uvCoord.y * (2.0 - uvCoord.y);\n}\noutAlpha = bulge; \noutColor = vec3(bulge, bulge, bulge); \n}";
var node_bump_2d_my_frag = "void node_bump_2d(\nvec3 normal,\nfloat bumpDepth, float bumpValue,\nout vec3 outNormal) {\nvec3 position = vViewPosition;\nvec3 dPdx = dFdx(position);\nvec3 dPdy = dFdy(position);\nfloat dHdx = dFdx(bumpValue);\nfloat dHdy = dFdy(bumpValue);\nvec3 tanX = cross(dPdy, normal);\nvec3 tanY = cross(normal, dPdx);\nvec3 surfaceGrad = dHdx * tanX + dHdy * tanY;\nfloat dotPosTanX = dot(dPdx, tanX);\noutNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * sign(dotPosTanX));\noutNormal = normalize(mix(normal, outNormal, max(0.0, bumpDepth)));\n}\nvoid node_bump_2d(\nvec3 normal, vec4 tangent,\nfloat bumpDepth, vec3 bumpValue,\nout vec3 outNormal) {\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nif (length(tangent.xyz) == 0.0)\ntangent.x = 1.0;\nvec3 normalTex = (bumpValue.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\noutNormal = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent\n+ normalTex.z * normal);\noutNormal = mix(normal, outNormal, bumpDepth);\n}";
var node_channels_my_frag = "void node_channels(\nint channelR, int channelG, int channelB, int channelA,\nfloat inAlpha, vec3 inColor,\nout float outAlpha, out vec3 outColor) {\noutAlpha = 1.0;\noutColor = vec3(1.0);\nif (channelR == 0)\noutColor.r = inColor.r;\nelse if (channelR == 1)\noutColor.r = inColor.g;\nelse if (channelR == 2)\noutColor.r = inColor.b;\nelse\noutColor.r = inAlpha;\nif (channelG == 0)\noutColor.g = inColor.r;\nelse if (channelG == 1)\noutColor.g = inColor.g;\nelse if (channelG == 2)\noutColor.g = inColor.b;\nelse\noutColor.g = inAlpha;\nif (channelB == 0)\noutColor.b = inColor.r;\nelse if (channelB == 1)\noutColor.b = inColor.g;\nelse if (channelB == 2)\noutColor.b = inColor.b;\nelse\noutColor.b = inAlpha;\nif (channelA == 0)\noutAlpha = inColor.r;\nelse if (channelA == 1)\noutAlpha = inColor.g;\nelse if (channelA == 2)\noutAlpha = inColor.b;\nelse\noutAlpha = inAlpha;\n}";
var node_checker_my_frag = "void node_checker(\nvec3 color1, vec3 color2, float contrast, vec2 uvCoord,\nout float outAlpha, out vec3 outColor) {\nuvCoord -= floor(uvCoord); \nvec3 deltaColor = color2 - color1;\ncolor1 += (1.0 - contrast) * 0.5 * deltaColor;\ncolor2 -= (1.0 - contrast) * 0.5 * deltaColor;\nif ((uvCoord.x < 0.5 && uvCoord.y >= 0.5) || (uvCoord.x >= 0.5 && uvCoord.y < 0.5)) { \noutColor = color2; \noutAlpha = 1.0; \n} else {\noutColor = color1; \noutAlpha = 0.0; \n}\n}";
var node_clamp_my_frag = "void node_clamp(\nvec3 inputValue, vec3 maxValue, vec3 minValue,\nout vec3 outputValue) {\noutputValue = clamp(inputValue, minValue, maxValue);\n}";
var node_cloth_my_frag = "void node_cloth(\nfloat brightSpread, vec3 gapColor, float randomness, vec3 uColor, float uWave, float uWidth,\nvec3 vColor, float vWave, float vWidth, float widthSpread, vec2 uvCoord,\nout float outAlpha, out vec3 outColor) {\nif (abs(uWave) > -EPSILON || abs(vWave) > -EPSILON) {\nuvCoord.x += - uWave * sin(PI2 * uvCoord.y);\nuvCoord.y += vWave * sin(PI2 * uvCoord.x);\n}\nuvCoord = fract(uvCoord);\nint thread = 0;\nif ((uvCoord.x >= 0.5 && uvCoord.y < 0.5) || (uvCoord.x < 0.5 && uvCoord.y >= 0.5)) {\nfloat flippedCoord;\nflippedCoord = uvCoord.x;\nuvCoord.x = uvCoord.y;\nuvCoord.y = flippedCoord;\nflippedCoord = uWidth;\nuWidth = vWidth;\nvWidth = flippedCoord;\nthread = 1;\n}\nuvCoord = fract(2.0 * uvCoord);\nfloat cloth = 1.0;\nif (uvCoord.y <= vWidth) {\nfloat clothU = uvCoord.x - 0.5 * uWidth;\nfloat clothV = 2.0 * uvCoord.y / vWidth - 1.0;\ncloth = 0.75 * (clothU * clothU + clothV * clothV);\n} else if (uvCoord.x <= uWidth) {\nfloat clothU = 2.0 * uvCoord.x / uWidth - 1.0;\nfloat clothV = uvCoord.y - 0.5 * vWidth - 1.0;\ncloth = 0.75 * (clothU * clothU + clothV * clothV);\nthread = 1 - thread;\n}\noutColor = gapColor;\nif (cloth < 1.0) {\ncloth = 1.0 - cloth;\ncloth = min(cloth, 1.0);\noutColor *= (1.0 - cloth);\nvec3 threadColor = uColor;\nif (thread == 0)\nthreadColor = vColor;\noutColor += threadColor * cloth;\n}\noutAlpha = dot(outColor, LUM_WEIGHTS_MAYA);\n}";
var node_color_condition_my_frag = "void node_color_condition(\nfloat alphaA, float alphaB, vec3 colorA, vec3 colorB, bool condition,\nout float outAlpha, out vec3 outColor) {\noutAlpha = condition ? alphaA : alphaB;\noutColor = condition ? colorA : colorB;\n}";
var node_color_composite_my_frag = "void node_color_composite(int operation,\nvec3 colorA, float alphaA, vec3 colorB, float alphaB, float factor,\nout vec3 outColor, out float outAlpha)\n{\nif (factor <= 0.0) {\noutColor = colorA;\noutAlpha = alphaA;\nreturn;\n}\nif (operation == 0) {\noutColor[0] = colorA[0] + (colorB[0] * factor);\noutColor[1] = colorA[1] + (colorB[1] * factor);\noutColor[2] = colorA[2] + (colorB[2] * factor);\noutAlpha = alphaA + (alphaB * factor);\n} else if (operation == 1) {\noutColor[0] = colorA[0] + ((colorB[0] - 1.0) * factor);\noutColor[1] = colorA[1] + ((colorB[1] - 1.0) * factor);\noutColor[2] = colorA[2] + ((colorB[2] - 1.0) * factor);\noutAlpha = alphaA + ((alphaB - 1.0) * factor);\n} else if (operation == 2) {\nif (factor >= 1.0) {\noutColor = colorB;\noutAlpha = alphaB;\nreturn;\n}\noutColor[0] = mix(colorA[0], colorB[0], factor);\noutColor[1] = mix(colorA[1], colorB[1], factor);\noutColor[2] = mix(colorA[2], colorB[2], factor);\noutAlpha = mix(alphaA, alphaB, factor);\n} else if (operation == 3) {\noutColor[0] = colorA[0] * (colorB[0] * factor + (1.0 - factor));\noutColor[1] = colorA[1] * (colorB[1] * factor + (1.0 - factor));\noutColor[2] = colorA[2] * (colorB[2] * factor + (1.0 - factor));\noutAlpha = alphaA * (alphaB * factor + (1.0 - factor));\n} else if (operation == 4) {\noutColor[0] = 1.0 - ((1.0 - colorA[0]) * (1.0 - colorB[0] * factor));\noutColor[1] = 1.0 - ((1.0 - colorA[1]) * (1.0 - colorB[1] * factor));\noutColor[2] = 1.0 - ((1.0 - colorA[2]) * (1.0 - colorB[2] * factor));\noutAlpha = 1.0 - ((1.0 - alphaA) * (1.0 - alphaB * factor));\n} else if (operation == 5) {\noutColor[0] = colorB[0] > 0.5 ? (2.0 * colorA[0] * colorB[0] * factor) + colorA[0] * (1.0 - factor) :\n1.0 - ((1.0 - colorA[0]) * (1.0 - colorB[0] * factor)) * (2.0 - (1.0 - factor));\noutColor[1] = colorB[1] > 0.5 ? (2.0 * colorA[1] * colorB[1] * factor) + colorA[1] * (1.0 - factor) :\n1.0 - ((1.0 - colorA[1]) * (1.0 - colorB[1] * factor)) * (2.0 - (1.0 - factor));\noutColor[2] = colorB[2] > 0.5 ? (2.0 * colorA[2] * colorB[2] * factor) + colorA[2] * (1.0 - factor) :\n1.0 - ((1.0 - colorA[2]) * (1.0 - colorB[2] * factor)) * (2.0 - (1.0 - factor));\noutAlpha = alphaB > 0.5 ? (2.0 * alphaA * alphaB * factor) + alphaA * (1.0 - factor) :\n1.0 - ((1.0 - alphaA) * (1.0 - alphaB * factor)) * (2.0 - (1.0 - factor));\n} else if (operation == 6) {\noutColor[0] = abs(colorA[0] - (colorB[0] * factor));\noutColor[1] = abs(colorA[1] - (colorB[1] * factor));\noutColor[2] = abs(colorA[2] - (colorB[2] * factor));\noutAlpha = abs(alphaA - (alphaB * factor));\n} else if (operation == 7) {\noutColor[0] = clamp(mix(colorA[0], colorA[0] / max(1.0 - colorB[0], 0.00001), factor), colorA[0], colorB[0]);\noutColor[1] = clamp(mix(colorA[1], colorA[1] / max(1.0 - colorB[1], 0.00001), factor), colorA[1], colorB[1]);\noutColor[2] = clamp(mix(colorA[2], colorA[2] / max(1.0 - colorB[2], 0.00001), factor), colorA[2], colorB[2]);\noutAlpha = clamp(mix(alphaA, alphaA / max(1.0 - alphaB, 0.00001), factor), alphaA, alphaB);\n} else if (operation == 8) {\noutColor[0] = clamp(mix(colorA[0], 1.0 - (colorA[0] / max(1.0 - colorB[0], 0.00001)), factor), colorA[0], colorB[0]);\noutColor[1] = clamp(mix(colorA[1], 1.0 - (colorA[1] / max(1.0 - colorB[1], 0.00001)), factor), colorA[1], colorB[1]);\noutColor[2] = clamp(mix(colorA[2], 1.0 - (colorA[2] / max(1.0 - colorB[2], 0.00001)), factor), colorA[2], colorB[2]);\noutAlpha = clamp(mix(alphaA, 1.0 - (alphaA / max(1.0 - alphaB, 0.00001)), factor), alphaA, alphaB);\n}\n}";
var node_color_constant_my_frag = "void node_color_constant(vec3 inColor, float inAlpha, out vec3 outColor, out float outAlpha)\n{\noutColor = inColor;\noutAlpha = inAlpha;\n}";
var node_color_correct_my_frag = "void node_color_correct(\nbool colClamp, vec3 colClampMin, vec3 colClampMax,\nbool alphaClamp, float alphaClampMin, float alphaClampMax,\nbool unpremultInput, bool premultResult,\nfloat alphaGain, float alphaGamma, float alphaOffset,\nvec3 colGain, vec3 colGamma, vec3 colOffset, float hueShift,\nfloat inAlpha, vec3 inColor, float satGain, float valGain,\nout float outAlpha, out vec3 outColor)\n{\noutColor = unpremultInput ? inColor/inAlpha : inColor;\nif (hueShift != 0.0 || satGain != 1.0 || valGain != 1.0) {\nvec4 color = vec4(outColor, 1.0);\nrgbToHSV(vec4(inColor, 1.0), color);\ncolor.r += hueShift / 360.0;\nif (color.r > 1.0)\ncolor.r -= 1.0;\nelse if (color.r < 0.0)\ncolor.r += 1.0;\ncolor.g *= satGain;\ncolor.b *= valGain;\nhsvToRGB(color, color);\noutColor = color.rgb;\n}\noutColor *= colGain;\noutColor += colOffset;\nif (any(notEqual(colGamma, vec3(1.0))))\noutColor = pow(outColor, 1.0 / colGamma);\nif (colClamp)\noutColor = clamp(outColor, colClampMin, colClampMax);\noutAlpha = inAlpha * alphaGain;\noutAlpha += alphaOffset;\nif (alphaGamma != 1.0)\noutAlpha = pow(outAlpha, 1.0 / alphaGamma);\nif (alphaClamp)\noutAlpha = clamp(outAlpha, alphaClampMin, alphaClampMax);\nif (premultResult)\noutColor *= outAlpha;\n}";
var node_color_logic_my_frag = "void node_color_logic(\nint operation,\nvec3 colorA, vec3 colorB,\nout bool outBool) {\nif (operation == 0) {\noutBool = all(equal(colorA, colorB));\n} else if (operation == 1) {\noutBool = any(notEqual(colorA, colorB));\n} else if (operation == 2) {\noutBool = ((colorA.x + colorA.y + colorA.z) < (colorB.x + colorB.y + colorB.z));\n} else if (operation == 3) {\noutBool = ((colorA.x + colorA.y + colorA.z) > (colorB.x + colorB.y + colorB.z));\n} else if (operation == 4) {\noutBool = ((colorA.x + colorA.y + colorA.z) <= (colorB.x + colorB.y + colorB.z));\n} else {\noutBool = ((colorA.x + colorA.y + colorA.z) >= (colorB.x + colorB.y + colorB.z));\n}\n}";
var node_color_mask_my_frag = "void node_color_mask(\nbool maskAlphaIsLuminance,\nfloat inAlpha, vec3 inColor, vec3 mask, float maskAlpha,\nout float outAlpha, out vec3 outColor) {\nif (maskAlphaIsLuminance)\nmaskAlpha = 1.0 - dot(mask, LUM_WEIGHTS_MAYA);\noutColor = inColor * (1.0 - maskAlpha);\n}";
var node_color_math_my_frag = "void node_color_math(\nint operation,\nfloat alphaA, float alphaB, vec3 colorA, vec3 colorB,\nout float outAlpha, out vec3 outColor) {\nif (operation == 0) {\noutColor = colorA + colorB;\noutAlpha = alphaA + alphaB;\n} else if (operation == 1) {\noutColor = colorA - colorB;\noutAlpha = alphaA - alphaB;\n} else if (operation == 2) {\noutColor = colorA * colorB;\noutAlpha = alphaA * alphaB;\n} else if (operation == 3) {\noutColor = colorA / colorB;\noutAlpha = alphaA / alphaB;\n} else if (operation == 4) {\noutColor = min(colorA, colorB);\noutAlpha = min(alphaA, alphaB);\n} else {\noutColor = max(colorA, colorB);\noutAlpha = max(alphaA, alphaB);\n}\n}";
var node_compose_matrix_my_frag = "mat3 quatToMat3(vec4 quat) {\nfloat x = quat.x,\ny = quat.y,\nz = quat.z,\nw = quat.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\n\nfloat xx = x * x2;\nfloat yx = y * x2;\nfloat yy = y * y2;\nfloat zx = z * x2;\nfloat zy = z * y2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\n\nmat3 mat;\n\nmat[0][0] = 1.0 - yy - zz;\nmat[1][0] = yx - wz;\nmat[2][0] = zx + wy;\n\nmat[0][1] = yx + wz;\nmat[1][1] = 1.0 - xx - zz;\nmat[2][1] = zy - wx;\n\nmat[0][2] = zx - wy;\nmat[1][2] = zy + wx;\nmat[2][2] = 1.0 - xx - yy;\nreturn mat;\n}\nvoid node_compose_matrix(\nbool useEulerRotation, int inputRotateOrder,\nvec4 inputQuat, vec3 inputRotate, vec3 inputScale, vec3 inputShear, vec3 inputTranslate,\nout mat4 outputMatrix)\n{\nmat4 rotateMatrix;\ninputRotate = radians(inputRotate);\nif (useEulerRotation)\nrotateMatrix = toMat4(mat3RotateX(inputRotate.x) * mat3RotateY(inputRotate.y) * mat3RotateZ(inputRotate.z));\nelse\nrotateMatrix = toMat4(quatToMat3(normalize(inputQuat)));\nmat4 scaleMatrix = mat4(inputScale.x, 0.0, 0.0, 0.0,\n0.0, inputScale.y, 0.0, 0.0,\n0.0, 0.0, inputScale.z, 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 shearMatrix = mat4(1.0, 0.0, 0.0, 0.0,\ninputShear.x, 1.0, 0.0, 0.0,\ninputShear.y, inputShear.z, 1.0, 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 transMatrix = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0,\n0.0, 0.0, 1.0, 0.0,\ninputTranslate.x, inputTranslate.y, inputTranslate.z, 1.0);\noutputMatrix = scaleMatrix * shearMatrix * rotateMatrix * transMatrix;\n}";
var node_condition_my_frag = "void node_condition(\nint operation,\nvec3 colorIfFalse, vec3 colorIfTrue, float firstTerm, float secondTerm,\nout vec3 outColor) {\nif (operation == 0) {\nif (firstTerm == secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 1) {\nif (firstTerm != secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 2) {\nif (firstTerm > secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 3) {\nif (firstTerm >= secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 4) {\nif (firstTerm < secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 5) {\nif (firstTerm <= secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n}\n}";
var node_decompose_matrix_my_frag = "vec4 mat3ToQuat(mat3 m) {\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 q = vec4(0.0, 0.0, 0.0, 0.0);\nif (trace > 0.0) {\nfloat s = sqrt(trace + 1.0) * 2.0;\nq.w = 0.25 * s;\nq.x = (m[2][1] - m[1][2]) / s;\nq.y = (m[0][2] - m[2][0]) / s;\nq.z = (m[1][0] - m[0][1]) / s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2.0;\nq.w = (m[2][1] - m[1][2]) / s;\nq.x = 0.25 * s;\nq.y = (m[0][1] + m[1][0]) / s;\nq.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2.0;\nq.w = (m[0][2] - m[2][0]) / s;\nq.x = (m[0][1] + m[1][0]) / s;\nq.y = 0.25 * s;\nq.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2.0;\nq.w = (m[1][0] - m[0][1]) / s;\nq.x = (m[0][2] + m[2][0]) / s;\nq.y = (m[1][2] + m[2][1]) / s;\nq.z = 0.25 * s;\n}\nreturn q;\n}\nvec3 mat3ToEuler(mat3 m) {\nfloat m11 = m[0][0], m12 = m[1][0], m13 = m[2][0];\nfloat m21 = m[0][1], m22 = m[1][1], m23 = m[2][1];\nfloat m31 = m[0][2], m32 = m[1][2], m33 = m[2][2];\nvec3 euler;\neuler.y = asin(clamp(m13, -1.0, 1.0));\nif (abs(m13) < 0.9999999) {\neuler.x = atan(-m23, m33);\neuler.z = atan(-m12, m11);\n} else {\neuler.x = atan(m32, m22);\neuler.z = 0.0;\n}\nreturn euler;\n}\nvoid decomposeMat4(mat4 m, out vec3 position, out vec4 quat, out vec3 euler, out vec3 scale) {\nfloat sx = length(vec3(m[0][0], m[0][1], m[0][2]));\nfloat sy = length(vec3(m[1][0], m[1][1], m[1][2]));\nfloat sz = length(vec3(m[2][0], m[2][1], m[2][2]));\nfloat det = mat3GetDeterminant(toMat3(m));\nif (det < 0.0)\nsx = -sx;\nposition.x = m[3][0];\nposition.y = m[3][1];\nposition.z = m[3][2];\nfloat invSX = 1.0 / sx;\nfloat invSY = 1.0 / sy;\nfloat invSZ = 1.0 / sz;\nm[0][0] *= invSX;\nm[0][1] *= invSX;\nm[0][2] *= invSX;\nm[1][0] *= invSY;\nm[1][1] *= invSY;\nm[1][2] *= invSY;\nm[2][0] *= invSZ;\nm[2][1] *= invSZ;\nm[2][2] *= invSZ;\nquat = mat3ToQuat(toMat3(m));\neuler = mat3ToEuler(toMat3(m));\nscale.x = sx;\nscale.y = sy;\nscale.z = sz;\n}\nvoid node_decompose_matrix(\nmat4 inputMatrix,\nout vec4 outputQuat, out vec3 outputRotate, out vec3 outputScale, out vec3 outputShear, out vec3 outputTranslate)\n{\ndecomposeMat4(inputMatrix, outputTranslate, outputQuat, outputRotate, outputScale);\noutputShear = vec3(0.0, 0.0, 0.0);\n}";
var node_env_sphere_my_frag = "void node_env_sphere(sampler2D envMap, int encoding, vec3 normal,\nmat4 placementMatrix,\nout float outAlpha, out vec3 outColor)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec = normalize(cameraToVertex);\n#else\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nreflectVec = reflect(cameraToVertex, worldNormal);\n#endif\nmat3 uvTransform = mat3(1.0);\nreflectVec = toMat3(placementMatrix) * reflectVec;\nvec4 tex = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\noutAlpha = tex.a;\noutColor = tex.rgb;\n}";
var node_file_my_frag = "void node_file(sampler2D ima, const int encoding, const bool rgbToAlpha,\nvec2 uvCoord,\nout float outAlpha, out vec3 outColor, out vec2 outSize, out vec3 outTransparency) {\nvec2 uv = vec2(uvCoord.x, 1.0 - uvCoord.y);\nvec4 tex = texture2D(ima, uv);\noutColor = nodeTexelToLinear(tex, encoding).rgb;\nif (rgbToAlpha)\noutAlpha = dot(tex.rgb, LUM_WEIGHTS_MAYA);\nelse\noutAlpha = tex.a;\noutSize = vec2(0.0);\noutTransparency = vec3(1.0 - outAlpha, 1.0 - outAlpha, 1.0 - outAlpha);\n}";
var node_float_condition_my_frag = "void node_float_condition(\nbool condition, float floatA, float floatB, \nout float outFloat) {\noutFloat = condition ? floatA : floatB;\n}";
var node_float_composite_my_frag = "void node_float_composite(int operation,\nfloat floatA, float floatB, float factor,\nout float outFloat)\n{\nif (factor <= 0.0) {\noutFloat = floatA;\nreturn;\n}\nif (operation == 0) {\noutFloat = floatA + (floatB * factor);\n} else if (operation == 1) {\noutFloat = floatA + ((floatB - 1.0) * factor);\n} else if (operation == 2) {\nif (factor >= 1.0) {\noutFloat = floatB;\nreturn;\n}\noutFloat = mix(floatA, floatB, factor);\n} else if (operation == 3) {\noutFloat = floatA * (floatB * factor + (1.0 - factor));\n} else if (operation == 4) {\noutFloat = 1.0 - ((1.0 - floatA) * (1.0 - floatB * factor));\n} else if (operation == 5) {\noutFloat = floatB > 0.5 ? (2.0 * floatA * floatB * factor) + floatA * (1.0 - factor) :\n1.0 - ((1.0 - floatA) * (1.0 - floatB * factor)) * (2.0 - (1.0 - factor));\n} else if (operation == 6) {\noutFloat = abs(floatA - (floatB * factor));\n} else if (operation == 7) {\noutFloat = clamp(mix(floatA, floatA / max(1.0 - floatB, 0.00001), factor), floatA, floatB);\n} else if (operation == 8) {\noutFloat = clamp(mix(floatA, 1.0 - (floatA / max(1.0 - floatB, 0.00001)), factor), floatA, floatB);\n}\n}";
var node_float_constant_my_frag = "void node_float_constant(float value, out float outValue)\n{\noutValue = value;\n}";
var node_float_logic_my_frag = "void node_float_logic(\nint operation,\nfloat floatA, float floatB,\nout bool outBool) {\nif (operation == 0) {\noutBool = (floatA == floatB);\n} else if (operation == 1) {\noutBool = (floatA != floatB);\n} else if (operation == 2) {\noutBool = (floatA < floatB);\n} else if (operation == 3) {\noutBool = (floatA > floatB);\n} else if (operation == 4) {\noutBool = (floatA <= floatB);\n} else {\noutBool = (floatA >= floatB);\n}\n}";
var node_float_mask_my_frag = "void node_float_mask(\nfloat inFloat, float mask,\nout float outFloat) {\noutFloat = inFloat - mask;\n}";
var node_float_math_my_frag = "void node_float_math(\nint operation,\nfloat floatA, float floatB,\nout float outFloat) {\nif (operation == 0) {\noutFloat = floatA + floatB;\n} else if (operation == 1) {\noutFloat = floatA - floatB;\n} else if (operation == 2) {\noutFloat = floatA * floatB;\n} else if (operation == 3) {\noutFloat = floatA / floatB;\n} else if (operation == 4) {\noutFloat = min(floatA, floatB);\n} else if (operation == 5) {\noutFloat = max(floatA, floatB);\n} else {\noutFloat = pow(floatA, floatB);\n}\n}";
var node_four_by_four_matrix_my_frag = "void node_four_by_four_matrix(\nfloat in00, float in01, float in02, float in03,\nfloat in10, float in11, float in12, float in13,\nfloat in20, float in21, float in22, float in23,\nfloat in30, float in31, float in32, float in33,\nout mat4 outMatrix)\n{\noutMatrix = mat4(in00, in01, in02, in03,\nin10, in11, in12, in13,\nin20, in21, in22, in23,\nin30, in31, in32, in33);\n}";
var node_gamma_correct_my_frag = "void node_gamma_correct(\nvec3 gamma, vec3 value,\nout vec3 outValue) {\noutValue = pow(value, 1.0 / gamma);\n}";
var node_grid_my_frag = "void node_grid(\nfloat contrast, vec3 fillerColor, vec3 lineColor, float uWidth, float vWidth, vec2 uvCoord,\nout float outAlpha, out vec3 outColor) {\nuvCoord = fract(uvCoord); \nfloat v0 = max(uvCoord.y, 0.5 * vWidth);\nfloat v1 = min(uvCoord.y, 1.0 - 0.5 * vWidth);\nfloat u0 = max(uvCoord.x, 0.5 * uWidth);\nfloat u1 = min(uvCoord.x, 1.0 - 0.5 * uWidth);\nfloat gridFactor = (v0 <= v1 && u0 <= u1) ? 1.0 : 0.0;\ngridFactor = 0.5 - contrast * (gridFactor - 0.5);\ngridFactor = max(gridFactor, 0.0);\nvec3 gridColor = mix(fillerColor, lineColor, gridFactor); \ngridColor.r = max(gridColor.r, 0.0);\ngridColor.g = max(gridColor.g, 0.0);\ngridColor.b = max(gridColor.b, 0.0);\noutAlpha = saturate(gridFactor); \noutColor = gridColor; \n}";
var node_inverse_matrix_my_frag = "\nmat4 inverseMat4(mat4 m) {\nfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\na10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\na20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\na30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\nfloat b00 = a00 * a11 - a01 * a10,\nb01 = a00 * a12 - a02 * a10,\nb02 = a00 * a13 - a03 * a10,\nb03 = a01 * a12 - a02 * a11,\nb04 = a01 * a13 - a03 * a11,\nb05 = a02 * a13 - a03 * a12,\nb06 = a20 * a31 - a21 * a30,\nb07 = a20 * a32 - a22 * a30,\nb08 = a20 * a33 - a23 * a30,\nb09 = a21 * a32 - a22 * a31,\nb10 = a21 * a33 - a23 * a31,\nb11 = a22 * a33 - a23 * a32;\nfloat det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\nreturn mat4(a11 * b11 - a12 * b10 + a13 * b09,\na02 * b10 - a01 * b11 - a03 * b09,\na31 * b05 - a32 * b04 + a33 * b03,\na22 * b04 - a21 * b05 - a23 * b03,\na12 * b08 - a10 * b11 - a13 * b07,\na00 * b11 - a02 * b08 + a03 * b07,\na32 * b02 - a30 * b05 - a33 * b01,\na20 * b05 - a22 * b02 + a23 * b01,\na10 * b10 - a11 * b08 + a13 * b06,\na01 * b08 - a00 * b10 - a03 * b06,\na30 * b04 - a31 * b02 + a33 * b00,\na21 * b02 - a20 * b04 - a23 * b00,\na11 * b07 - a10 * b09 - a12 * b06,\na00 * b09 - a01 * b07 + a02 * b06,\na31 * b01 - a30 * b03 - a32 * b00,\na20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvoid node_inverse_matrix(\nmat4 inputMatrix,\nout mat4 outputMatrix)\n{\noutputMatrix = inverseMat4(inputMatrix);\n}";
var node_lambert_my_frag = "void node_lambert(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float translucence, vec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Direct RE_DirectDiffuseOnly_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + incandescence, alpha);\n}";
var node_layered_texture_layer_my_frag = "#define LAYER_BLEND_MODE_NONE 0.0\n#define LAYER_BLEND_MODE_OVER 1.0\n#define LAYER_BLEND_MODE_IN 2.0\n#define LAYER_BLEND_MODE_OUT 3.0\n#define LAYER_BLEND_MODE_ADD 4.0\n#define LAYER_BLEND_MODE_SUBTRACT 5.0\n#define LAYER_BLEND_MODE_MULTIPLY 6.0\n#define LAYER_BLEND_MODE_DIFFERENCE 7.0\n#define LAYER_BLEND_MODE_LIGHTEN 8.0\n#define LAYER_BLEND_MODE_DARKEN 9.0\n#define LAYER_BLEND_MODE_SATURATE 10.0\n#define LAYER_BLEND_MODE_DESATURATE 11.0\n#define LAYER_BLEND_MODE_ILLUMINATE 12.0\nvoid node_layered_texture_layer(\nconst float alphaBG, const vec3 colorBG, \nconst vec3 color, const float alpha, const float blendMode, const bool isVisible,\nout float outAlpha, out vec3 outColor)\n{\noutAlpha = alphaBG;\noutColor = colorBG;\nif (!isVisible)\nreturn;\nif (blendMode == LAYER_BLEND_MODE_NONE) {\noutColor = color;\n} else if (blendMode == LAYER_BLEND_MODE_OVER) {\noutColor = mix(colorBG, color, alpha);\n} else if (blendMode == LAYER_BLEND_MODE_IN) {\noutColor = alpha * colorBG;\n} else if (blendMode == LAYER_BLEND_MODE_OUT) {\noutColor = (1.0 - alpha) * colorBG;\n} else if (blendMode == LAYER_BLEND_MODE_ADD) {\noutColor = mix(colorBG, colorBG + color, alpha);\n} else if (blendMode == LAYER_BLEND_MODE_SUBTRACT) {\noutColor = mix(colorBG, colorBG - color, alpha);\n} else if (blendMode == LAYER_BLEND_MODE_MULTIPLY) {\noutColor = mix(colorBG, colorBG * color, alpha);\n} else {\noutColor = mix(colorBG, color, alpha);\n}\n}";
var node_luminance_my_frag = "void node_luminance(\nvec3 value,\nout float outValue) {\noutValue = dot(value, LUM_WEIGHTS_MAYA);\n}";
var node_multiply_divide_my_frag = "void node_multiply_divide(\nint operation,\nvec3 input1, vec3 input2,\nout vec3 outValue) {\nif (operation == 0) {\noutValue = input1;\n} else if (operation == 1) {\noutValue = input1 * input2;\n} else if (operation == 2) {\n\noutValue = input1 / input2;\n} else {\noutValue = pow(input1, input2);\n}\n}";
var node_mult_double_linear_my_frag = "void node_mult_double_linear(\nfloat input1, float input2,\nout float outValue) {\noutValue = input1 * input2;\n}";
var node_mult_matrix_my_frag = "\nvoid node_mult_matrix(\nmat4 matrixIn1,\nout mat4 matrixSum)\n{\nmatrixSum = matrixIn1;\n}\nvoid node_mult_matrix(\nmat4 matrixIn1, mat4 matrixIn2,\nout mat4 matrixSum)\n{\nmatrixSum = matrixIn2 * matrixIn1;\n}\nvoid node_mult_matrix(\nmat4 matrixIn1, mat4 matrixIn2, mat4 matrixIn3,\nout mat4 matrixSum)\n{\nmatrixSum = matrixIn3 * matrixIn2 * matrixIn1;\n}";
var node_noise_my_frag = "vec2 calcNoiseImplode(float implode, vec2 implodeCenter, vec2 uv) {\nif (abs(implode) >= EPSILON) {\nuv -= implodeCenter;\nfloat len = length(uv);\nif (len > EPSILON) {\nfloat factor = pow(len, 1.0-implode) / len;\nuv *= factor;\n}\nuv += implodeCenter;\n}\nreturn uv;\n}\nvoid node_noise(\nfloat amplitude, int depthMax, float frequency, float frequencyRatio, float implode,\nvec2 implodeCenter, bool inflection, float ratio, float threshold, float time, vec2 uvCoord,\nout float outAlpha, out vec3 outColor) {\nuvCoord = calcNoiseImplode(implode, implodeCenter, uvCoord);\nfrequency *= 0.6;\namplitude *= 0.9;\nuvCoord *= frequency;\nfloat noiseAccum = 0.0;\nvec2 freqOffset = vec2(0.02, 0.3);\n#if __VERSION__ == 300\nfor (int depthId = 0; depthId < depthMax; depthId++) {\n#else\nfor (int depthId = 0; depthId < 3; depthId++) {\n#endif\nint stepVal = depthId;\nfloat noise = noisePerlin(vec3(uvCoord + freqOffset, time + 0.5 * float(stepVal)));\nif (inflection)\nnoise = abs(noise);\nnoiseAccum += amplitude * noise;\nuvCoord *= frequencyRatio;\ntime *= sqrt(frequencyRatio);\namplitude *= ratio;\nfreqOffset += vec2(0.02, 0.3);\n}\nif (!inflection)\nnoiseAccum = 0.5 * noiseAccum + 0.5;\nnoiseAccum += threshold;\noutAlpha = min(1.0, noiseAccum);\noutColor = vec3(outAlpha, outAlpha, outAlpha);\n}";
var node_openpbr_surface_my_frag = "void node_openpbr_surface(\nvec3 geometryNormal, const bool thinWalled,\nconst float baseWeight, const vec3 baseColor, const float baseDiffuseRoughness, const float baseMetalness,\nconst float specularWeight, const vec3 specularColor, const float specularRoughness, const float specularIOR,\nconst float transmissionWeight, const vec3 transmissionColor,\nconst float transmissionDepth, const vec3 transmissionScatter,\nconst float fuzzWeight, const vec3 fuzzColor, const float fuzzRoughness,\nconst float coatWeight, const vec3 coatColor, const float coatRoughness,\nconst float emissionLuminance, const vec3 emissionColor, const float geometryOpacity,\nconst vec3 normal,\nout vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = baseWeight * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - baseMetalness) * (1.0 - transmissionWeight);\nvec3 clearcoatNormal = normal;\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat = saturate(coatWeight);\nmaterial.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);\nmaterial.clearcoatF0 = vec3(0.04);\nmaterial.clearcoatF90 = 1.0;\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = saturate(fuzzWeight * fuzzColor);\nmaterial.sheenRoughness = clamp(fuzzRoughness, 0.0, 1.0);\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.roughness = max(specularRoughness, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\nvec3 specularColorWeighted = specularWeight * specularColor;\nvec3 dielRefl = pow2((1.0 - specularIOR) / (1.0 + specularIOR)) * specularColorWeighted;\nmaterial.specularColor = mix(dielRefl, baseColorWeighted, baseMetalness);\nmaterial.fresnelRefl90 = mix(specularColorWeighted, vec3(1.0), baseMetalness);\nmaterial.specularF90 = average(material.fresnelRefl90);\nmaterial.refractionColor = pow(transmissionWeight * (1.0 - baseMetalness) * transmissionColor.rgb, vec3(2.0));\nmaterial.refractionIOR = specularIOR;\nmaterial.refractionRoughness = material.roughness;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef USE_GTAO\nvec4 gtaoVisibilityBentNormal = texture2D(gtaoMap,\ngl_FragCoord.xy / currResolution);\nvec3 bentNormal = normalize(unpackRGBToNormal(gtaoVisibilityBentNormal.gba));\n#define PROBE_NORMAL bentNormal\n#endif\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef PROBE_NORMAL\n#undef PROBE_NORMAL\n#endif\n#ifdef USE_GTAO\nreflectedLight.indirectDiffuse *= gtaoVisibilityBentNormal.r;\nfloat gtaoVisibility = gtaoVisibilityBentNormal.r;\nvec3 gtaoBentNormal = bentNormal;\nvec3 gtaoViewDir = geometry.viewDir;\nvec3 gtaoNormal = normal;\nfloat gtaoRoughness = material.roughness;\n#endif\n#include <lights_fragment_gtso>\nvec3 totalEmissiveRadiance = emissionLuminance * OPENPBR_EMISSION_LUM_FACTOR * emissionColor;\nvec3 outSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\noutSpecular + totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp = 1.0 - 0.157 * max3(material.sheenColor);\noutColor3 = outColor3 * sheenEnergyComp + sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 Fcc = F_Schlick(material.clearcoatF0, material.clearcoatF90, dotNVcc);\noutColor3 = outColor3 * (1.0 - material.clearcoat * Fcc) + clearcoatSpecular * material.clearcoat;\n#endif\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = geometryOpacity * (1.0 - saturate(transmissionWeight) + maxFromRGB(outSpecular) * saturate(transmissionWeight));\n} else {\noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha));\n}";
var node_output_my_frag = "void node_output(vec4 rgb, out vec4 outgoingLight)\n{\noutgoingLight = rgb;\n}";
var node_phong_my_frag = "void node_phong(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,\nfloat cosinePower, vec3 specularColor, float translucence, vec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color;\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nfloat roughness = sqrt(1.0 / (0.454 * cosinePower + 3.357));\nmaterial.roughness = max(roughness, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\nmaterial.specularColor = specularColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);\n}";
var node_phong_e_my_frag = "void node_phong_e(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,\nfloat highlightSize, float roughness, vec3 specularColor, float translucence, vec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color;\n#ifdef USE_CLEARCOAT\n#undef USE_CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.roughness = max(roughness, 0.0525);\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min(material.roughness, 1.0);\nmaterial.specularColor = specularColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_Direct RE_Direct_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Direct\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define USE_CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);\n}";
var node_place_2d_texture_my_frag = "void node_place_2d_texture(const vec2 inUv,\nvec2 offset, vec2 repeatUv, float rotateUv,\nout vec2 outUv)\n{\noutUv = (calcUvTransform(offset.x, offset.y, repeatUv.x, repeatUv.y, rotateUv) * vec3(inUv, 1.0)).xy;\noutUv.y = 1.0 - outUv.y;\n}";
var node_premultiply_my_frag = "void node_premultiply(\nfloat inAlpha, vec3 inColor,\nout float outAlpha, out vec3 outColor) {\noutColor = inColor * inAlpha;\noutAlpha = inAlpha;\n}";
var node_ramp_my_frag = "#define RAMP_WRAP_REPEAT 1000\n#define RAMP_WRAP_CLAMP_TO_EDGE 1001\n#define RAMP_WRAP_MIRROR 1002\nfloat applyWrap(float coord, int wrap) {\nif (coord < 0.0 || coord > 1.0) {\nif (wrap == RAMP_WRAP_REPEAT)\ncoord = mod(coord, 1.0);\nelse if (wrap == RAMP_WRAP_CLAMP_TO_EDGE)\ncoord = clamp(coord, 0.0, 1.0);\nelse if (wrap == RAMP_WRAP_MIRROR) {\nif (mod(floor(coord), 2.0) == 0.0)\ncoord = coord - floor(coord);\nelse\ncoord = 1.0 - (coord - floor(coord));\n}\n}\nreturn coord;\n}\nvoid node_ramp(\nsampler2D rampData, int rampType, int wrapU, int wrapV,\nvec2 uvCoord,\nout float outAlpha, out vec3 outColor)\n{\nuvCoord.x = applyWrap(uvCoord.x, wrapU);\nuvCoord.y = applyWrap(uvCoord.y, wrapV);\nfloat coord;\nif (rampType == 0) {\ncoord = uvCoord.y;\n} else if (rampType == 1) {\ncoord = uvCoord.x;\n} else if (rampType == 2) {\ncoord = abs(uvCoord.x + uvCoord.y) / 2.0;\n} else if (rampType == 3) {\nvec2 uvSpiral = mat2(0.0, 1.0, 1.0, 0.0) * (uvCoord - vec2(0.5));\ncoord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;\n} else if (rampType == 4) {\ncoord = length(uvCoord - vec2(0.5)) * sqrt(2.0);\n} else if (rampType == 5) {\nvec2 boxUv = abs(uvCoord - vec2(0.5)) * 2.0;\ncoord = max(boxUv.x, boxUv.y);\n} else if (rampType == 6) {\nuvCoord = abs((uvCoord - vec2(0.5)) * 2.0);\ncoord = uvCoord.y;\n} else if (rampType == 7) {\ncoord = uvCoord.y;\n} else {\ncoord = uvCoord.y;\n}\nfloat offset = 0.5 / float(RAMP_TEX_SIZE);\nfloat scale = 1.0 - (1.0 / float(RAMP_TEX_SIZE));\ncoord = coord * scale + offset;\nvec4 tex = texture2D(rampData, vec2(coord, 0.0));\noutAlpha = average(tex.xyz);\noutColor = tex.xyz;\n}";
var node_remap_hsv_my_frag = "void node_remap_hsv(vec3 color, out vec3 outColor)\n{\noutColor = color;\n}";
var node_reverse_my_frag = "void node_reverse(\nvec3 inValue,\nout vec3 outValue) {\noutValue = 1.0 - inValue;\n}";
var node_sampler_info_my_frag = "void node_sampler_info(\nfloat frontFacing, vec4 tangent, vec2 uv,\nvec3 viewNorm,\nout float facingRatio, out bool flippedNormal, out mat4 matrixEyeToWorld,\nout vec3 normalCamera, out vec2 pixelCenter, out vec3 pointCamera,\nout vec3 pointObj, out vec3 pointWorld,\nout vec3 tangentUCamera, out vec3 tangentVCamera, out vec2 uvCoord)\n{\nvec4 worldPos = invViewMatrix * vec4(-vViewPosition, 1.0);\nfacingRatio = dot(normalize(viewNorm), normalize(vViewPosition));\nflippedNormal = (frontFacing > 0.0);\nmatrixEyeToWorld = invViewMatrix;\nnormalCamera = viewNorm;\npixelCenter = vec2(1.0);\npointCamera = -vViewPosition;\npointObj = (invModelMatrix * worldPos).xyz;\npointWorld = worldPos.xyz;\ntangentUCamera = normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz);\ntangentVCamera = tangent.w * cross(viewNorm, tangentUCamera);\nuvCoord = vec2(uv.x, 1.0-uv.y);\n}";
var node_set_range_my_frag = "void node_set_range(\nvec3 maxValue, vec3 minValue, vec3 oldMax, vec3 oldMin, vec3 value,\nout vec3 outValue) {\noutValue = minValue + (((value - oldMin) / (oldMax - oldMin)) * (maxValue - minValue));\n}";
var node_shading_engine_my_frag = "void node_shading_engine(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}";
var node_sub_transform_my_frag = "#define COORD_WORLD_SPACE 0\n#define COORD_OBJECT_SPACE 1\nvoid node_sub_transform(\nconst int coordSpace,\nvec3 scale, vec3 rotate, vec3 offset,\nout vec3 outVector, out vec3 outNormal)\n{\nvec3 norm = vNormal;\nnorm = (invViewMatrix * vec4(norm, 0.0)).xyz;\nvec3 vector = vWorldPosition.xyz;\nif (coordSpace == COORD_OBJECT_SPACE) {\nvector = (invModelMatrix * vec4(vector, 1.0)).xyz;\nnorm = (invModelMatrix * vec4(norm, 0.0)).xyz;\n}\nvector -= offset;\nvector *= scale;\nmat3 rotX = mat3RotateX(radians(rotate.x));\nmat3 rotY = mat3RotateY(radians(-rotate.y));\nmat3 rotZ = mat3RotateZ(radians(rotate.z));\nmat3 rotMat = rotX * rotY * rotZ;\nvector = rotMat * vector;\nnorm = rotMat * norm;\noutVector = vector;\noutNormal = normalize(norm);\n}";
var node_surface_shader_my_frag = "void node_surface_shader(\nvec3 color, vec3 glowColor, vec3 matteOpacity, vec3 transparency,\nout vec3 outColor, out vec3 outGlowColor, out vec3 outMatteOpacity, out vec3 outTransparency)\n{\noutColor = color;\noutGlowColor = glowColor;\noutMatteOpacity = matteOpacity;\noutTransparency = transparency;\n}";
var node_transform_my_frag = "void node_transform(\nout vec3 center, out mat4 inverseMatrix, out mat4 matrix,\nout mat4 parentInverseMatrix, out mat4 parentMatrix, out mat4 worldInverseMatrix,\nout mat4 worldMatrix, out mat4 xformMatrix)\n{\ncenter = modelMatrix[3].xyz;\ninverseMatrix = invModelMatrix;\nmatrix = modelMatrix;\nparentInverseMatrix = mat4(1.0);\nparentMatrix = mat4(1.0);\nworldInverseMatrix = invModelMatrix;\nworldMatrix = modelMatrix;\nxformMatrix = matrix;\n}";
var node_transpose_matrix_my_frag = "mat4 transposeMat4(mat4 m) {\nreturn mat4(vec4(m[0].x, m[1].x, m[2].x, m[3].x),\nvec4(m[0].y, m[1].y, m[2].y, m[3].y),\nvec4(m[0].z, m[1].z, m[2].z, m[3].z),\nvec4(m[0].w, m[1].w, m[2].w, m[3].w));\n}\nvoid node_transpose_matrix(\nmat4 inputMatrix,\nout mat4 outputMatrix)\n{\noutputMatrix = transposeMat4(inputMatrix);\n}";
var node_unit_conversion_my_frag = "void node_unit_conversion(float conversionFactor, float inInput, out float outOutput)\n{\noutOutput = conversionFactor * inInput;\n}\nvoid node_unit_conversion(float conversionFactor, vec3 inInput, out vec3 outOutput)\n{\noutOutput = conversionFactor * inInput;\n}";
var node_unpremultiply_my_frag = "void node_unpremultiply(\nfloat inAlpha, vec3 inColor,\nout float outAlpha, out vec3 outColor) {\noutColor = inColor / inAlpha;\noutAlpha = inAlpha;\n}";
var node_vector_product_my_frag = "void node_vector_product(\nconst int operation, const bool normalizeOutput,\nvec3 input1, vec3 input2, mat4 matrix,\nout vec3 outVector) {\nif (operation == 0) {\noutVector = input1;\n} else if (operation == 1) {\nif (normalizeOutput) {\ninput1 = normalize(input1);\ninput2 = normalize(input2);\n}\noutVector = vec3(dot(input1, input2));\n} else if (operation == 2) {\noutVector = cross(input1, input2);\n} else if (operation == 3) {\noutVector = (matrix * vec4(input1, 0.0)).xyz;\n} else {\noutVector = (matrix * vec4(input1, 1.0)).xyz;\n}\n\nif (operation > 1 && normalizeOutput)\noutVector = normalize(outVector);\n}";
var node_wt_add_matrix_my_frag = "void node_wt_add_matrix(\nmat4 matrixIn1, float weightIn1,\nout mat4 matrixSum)\n{\nmatrixSum = weightIn1 * matrixIn1;\n}\nvoid node_wt_add_matrix(\nmat4 matrixIn1, float weightIn1, mat4 matrixIn2, float weightIn2,\nout mat4 matrixSum)\n{\nmatrixSum = weightIn1 * matrixIn1 + weightIn2 * matrixIn2;\n}\nvoid node_wt_add_matrix(\nmat4 matrixIn1, float weightIn1, mat4 matrixIn2, float weightIn2, mat4 matrixIn3, float weightIn3,\nout mat4 matrixSum)\n{\nmatrixSum = weightIn1 * matrixIn1 + weightIn2 * matrixIn2 + weightIn3 * matrixIn3;\n}";
var pp_plane_vert = "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
var pp_oit_weighted_frag = "varying vec2 vUv;\nuniform sampler2D tRGBABuffer;\nuniform sampler2D tFloatBuffer;\nvoid main() {\nvec4 color = texture2D(tRGBABuffer, vUv);\nvec3 colorSum = color.rgb;\nfloat alphaProduct = color.a;\nfloat alphaSum = texture2D(tFloatBuffer, vUv).r;\ngl_FragColor = vec4(colorSum.rgb / max(alphaSum, 1e-5), 1.0 - alphaProduct);\n}";
var pp_afterimage_frag = "uniform float damp;\nuniform sampler2D tOld;\nuniform sampler2D tNew;\nvarying vec2 vUv;\nvec4 when_gt(vec4 x, float y) {\nreturn max(sign(x - y), 0.0);\n}\nvoid main() {\nvec4 texelOld = texture2D(tOld, vUv);\nvec4 texelNew = texture2D(tNew, vUv);\n\ntexelOld *= damp * when_gt(texelOld, 0.1);\ngl_FragColor = max(texelNew, texelOld);\n}";
var pp_bloom_composite_frag = "varying vec2 vUv;\nuniform sampler2D blurTexture1;\nuniform sampler2D blurTexture2;\nuniform sampler2D blurTexture3;\nuniform sampler2D blurTexture4;\nuniform sampler2D blurTexture5;\nuniform sampler2D dirtTexture;\nuniform float bloomStrength;\nuniform float bloomRadius;\nuniform float bloomFactors[NUM_MIPS];\nuniform vec3 bloomTintColors[NUM_MIPS];\nfloat lerpBloomFactor(const in float factor) {\nfloat mirrorFactor = 1.2 - factor;\nreturn mix(factor, mirrorFactor, bloomRadius);\n}\nvoid main() {\ngl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv)\n);\n}";
var pp_bloom_lum_high_pass_frag = "uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat v = dot(texel.xyz, luma);\nvec4 outputColor = vec4(defaultColor.rgb, defaultOpacity);\nfloat alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\ngl_FragColor = mix(outputColor, texel, alpha);\ngl_FragColor = clamp(gl_FragColor, 0.0, 10.0);\n}";
var pp_bloom_separable_blur_frag = "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat fSigma = float(SIGMA);\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = direction * invSize * x;\nvec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;\nvec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;\ndiffuseSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n}";
var pp_blur_frag = "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat weightSum = gaussianPdf(0.0, kernelRadius);\n#if LOG_SPACE == 1\nfloat origDiffuse = texture2D(colorTexture, vUv).r;\nfloat diffuseSum = weightSum;\n#else\nfloat diffuseSum = texture2D(colorTexture, vUv).r * weightSum;\n#endif\nvec2 delta = direction * invSize * kernelRadius/float(MAX_SAMPLE_RADIUS);\nvec2 uvOffset = delta;\n#if OCTAHEDRAL_MAP == 1\nvec3 cubeDir = normalize(octUVToCubeVec(vUv, invSize));\nvec3 dirX = normalize(abs(cubeDir.y) < 0.99999 ? vec3(cubeDir.z, 0.0, -cubeDir.x)\n: vec3(0.0, -cubeDir.z, cubeDir.y));\nvec3 dirY = cross(cubeDir, dirX);\n#endif\n#pragma unroll_loop\nfor (int i = 1; i <= MAX_SAMPLE_RADIUS; i++) {\nfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n#if OCTAHEDRAL_MAP == 1\nvec3 cubeOffset = uvOffset.x * dirX + uvOffset.y * dirY;\nvec2 uv1 = cubeVecToOctUV(cubeDir + cubeOffset, invSize);\nvec2 uv2 = cubeVecToOctUV(cubeDir - cubeOffset, invSize);\n#else\nvec2 uv1 = vUv + uvOffset;\nvec2 uv2 = vUv - uvOffset;\n#endif\nfloat sample1 = texture2D(colorTexture, uv1).r;\nfloat sample2 = texture2D(colorTexture, uv2).r;\n#if LOG_SPACE == 1\ndiffuseSum += (\nclamp(exp(sample1 - origDiffuse), 0.0, 1e38) +\nclamp(exp(sample2 - origDiffuse), 0.0, 1e38)\n) * w;\n#else\ndiffuseSum += ((sample1 + sample2) * w);\n#endif\nweightSum += 2.0 * w;\nuvOffset += delta;\n}\n#if LOG_SPACE == 1\ngl_FragColor = vec4(origDiffuse + log(diffuseSum/weightSum), 0.0, 0.0, 1.0);\n#else\ngl_FragColor = vec4(diffuseSum/weightSum, 0.0, 0.0, 1.0);\n#endif\n}";
var pp_bokeh_frag = "#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\nuniform float depthLeakThreshold;\n#include <packing>\nfloat getDepth(const in vec2 screenPosition) {\n#if DEPTH_PACKING == 1\nreturn unpackRGBAToDepth(texture2D(tDepth, screenPosition));\n#else\nreturn texture2D(tDepth, screenPosition).x;\n#endif\n}\nfloat getViewZ(const in float depth) {\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth, nearClip, farClip);\n#else\nreturn orthoDepthToViewZ(depth, nearClip, farClip);\n#endif\n}\nvec4 blurSample(vec2 uvOffset, vec4 centerCol, float viewZCenter) {\nfloat viewZ = -getViewZ(getDepth(vUv + uvOffset));\nfloat blurFactor = (viewZ >= viewZCenter) ? 1.0 : \nmin(depthLeakThreshold * abs((focus - viewZ) / aperture), 1.0);\nreturn mix(centerCol, texture2D(tColor, vUv + uvOffset), blurFactor);\n}\nvoid main() {\nvec2 aspectcorrect = vec2(1.0, aspect);\nfloat viewZ = -getViewZ(getDepth(vUv));\nfloat factor = abs(focus - viewZ);\n\nfloat dofblur = maxblur * min(factor / aperture, 1.0);\nfloat dofblur9 = dofblur * 0.9;\nfloat dofblur7 = dofblur * 0.7;\nfloat dofblur4 = dofblur * 0.4;\nvec4 centerCol = texture2D(tColor, vUv);\nvec4 col = centerCol;\ncol += blurSample((vec2( 0.0, 0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, 0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, 0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, 0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.40, 0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.0, -0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, 0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, 0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, 0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.4, 0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.15, 0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, 0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, 0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, 0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.29, 0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.40, 0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.0, -0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, 0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.4, 0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.0, 0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.29, 0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.4, 0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.0, -0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, 0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.4, 0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.0, 0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ngl_FragColor = col / 41.0;\ngl_FragColor.a = centerCol.a;\n}";
var pp_brightness_contrast_frag = "\nuniform sampler2D tDiffuse;\nuniform float brightness;\nuniform float contrast;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\ntexel.rgb += brightness;\nif (contrast > 0.0)\ntexel.rgb = (texel.rgb - 0.5) / (1.0 - contrast) + 0.5;\nelse\ntexel.rgb = (texel.rgb - 0.5) * (1.0 + contrast) + 0.5;\ngl_FragColor = texel;\n}";
var pp_copy_frag = "uniform sampler2D tDiffuse;\nuniform float opacity;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = (texture2D(tDiffuse, vUv));\ngl_FragColor = opacity * texel;\n}";
var pp_cube_octahedral_proj_frag = "#include <common>\nuniform samplerCube tCube;\nuniform vec2 texelSize;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = textureCube(tCube, octUVToCubeVec(gl_FragCoord.xy * texelSize,\ntexelSize));\n}";
var pp_fxaa_frag = "precision highp float;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#ifndef FXAA_GLSL_120\n#define FXAA_GLSL_120 0\n#endif\n#ifndef FXAA_GLSL_130\n#define FXAA_GLSL_130 0\n#endif\n#ifndef FXAA_GREEN_AS_LUMA\n#define FXAA_GREEN_AS_LUMA 0\n#endif\n#ifndef FXAA_EARLY_EXIT\n#define FXAA_EARLY_EXIT 1\n#endif\n#ifndef FXAA_DISCARD\n#define FXAA_DISCARD 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#ifdef GL_EXT_gpu_shader4\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#define FXAA_FAST_PIXEL_OFFSET 0\n#endif\n#endif\n#ifndef FXAA_QUALITY_PRESET\n#define FXAA_QUALITY_PRESET 12\n#endif\n#if (FXAA_QUALITY_PRESET == 10)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 3.0\n#define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 3.0\n#define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 4.0\n#define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 4.0\n#define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 4.0\n#define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 2.0\n#define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 3.0\n#define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n#define FXAA_QUALITY_PS 9\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 4.0\n#define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n#define FXAA_QUALITY_PS 10\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 4.0\n#define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n#define FXAA_QUALITY_PS 11\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 4.0\n#define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.0\n#define FXAA_QUALITY_P2 1.0\n#define FXAA_QUALITY_P3 1.0\n#define FXAA_QUALITY_P4 1.0\n#define FXAA_QUALITY_P5 1.5\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if 1\n#define FxaaBool bool\n#define FxaaDiscard discard\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 ivec2\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTex sampler2D\n#endif\n#if (FXAA_GLSL_100 == 1)\n#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GLSL_120 == 1)\n#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n#if (FXAA_FAST_PIXEL_OFFSET == 1)\n#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#else\n#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n#endif\n#endif\n#if (FXAA_GLSL_130 == 1)\n#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\nFxaaFloat4 FxaaPixelShader(\nFxaaFloat2 pos,\nFxaaFloat4 fxaaConsolePosPos,\nFxaaTex tex,\nFxaaTex fxaaConsole360TexExpBiasNegOne,\nFxaaTex fxaaConsole360TexExpBiasNegTwo,\nFxaaFloat2 fxaaQualityRcpFrame,\nFxaaFloat4 fxaaConsoleRcpFrameOpt,\nFxaaFloat4 fxaaConsoleRcpFrameOpt2,\nFxaaFloat4 fxaaConsole360RcpFrameOpt2,\nFxaaFloat fxaaQualitySubpix,\nFxaaFloat fxaaQualityEdgeThreshold,\nFxaaFloat fxaaQualityEdgeThresholdMin\n) {\nFxaaFloat2 posM;\nposM.x = pos.x;\nposM.y = pos.y;\n#if 1\nFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n#if (FXAA_GLSL_100 == 1)\nFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n#else\nFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n#endif\n#endif\nFxaaFloat maxSM = max(lumaS, lumaM);\nFxaaFloat minSM = min(lumaS, lumaM);\nFxaaFloat maxESM = max(lumaE, maxSM);\nFxaaFloat minESM = min(lumaE, minSM);\nFxaaFloat maxWN = max(lumaN, lumaW);\nFxaaFloat minWN = min(lumaN, lumaW);\nFxaaFloat rangeMax = max(maxWN, maxESM);\nFxaaFloat rangeMin = min(minWN, minESM);\nFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\nFxaaFloat range = rangeMax - rangeMin;\nFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\nFxaaBool earlyExit = range < rangeMaxClamped;\nif(earlyExit)\n#if (FXAA_DISCARD == 1)\nreturn rgbyM;\n#else\nreturn rgbyM;\n#endif\n#if 1\n#if (FXAA_GLSL_100 == 1)\nFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n#else\nFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\n#else\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\nFxaaFloat lumaNS = lumaN + lumaS;\nFxaaFloat lumaWE = lumaW + lumaE;\nFxaaFloat subpixRcpRange = 1.0/range;\nFxaaFloat subpixNSWE = lumaNS + lumaWE;\nFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\nFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\nFxaaFloat lumaNESE = lumaNE + lumaSE;\nFxaaFloat lumaNWNE = lumaNW + lumaNE;\nFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\nFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\nFxaaFloat lumaNWSW = lumaNW + lumaSW;\nFxaaFloat lumaSWSE = lumaSW + lumaSE;\nFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\nFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\nFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\nFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\nFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\nFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\nFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\nFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\nFxaaBool horzSpan = edgeHorz >= edgeVert;\nFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\nif(!horzSpan) lumaN = lumaW;\nif(!horzSpan) lumaS = lumaE;\nif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\nFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\nFxaaFloat gradientN = lumaN - lumaM;\nFxaaFloat gradientS = lumaS - lumaM;\nFxaaFloat lumaNN = lumaN + lumaM;\nFxaaFloat lumaSS = lumaS + lumaM;\nFxaaBool pairN = abs(gradientN) >= abs(gradientS);\nFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\nif(pairN) lengthSign = -lengthSign;\nFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\nFxaaFloat2 posB;\nposB.x = posM.x;\nposB.y = posM.y;\nFxaaFloat2 offNP;\noffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\noffNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\nif(!horzSpan) posB.x += lengthSign * 0.5;\nif(horzSpan) posB.y += lengthSign * 0.5;\nFxaaFloat2 posN;\nposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\nposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\nFxaaFloat2 posP;\nposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\nposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\nFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\nFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\nFxaaFloat subpixE = subpixC * subpixC;\nFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\nif(!pairN) lumaNN = lumaSS;\nFxaaFloat gradientScaled = gradient * 1.0/4.0;\nFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\nFxaaFloat subpixF = subpixD * subpixE;\nFxaaBool lumaMLTZero = lumaMM < 0.0;\nlumaEndN -= lumaNN * 0.5;\nlumaEndP -= lumaNN * 0.5;\nFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\nFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\nFxaaBool doneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n#if (FXAA_QUALITY_PS > 3)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n#if (FXAA_QUALITY_PS > 4)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n#if (FXAA_QUALITY_PS > 5)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n#if (FXAA_QUALITY_PS > 6)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n#if (FXAA_QUALITY_PS > 7)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n#if (FXAA_QUALITY_PS > 8)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n#if (FXAA_QUALITY_PS > 9)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n#if (FXAA_QUALITY_PS > 10)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n#if (FXAA_QUALITY_PS > 11)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n#if (FXAA_QUALITY_PS > 12)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\nFxaaFloat dstN = posM.x - posN.x;\nFxaaFloat dstP = posP.x - posM.x;\nif(!horzSpan) dstN = posM.y - posN.y;\nif(!horzSpan) dstP = posP.y - posM.y;\nFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\nFxaaFloat spanLength = (dstP + dstN);\nFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\nFxaaFloat spanLengthRcp = 1.0/spanLength;\nFxaaBool directionN = dstN < dstP;\nFxaaFloat dst = min(dstN, dstP);\nFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\nFxaaFloat subpixG = subpixF * subpixF;\nFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\nFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\nFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\nFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\nif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\nif(horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n#if (FXAA_DISCARD == 1)\nreturn FxaaTexTop(tex, posM);\n#else\nreturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n#endif\n}\nvoid main() {\ngl_FragColor = FxaaPixelShader(\nvUv,\nvec4(0.0),\ntDiffuse,\ntDiffuse,\ntDiffuse,\nresolution,\nvec4(0.0),\nvec4(0.0),\nvec4(0.0),\n0.75,\n0.166,\n0.0833\n);\n}";
var pp_grayscale_frag = "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nfloat bw = texel.r * 0.35 + texel.g * 0.45 + texel.b * 0.2;\ntexel = vec4(bw, bw, bw, texel.a);\ngl_FragColor = texel;\n}";
var pp_gtao_blur_frag = "uniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform vec2 direction;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#include <packing>\nconst float SIGMA_SPATIAL = 1.5;\nconst float SIGMA_INTENSITY = 0.01;\nfloat gaussianPdf(float x, float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nfloat weightSum = gaussianPdf(0.0, SIGMA_SPATIAL)\n* gaussianPdf(0.0, SIGMA_INTENSITY);\nvec4 diffSample = texture2D(tDiffuse, vUv);\nvec4 gtaoDataSum = vec4(diffSample.r, unpackRGBToNormal(diffSample.gba)) * weightSum;\nvec3 normCenter = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);\nvec2 delta = direction / resolution;\nvec2 offset = delta;\n#pragma unroll_loop\nfor (int i = 1; i <= BLUR_RADIUS_PX; i++) {\nvec2 uvCoords0 = vUv + offset;\nvec2 uvCoords1 = vUv - offset;\nvec4 diffSample0 = texture2D(tDiffuse, uvCoords0);\nvec4 diffSample1 = texture2D(tDiffuse, uvCoords1);\nvec4 gtaoData0 = vec4(diffSample0.r, unpackRGBToNormal(diffSample0.gba));\nvec4 gtaoData1 = vec4(diffSample1.r, unpackRGBToNormal(diffSample1.gba));\nvec3 normSample0 = unpackRGBToNormal(texture2D(tNormal, uvCoords0).xyz);\nvec3 normSample1 = unpackRGBToNormal(texture2D(tNormal, uvCoords1).xyz);\nfloat weightSpatial = gaussianPdf(float(i), SIGMA_SPATIAL);\nfloat weight0 = weightSpatial * gaussianPdf(1.0 - max(0.0,\ndot(normCenter, normSample0)), SIGMA_INTENSITY);\nfloat weight1 = weightSpatial * gaussianPdf(1.0 - max(0.0,\ndot(normCenter, normSample1)), SIGMA_INTENSITY);\nweightSum += weight0 + weight1;\ngtaoDataSum += weight0 * gtaoData0 + weight1 * gtaoData1;\noffset += delta;\n}\nfloat visibility = gtaoDataSum.r / weightSum;\nvec3 bentNormal = normalize(gtaoDataSum.gba);\ngl_FragColor = vec4(visibility, packNormalToRGB(bentNormal));\n}";
var pp_gtao_frag = "uniform sampler2D tNormal;\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform float occlDistance;\nuniform float factor;\nuniform float occlPrecision;\nuniform mat4 mainCameraProjMat;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#include <common>\n#include <packing>\nconst vec3 AXIS_Z = vec3(0.0, 0.0, 1.0);\nconst float NUM_SAMPLES_HALF_MIN = 4.0;\nconst float NUM_SAMPLES_HALF_MAX = 8.0;\nconst float NOISE_TEX_SIZE = 32.0;\nconst float NEAR_FIELD_COEFF = 0.5;\nconst float SELF_OCCL_BIAS = -1e-5;\nconst float NORMAL_RENDER_GEOM_MAX_DIFF_ANGLE = 0.85 * PI_HALF;\nfloat integrateArc(vec2 horizonAngles, float normalAngle) {\nvec2 visCoeffs = (-cos(2.0 * horizonAngles - normalAngle) + cos(normalAngle)\n+ 2.0 * horizonAngles * sin(normalAngle)) / 4.0;\nreturn visCoeffs.x + visCoeffs.y;\n}\nvec3 calcViewFromUVDepth(vec2 uv, float depth, float zBias) {\nvec3 ndcCo = 2.0 * vec3(uv, depth) - 1.0;\n#if ORTHO_CAMERA == 1\nfloat viewZ = (ndcCo.z - mainCameraProjMat[3][2]) / mainCameraProjMat[2][2] + zBias;\nvec2 _00_11 = vec2(mainCameraProjMat[0][0], mainCameraProjMat[1][1]);\nvec2 _30_31 = vec2(mainCameraProjMat[3][0], mainCameraProjMat[3][1]);\nreturn vec3((ndcCo.xy - _30_31) / _00_11, viewZ);\n#else\nfloat viewZ = -mainCameraProjMat[3][2] / (mainCameraProjMat[2][2] + ndcCo.z) + zBias;\nvec2 _00_11 = vec2(mainCameraProjMat[0][0], mainCameraProjMat[1][1]);\nvec2 _20_21 = vec2(mainCameraProjMat[2][0], mainCameraProjMat[2][1]);\nreturn vec3(-viewZ * (ndcCo.xy + _20_21) / _00_11, viewZ);\n#endif\n}\nvec2 calcSliceRadiusUV(float viewZ) {\nvec4 distView = vec4(occlDistance, occlDistance, viewZ, 1.0);\nvec4 distClip = mainCameraProjMat * distView;\nvec2 xyNDC = distClip.xy / distClip.w;\nreturn clamp(0.5 * xyNDC, 0.0, 0.5);\n}\nvec2 calcHorizonAngles(vec3 viewPos, vec3 viewVec, vec2 sliceDir,\nfloat offsetNoise) {\nvec2 maxHorizonCos = vec2(-1.0);\nvec2 sliceRadius = calcSliceRadiusUV(viewPos.z);\nvec2 pxSize = 1.0 / resolution;\nint NUM_SAMPLES_HALF = int(occlPrecision\n* (NUM_SAMPLES_HALF_MAX - NUM_SAMPLES_HALF_MIN) + NUM_SAMPLES_HALF_MIN);\n#if __VERSION__ == 300\nfor (int i = 0; i < NUM_SAMPLES_HALF; i++) {\n#else\nfor (int i = 0; i < int(NUM_SAMPLES_HALF_MAX); i++) {\nif (i >= NUM_SAMPLES_HALF) continue;\n#endif\nvec2 offset = sliceDir * (pxSize * (1.0 + float(i))\n+ sliceRadius * pow((float(i) + offsetNoise) / float(NUM_SAMPLES_HALF), 2.0));\nvec2 uvs = vUv - offset;\nvec3 ps = calcViewFromUVDepth(uvs, texture2D(tDepth, uvs).x, SELF_OCCL_BIAS);\nvec3 ds = normalize(ps - viewPos);\nvec2 uvt = vUv + offset;\nvec3 pt = calcViewFromUVDepth(uvt, texture2D(tDepth, uvt).x, SELF_OCCL_BIAS);\nvec3 dt = normalize(pt - viewPos);\nvec2 sampleLen = vec2(length(ps - viewPos), length(pt - viewPos));\nvec2 blendWeight = (sampleLen / occlDistance - 1.0) / (NEAR_FIELD_COEFF - 1.0);\nblendWeight = clamp(blendWeight, 0.0, 1.0);\nvec2 maxHorizonCosNoBlending = max(maxHorizonCos, vec2(dot(ds, viewVec),\ndot(dt, viewVec)));\nmaxHorizonCos = mix(maxHorizonCos, maxHorizonCosNoBlending, blendWeight);\n}\nvec2 horizons = acos(maxHorizonCos);\nreturn vec2(-horizons.x, horizons.y);\n}\nvec2 calcNormalAngleAndProjLen(vec3 viewVec, vec3 normal, vec2 sliceDir) {\nvec3 sliceVec = vec3(sliceDir, 0.0);\nsliceVec = sliceVec - dot(sliceVec, viewVec) * viewVec;\nvec3 sliceOrthoVec = cross(sliceVec, viewVec);\nvec3 normalProj = normal - dot(normal, sliceOrthoVec) * sliceOrthoVec;\nfloat normalProjLen = length(normalProj);\nfloat normalAngle = acos(clamp(dot(normalProj / normalProjLen, viewVec), 0.0, 1.0));\nnormalAngle *= sign(dot(normalProj, sliceVec));\nreturn vec2(normalAngle, normalProjLen);\n}\n#if CALC_BENT_NORMALS == 1\nvec3 calcSliceBentNormal(vec2 sliceDir, vec2 h, float n) {\nvec2 t = vec2(\n6.0 * sin(h[0] - n) - sin(3.0 * h[0] - n) + 6.0 * sin(h[1] - n)\n- sin(3.0 * h[1] - n) + 16.0 * sin(n) - 3.0 * (sin(h[0] + n) + sin(h[1] + n)),\n-cos(3.0 * h[0] - n) - cos(3.0 * h[1] - n) + 8.0 * cos(n)\n- 3.0 * (cos(h[0] + n) + cos(h[1] + n))\n) / 12.0;\nreturn vec3(sliceDir * t[0], t[1]);\n}\n#endif\nvec2 clampHorizonAnglesAroundNormal(vec2 horizonAngles, float normalAngle,\nfloat geomNormalAngle) {\nhorizonAngles = normalAngle + clamp(horizonAngles - normalAngle, -PI_HALF, PI_HALF);\nif (abs(normalAngle - geomNormalAngle) < NORMAL_RENDER_GEOM_MAX_DIFF_ANGLE) {\nhorizonAngles = geomNormalAngle + clamp(horizonAngles - geomNormalAngle, -PI_HALF, PI_HALF);\n}\nreturn horizonAngles;\n}\nvoid main() {\nfloat depth = texture2D(tDepth, vUv).x;\n#ifndef GTAO_DISABLE_BKG_FIX\nif (depth == 1.0) {\ngl_FragColor = vec4(vec3(1.0), 1.0);\n} else {\n#endif\nvec3 viewPos = calcViewFromUVDepth(vUv, depth, 0.0);\n#if ORTHO_CAMERA == 1\nvec3 viewVec = vec3(0.0, 0.0, 1.0);\n#else\nvec3 viewVec = normalize(-viewPos);\n#endif\nvec3 viewNormal = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);\nvec3 geomViewNormal = normalize(cross(dFdx(viewPos), dFdy(viewPos)));\nvec2 noiseScale = resolution / NOISE_TEX_SIZE;\nvec4 noiseData = texture2D(tNoise, vUv * noiseScale);\nfloat randAngle = noiseData.r * PI_HALF;\nfloat visibility = 0.0;\nvec3 bentNormalAvg = viewNormal;\nfloat normalAngle, normalProjLen, geomNormalAngle;\nvec2 horizonAngles, _vec2Tmp;\nvec3 sliceBentNormal;\n#if CALC_BENT_NORMALS == 1\nbentNormalAvg = vec3(0.0);\n#if ORTHO_CAMERA == 0\nvec3 bentRotAxis = cross(AXIS_Z, viewVec);\nfloat bentRotAngle = acos(clamp(dot(AXIS_Z, viewVec), -1.0, 1.0));\n#endif\n#endif\nvec2 sliceDir = vec2(cos(randAngle), sin(randAngle));\n#pragma unroll_loop\nfor (int i = 0; i < 2; i++) {\n_vec2Tmp = calcNormalAngleAndProjLen(viewVec, viewNormal, sliceDir);\nnormalAngle = _vec2Tmp[0], normalProjLen = _vec2Tmp[1];\n_vec2Tmp = calcNormalAngleAndProjLen(viewVec, geomViewNormal, sliceDir);\ngeomNormalAngle = _vec2Tmp[0];\nhorizonAngles = calcHorizonAngles(viewPos, viewVec, sliceDir, noiseData.g);\nhorizonAngles = clampHorizonAnglesAroundNormal(horizonAngles,\nnormalAngle, geomNormalAngle);\nvisibility += normalProjLen * integrateArc(horizonAngles, normalAngle);\n#if CALC_BENT_NORMALS == 1\nsliceBentNormal = calcSliceBentNormal(sliceDir, horizonAngles, normalAngle);\n#if ORTHO_CAMERA == 0\nsliceBentNormal = vec3RotateAxisAngle(sliceBentNormal,\nbentRotAxis, bentRotAngle);\n#endif\nbentNormalAvg += sliceBentNormal * normalProjLen;\n#endif\nsliceDir = vec2(-sliceDir.y, sliceDir.x);\n}\nvisibility /= 2.0;\n#if CALC_BENT_NORMALS == 1\nfloat mixFactor = clamp((1.0 - 2.0 * visibility) / (3.0 * visibility - 4.0), 0.0, 1.0);\nbentNormalAvg = normalize(mix(bentNormalAvg, viewNormal, mixFactor));\n#endif\ngl_FragColor = vec4(pow(visibility, factor), packNormalToRGB(bentNormalAvg));\n#ifndef GTAO_DISABLE_BKG_FIX\n}\n#endif\n}";
var pp_outline_edge_frag = "varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform vec2 texSize;\nuniform vec4 visibleEdgeColor;\nuniform vec4 hiddenEdgeColor;\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\nvec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\nvec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\nvec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\nvec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\nfloat diff1 = (c1.r - c2.r) * 0.5;\nfloat diff2 = (c3.r - c4.r) * 0.5;\nfloat d = length(vec2(diff1, diff2));\nfloat a1 = min(c1.g, c2.g);\nfloat a2 = min(c3.g, c4.g);\nfloat visibilityFactor = min(a1, a2);\nvec4 edgeColor = (1.0 - visibilityFactor > 0.001) ? visibleEdgeColor : hiddenEdgeColor;\ngl_FragColor = edgeColor * vec4(d);\n}";
var pp_outline_blur_frag = "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat weightSum = gaussianPdf(0.0, kernelRadius);\nvec4 diffuseSum = texture2D(colorTexture, vUv);\n#if defined(LOG_SPACE)\ndiffuseSum = exp(diffuseSum);\n#endif\ndiffuseSum *= weightSum;\nvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\nvec2 uvOffset = delta;\nfor (int i = 1; i <= MAX_RADIUS; i++) {\nfloat w = gaussianPdf(uvOffset.x, kernelRadius);\nvec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\nvec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n#if defined(LOG_SPACE)\nsample1 = exp(sample1);\nsample2 = exp(sample2);\n#endif\ndiffuseSum += ((sample1 + sample2) * w);\nweightSum += (2.0 * w);\nuvOffset += delta;\n}\nvec4 finalCol = diffuseSum / weightSum;\n#if defined(LOG_SPACE)\nfinalCol = log(finalCol);\n#endif\ngl_FragColor = finalCol;\n}";
var pp_outline_overlay_frag = "varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform sampler2D edgeTexture1;\nuniform sampler2D edgeTexture2;\nuniform sampler2D patternTexture;\nuniform float edgeStrength;\nuniform float edgeGlow;\nuniform bool usePatternTexture;\nvoid main() {\nvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\nvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\nvec4 maskColor = texture2D(maskTexture, vUv);\nvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\nfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\nvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\nvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\nif (usePatternTexture)\nfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\nfloat maxChannel = max(finalColor.r, max(finalColor.g, finalColor.b));\nif (maxChannel != 0.0) {\nfinalColor.rgb /= maxChannel;\n}\ngl_FragColor = finalColor;\n}";
var pp_tonemap_frag = "#include <common>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nfloat alpha = clamp(texel.a, 0.0, 1.0);\ngl_FragColor = texel;\ngl_FragColor.rgb /= alpha;\n#include <tonemapping_fragment>\ngl_FragColor = LinearTosRGB(gl_FragColor);\ngl_FragColor.rgb *= alpha;\n#if ALPHA_AS_LUMA == 1\ngl_FragColor.a = linearToRelativeLuminance(gl_FragColor.rgb);\n#endif\n}";
var vertex = "precision highp float;\nattribute vec3 position;\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\nattribute vec2 uv;\nattribute float counters;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\nvarying float vCounters;\nvarying vec2 vUV;\nconst float EQ_EPS = 0.000001;\nvec2 fix(vec4 i, float aspect) {\nvec2 res = i.xy / i.w;\nres.x *= aspect;\nreturn res;\n}\nbool posEqual(vec2 pos0, vec2 pos1) {\nreturn length(pos0 - pos1) < EQ_EPS;\n}\nvoid main() {\nfloat aspect = resolution.x / resolution.y;\nvCounters = counters;\nvUV = uv;\nmat4 m = projectionMatrix * modelViewMatrix;\nvec4 finalPosition = m * vec4(position, 1.0);\nvec4 prevPos = m * vec4(previous, 1.0);\nvec4 nextPos = m * vec4(next, 1.0);\nvec2 currentP = fix(finalPosition, aspect);\nvec2 prevP = fix(prevPos, aspect);\nvec2 nextP = fix(nextPos, aspect);\nfloat w = lineWidth * width;\nif (sizeAttenuation == 0.0) {\nw *= finalPosition.w / resolution.x;\n}\nvec2 dir;\nif (posEqual(nextP, currentP)) {\ndir = normalize(currentP - prevP);\n} else if (posEqual(prevP, currentP)) {\ndir = normalize(nextP - currentP);\n} else {\nvec2 dir1 = normalize(currentP - prevP);\nvec2 dir2 = normalize(nextP - currentP);\ndir = normalize(dir1 + dir2);\n}\nvec2 offset = vec2(-dir.y, dir.x);\noffset.y *= aspect;\noffset *= w;\nfinalPosition.xy += offset * side;\ngl_Position = finalPosition;\n}";
var fragment = "precision mediump float;\nuniform sampler2D map;\nuniform sampler2D alphaMap;\nuniform float useMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\nuniform vec2 repeat;\nuniform vec3 color;\nuniform float opacity;\nvarying vec2 vUV;\nvarying float vCounters;\n#include <encodings_pars_fragment>\nvoid main() {\nvec4 c = vec4(color, opacity);\nif (useMap == 1.0) {\nc *= texture2D(map, vUV * repeat);\n}\nif (useAlphaMap == 1.0) {\nc.a *= texture2D(alphaMap, vUV * repeat).a;\n}\nif (c.a < alphaTest) {\ndiscard;\n}\ngl_FragColor = c;\ngl_FragColor.a *= step(vCounters, visibility);\ngl_FragColor = LinearTosRGB(gl_FragColor);\n}";
var ShaderChunk = { alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_physical_pars_fragment, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, output_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, webgl1_compat, worldpos_vertex, background_vert: vertex$g, background_frag: fragment$g, backgroundCube_vert: vertex$f, backgroundCube_frag: fragment$f, cube_vert: vertex$e, cube_frag: fragment$e, depth_vert: vertex$d, depth_frag: fragment$d, distanceRGBA_vert: vertex$c, distanceRGBA_frag: fragment$c, equirect_vert: vertex$b, equirect_frag: fragment$b, linedashed_vert: vertex$a, linedashed_frag: fragment$a, meshbasic_vert: vertex$9, meshbasic_frag: fragment$9, meshlambert_vert: vertex$8, meshlambert_frag: fragment$8, meshnormal_vert: vertex$7, meshnormal_frag: fragment$7, meshphysical_vert: vertex$6, meshphysical_frag: fragment$6, points_vert: vertex$5, points_frag: fragment$5, shadow_vert: vertex$4, shadow_frag: fragment$4, sprite_vert: vertex$3, sprite_frag: fragment$3, mask_vert: vertex$2, mask_frag: fragment$2, meshnode_vert: vertex$1, meshnode_frag: fragment$1, lights_node_pars_fragment, lights_node_gtao_pars_fragment, lights_fragment_gtso, normal_output_fragment, ssr_pars_fragment, plane_reflection_pars_vertex, plane_reflection_pars_fragment, plane_reflection_vertex, oit_weighted_pars_fragment, oit_weighted_fragment, node_common_frag, node_osl_frag, node_incident_frag, node_normal_frag, node_position_frag, node_rgb_alpha_frag, node_value_frag, node_u_float_frag, node_abs_ar_frag, node_add_ar_frag, node_atan_ar_frag, node_checkerboard_ar_frag, node_clamp_ar_frag, node_color_convert_ar_frag, node_color_correct_ar_frag, node_color_to_float_ar_frag, node_compare_ar_frag, node_complement_ar_frag, node_composite_ar_frag, node_cross_ar_frag, node_divide_ar_frag, node_dot_ar_frag, node_exp_ar_frag, node_facing_ratio_ar_frag, node_flat_ar_frag, node_float_to_int_ar_frag, node_float_to_matrix_ar_frag, node_float_to_rgba_ar_frag, node_float_to_rgb_ar_frag, node_fraction_ar_frag, node_is_finite_ar_frag, node_image_ar_frag, node_lambert_ar_frag, node_length_ar_frag, node_log_ar_frag, node_map_to_mtl_ar_frag, node_matrix_transform_ar_frag, node_max_ar_frag, node_min_ar_frag, node_mix_shader_ar_frag, node_modulo_ar_frag, node_multiply_ar_frag, node_negate_ar_frag, node_normalize_ar_frag, node_normal_map_ar_frag, node_pow_ar_frag, node_random_ar_frag, node_range_ar_frag, node_ray_switch_ar_frag, node_reciprocal_ar_frag, node_rgba_to_float_ar_frag, node_rgb_to_float_ar_frag, node_rgb_to_vector_ar_frag, node_shadow_matte_ar_frag, node_shuffle_ar_frag, node_sign_ar_frag, node_skydome_light_ar_frag, node_sqrt_ar_frag, node_standard_surface_ar_frag, node_subtract_ar_frag, node_trigo_ar_frag, node_triplanar_ar_frag, node_triplanar_uv_ar_frag, node_two_sided_ar_frag, node_user_data_color_ar_frag, node_uv_projection_ar_frag, node_vector_to_rgb_ar_frag, node_add_shader_bl_frag, node_ambient_occlusion_bl_frag, node_attribute_bl_frag, node_background_bl_frag, node_bevel_bl_frag, node_blackbody_bl_frag, node_brightcontrast_bl_frag, node_bsdf_anisotropic_bl_frag, node_bsdf_diffuse_bl_frag, node_bsdf_glass_bl_frag, node_bsdf_glossy_bl_frag, node_bsdf_metallic_bl_frag, node_bsdf_hair_bl_frag, node_bsdf_principled_bl_frag, node_bsdf_refraction_bl_frag, node_bsdf_sheen_bl_frag, node_bsdf_toon_bl_frag, node_bsdf_translucent_bl_frag, node_bsdf_transparent_bl_frag, node_bsdf_velvet_bl_frag, node_bump_bl_frag, node_camera_bl_frag, node_clamp_bl_frag, node_combhsv_bl_frag, node_combine_color_bl_frag, node_combrgb_bl_frag, node_combxyz_bl_frag, node_curve_float_bl_frag, node_curve_rgb_bl_frag, node_curve_vec_bl_frag, node_diffuse_bsdf_bl_frag, node_displacement_bl_frag, node_eevee_specular_bl_frag, node_emission_bl_frag, node_fresnel_bl_frag, node_gamma_bl_frag, node_hair_info_bl_frag, node_holdout_bl_frag, node_hue_sat_bl_frag, node_invert_bl_frag, node_layer_weight_bl_frag, node_light_falloff_bl_frag, node_light_path_bl_frag, node_mapping_bl_frag, node_map_range_bl_frag, node_math_bl_frag, node_mix_bl_frag, node_mix_rgb_bl_frag, node_mix_shader_bl_frag, node_new_geometry_bl_frag, node_normal_bl_frag, node_normal_map_bl_frag, node_object_info_bl_frag, node_output_lamp_bl_frag, node_output_material_bl_frag, node_output_world_bl_frag, node_particle_info_bl_frag, node_point_info_bl_frag, node_principled_volume_bl_frag, node_rgb_bl_frag, node_rgbtobw_bl_frag, node_script_bl_frag, node_sephsv_bl_frag, node_separate_color_bl_frag, node_seprgb_bl_frag, node_sepxyz_bl_frag, node_shadertorgb_bl_frag, node_squeeze_bl_frag, node_subsurface_scattering_bl_frag, node_tangent_bl_frag, node_tex_brick_bl_frag, node_tex_checker_bl_frag, node_tex_coord_bl_frag, node_tex_environment_bl_frag, node_tex_environment_none_bl_frag, node_tex_gabor_bl_frag, node_tex_gradient_bl_frag, node_tex_ies_bl_frag, node_tex_image_bl_frag, node_tex_image_none_bl_frag, node_tex_magic_bl_frag, node_tex_musgrave_bl_frag, node_tex_noise_bl_frag, node_tex_pointdensity_bl_frag, node_tex_sky_bl_frag, node_tex_voronoi_bl_frag, node_tex_wave_bl_frag, node_tex_white_noise_bl_frag, node_uvmap_bl_frag, node_valtorgb_bl_frag, node_value_bl_frag, node_vect_math_bl_frag, node_vect_transform_bl_frag, node_vector_displacement_bl_frag, node_vector_rotate_bl_frag, node_vertex_color_bl_frag, node_volume_absorption_bl_frag, node_volume_info_bl_frag, node_volume_scatter_bl_frag, node_wavelength_bl_frag, node_wireframe_bl_frag, node_bitmap_none_mx_frag, node_bitmap_env_mx_frag, node_bitmap_mx_frag, node_bump_mx_frag, node_blend_mx_frag, node_color_correction_mx_frag, node_color_map_mx_frag, node_composite_layer_mx_frag, node_falloff_mx_frag, node_gradient_mx_frag, node_gradient_ramp_mx_frag, node_map_mx_frag, node_mask_mx_frag, node_material_mx_frag, node_matte_shadow_mx_frag, node_mix_mx_frag, node_noise_mx_frag, node_normal_bump_mx_frag, node_openpbr_surface_mx_frag, node_output_map_mx_frag, node_output_mx_frag, node_physical_mx_frag, node_phy_sun_sky_env_mx_frag, node_reflect_refract_mx_frag, node_reflect_refract_color_mx_frag, node_rgb_multiply_mx_frag, node_rgb_tint_mx_frag, node_rgb_mx_frag, node_shellac_mx_frag, node_sub_transform_mx_frag, node_value_mx_frag, node_vertex_color_mx_frag, node_add_double_linear_my_frag, node_add_matrix_my_frag, node_anim_curve_ta_my_frag, node_anim_curve_tu_my_frag, node_blend_colors_my_frag, node_bulge_my_frag, node_blinn_my_frag, node_bump_2d_my_frag, node_channels_my_frag, node_checker_my_frag, node_clamp_my_frag, node_cloth_my_frag, node_color_condition_my_frag, node_color_composite_my_frag, node_color_constant_my_frag, node_color_correct_my_frag, node_color_logic_my_frag, node_color_mask_my_frag, node_color_math_my_frag, node_compose_matrix_my_frag, node_condition_my_frag, node_decompose_matrix_my_frag, node_env_sphere_my_frag, node_file_my_frag, node_float_condition_my_frag, node_float_composite_my_frag, node_float_constant_my_frag, node_float_logic_my_frag, node_float_mask_my_frag, node_float_math_my_frag, node_four_by_four_matrix_my_frag, node_gamma_correct_my_frag, node_grid_my_frag, node_inverse_matrix_my_frag, node_lambert_my_frag, node_layered_texture_layer_my_frag, node_luminance_my_frag, node_multiply_divide_my_frag, node_mult_double_linear_my_frag, node_mult_matrix_my_frag, node_noise_my_frag, node_openpbr_surface_my_frag, node_output_my_frag, node_place_2d_texture_my_frag, node_phong_my_frag, node_phong_e_my_frag, node_premultiply_my_frag, node_ramp_my_frag, node_remap_hsv_my_frag, node_reverse_my_frag, node_sampler_info_my_frag, node_set_range_my_frag, node_shading_engine_my_frag, node_sub_transform_my_frag, node_surface_shader_my_frag, node_transform_my_frag, node_transpose_matrix_my_frag, node_unit_conversion_my_frag, node_unpremultiply_my_frag, node_vector_product_my_frag, node_wt_add_matrix_my_frag, pp_plane_vert, pp_afterimage_frag, pp_bloom_composite_frag, pp_bloom_lum_high_pass_frag, pp_bloom_separable_blur_frag, pp_blur_frag, pp_brightness_contrast_frag, pp_bokeh_frag, pp_copy_frag, pp_cube_octahedral_proj_frag, pp_fxaa_frag, pp_grayscale_frag, pp_gtao_blur_frag, pp_gtao_frag, pp_outline_edge_frag, pp_outline_blur_frag, pp_outline_overlay_frag, pp_tonemap_frag, pp_oit_weighted_frag, raw_meshline_vert: vertex, raw_meshline_frag: fragment };
var UniformsLib = { common: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Matrix3() }, uv2Transform: { value: new Matrix3() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Vector2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Color(16777215) } }, lights: { ambientLightColor: { value: [], needsUpdate: true }, lightProbe: { value: [], needsUpdate: true }, directionalLights: { value: [], needsUpdate: true }, directionalLightShadowsCSM: { value: [], needsUpdate: true }, directionalLightShadowsCSMCascade: { value: [], needsUpdate: true }, directionalShadowCSMMap: { value: [] }, directionalShadowCSMMatrix: { value: [] }, spotLights: { value: [], needsUpdate: true }, spotLightShadows: { value: [], needsUpdate: true }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], needsUpdate: true }, pointLightShadows: { value: [], needsUpdate: true }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], needsUpdate: true }, rectAreaLights: { value: [], needsUpdate: true }, rectAreaLightShadows: { value: [], needsUpdate: true }, rectAreaShadowMap: { value: [] }, rectAreaShadowMatrix: { value: [] }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Matrix3() } }, sprite: { diffuse: { value: new Color(16777215) }, opacity: { value: 1 }, center: { value: new Vector2(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Matrix3() } }, mask: { depthTexture: { value: null }, cameraNearFar: { value: new Vector2(0.5, 0.5) }, textureMatrix: { value: new Matrix4() } }, node: { nodeRGB: { value: [] }, nodeValue: { value: [] }, nodeInputsFloat: { value: [] }, nodeInputsInt: { value: [] }, nodeInputsBool: { value: [] }, nodeInputsVec2: { value: [] }, nodeInputsVec3: { value: [] }, nodeInputsVec4: { value: [] }, nodeInputsMat3: { value: [] }, nodeInputsMat4: { value: [] }, flipCubeMap: { value: -1 }, materialIndex: { value: 0 } }, nodeGTAO: { gtaoMap: { value: null } }, ssr: { invProjectionMatrix: { value: new Matrix4() }, ssrSourceBuffer: { value: null }, ssrDepthBuffer: { value: null }, ssrBackfaceDepthBuffer: { value: null }, ssrStride: { value: 20 }, ssrResolution: { value: new Vector2() }, ssrThickness: { value: 0.01 }, ssrJitter: { value: 1 }, ssrMaxDistance: { value: 100 } }, planeReflectionProbe: { planeReflTexture: { value: null }, planeReflTextureMatrix: { value: new Matrix4() }, planeReflDir: { value: new Vector3() }, planeReflBoundingBoxMin: { value: new Vector3() }, planeReflBoundingBoxMax: { value: new Vector3() }, planeReflInvModelMatrix: { value: new Matrix4() }, planeReflFalloff: { value: 0 } } };
var ShaderLib = { basic: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color(0) } }]), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, standard: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, UniformsLib.planeReflectionProbe, { emissive: { value: new Color(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 }, envMapParallaxType: { value: 0 }, envMapParallaxMatrix: { value: new Matrix4() }, envMapParallaxMatrixInv: { value: new Matrix4() } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, points: { uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { slopeScaledBias: { value: 0 } }]), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.meshnormal_vert, fragmentShader: ShaderChunk.meshnormal_frag }, sprite: { uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: new Matrix3() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: ShaderChunk.backgroundCube_vert, fragmentShader: ShaderChunk.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null }, invertU: { value: false }, offsetU: { value: 0 } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: new Vector3() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 }, slopeScaledBias: { value: 0 } }]), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, { color: { value: new Color(0) }, opacity: { value: 1 } }]), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag }, mask: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, UniformsLib.mask]), vertexShader: ShaderChunk.mask_vert, fragmentShader: ShaderChunk.mask_frag }, node: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, UniformsLib.envmap, UniformsLib.fog, UniformsLib.lights, UniformsLib.ssr, UniformsLib.planeReflectionProbe, UniformsLib.node, UniformsLib.nodeGTAO, { envMapIntensity: { value: 1 }, envMapParallaxType: { value: 0 }, envMapParallaxMatrix: { value: new Matrix4() }, envMapParallaxMatrixInv: { value: new Matrix4() } }]), vertexShader: ShaderChunk.meshnode_vert, fragmentShader: ShaderChunk.meshnode_frag }, cubeOctahedral: { uniforms: { tCube: { value: null }, texelSize: { value: new Vector2(0.5, 0.5) } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_cube_octahedral_proj_frag } };
ShaderLib.physical = { uniforms: mergeUniforms([ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Vector2(1, 1) }, clearcoatNormalMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new Vector2() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Color(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Color(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, ShaderLib.copy = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_copy_frag }, ShaderLib.bokeh = { defines: { DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tColor: { value: null }, tDepth: { value: null }, focus: { value: 1 }, aspect: { value: 1 }, aperture: { value: 0.025 }, maxblur: { value: 1 }, nearClip: { value: 1 }, farClip: { value: 1e3 }, depthLeakThreshold: { value: 0.2 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_bokeh_frag }, ShaderLib.fxaa = { defines: { FXAA_GLSL_100: 1, FXAA_GLSL_130: 0, FXAA_QUALITY_PRESET: 12, FXAA_GREEN_AS_LUMA: 1 }, uniforms: { tDiffuse: { value: null }, resolution: { value: new Vector2(1 / 1024, 1 / 512) } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_fxaa_frag }, ShaderLib.grayscale = { uniforms: { tDiffuse: { value: null } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_grayscale_frag }, ShaderLib.brightness_contrast = { uniforms: { tDiffuse: { value: null }, brightness: { value: 0 }, contrast: { value: 0 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_brightness_contrast_frag }, ShaderLib.bloomLumHighPass = { uniforms: { tDiffuse: { type: "t", value: null }, luminosityThreshold: { type: "f", value: 1 }, smoothWidth: { type: "f", value: 1 }, defaultColor: { type: "c", value: new Color(0) }, defaultOpacity: { type: "f", value: 0 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_bloom_lum_high_pass_frag }, ShaderLib.blur = { defines: { LOG_SPACE: 0, OCTAHEDRAL_MAP: 0 }, uniforms: { colorTexture: { value: null }, texSize: { value: new Vector2(0.5, 0.5) }, direction: { value: new Vector2(0.5, 0.5) }, kernelRadius: { value: 1 } }, customPrepTokens: { MAX_SAMPLE_RADIUS: 4 }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_blur_frag }, ShaderLib.tonemap = { defines: { ALPHA_AS_LUMA: 0 }, uniforms: { tDiffuse: { value: null } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_tonemap_frag }, ShaderLib.afterimage = { uniforms: { damp: { value: 0.96 }, tOld: { value: null }, tNew: { value: null } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_afterimage_frag }, ShaderLib.oitWeighted = { uniforms: { tRGBABuffer: { value: null }, tFloatBuffer: { value: null } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_oit_weighted_frag };
var _rgb = { r: 0, b: 0, g: 0 };
function WebGLBackground(e, t, n, o, r, i, a) {
  const s = new Color(0);
  let l, c, u = true === i ? 0 : 1, d = null, h = 0, f = null;
  function p(t2, n2) {
    t2.getRGB(_rgb, getUnlitUniformColorSpace(e)), o.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, n2, a);
  }
  return { getClearColor: function() {
    return s;
  }, setClearColor: function(e2, t2 = 1) {
    s.set(e2), u = t2, p(s, u);
  }, getClearAlpha: function() {
    return u;
  }, setClearAlpha: function(e2) {
    u = e2, p(s, u);
  }, dispose: function() {
    l && (l.geometry.dispose(), l.material.dispose()), l = void 0, c && (c.geometry.dispose(), c.material.dispose()), c = void 0;
  }, render: function(o2, i2) {
    let a2 = false, m = true === i2.isScene ? i2.background : null;
    if (m && m.isTexture) {
      m = (i2.backgroundBlurriness > 0 ? n : t).get(m);
    }
    const g = e.xr, _ = g.getSession && g.getSession();
    _ && "additive" === _.environmentBlendMode && (m = null), null === m ? p(s, u) : m && m.isColor && (p(m, 1), a2 = true), (e.autoClear || a2) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || 306 === m.mapping) ? (void 0 === c && (c = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({ type: "BackgroundCubeMaterial", uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms), vertexShader: ShaderLib.backgroundCube.vertexShader, fragmentShader: ShaderLib.backgroundCube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(e2, t2, n2) {
      const o3 = n2.far;
      this.matrixWorld.makeScale(o3, o3, o3), this.matrixWorld.copyPosition(n2.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), r.update(c)), c.material.uniforms.envMap.value = m, c.material.uniforms.flipEnvMap.value = m.isCubeTexture && false === m.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = i2.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = i2.backgroundIntensity, c.material.toneMapped = i2.backgroundToneMapped, d === m && h === m.version && f === e.toneMapping || (c.material.needsUpdate = true, d = m, h = m.version, f = e.toneMapping), c.layers.enableAll(), o2.unshift(c, c.geometry, c.material, 0, 0, null)) : m && m.isTexture && (void 0 === l && (l = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({ type: "BackgroundMaterial", uniforms: cloneUniforms(ShaderLib.background.uniforms), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), r.update(l)), l.material.uniforms.t2D.value = m, l.material.uniforms.backgroundIntensity.value = i2.backgroundIntensity, l.material.toneMapped = i2.backgroundToneMapped, true === m.matrixAutoUpdate && m.updateMatrix(), l.material.uniforms.uvTransform.value.copy(m.matrix), d === m && h === m.version && f === e.toneMapping || (l.material.needsUpdate = true, d = m, h = m.version, f = e.toneMapping), l.layers.enableAll(), o2.unshift(l, l.geometry, l.material, 0, 0, null));
  } };
}
function WebGLBindingStates(e, t, n, o) {
  const r = e.getParameter(34921), i = o.isWebGL2 ? null : t.get("OES_vertex_array_object"), a = o.isWebGL2 || null !== i, s = {}, l = f(null);
  let c = l, u = false;
  function d(t2) {
    return o.isWebGL2 ? e.bindVertexArray(t2) : i.bindVertexArrayOES(t2);
  }
  function h(t2) {
    return o.isWebGL2 ? e.deleteVertexArray(t2) : i.deleteVertexArrayOES(t2);
  }
  function f(e2) {
    const t2 = [], n2 = [], o2 = [];
    for (let e3 = 0; e3 < r; e3++) t2[e3] = 0, n2[e3] = 0, o2[e3] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: t2, enabledAttributes: n2, attributeDivisors: o2, object: e2, attributes: {}, index: null };
  }
  function p() {
    const e2 = c.newAttributes;
    for (let t2 = 0, n2 = e2.length; t2 < n2; t2++) e2[t2] = 0;
  }
  function m(e2) {
    g(e2, 0);
  }
  function g(n2, r2) {
    const i2 = c.newAttributes, a2 = c.enabledAttributes, s2 = c.attributeDivisors;
    if (i2[n2] = 1, 0 === a2[n2] && (e.enableVertexAttribArray(n2), a2[n2] = 1), s2[n2] !== r2) {
      (o.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[o.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n2, r2), s2[n2] = r2;
    }
  }
  function _() {
    const t2 = c.newAttributes, n2 = c.enabledAttributes;
    for (let o2 = 0, r2 = n2.length; o2 < r2; o2++) n2[o2] !== t2[o2] && (e.disableVertexAttribArray(o2), n2[o2] = 0);
  }
  function A(t2, n2, r2, i2, a2, s2) {
    true !== o.isWebGL2 || 5124 !== r2 && 5125 !== r2 ? e.vertexAttribPointer(t2, n2, r2, i2, a2, s2) : e.vertexAttribIPointer(t2, n2, r2, a2, s2);
  }
  function v() {
    x(), u = true, c !== l && (c = l, d(c.object));
  }
  function x() {
    l.geometry = null, l.program = null, l.wireframe = false;
  }
  return { setup: function(r2, l2, h2, v2, x2) {
    let y = false;
    if (a) {
      const t2 = function(t3, n2, r3) {
        const a2 = true === r3.wireframe;
        let l3 = s[t3.id];
        void 0 === l3 && (l3 = {}, s[t3.id] = l3);
        let c2 = l3[n2.id];
        void 0 === c2 && (c2 = {}, l3[n2.id] = c2);
        let u2 = c2[a2];
        void 0 === u2 && (u2 = f(o.isWebGL2 ? e.createVertexArray() : i.createVertexArrayOES()), c2[a2] = u2);
        return u2;
      }(v2, h2, l2);
      c !== t2 && (c = t2, d(c.object)), y = function(e2, t3, n2, o2) {
        const r3 = c.attributes, i2 = t3.attributes;
        let a2 = 0;
        const s2 = n2.getAttributes();
        for (const t4 in s2) {
          if (s2[t4].location >= 0) {
            const n3 = r3[t4];
            let o3 = i2[t4];
            if (void 0 === o3 && ("instanceMatrix" === t4 && e2.instanceMatrix && (o3 = e2.instanceMatrix), "instanceColor" === t4 && e2.instanceColor && (o3 = e2.instanceColor)), void 0 === n3) return true;
            if (n3.attribute !== o3) return true;
            if (o3 && n3.data !== o3.data) return true;
            a2++;
          }
        }
        return c.attributesNum !== a2 || c.index !== o2;
      }(r2, v2, h2, x2), y && function(e2, t3, n2, o2) {
        const r3 = {}, i2 = t3.attributes;
        let a2 = 0;
        const s2 = n2.getAttributes();
        for (const t4 in s2) {
          if (s2[t4].location >= 0) {
            let n3 = i2[t4];
            void 0 === n3 && ("instanceMatrix" === t4 && e2.instanceMatrix && (n3 = e2.instanceMatrix), "instanceColor" === t4 && e2.instanceColor && (n3 = e2.instanceColor));
            const o3 = {};
            o3.attribute = n3, n3 && n3.data && (o3.data = n3.data), r3[t4] = o3, a2++;
          }
        }
        c.attributes = r3, c.attributesNum = a2, c.index = o2;
      }(r2, v2, h2, x2);
    } else {
      const e2 = true === l2.wireframe;
      c.geometry === v2.id && c.program === h2.id && c.wireframe === e2 || (c.geometry = v2.id, c.program = h2.id, c.wireframe = e2, y = true);
    }
    null !== x2 && n.update(x2, 34963), (y || u) && (u = false, function(r3, i2, a2, s2) {
      if (false === o.isWebGL2 && (r3.isInstancedMesh || s2.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
      p();
      const l3 = s2.attributes, c2 = a2.getAttributes(), u2 = i2.defaultAttributeValues;
      for (const t2 in c2) {
        const o2 = c2[t2];
        if (o2.location >= 0) {
          let i3 = l3[t2];
          if (void 0 === i3 && ("instanceMatrix" === t2 && r3.instanceMatrix && (i3 = r3.instanceMatrix), "instanceColor" === t2 && r3.instanceColor && (i3 = r3.instanceColor)), void 0 !== i3) {
            const t3 = i3.normalized, a3 = i3.itemSize, l4 = n.get(i3);
            if (void 0 === l4) continue;
            const c3 = l4.buffer, u3 = l4.type, d2 = l4.bytesPerElement;
            if (i3.isInterleavedBufferAttribute) {
              const n2 = i3.data, l5 = n2.stride, h3 = i3.offset;
              if (n2.isInstancedInterleavedBuffer) {
                for (let e2 = 0; e2 < o2.locationSize; e2++) g(o2.location + e2, n2.meshPerAttribute);
                true !== r3.isInstancedMesh && void 0 === s2._maxInstanceCount && (s2._maxInstanceCount = n2.meshPerAttribute * n2.count);
              } else for (let e2 = 0; e2 < o2.locationSize; e2++) m(o2.location + e2);
              e.bindBuffer(34962, c3);
              for (let e2 = 0; e2 < o2.locationSize; e2++) A(o2.location + e2, a3 / o2.locationSize, u3, t3, l5 * d2, (h3 + a3 / o2.locationSize * e2) * d2);
            } else {
              if (i3.isInstancedBufferAttribute) {
                for (let e2 = 0; e2 < o2.locationSize; e2++) g(o2.location + e2, i3.meshPerAttribute);
                true !== r3.isInstancedMesh && void 0 === s2._maxInstanceCount && (s2._maxInstanceCount = i3.meshPerAttribute * i3.count);
              } else for (let e2 = 0; e2 < o2.locationSize; e2++) m(o2.location + e2);
              e.bindBuffer(34962, c3);
              for (let e2 = 0; e2 < o2.locationSize; e2++) A(o2.location + e2, a3 / o2.locationSize, u3, t3, a3 * d2, a3 / o2.locationSize * e2 * d2);
            }
          } else if (void 0 !== u2) {
            const n2 = u2[t2];
            if (void 0 !== n2) switch (n2.length) {
              case 2:
                e.vertexAttrib2fv(o2.location, n2);
                break;
              case 3:
                e.vertexAttrib3fv(o2.location, n2);
                break;
              case 4:
                e.vertexAttrib4fv(o2.location, n2);
                break;
              default:
                e.vertexAttrib1fv(o2.location, n2);
            }
          }
        }
      }
      _();
    }(r2, l2, h2, v2), null !== x2 && e.bindBuffer(34963, n.get(x2).buffer));
  }, reset: v, resetDefaultState: x, dispose: function() {
    v();
    for (const e2 in s) {
      const t2 = s[e2];
      for (const e3 in t2) {
        const n2 = t2[e3];
        for (const e4 in n2) h(n2[e4].object), delete n2[e4];
        delete t2[e3];
      }
      delete s[e2];
    }
  }, releaseStatesOfGeometry: function(e2) {
    if (void 0 === s[e2.id]) return;
    const t2 = s[e2.id];
    for (const e3 in t2) {
      const n2 = t2[e3];
      for (const e4 in n2) h(n2[e4].object), delete n2[e4];
      delete t2[e3];
    }
    delete s[e2.id];
  }, releaseStatesOfProgram: function(e2) {
    for (const t2 in s) {
      const n2 = s[t2];
      if (void 0 === n2[e2.id]) continue;
      const o2 = n2[e2.id];
      for (const e3 in o2) h(o2[e3].object), delete o2[e3];
      delete n2[e2.id];
    }
  }, initAttributes: p, enableAttribute: m, disableUnusedAttributes: _ };
}
function WebGLBufferRenderer(e, t, n, o) {
  const r = o.isWebGL2;
  let i;
  this.setMode = function(e2) {
    i = e2;
  }, this.render = function(t2, o2) {
    e.drawArrays(i, t2, o2), n.update(o2, i, 1);
  }, this.renderInstances = function(o2, a, s) {
    if (0 === s) return;
    let l, c;
    if (r) l = e, c = "drawArraysInstanced";
    else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("v3d.WebGLBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l[c](i, o2, a, s), n.update(a, i, s);
  };
}
function WebGLCapabilities(e, t, n) {
  let o;
  function r(t2) {
    if ("highp" === t2) {
      if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
      t2 = "mediump";
    }
    return "mediump" === t2 && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const i = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
  let a = void 0 !== n.precision ? n.precision : "highp";
  const s = r(a);
  s !== a && (console.warn("v3d.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
  const l = i || t.has("WEBGL_draw_buffers"), c = true === n.logarithmicDepthBuffer, u = e.getParameter(34930), d = e.getParameter(35660), h = e.getParameter(3379), f = e.getParameter(34076), p = e.getParameter(34921), m = e.getParameter(36347), g = e.getParameter(36348), _ = e.getParameter(36349), A = d > 0, v = i || t.has("OES_texture_float");
  return { isWebGL2: i, drawBuffers: l, getMaxAnisotropy: function() {
    if (void 0 !== o) return o;
    if (true === t.has("EXT_texture_filter_anisotropic")) {
      const n2 = t.get("EXT_texture_filter_anisotropic");
      o = e.getParameter(n2.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else o = 0;
    return o;
  }, getMaxPrecision: r, precision: a, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: d, maxTextureSize: h, maxCubemapSize: f, maxAttributes: p, maxVertexUniforms: m, maxVaryings: g, maxFragmentUniforms: _, vertexTextures: A, floatFragmentTextures: v, floatVertexTextures: A && v, maxSamples: i ? e.getParameter(36183) : 0 };
}
function WebGLClipping(e) {
  const t = this;
  let n = null, o = 0, r = false, i = false;
  const a = new Plane(), s = new Matrix3(), l = { value: null, needsUpdate: false };
  function c() {
    l.value !== n && (l.value = n, l.needsUpdate = o > 0), t.numPlanes = o, t.numIntersection = 0;
  }
  function u(e2, n2, o2, r2) {
    const i2 = null !== e2 ? e2.length : 0;
    let c2 = null;
    if (0 !== i2) {
      if (c2 = l.value, true !== r2 || null === c2) {
        const t2 = o2 + 4 * i2, r3 = n2.matrixWorldInverse;
        s.getNormalMatrix(r3), (null === c2 || c2.length < t2) && (c2 = new Float32Array(t2));
        for (let t3 = 0, n3 = o2; t3 !== i2; ++t3, n3 += 4) a.copy(e2[t3]).applyMatrix4(r3, s), a.normal.toArray(c2, n3), c2[n3 + 3] = a.constant;
      }
      l.value = c2, l.needsUpdate = true;
    }
    return t.numPlanes = i2, t.numIntersection = 0, c2;
  }
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e2, t2, i2) {
    const a2 = 0 !== e2.length || t2 || 0 !== o || r;
    return r = t2, n = u(e2, i2, 0), o = e2.length, a2;
  }, this.beginShadows = function() {
    i = true, u(null);
  }, this.endShadows = function() {
    i = false, c();
  }, this.setState = function(t2, a2, s2) {
    const d = t2.clippingPlanes, h = t2.clipIntersection, f = t2.clipShadows, p = e.get(t2);
    if (!r || null === d || 0 === d.length || i && !f) i ? u(null) : c();
    else {
      const e2 = i ? 0 : o, t3 = 4 * e2;
      let r2 = p.clippingState || null;
      l.value = r2, r2 = u(d, a2, t3, s2);
      for (let e3 = 0; e3 !== t3; ++e3) r2[e3] = n[e3];
      p.clippingState = r2, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += e2;
    }
  };
}
function WebGLCubeMaps(e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(e2, t2) {
    return 303 === t2 ? e2.mapping = 301 : 304 === t2 && (e2.mapping = 302), e2;
  }
  function o(e2) {
    const n2 = e2.target;
    n2.removeEventListener("dispose", o);
    const r = t.get(n2);
    void 0 !== r && (t.delete(n2), r.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture && false === r.isRenderTargetTexture) {
      const i = r.mapping;
      if (303 === i || 304 === i) {
        if (t.has(r)) {
          return n(t.get(r).texture, r.mapping);
        }
        {
          const i2 = r.image;
          if (i2 && i2.height > 0) {
            const a = new WebGLCubeRenderTarget(i2.height / 2);
            return a.fromEquirectangularTexture(e, r), t.set(r, a), r.addEventListener("dispose", o), n(a.texture, r.mapping);
          }
          return null;
        }
      }
    }
    return r;
  }, dispose: function() {
    t = /* @__PURE__ */ new WeakMap();
  } };
}
var OrthographicCamera = class extends Camera {
  constructor(e = -1, t = 1, n = 1, o = -1, r = 0.1, i = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = o, this.near = r, this.far = i, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, o, r, i) {
    null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = o, this.view.width = r, this.view.height = i, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, o = (this.top + this.bottom) / 2;
    let r = n - e, i = n + e, a = o + t, s = o - t;
    if (null !== this.view && this.view.enabled) {
      const e2 = (this.right - this.left) / this.view.fullWidth / this.zoom, t2 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += e2 * this.view.offsetX, i = r + e2 * this.view.width, a -= t2 * this.view.offsetY, s = a - t2 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, i, a, s, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
};
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(e) {
    super(e), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
  }
};
var MAX_TILE_SIZE = 256;
var LOD_CONFIG = [{ relSize: 1, sigma: 0, origin: [0, 0] }, { relSize: 0.5, sigma: 0.025, origin: [0, 2 / 3] }, { relSize: 1 / 4, sigma: 0.07, origin: [0.5, 2 / 3] }, { relSize: 1 / 8, sigma: 0.18, origin: [0.75, 2 / 3] }, { relSize: 1 / 16, sigma: 0.24, origin: [0.875, 2 / 3] }, { relSize: 1 / 16, sigma: 0.3, origin: [0.875, 17 / 24] }, { relSize: 1 / 16, sigma: 0.36, origin: [0.875, 0.75] }, { relSize: 1 / 16, sigma: 0.42, origin: [0.875, 19 / 24] }, { relSize: 1 / 16, sigma: 0.48, origin: [0.875, 20 / 24] }, { relSize: 1 / 16, sigma: 0.54, origin: [0.875, 0.875] }, { relSize: 1 / 16, sigma: 0.6, origin: [0.875, 22 / 24] }];
function _getLodTileSize(e) {
  return LOD_CONFIG[e].relSize * MAX_TILE_SIZE;
}
function _getLodOrigin(e) {
  return LOD_CONFIG[e].origin.map(function(e2) {
    return e2 * MAX_TILE_SIZE * 3;
  });
}
var _flatCamera = new OrthographicCamera();
var _lodPlanes = _createPlanes();
var _clearColor$2 = new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];
var PMREMGenerator = class {
  constructor(e, t) {
    this._renderer = e, this._pingPongRenderTarget = null, this._equirectShader = null, this._cubemapShader = null, this.flipCubemapX = false, Object.defineProperties(this, { maxTileSize: { get: function() {
      return MAX_TILE_SIZE;
    }, set: function(e2) {
      MAX_TILE_SIZE = e2;
    } } }), void 0 !== t && (this.maxTileSize = t), this._blurMaterial = _getBlurShader(20, this.maxTileSize), this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, o = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const r = this._allocateTargets();
    return this._sceneToCubeUV(e, n, o, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  fromEquirectangular(e) {
    return e.magFilter = 1006, e.minFilter = 1006, e.generateMipmaps = false, this.fromCubemap(e);
  }
  fromCubemap(e) {
    _oldTarget = this._renderer.getRenderTarget();
    const t = this._allocateTargets(e);
    return this._textureToCubeUV(e, t, this.flipCubemapX), this._applyPMREM(t), this._cleanup(t), t;
  }
  fromCubeRenderTarget(e, t) {
    const n = this._allocateTargets(e.texture, t);
    return this._cubeRTToCubeUV(e, n, this.flipCubemapX), this._applyPMREM(n), this._cleanup(n), n;
  }
  compileCubemapShader() {
    null === this._cubemapShader && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader));
  }
  compileEquirectangularShader() {
    null === this._equirectShader && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader));
  }
  dispose() {
    this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
    for (let e = 0; e < _lodPlanes.length; e++) _lodPlanes[e].dispose();
    this._renderer = null;
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(_oldTarget), e.scissorTest = false, e.setSize(e.width, e.height);
  }
  _allocateTargets(e, t) {
    const n = { magFilter: 1006, minFilter: 1006, generateMipmaps: false, type: e ? e.type : 1016, format: e ? e.format : 1023, encoding: e ? e.encoding : 3e3, depthBuffer: false, stencilBuffer: false };
    void 0 !== t && Object.assign(n, t);
    const o = _createRenderTarget(n);
    return o.depthBuffer = !e, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = _createRenderTarget(n)), o;
  }
  _compileMaterial(e) {
    const t = new Scene();
    t.add(new Mesh(_lodPlanes[0], e)), this._renderer.compile(t, _flatCamera);
  }
  _sceneToCubeUV(e, t, n, o) {
    const r = new PerspectiveCamera(90, 1, t, n), i = [1, 1, 1, 1, -1, 1], a = [1, 1, -1, -1, -1, 1], s = this._renderer, l = s.outputEncoding, c = s.toneMapping, u = s.toneMappingExposure;
    s.getClearColor(_clearColor$2);
    const d = s.getClearAlpha();
    s.toneMapping = 1, s.toneMappingExposure = 1, s.outputEncoding = 3e3, e.scale.z *= -1;
    let h = e.background;
    if (h && h.isColor) {
      h.convertSRGBToLinear();
      const t2 = Math.max(h.r, h.g, h.b), n2 = Math.min(Math.max(Math.ceil(Math.log2(t2)), -128), 127);
      h = h.multiplyScalar(Math.pow(2, -n2));
      const o2 = (n2 + 128) / 255;
      s.setClearColor(h, o2), e.background = null;
    }
    for (let t2 = 0; t2 < 6; t2++) {
      const n2 = t2 % 3;
      0 === n2 ? (r.up.set(0, i[t2], 0), r.lookAt(a[t2], 0, 0)) : 1 === n2 ? (r.up.set(0, 0, i[t2]), r.lookAt(0, a[t2], 0)) : (r.up.set(0, i[t2], 0), r.lookAt(0, 0, a[t2]));
      const l2 = _getLodTileSize(0);
      _setViewport(o, n2 * l2, t2 > 2 ? l2 : 0, l2, l2), s.setRenderTarget(o), s.render(e, r);
    }
    s.toneMapping = c, s.toneMappingExposure = u, s.outputEncoding = l, s.setClearColor(_clearColor$2, d), e.scale.z *= -1;
  }
  _textureToCubeUV(e, t, n) {
    const o = this._renderer, r = new Scene();
    e.isCubeTexture ? null === this._cubemapShader && (this._cubemapShader = _getCubemapShader()) : null === this._equirectShader && (this._equirectShader = _getEquirectShader());
    const i = e.isCubeTexture ? this._cubemapShader : this._equirectShader;
    r.add(new Mesh(_lodPlanes[0], i));
    const a = i.uniforms;
    a.envMap.value = e, e.isCubeTexture ? a.flipCubemapX.value = n || false : a.texelSize.value.set(1 / e.image.width, 1 / e.image.height);
    const s = _getLodTileSize(0);
    _setViewport(t, 0, 0, 3 * s, 2 * s), o.setRenderTarget(t), o.render(r, _flatCamera);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = false;
    for (let t2 = 1; t2 < LOD_CONFIG.length; t2++) {
      const n2 = LOD_CONFIG[t2].sigma, o = LOD_CONFIG[t2 - 1].sigma, r = Math.sqrt(n2 * n2 - o * o), i = _axisDirections[(t2 - 1) % _axisDirections.length];
      this._blur(e, t2 - 1, t2, r, i);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, o, r) {
    const i = this._pingPongRenderTarget;
    this._halfBlur(e, i, t, n, o, "latitudinal", r), this._halfBlur(i, e, n, n, o, "longitudinal", r);
  }
  _halfBlur(e, t, n, o, r, i, a) {
    const s = this._renderer, l = this._blurMaterial;
    "latitudinal" !== i && "longitudinal" !== i && console.error("blur direction must be either latitudinal or longitudinal!");
    const c = new Scene();
    c.add(new Mesh(_lodPlanes[o], l));
    const u = l.uniforms, d = _getLodTileSize(n) - 1;
    let h = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / 39, f = r / h, p = isFinite(r) ? 1 + Math.floor(3 * f) : 20;
    p > 20 && (p = 20, f = 19 / 3, h = r / f);
    const m = [];
    let g = 0;
    for (let e2 = 0; e2 < 20; ++e2) {
      const t2 = e2 / f, n2 = Math.exp(-t2 * t2 / 2);
      m.push(n2), 0 === e2 ? g += n2 : e2 < p && (g += 2 * n2);
    }
    for (let e2 = 0; e2 < m.length; e2++) m[e2] = m[e2] / g;
    u.envMap.value = e.texture, u.samples.value = p, u.weights.value = m, u.latitudinal.value = "latitudinal" === i, a && (u.poleAxis.value = a), u.dTheta.value = h, u.lodIdx.value = n;
    l.defines.cubeUV_maxTileSize = shaderFloatStr(_getLodTileSize(0));
    const [_, A] = _getLodOrigin(o), v = _getLodTileSize(o);
    _setViewport(t, _, A, 3 * v, 2 * v), s.setRenderTarget(t), s.render(c, _flatCamera);
  }
  _cubeRTToCubeUV(e, t, n) {
    const o = this._renderer, r = new Scene();
    null == this._cubemapShader && (this._cubemapShader = _getCubemapShader());
    const i = this._cubemapShader;
    r.add(new Mesh(_lodPlanes[0], i));
    const a = i.uniforms;
    a.envMap.value = e.texture, a.flipCubemapX.value = n || false;
    const s = _getLodTileSize(0);
    _setViewport(t, 0, 0, 3 * s, 2 * s), o.setRenderTarget(t), o.render(r, _flatCamera);
  }
};
function _createPlanes() {
  return LOD_CONFIG.map(function(e, t) {
    const n = 1 / (_getLodTileSize(t) - 1), o = -n / 2, r = 1 + n / 2, i = [o, o, r, o, r, r, o, o, r, r, o, r], a = new Float32Array(108), s = new Float32Array(72), l = new Float32Array(36);
    for (let e2 = 0; e2 < 6; e2++) {
      const t2 = e2 % 3 * 2 / 3 - 1, n2 = e2 > 2 ? 0 : -1, o2 = [t2, n2, 0, t2 + 2 / 3, n2, 0, t2 + 2 / 3, n2 + 1, 0, t2, n2, 0, t2 + 2 / 3, n2 + 1, 0, t2, n2 + 1, 0];
      a.set(o2, 18 * e2), s.set(i, 12 * e2);
      const r2 = [e2, e2, e2, e2, e2, e2];
      l.set(r2, 6 * e2);
    }
    const c = new BufferGeometry();
    return c.setAttribute("position", new BufferAttribute(a, 3)), c.setAttribute("uv", new BufferAttribute(s, 2)), c.setAttribute("faceIndex", new BufferAttribute(l, 1)), c;
  });
}
function _createRenderTarget(e) {
  const t = _getLodTileSize(0), n = new WebGLRenderTarget(3 * t, 3 * t, e);
  return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUV", n.scissorTest = true, n;
}
function _setViewport(e, t, n, o, r) {
  e.viewport.set(t, n, o, r), e.scissor.set(t, n, o, r);
}
function _getBlurShader(e, t) {
  const n = new Float32Array(e), o = new Vector3(0, 1, 0), r = new RawShaderMaterial({ defines: { n: e, cubeUV_maxTileSize: shaderFloatStr(t) }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: false }, dTheta: { value: 0 }, lodIdx: { value: 0 }, poleAxis: { value: o } }, vertexShader: _getCommonVertexShader(), fragmentShader: "\n\n            precision highp float;\n            precision highp int;\n\n            varying vec3 vOutputDirection;\n\n            uniform sampler2D envMap;\n            uniform int samples;\n            uniform float weights[n];\n            uniform bool latitudinal;\n            uniform float dTheta;\n            uniform float lodIdx;\n            uniform vec3 poleAxis;\n\n            #define ENVMAP_TYPE_CUBE_UV\n            #include <cube_uv_reflection_fragment>\n\n            vec3 getSample(float theta, vec3 axis) {\n\n                float cosTheta = cos(theta);\n                // Rodrigues' axis-angle rotation\n                vec3 sampleDirection = vOutputDirection * cosTheta\n                    + cross(axis, vOutputDirection) * sin(theta)\n                    + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\n                return bilinearCubeUV(envMap, sampleDirection, lodIdx);\n\n            }\n\n            void main() {\n\n                vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\n                if (all(equal(axis, vec3(0.0)))) {\n\n                    axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\n                }\n\n                axis = normalize(axis);\n\n                gl_FragColor = vec4(0.0);\n                gl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\n                for (int i = 1; i < n; i++) {\n\n                    if (i >= samples) {\n\n                        break;\n\n                    }\n\n                    float theta = dTheta * float(i);\n                    gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n                    gl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\n                }\n\n            }\n        ", blending: 0, depthTest: false, depthWrite: false });
  return r.type = "SphericalGaussianBlur", r;
}
function _getEquirectShader() {
  const e = new Vector2(1, 1), t = new RawShaderMaterial({ uniforms: { envMap: { value: null }, texelSize: { value: e } }, vertexShader: _getCommonVertexShader(), fragmentShader: "\n\n            precision mediump float;\n            precision mediump int;\n\n            varying vec3 vOutputDirection;\n\n            uniform sampler2D envMap;\n            uniform vec2 texelSize;\n\n            #define RECIPROCAL_PI 0.31830988618\n            #define RECIPROCAL_PI2 0.15915494\n\n            void main() {\n\n                gl_FragColor = vec4(0.0);\n\n                vec3 outputDirection = normalize(vOutputDirection);\n                vec2 uv;\n                uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n                uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\n                vec2 f = fract(uv / texelSize - 0.5);\n                uv -= f * texelSize;\n                vec3 tl = texture2D(envMap, uv).rgb;\n                uv.x += texelSize.x;\n                vec3 tr = texture2D(envMap, uv).rgb;\n                uv.y += texelSize.y;\n                vec3 br = texture2D(envMap, uv).rgb;\n                uv.x -= texelSize.x;\n                vec3 bl = texture2D(envMap, uv).rgb;\n\n                vec3 tm = mix(tl, tr, f.x);\n                vec3 bm = mix(bl, br, f.x);\n                gl_FragColor.rgb = mix(tm, bm, f.y);\n\n            }\n        ", blending: 0, depthTest: false, depthWrite: false });
  return t.type = "EquirectangularToCubeUV", t;
}
function _getCubemapShader() {
  const e = new RawShaderMaterial({ uniforms: { envMap: { value: null }, flipCubemapX: { value: false } }, vertexShader: _getCommonVertexShader(), fragmentShader: "\n\n            precision mediump float;\n            precision mediump int;\n\n            uniform bool flipCubemapX;\n\n            varying vec3 vOutputDirection;\n\n            uniform samplerCube envMap;\n\n            void main() {\n\n                gl_FragColor = textureCube(envMap, vec3(vOutputDirection.x * (flipCubemapX ? -1.0 : 1.0), vOutputDirection.yz));\n\n            }\n        ", blending: 0, depthTest: false, depthWrite: false });
  return e.type = "CubemapToCubeUV", e;
}
function _getCommonVertexShader() {
  return "\n\n        precision mediump float;\n        precision mediump int;\n\n        attribute vec3 position;\n        attribute vec2 uv;\n        attribute float faceIndex;\n\n        varying vec3 vOutputDirection;\n\n        // RH coordinate system; PMREM face-indexing convention\n        vec3 getDirection(vec2 uv, float face) {\n\n            uv = 2.0 * uv - 1.0;\n\n            vec3 direction = vec3(uv, 1.0);\n\n            if (face == 0.0) {\n\n                direction = direction.zyx;\n                direction.z *= -1.0;\n\n            } else if (face == 1.0) {\n\n                direction = direction.xzy;\n                direction.z *= -1.0;\n\n            } else if (face == 3.0) {\n\n                direction = direction.zyx;\n                direction.x *= -1.0;\n\n            } else if (face == 4.0) {\n\n                direction = direction.xzy;\n                direction.y *= -1.0;\n\n            } else if (face == 5.0) {\n\n                direction.xz *= -1.0;\n\n            }\n\n            return direction;\n\n        }\n\n        void main() {\n\n            vOutputDirection = getDirection(uv, faceIndex);\n            gl_Position = vec4(position, 1.0);\n\n        }\n    ";
}
function WebGLCubeUVMaps(e) {
  let t = /* @__PURE__ */ new WeakMap(), n = null;
  function o(e2) {
    const n2 = e2.target;
    n2.removeEventListener("dispose", o);
    const r = t.get(n2);
    void 0 !== r && (t.delete(n2), r.dispose());
  }
  return { get: function(r) {
    if (r && r.isTexture) {
      const i = r.mapping, a = 303 === i || 304 === i, s = 301 === i || 302 === i;
      if (a || s) {
        if (r.isRenderTargetTexture && true === r.needsPMREMUpdate) {
          r.needsPMREMUpdate = false;
          let o2 = t.get(r);
          return null === n && (n = new PMREMGenerator(e)), o2 = a ? n.fromEquirectangular(r, o2) : n.fromCubemap(r, o2), t.set(r, o2), o2.texture;
        }
        if (t.has(r)) return t.get(r).texture;
        {
          const i2 = r.image;
          if (a && i2 && i2.height > 0 || s && i2 && function(e2) {
            let t2 = 0;
            const n2 = 6;
            for (let o2 = 0; o2 < n2; o2++) void 0 !== e2[o2] && t2++;
            return t2 === n2;
          }(i2)) {
            null === n && (n = new PMREMGenerator(e));
            const i3 = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
            return t.set(r, i3), r.addEventListener("dispose", o), i3.texture;
          }
          return null;
        }
      }
    }
    return r;
  }, dispose: function() {
    t = /* @__PURE__ */ new WeakMap(), null !== n && (n.dispose(), n = null);
  } };
}
function WebGLExtensions(e) {
  const t = {};
  function n(n2) {
    if (void 0 !== t[n2]) return t[n2];
    let o;
    switch (n2) {
      case "WEBGL_depth_texture":
        o = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        o = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        o = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        o = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        o = e.getExtension(n2);
    }
    return t[n2] = o, o;
  }
  return { has: function(e2) {
    return null !== n(e2);
  }, init: function(e2) {
    e2.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture");
  }, get: function(e2) {
    const t2 = n(e2);
    return null === t2 && console.warn("v3d.WebGLRenderer: " + e2 + " extension not supported."), t2;
  } };
}
function WebGLGeometries(e, t, n, o) {
  const r = {}, i = /* @__PURE__ */ new WeakMap();
  function a(e2) {
    const s2 = e2.target;
    null !== s2.index && t.remove(s2.index);
    for (const e3 in s2.attributes) t.remove(s2.attributes[e3]);
    s2.removeEventListener("dispose", a), delete r[s2.id];
    const l = i.get(s2);
    l && (t.remove(l), i.delete(s2)), o.releaseStatesOfGeometry(s2), true === s2.isInstancedBufferGeometry && delete s2._maxInstanceCount, n.memory.geometries--;
  }
  function s(e2) {
    const n2 = [], o2 = e2.index, r2 = e2.attributes.position;
    let a2 = 0;
    if (null !== o2) {
      const e3 = o2.array;
      a2 = o2.version;
      for (let t2 = 0, o3 = e3.length; t2 < o3; t2 += 3) {
        const o4 = e3[t2 + 0], r3 = e3[t2 + 1], i2 = e3[t2 + 2];
        n2.push(o4, r3, r3, i2, i2, o4);
      }
    } else {
      const e3 = r2.array;
      a2 = r2.version;
      for (let t2 = 0, o3 = e3.length / 3 - 1; t2 < o3; t2 += 3) {
        const e4 = t2 + 0, o4 = t2 + 1, r3 = t2 + 2;
        n2.push(e4, o4, o4, r3, r3, e4);
      }
    }
    const s2 = new (arrayNeedsUint32(n2) ? Uint32BufferAttribute : Uint16BufferAttribute)(n2, 1);
    s2.version = a2;
    const l = i.get(e2);
    l && t.remove(l), i.set(e2, s2);
  }
  return { get: function(e2, t2) {
    return true === r[t2.id] || (t2.addEventListener("dispose", a), r[t2.id] = true, n.memory.geometries++), t2;
  }, update: function(e2) {
    const n2 = e2.attributes;
    for (const e3 in n2) t.update(n2[e3], 34962);
    const o2 = e2.morphAttributes;
    for (const e3 in o2) {
      const n3 = o2[e3];
      for (let e4 = 0, o3 = n3.length; e4 < o3; e4++) t.update(n3[e4], 34962);
    }
  }, getWireframeAttribute: function(e2) {
    const t2 = i.get(e2);
    if (t2) {
      const n2 = e2.index;
      null !== n2 && t2.version < n2.version && s(e2);
    } else s(e2);
    return i.get(e2);
  } };
}
function WebGLIndexedBufferRenderer(e, t, n, o) {
  const r = o.isWebGL2;
  let i, a, s;
  this.setMode = function(e2) {
    i = e2;
  }, this.setIndex = function(e2) {
    a = e2.type, s = e2.bytesPerElement;
  }, this.render = function(t2, o2) {
    e.drawElements(i, o2, a, t2 * s), n.update(o2, i, 1);
  }, this.renderInstances = function(o2, l, c) {
    if (0 === c) return;
    let u, d;
    if (r) u = e, d = "drawElementsInstanced";
    else if (u = t.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", null === u) return void console.error("v3d.WebGLIndexedBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    u[d](i, l, a, o2 * s, c), n.update(l, i, c);
  };
}
function WebGLInfo(e) {
  const t = { geometries: 0, textures: 0, textureSpecs: /* @__PURE__ */ new Map() }, n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0, customCounter: 0 };
  return { memory: t, render: n, programs: null, numShaderCompiles: 0, reset: function() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0, n.customCounter = 0;
  }, update: function(e2, t2, o) {
    switch (n.calls++, t2) {
      case 4:
        n.triangles += o * (e2 / 3);
        break;
      case 1:
        n.lines += o * (e2 / 2);
        break;
      case 3:
        n.lines += o * (e2 - 1);
        break;
      case 2:
        n.lines += o * e2;
        break;
      case 0:
        n.points += o * e2;
        break;
      default:
        console.error("v3d.WebGLInfo: Unknown draw mode:", t2);
    }
  }, count: function() {
    n.customCounter++;
  }, addTextureSpec: function(e2) {
    let n2, o, r, i, a, s;
    e2.isWebGLRenderTarget ? (n2 = e2.texture.name, o = "RenderTarget", r = e2.width, i = e2.height, a = e2.texture.format, s = !!e2.texture.isCubeTexture) : (n2 = e2.name, o = "Texture", r = e2.image.width, i = e2.image.height, a = e2.format, s = !!e2.isCubeTexture), t.textureSpecs.set(e2, { name: n2, type: o, width: r, height: i, format: a, isCube: s });
  }, removeTextureSpec: function(e2) {
    t.textureSpecs.delete(e2);
  } };
}
function WebGLMaterials(e, t) {
  function n(e2, n2) {
    e2.opacity.value = n2.opacity, n2.color && e2.diffuse.value.copy(n2.color), n2.emissive && e2.emissive.value.copy(n2.emissive).multiplyScalar(n2.emissiveIntensity), n2.map && (e2.map.value = n2.map), n2.alphaMap && (e2.alphaMap.value = n2.alphaMap), n2.bumpMap && (e2.bumpMap.value = n2.bumpMap, e2.bumpScale.value = n2.bumpScale, 1 === n2.side && (e2.bumpScale.value *= -1)), n2.displacementMap && (e2.displacementMap.value = n2.displacementMap, e2.displacementScale.value = n2.displacementScale, e2.displacementBias.value = n2.displacementBias), n2.emissiveMap && (e2.emissiveMap.value = n2.emissiveMap), n2.normalMap && (e2.normalMap.value = n2.normalMap, e2.normalScale.value.copy(n2.normalScale), 1 === n2.side && e2.normalScale.value.negate()), n2.specularMap && (e2.specularMap.value = n2.specularMap), n2.alphaTest > 0 && (e2.alphaTest.value = n2.alphaTest);
    const o = t.get(n2).envMap;
    let r, i;
    o && (e2.envMap.value = o, e2.flipEnvMap.value = o.isCubeTexture && false === o.isRenderTargetTexture ? -1 : 1, e2.reflectivity.value = n2.reflectivity, e2.ior.value = n2.ior, e2.refractionRatio.value = n2.refractionRatio), n2.lightMap && (e2.lightMap.value = n2.lightMap, e2.lightMapIntensity.value = n2.lightMapIntensity), n2.aoMap && (e2.aoMap.value = n2.aoMap, e2.aoMapIntensity.value = n2.aoMapIntensity), n2.map ? r = n2.map : n2.specularMap ? r = n2.specularMap : n2.displacementMap ? r = n2.displacementMap : n2.normalMap ? r = n2.normalMap : n2.bumpMap ? r = n2.bumpMap : n2.roughnessMap ? r = n2.roughnessMap : n2.metalnessMap ? r = n2.metalnessMap : n2.alphaMap ? r = n2.alphaMap : n2.emissiveMap ? r = n2.emissiveMap : n2.clearcoatMap ? r = n2.clearcoatMap : n2.clearcoatNormalMap ? r = n2.clearcoatNormalMap : n2.clearcoatRoughnessMap ? r = n2.clearcoatRoughnessMap : n2.specularIntensityMap ? r = n2.specularIntensityMap : n2.specularColorMap ? r = n2.specularColorMap : n2.transmissionMap ? r = n2.transmissionMap : n2.thicknessMap && (r = n2.thicknessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), true === r.matrixAutoUpdate && r.updateMatrix(), e2.uvTransform.value.copy(r.matrix)), n2.aoMap ? i = n2.aoMap : n2.lightMap && (i = n2.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), true === i.matrixAutoUpdate && i.updateMatrix(), e2.uv2Transform.value.copy(i.matrix));
  }
  return { refreshFogUniforms: function(t2, n2) {
    n2.color.getRGB(t2.fogColor.value, getUnlitUniformColorSpace(e)), n2.isFog ? (t2.fogNear.value = n2.near, t2.fogFar.value = n2.far) : n2.isFogExp2 && (t2.fogDensity.value = n2.density);
  }, refreshMaterialUniforms: function(e2, o, r, i, a) {
    o.ssrParams && function(e3, t2) {
      e3.invProjectionMatrix.value = t2.ssrParams.invProjectionMatrix, e3.ssrSourceBuffer.value = t2.ssrParams.sourceBuffer.texture, e3.ssrDepthBuffer.value = t2.ssrParams.depthBuffer.texture, e3.ssrBackfaceDepthBuffer.value = t2.ssrParams.backfaceDepthBuffer.texture, e3.ssrResolution.value.set(t2.ssrParams.sourceBuffer.width, t2.ssrParams.sourceBuffer.height), e3.ssrStride.value = t2.ssrParams.stride, e3.ssrThickness.value = t2.ssrParams.thickness, e3.ssrMaxDistance.value = t2.ssrParams.maxDistance, e3.ssrJitter.value = t2.ssrParams.jitter;
    }(e2, o), o.isMeshBasicMaterial || o.isMeshLambertMaterial ? n(e2, o) : o.isMeshStandardMaterial ? (n(e2, o), function(e3, n2) {
      e3.roughness.value = n2.roughness, e3.metalness.value = n2.metalness, n2.roughnessMap && (e3.roughnessMap.value = n2.roughnessMap);
      n2.metalnessMap && (e3.metalnessMap.value = n2.metalnessMap);
      const o2 = t.get(n2).envMap;
      o2 && (e3.envMapIntensity.value = n2.envMapIntensity, e3.envMapParallaxType.value = n2.envMapParallaxType, e3.envMapParallaxMatrix.value.copy(n2.envMapParallaxMatrix), e3.envMapParallaxMatrixInv.value.copy(n2.envMapParallaxMatrixInv));
    }(e2, o), o.isMeshPhysicalMaterial && function(e3, t2, n2) {
      e3.ior.value = t2.ior, t2.clearcoat > 0 && (e3.clearcoat.value = t2.clearcoat, e3.clearcoatRoughness.value = t2.clearcoatRoughness, t2.clearcoatMap && (e3.clearcoatMap.value = t2.clearcoatMap), t2.clearcoatRoughnessMap && (e3.clearcoatRoughnessMap.value = t2.clearcoatRoughnessMap), t2.clearcoatNormalMap && (e3.clearcoatNormalScale.value.copy(t2.clearcoatNormalScale), e3.clearcoatNormalMap.value = t2.clearcoatNormalMap, 1 === t2.side && e3.clearcoatNormalScale.value.negate()));
      t2.transmission > 0 && (e3.transmission.value = t2.transmission, e3.transmissionSamplerMap.value = n2.texture, e3.transmissionSamplerSize.value.set(n2.width, n2.height), t2.transmissionMap && (e3.transmissionMap.value = t2.transmissionMap), e3.thickness.value = t2.thickness, t2.thicknessMap && (e3.thicknessMap.value = t2.thicknessMap), e3.attenuationDistance.value = t2.attenuationDistance, e3.attenuationColor.value.copy(t2.attenuationColor));
      e3.specularIntensity.value = t2.specularIntensity, e3.specularColor.value.copy(t2.specularColor), t2.specularIntensityMap && (e3.specularIntensityMap.value = t2.specularIntensityMap);
      t2.specularColorMap && (e3.specularColorMap.value = t2.specularColorMap);
    }(e2, o, a)) : o.isMeshDepthMaterial ? (n(e2, o), function(e3, t2) {
      e3.slopeScaledBias.value = t2.slopeScaledBias;
    }(e2, o)) : o.isMeshDistanceMaterial ? (n(e2, o), function(e3, t2) {
      e3.referencePosition.value.copy(t2.referencePosition), e3.nearDistance.value = t2.nearDistance, e3.farDistance.value = t2.farDistance, e3.slopeScaledBias.value = t2.slopeScaledBias;
    }(e2, o)) : o.isMeshNormalMaterial ? n(e2, o) : o.isLineBasicMaterial ? (function(e3, t2) {
      e3.diffuse.value.copy(t2.color), e3.opacity.value = t2.opacity;
    }(e2, o), o.isLineDashedMaterial && function(e3, t2) {
      e3.dashSize.value = t2.dashSize, e3.totalSize.value = t2.dashSize + t2.gapSize, e3.scale.value = t2.scale;
    }(e2, o)) : o.isPointsMaterial ? function(e3, t2, n2, o2) {
      e3.diffuse.value.copy(t2.color), e3.opacity.value = t2.opacity, e3.size.value = t2.size * n2, e3.scale.value = 0.5 * o2, t2.map && (e3.map.value = t2.map);
      t2.alphaMap && (e3.alphaMap.value = t2.alphaMap);
      t2.alphaTest > 0 && (e3.alphaTest.value = t2.alphaTest);
      let r2;
      t2.map ? r2 = t2.map : t2.alphaMap && (r2 = t2.alphaMap);
      void 0 !== r2 && (true === r2.matrixAutoUpdate && r2.updateMatrix(), e3.uvTransform.value.copy(r2.matrix));
    }(e2, o, r, i) : o.isSpriteMaterial ? function(e3, t2) {
      e3.diffuse.value.copy(t2.color), e3.opacity.value = t2.opacity, e3.rotation.value = t2.rotation, t2.map && (e3.map.value = t2.map);
      t2.alphaMap && (e3.alphaMap.value = t2.alphaMap);
      t2.alphaTest > 0 && (e3.alphaTest.value = t2.alphaTest);
      let n2;
      t2.map ? n2 = t2.map : t2.alphaMap && (n2 = t2.alphaMap);
      void 0 !== n2 && (true === n2.matrixAutoUpdate && n2.updateMatrix(), e3.uvTransform.value.copy(n2.matrix));
    }(e2, o) : o.isShadowMaterial ? (e2.color.value.copy(o.color), e2.opacity.value = o.opacity) : o.isMeshMaskMaterial ? (n(e2, o), function(e3, t2) {
      t2.cameraNearFar && (e3.cameraNearFar.value = t2.cameraNearFar);
      e3.depthTexture.value = t2.depthTexture, t2.textureMatrix && (e3.textureMatrix.value = t2.textureMatrix);
    }(e2, o)) : o.isMeshNodeMaterial ? function(e3, n2) {
      n2.alphaTest > 0 && (e3.alphaTest.value = n2.alphaTest);
      for (let t2 = 0; t2 < n2.nodeValue.length; t2++) e3.nodeValue.value[t2] = n2.nodeValue[t2];
      for (let t2 = 0; t2 < n2.nodeRGB.length; t2++) {
        n2.nodeRGB[t2].toArray(e3.nodeRGB.value, 4 * t2);
      }
      const o2 = t.get(n2).envMap;
      o2 && (e3.envMap.value = o2, e3.flipEnvMap.value = o2.isCubeTexture && o2.isRenderTargetTexture ? -1 : 1, e3.envMapIntensity.value = n2.envMapIntensity, e3.envMapParallaxType.value = n2.envMapParallaxType, e3.envMapParallaxMatrix.value.copy(n2.envMapParallaxMatrix), e3.envMapParallaxMatrixInv.value.copy(n2.envMapParallaxMatrixInv));
      n2.displacementMap && (e3.displacementMap.value = n2.displacementMap, e3.displacementScale.value = n2.displacementScale, e3.displacementBias.value = n2.displacementBias);
      e3.materialIndex.value = n2.materialIndex;
    }(e2, o) : o.isMeshLineMaterial ? function(e3, t2) {
      e3.lineWidth.value = t2.lineWidth, e3.sizeAttenuation.value = t2.sizeAttenuation, e3.color.value = t2.color, e3.opacity.value = t2.opacity, e3.useMap.value = t2.useMap, t2.map && (e3.map.value = t2.map);
      e3.useAlphaMap.value = t2.useAlphaMap, t2.alphaMap && (e3.alphaMap.value = t2.alphaMap);
      e3.visibility.value = t2.visibility, e3.alphaTest.value = t2.alphaTest, e3.repeat.value = t2.repeat;
    }(e2, o) : o.isShaderMaterial && (o.uniformsNeedUpdate = false);
  }, refreshGTAOUniforms: function(e2, t2) {
    e2.gtaoMap.value = t2;
  }, refreshPlaneReflProbeUniforms: function(e2, t2) {
    e2.planeReflTexture.value = t2.renderTarget.texture, e2.planeReflTextureMatrix.value.copy(t2.textureMatrix), e2.planeReflDir.value.copy(t2.normal), e2.planeReflBoundingBoxMin.value.copy(t2.boundingBox.min), e2.planeReflBoundingBoxMax.value.copy(t2.boundingBox.max), e2.planeReflInvModelMatrix.value.copy(t2.matrixWorldInverse), e2.planeReflFalloff.value = t2.falloff;
  } };
}
function numericalSort(e, t) {
  return e[0] - t[0];
}
function absNumericalSort(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function WebGLMorphtargets(e, t, n) {
  const o = {}, r = new Float32Array(12), i = /* @__PURE__ */ new WeakMap(), a = new Vector4(), s = [];
  for (let e2 = 0; e2 < 12; e2++) s[e2] = [e2, 0];
  return { update: function(l, c, u, d) {
    const h = l.morphTargetInfluences;
    if (true === t.isWebGL2) {
      const o2 = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, r2 = void 0 !== o2 ? o2.length : 0;
      let s2 = i.get(c);
      if (void 0 === s2 || s2.count !== r2) {
        void 0 !== s2 && s2.texture.dispose();
        const e2 = void 0 !== c.morphAttributes.position, n2 = void 0 !== c.morphAttributes.normal, o3 = void 0 !== c.morphAttributes.color, l3 = c.morphAttributes.position || [], u3 = c.morphAttributes.normal || [], d2 = c.morphAttributes.color || [];
        let h2 = 0;
        true === e2 && (h2 = 1), true === n2 && (h2 = 2), true === o3 && (h2 = 3);
        let f = c.attributes.position.count * h2, p = 1;
        f > t.maxTextureSize && (p = Math.ceil(f / t.maxTextureSize), f = t.maxTextureSize);
        const m = new Float32Array(f * p * 4 * r2), g = new DataArrayTexture(m, f, p, r2);
        g.type = 1015, g.needsUpdate = true;
        const _ = 4 * h2;
        for (let t2 = 0; t2 < r2; t2++) {
          const r3 = l3[t2], i2 = u3[t2], s3 = d2[t2], c2 = f * p * 4 * t2;
          for (let t3 = 0; t3 < r3.count; t3++) {
            const l4 = t3 * _;
            true === e2 && (a.fromBufferAttribute(r3, t3), m[c2 + l4 + 0] = a.x, m[c2 + l4 + 1] = a.y, m[c2 + l4 + 2] = a.z, m[c2 + l4 + 3] = 0), true === n2 && (a.fromBufferAttribute(i2, t3), m[c2 + l4 + 4] = a.x, m[c2 + l4 + 5] = a.y, m[c2 + l4 + 6] = a.z, m[c2 + l4 + 7] = 0), true === o3 && (a.fromBufferAttribute(s3, t3), m[c2 + l4 + 8] = a.x, m[c2 + l4 + 9] = a.y, m[c2 + l4 + 10] = a.z, m[c2 + l4 + 11] = 4 === s3.itemSize ? a.w : 1);
          }
        }
        s2 = { count: r2, texture: g, size: new Vector2(f, p) }, i.set(c, s2), c.addEventListener("dispose", function e3() {
          g.dispose(), i.delete(c), c.removeEventListener("dispose", e3);
        });
      }
      let l2 = 0;
      for (let e2 = 0; e2 < h.length; e2++) l2 += h[e2];
      const u2 = c.morphTargetsRelative ? 1 : 1 - l2;
      d.getUniforms().setValue(e, "morphTargetBaseInfluence", u2), d.getUniforms().setValue(e, "morphTargetInfluences", h), d.getUniforms().setValue(e, "morphTargetsTexture", s2.texture, n), d.getUniforms().setValue(e, "morphTargetsTextureSize", s2.size);
    } else {
      const t2 = void 0 === h ? 0 : h.length;
      let n2 = o[c.id];
      if (void 0 === n2 || n2.length !== t2) {
        n2 = [];
        for (let e2 = 0; e2 < t2; e2++) n2[e2] = [e2, 0];
        o[c.id] = n2;
      }
      for (let e2 = 0; e2 < t2; e2++) {
        const t3 = n2[e2];
        t3[0] = e2, t3[1] = h[e2];
      }
      n2.sort(absNumericalSort);
      for (let e2 = 0; e2 < 12; e2++) e2 < t2 && n2[e2][1] ? (s[e2][0] = n2[e2][0], s[e2][1] = n2[e2][1]) : (s[e2][0] = Number.MAX_SAFE_INTEGER, s[e2][1] = 0);
      s.sort(numericalSort);
      const i2 = c.morphAttributes.position, a2 = c.morphAttributes.normal;
      let l2 = 0;
      for (let e2 = 0; e2 < 12; e2++) {
        const t3 = s[e2], n3 = t3[0], o2 = t3[1];
        n3 !== Number.MAX_SAFE_INTEGER && o2 ? (i2 && c.getAttribute("morphTarget" + e2) !== i2[n3] && c.setAttribute("morphTarget" + e2, i2[n3]), a2 && c.getAttribute("morphNormal" + e2) !== a2[n3] && c.setAttribute("morphNormal" + e2, a2[n3]), r[e2] = o2, l2 += o2) : (i2 && true === c.hasAttribute("morphTarget" + e2) && c.deleteAttribute("morphTarget" + e2), a2 && true === c.hasAttribute("morphNormal" + e2) && c.deleteAttribute("morphNormal" + e2), r[e2] = 0);
      }
      const u2 = c.morphTargetsRelative ? 1 : 1 - l2;
      d.getUniforms().setValue(e, "morphTargetBaseInfluence", u2), d.getUniforms().setValue(e, "morphTargetInfluences", r);
    }
  } };
}
var DepthTexture = class extends Texture {
  constructor(e, t, n, o, r, i, a, s, l, c) {
    if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c) throw new Error("DepthTexture format must be either v3d.DepthFormat or v3d.DepthStencilFormat");
    void 0 === n && 1026 === c && (n = 1014), void 0 === n && 1027 === c && (n = 1020), super(null, o, r, i, a, s, c, n, l), this.isDepthTexture = true, this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : 1003, this.minFilter = void 0 !== s ? s : 1003, this.flipY = false, this.generateMipmaps = false;
  }
};
var Pass = class extends EventDispatcher {
  constructor() {
    super(), this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("v3d.Pass: .render() must be implemented in derived pass.");
  }
  setCamera(e) {
  }
  dispose() {
  }
};
var _camera$1 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _geometry$1 = new BufferGeometry();
_geometry$1.setAttribute("position", new BufferAttribute(new Float32Array([-1, 3, 0, -1, -1, 0, 3, -1, 0]), 3)), _geometry$1.setAttribute("uv", new BufferAttribute(new Float32Array([0, 2, 0, 0, 2, 0]), 2));
var FullScreenQuad = class {
  constructor(e) {
    this._mesh = new Mesh(_geometry$1, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, _camera$1);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
  static dispose() {
    _geometry$1.dispose();
  }
};
var _clearColor$1 = new Color();
var _tmpLayers = new Layers();
var WebGLOITMethod = class {
  constructor(e, t) {
    this.isWebGLOITMethod = true, this.resolution = e, this.textureType = t, this.type = "WebGLOITMethod", this.mute = false;
  }
  render() {
    this.mute;
  }
  dispose() {
  }
  setSize(e, t) {
    this.resolution.set(e, t);
  }
  _ensureProperBuffersClearing(e) {
    e.state.buffers.depth.setTest(true), e.state.buffers.depth.setMask(true), e.state.buffers.color.setMask(true);
  }
};
var WebGLOITWeighted = class extends WebGLOITMethod {
  constructor(e, t, n) {
    super(e, t), this.isWebGLOITWeighted = true, this.type = "WebGLOITWeighted", this.shader = ShaderLib.oitWeighted, this.uniforms = UniformsUtils.clone(this.shader.uniforms), this.scene = null, this.camera = null, this.aaSamples = n || 0, this.renderTargetMRT = new WebGLMultipleRenderTargets(this.resolution.x, this.resolution.y, 2), this.renderTargetMRT.texture[0].name = "wboit_rgba", this.renderTargetMRT.texture[0].format = 1023, this.renderTargetMRT.texture[0].type = t, this.renderTargetMRT.texture[1].name = "wboit_r", this.renderTargetMRT.texture[1].format = 1028, this.renderTargetMRT.texture[1].type = t, this.aaSamples > 0 && (this.renderTargetMRTMSAA = new WebGLMultipleRenderTargets(this.resolution.x, this.resolution.y, 2, { samples: n }), this.renderTargetMRTMSAA.texture[0].name = "wboit_rgba", this.renderTargetMRTMSAA.texture[0].format = 1023, this.renderTargetMRTMSAA.texture[0].type = t, this.renderTargetMRTMSAA.texture[1].name = "wboit_r", this.renderTargetMRTMSAA.texture[1].format = 1028, this.renderTargetMRTMSAA.texture[1].type = t), this.fsQuadSolver = new FullScreenQuad(new ShaderMaterial({ defines: Object.assign({}, this.shader.defines), uniforms: UniformsUtils.clone(this.shader.uniforms), vertexShader: this.shader.vertexShader, fragmentShader: this.shader.fragmentShader, depthTest: false, depthWrite: false, blending: 5, blendEquation: 100, blendSrc: 204, blendDst: 205, blendEquationAlpha: 100, blendSrcAlpha: 201, blendDstAlpha: 205 })), this._layerMasks = {}, this._matSettings = {}, this._savedCameraLayers = new Layers();
  }
  dispose() {
    super.dispose(), this.renderTargetMRT.dispose(), this.renderTargetMRTMSAA && this.renderTargetMRTMSAA.dispose();
  }
  setSize(e, t) {
    super.setSize(e, t), this.renderTargetMRT.setSize(e, t), this.renderTargetMRTMSAA && this.renderTargetMRTMSAA.setSize(e, t);
  }
  render(e, t, n, o, r) {
    if (this.mute) return;
    this._ensureProperBuffersClearing(e);
    const i = e.getRenderTarget();
    if (i.isWebGLCubeRenderTarget) return void t(n, o, r);
    const a = o.overrideMaterial;
    if (a && !this.isSupportedMaterial(a)) return void t(n, o, r);
    if (this.resolution.x !== i.width && this.resolution.y !== i.height) return console.warn("v3d.WebGLOITRenderer: render target size mismatch in v3d.WebGLOITWeighted."), void t(n, o, r);
    this.scene = o, this.camera = r, this._savedCameraLayers.mask = this.camera.layers.mask;
    const s = e.getClearColor(_clearColor$1), l = e.getClearAlpha(), c = e.autoClear, u = e.useOIT, d = e.sortObjects;
    e.setClearColor(0), e.setClearAlpha(0), e.autoClear = false, e.sortObjects = false, e.useOIT = false;
    const h = this.renderTargetMRTMSAA && this.renderTargetMRTMSAA.samples == i.samples;
    if (a) {
      const s2 = [{ object: o, material: a }];
      this._accumulationPass(e, t, h, n, s2);
      const l2 = a.colorWrite;
      a.colorWrite = false, a.needsUpdate = true, e.setRenderTarget(i), t(n, o, r), a.colorWrite = l2, a.needsUpdate = true;
    } else this._saveLayers(n), this._setupLayers(n), r.layers.disableAll(), r.layers.enable(2), t(n, o, r), r.layers.disableAll(), r.layers.enable(1), this._accumulationPass(e, t, h, n), e.setRenderTarget(i), this._renderOnlyDepth(e, t, n, o, r), this._restoreLayers(n);
    e.setRenderTarget(i), this._solverPass(e, h), e.setClearColor(s), e.setClearAlpha(l), e.sortObjects = d, e.autoClear = c, e.useOIT = u;
  }
  isSupportedMaterial(e) {
    return !(!e || !e.isMeshStandardMaterial && !e.isMeshNodeMaterial);
  }
  _accumulationPass(e, t, n, o, r) {
    r || (r = o);
    const i = e.getContext(), a = e.getRenderTarget(), s = e.getClearAlpha();
    if (this._saveMatSettings(r), this._setupMatSettings(r), e.setClearAlpha(1), a) if (n) {
      e.setRenderTarget(this.renderTargetMRTMSAA), e.clear();
      const n2 = e.properties.get(this.renderTargetMRTMSAA).__webglDepthRenderbuffer, r2 = e.properties.get(a).__webglDepthRenderbuffer;
      if (r2 && (i.framebufferRenderbuffer(36160, 36096, 36161, r2), 36053 !== i.checkFramebufferStatus(36160))) return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.");
      t(o, this.scene, this.camera);
      if (e.getTextureUtils().updateMultisampleRenderTarget(this.renderTargetMRTMSAA), r2 && (i.framebufferRenderbuffer(36160, 36096, 36161, n2 || null), 36053 !== i.checkFramebufferStatus(36160))) return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.");
    } else if (a.samples > 0) {
      e.setRenderTarget(this.renderTargetMRT), e.clear();
      const n2 = e.properties.get(this.renderTargetMRT).__webglFramebuffer, r2 = e.properties.get(a).__webglMultisampledFramebuffer;
      if (r2 && (i.bindFramebuffer(36008, r2), i.bindFramebuffer(36009, n2), i.blitFramebuffer(0, 0, this.resolution.x, this.resolution.y, 0, 0, this.resolution.x, this.resolution.y, 256, 9728), i.bindFramebuffer(36160, n2), 36053 !== i.checkFramebufferStatus(36160))) return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted. Can not blit depth buffer from multisample render target.");
      t(o, this.scene, this.camera);
    } else {
      e.setRenderTarget(this.renderTargetMRT), e.clear();
      const n2 = e.properties.get(this.renderTargetMRT), r2 = n2.__webglDepthRenderbuffer || n2.__webglDepthbuffer, s2 = e.properties.get(a), l = s2.__webglDepthRenderbuffer || s2.__webglDepthbuffer;
      if (l) {
        if (i.framebufferRenderbuffer(36160, 36096, 36161, l), 36053 !== i.checkFramebufferStatus(36160)) return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.");
      } else if (a.depthTexture) {
        const t2 = e.properties.get(a.depthTexture).__webglTexture;
        i.framebufferTexture2D(36160, 36096, 3553, t2, 0);
      }
      if (t(o, this.scene, this.camera), l) {
        if (i.framebufferRenderbuffer(36160, 36096, 36161, r2 || null), 36053 !== i.checkFramebufferStatus(36160)) return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.");
      } else if (a.depthTexture && (i.framebufferRenderbuffer(36160, 36096, 36161, r2 || null), 36053 !== i.checkFramebufferStatus(36160))) return void console.error("v3d.WebGLOITRenderer: incomplete framebuffer in v3d.WebGLOITWeighted.");
    }
    else console.error("v3d.WebGLOITRenderer: undefined render target in v3d.WebGLOITWeighted.");
    this._restoreMatSettings(r), e.setClearAlpha(s), e.setRenderTarget(a);
  }
  _solverPass(e, t) {
    const n = t ? this.renderTargetMRTMSAA : this.renderTargetMRT;
    this.fsQuadSolver.material.uniforms.tRGBABuffer.value = n.texture[0], this.fsQuadSolver.material.uniforms.tFloatBuffer.value = n.texture[1], this.fsQuadSolver.render(e);
  }
  _testInitialLayersWithInitialCameraLayers(e) {
    const t = this._layerMasks[e.id];
    return _tmpLayers.mask = void 0 !== t ? t : e.layers.mask, this._savedCameraLayers.test(_tmpLayers);
  }
  _saveLayers(e) {
    this._layerMasks[this.camera.id] = this.camera.layers.mask;
    for (let t = 0, n = e.length; t < n; t++) {
      const n2 = e[t].object;
      this._layerMasks[n2.id] = n2.layers.mask;
    }
  }
  _setupLayers(e) {
    for (let t = 0, n = e.length; t < n; t++) {
      const n2 = e[t], o = n2.object, r = n2.material;
      this._testInitialLayersWithInitialCameraLayers(o) ? (o.layers.disableAll(), this.isSupportedMaterial(r) ? o.layers.enable(1) : o.layers.enable(2)) : o.layers.disableAll();
    }
  }
  _restoreLayers(e) {
    for (let t = 0, n = e.length; t < n; t++) {
      const n2 = e[t].object;
      n2.layers.mask = this._layerMasks[n2.id], delete this._layerMasks[n2.id];
    }
    this.camera.layers.mask = this._layerMasks[this.camera.id], delete this._layerMasks[this.camera.id];
  }
  _saveMatSettings(e) {
    for (let t = 0, n = e.length; t < n; t++) {
      const n2 = e[t], o = n2.object, r = n2.material;
      r && r.id in this._matSettings || this._testInitialLayersWithInitialCameraLayers(o) && this.isSupportedMaterial(r) && (this._matSettings[r.id] = { defines: { PREMULTIPLIED_ALPHA: r.defines.PREMULTIPLIED_ALPHA }, properties: { blending: r.blending, blendEquation: r.blendEquation, blendSrc: r.blendSrc, blendDst: r.blendDst, blendEquationAlpha: r.blendEquationAlpha, blendSrcAlpha: r.blendSrcAlpha, blendDstAlpha: r.blendDstAlpha, depthTest: r.depthTest, depthWrite: r.depthWrite } });
    }
  }
  _setupMatSettings(e) {
    for (let t = 0, n = e.length; t < n; t++) {
      const n2 = e[t], o = n2.object, r = n2.material;
      this._testInitialLayersWithInitialCameraLayers(o) && (this.isSupportedMaterial(r) && (r.defines.PREMULTIPLIED_ALPHA = "", r.defines.USE_OIT_WEIGHTED = "", r.blending = 5, r.blendEquation = 100, r.blendSrc = 201, r.blendDst = 201, r.blendEquationAlpha = 100, r.blendSrcAlpha = 200, r.blendDstAlpha = 205, r.depthTest = true, r.depthWrite = false, r.needsUpdate = true));
    }
  }
  _restoreMatSettings(e) {
    for (let t = 0, n = e.length; t < n; t++) {
      const n2 = e[t], o = n2.object, r = n2.material;
      if (!r || !(r.id in this._matSettings)) continue;
      if (!this._testInitialLayersWithInitialCameraLayers(o)) continue;
      if (!this.isSupportedMaterial(r)) continue;
      delete r.defines.USE_OIT_WEIGHTED;
      const i = this._matSettings[r.id];
      for (let e2 in i.properties) r[e2] = i.properties[e2];
      for (let e2 in i.defines) i.defines[e2] ? r.defines[e2] = i.defines[e2] : delete r.defines[e2];
      r.needsUpdate = true, delete this._matSettings[r.id];
    }
  }
  _renderOnlyDepth(e, t, n, o, r) {
    const i = {};
    for (let e2 = 0, t2 = n.length; e2 < t2; e2++) {
      const t3 = n[e2], o2 = t3.object, r2 = t3.material;
      r2 && r2.id in i || this._testInitialLayersWithInitialCameraLayers(o2) && this.isSupportedMaterial(r2) && (i[r2.id] = { properties: { colorWrite: r2.colorWrite } }, r2.colorWrite = false, r2.needsUpdate = true);
    }
    t(n, o, r);
    for (let e2 = 0, t2 = n.length; e2 < t2; e2++) {
      const t3 = n[e2];
      t3.object;
      const o2 = t3.material;
      if (!o2 || !(o2.id in i)) continue;
      const r2 = i[o2.id];
      for (let e3 in r2.properties) o2[e3] = r2.properties[e3];
      o2.needsUpdate = true, delete i[o2.id];
    }
  }
};
var WebGLOITRenderer = class {
  constructor(e) {
    this.isWebGLOITRenderer = true, this.resolution = e, this.texType = 1009, this.mute = false, this.method = 0, this.oitRenderer = null;
  }
  render(e, t, n, o, r) {
    this.mute || this.oitRenderer && this.oitRenderer.render(e, t, n, o, r);
  }
  setMethod(e, t) {
    this.method !== e && (this.oitRenderer && this.oitRenderer.dispose(), this.oitRenderer = null, this.method = e, 0 !== e && 1 === e && (this.oitRenderer = new WebGLOITWeighted(this.resolution, this.texType, t)));
  }
  isMethodCompatible(e, t) {
    return 0 === e || !(1 !== e || !t.isWebGL2);
  }
  dispose() {
    this.oitRenderer && this.oitRenderer.dispose(), this.method = 0;
  }
  setSize(e, t) {
    this.resolution.set(e, t), this.oitRenderer && this.oitRenderer.setSize(e, t);
  }
};
function WebGLObjects(e, t, n, o) {
  let r = /* @__PURE__ */ new WeakMap();
  function i(e2) {
    const t2 = e2.target;
    t2.removeEventListener("dispose", i), n.remove(t2.instanceMatrix), null !== t2.instanceColor && n.remove(t2.instanceColor);
  }
  return { update: function(e2) {
    const a = o.render.frame, s = e2.geometry, l = t.get(e2, s);
    return r.get(l) !== a && (t.update(l), r.set(l, a)), e2.isInstancedMesh && (false === e2.hasEventListener("dispose", i) && e2.addEventListener("dispose", i), n.update(e2.instanceMatrix, 34962), null !== e2.instanceColor && n.update(e2.instanceColor, 34962)), l;
  }, dispose: function() {
    r = /* @__PURE__ */ new WeakMap();
  } };
}
var emptyTexture = new Texture();
var emptyArrayTexture = new DataArrayTexture();
var empty3dTexture = new Data3DTexture();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(e, t, n) {
  const o = e[0];
  if (o <= 0 || o > 0) return e;
  const r = t * n;
  let i = arrayCacheF32[r];
  if (void 0 === i && (i = new Float32Array(r), arrayCacheF32[r] = i), 0 !== t) {
    o.toArray(i, 0);
    for (let o2 = 1, r2 = 0; o2 !== t; ++o2) r2 += n, e[o2].toArray(i, r2);
  }
  return i;
}
function arraysEqual(e, t) {
  if (e.length !== t.length) return false;
  for (let n = 0, o = e.length; n < o; n++) if (e[n] !== t[n]) return false;
  return true;
}
function copyArray(e, t) {
  for (let n = 0, o = t.length; n < o; n++) e[n] = t[n];
}
function allocTexUnits(e, t) {
  let n = arrayCacheI32[t];
  void 0 === n && (n = new Int32Array(t), arrayCacheI32[t] = n);
  for (let o = 0; o !== t; ++o) n[o] = e.allocateTextureUnit();
  return n;
}
function setValueV1f(e, t) {
  const n = this.cache;
  n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t);
}
function setValueV2f(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform2fv(this.addr, t), copyArray(n, t);
  }
}
function setValueV3f(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
  else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform3fv(this.addr, t), copyArray(n, t);
  }
}
function setValueV4f(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform4fv(this.addr, t), copyArray(n, t);
  }
}
function setValueM2(e, t) {
  const n = this.cache, o = t.elements;
  if (void 0 === o) {
    if (arraysEqual(n, t)) return;
    e.uniformMatrix2fv(this.addr, false, t), copyArray(n, t);
  } else {
    if (arraysEqual(n, o)) return;
    mat2array.set(o), e.uniformMatrix2fv(this.addr, false, mat2array), copyArray(n, o);
  }
}
function setValueM3(e, t) {
  const n = this.cache, o = t.elements;
  if (void 0 === o) {
    if (arraysEqual(n, t)) return;
    e.uniformMatrix3fv(this.addr, false, t), copyArray(n, t);
  } else {
    if (arraysEqual(n, o)) return;
    mat3array.set(o), e.uniformMatrix3fv(this.addr, false, mat3array), copyArray(n, o);
  }
}
function setValueM4(e, t) {
  const n = this.cache, o = t.elements;
  if (void 0 === o) {
    if (arraysEqual(n, t)) return;
    e.uniformMatrix4fv(this.addr, false, t), copyArray(n, t);
  } else {
    if (arraysEqual(n, o)) return;
    mat4array.set(o), e.uniformMatrix4fv(this.addr, false, mat4array), copyArray(n, o);
  }
}
function setValueV1i(e, t) {
  const n = this.cache;
  n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t);
}
function setValueV2i(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform2iv(this.addr, t), copyArray(n, t);
  }
}
function setValueV3i(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform3iv(this.addr, t), copyArray(n, t);
  }
}
function setValueV4i(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform4iv(this.addr, t), copyArray(n, t);
  }
}
function setValueV1ui(e, t) {
  const n = this.cache;
  n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t);
}
function setValueV2ui(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform2uiv(this.addr, t), copyArray(n, t);
  }
}
function setValueV3ui(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform3uiv(this.addr, t), copyArray(n, t);
  }
}
function setValueV4ui(e, t) {
  const n = this.cache;
  if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
  else {
    if (arraysEqual(n, t)) return;
    e.uniform4uiv(this.addr, t), copyArray(n, t);
  }
}
function setValueT1(e, t, n) {
  const o = this.cache, r = n.allocateTextureUnit();
  o[0] !== r && (e.uniform1i(this.addr, r), o[0] = r), n.setTexture2D(t || emptyTexture, r);
}
function setValueT3D1(e, t, n) {
  const o = this.cache, r = n.allocateTextureUnit();
  o[0] !== r && (e.uniform1i(this.addr, r), o[0] = r), n.setTexture3D(t || empty3dTexture, r);
}
function setValueT6(e, t, n) {
  const o = this.cache, r = n.allocateTextureUnit();
  o[0] !== r && (e.uniform1i(this.addr, r), o[0] = r), n.setTextureCube(t || emptyCubeTexture, r);
}
function setValueT2DArray1(e, t, n) {
  const o = this.cache, r = n.allocateTextureUnit();
  o[0] !== r && (e.uniform1i(this.addr, r), o[0] = r), n.setTexture2DArray(t || emptyArrayTexture, r);
}
function getSingularSetter(e) {
  switch (e) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(e, t) {
  e.uniform1fv(this.addr, t);
}
function setValueV2fArray(e, t) {
  const n = flatten(t, this.size, 2);
  e.uniform2fv(this.addr, n);
}
function setValueV3fArray(e, t) {
  const n = flatten(t, this.size, 3);
  e.uniform3fv(this.addr, n);
}
function setValueV4fArray(e, t) {
  const n = flatten(t, this.size, 4);
  e.uniform4fv(this.addr, n);
}
function setValueM2Array(e, t) {
  const n = flatten(t, this.size, 4);
  e.uniformMatrix2fv(this.addr, false, n);
}
function setValueM3Array(e, t) {
  const n = flatten(t, this.size, 9);
  e.uniformMatrix3fv(this.addr, false, n);
}
function setValueM4Array(e, t) {
  const n = flatten(t, this.size, 16);
  e.uniformMatrix4fv(this.addr, false, n);
}
function setValueV1iArray(e, t) {
  e.uniform1iv(this.addr, t);
}
function setValueV2iArray(e, t) {
  e.uniform2iv(this.addr, t);
}
function setValueV3iArray(e, t) {
  e.uniform3iv(this.addr, t);
}
function setValueV4iArray(e, t) {
  e.uniform4iv(this.addr, t);
}
function setValueV1uiArray(e, t) {
  e.uniform1uiv(this.addr, t);
}
function setValueV2uiArray(e, t) {
  e.uniform2uiv(this.addr, t);
}
function setValueV3uiArray(e, t) {
  e.uniform3uiv(this.addr, t);
}
function setValueV4uiArray(e, t) {
  e.uniform4uiv(this.addr, t);
}
function setValueT1Array(e, t, n) {
  const o = this.cache, r = t.length, i = allocTexUnits(n, r);
  arraysEqual(o, i) || (e.uniform1iv(this.addr, i), copyArray(o, i));
  for (let e2 = 0; e2 !== r; ++e2) n.setTexture2D(t[e2] || emptyTexture, i[e2]);
}
function setValueT3DArray(e, t, n) {
  const o = this.cache, r = t.length, i = allocTexUnits(n, r);
  arraysEqual(o, i) || (e.uniform1iv(this.addr, i), copyArray(o, i));
  for (let e2 = 0; e2 !== r; ++e2) n.setTexture3D(t[e2] || empty3dTexture, i[e2]);
}
function setValueT6Array(e, t, n) {
  const o = this.cache, r = t.length, i = allocTexUnits(n, r);
  arraysEqual(o, i) || (e.uniform1iv(this.addr, i), copyArray(o, i));
  for (let e2 = 0; e2 !== r; ++e2) n.setTextureCube(t[e2] || emptyCubeTexture, i[e2]);
}
function setValueT2DArrayArray(e, t, n) {
  const o = this.cache, r = t.length, i = allocTexUnits(n, r);
  arraysEqual(o, i) || (e.uniform1iv(this.addr, i), copyArray(o, i));
  for (let e2 = 0; e2 !== r; ++e2) n.setTexture2DArray(t[e2] || emptyArrayTexture, i[e2]);
}
function getPureArraySetter(e) {
  switch (e) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
var SingleUniform = class {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.setValue = getSingularSetter(t.type);
  }
};
var PureArrayUniform = class {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = getPureArraySetter(t.type);
  }
};
var StructuredUniform = class {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const o = this.seq;
    for (let r = 0, i = o.length; r !== i; ++r) {
      const i2 = o[r];
      i2.setValue(e, t[i2.id], n);
    }
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(e, t) {
  e.seq.push(t), e.map[t.id] = t;
}
function parseUniform(e, t, n) {
  const o = e.name, r = o.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const i = RePathPart.exec(o), a = RePathPart.lastIndex;
    let s = i[1];
    const l = "]" === i[2], c = i[3];
    if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === r) {
      addUniform(n, void 0 === c ? new SingleUniform(s, e, t) : new PureArrayUniform(s, e, t));
      break;
    }
    {
      let e2 = n.map[s];
      void 0 === e2 && (e2 = new StructuredUniform(s), addUniform(n, e2)), n = e2;
    }
  }
}
var WebGLUniforms = class {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, 35718);
    for (let o = 0; o < n; ++o) {
      const n2 = e.getActiveUniform(t, o);
      parseUniform(n2, e.getUniformLocation(t, n2.name), this);
    }
  }
  setValue(e, t, n, o) {
    const r = this.map[t];
    void 0 !== r && r.setValue(e, n, o);
  }
  setOptional(e, t, n) {
    const o = t[n];
    void 0 !== o && this.setValue(e, n, o);
  }
  static upload(e, t, n, o) {
    for (let r = 0, i = t.length; r !== i; ++r) {
      const i2 = t[r], a = n[i2.id];
      false !== a.needsUpdate && i2.setValue(e, a.value, o);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let o = 0, r = e.length; o !== r; ++o) {
      const r2 = e[o];
      r2.id in t && n.push(r2);
    }
    return n;
  }
};
function WebGLShader(e, t, n) {
  const o = e.createShader(t);
  return e.shaderSource(o, n), e.compileShader(o), o;
}
var programIdCount = 0;
function handleSource(e, t) {
  const n = e.split("\n"), o = [], r = Math.max(t - 6, 0), i = Math.min(t + 6, n.length);
  for (let e2 = r; e2 < i; e2++) {
    const r2 = e2 + 1;
    o.push(`${r2 === t ? ">" : " "} ${r2}: ${n[e2]}`);
  }
  return o.join("\n");
}
function getEncodingComponents(e) {
  switch (e) {
    case 3e3:
      return ["Linear", "(value)"];
    case 3001:
      return ["sRGB", "(value)"];
    default:
      return console.warn("v3d.WebGLProgram: Unsupported encoding:", e), ["Linear", "(value)"];
  }
}
function getShaderErrors(e, t, n) {
  const o = e.getShaderParameter(t, 35713), r = e.getShaderInfoLog(t).trim();
  if (o && "" === r) return "";
  const i = /ERROR: 0:(\d+)/.exec(r);
  if (i) {
    const o2 = parseInt(i[1]);
    return n.toUpperCase() + "\n\n" + r + "\n\n" + handleSource(e.getShaderSource(t), o2);
  }
  return r;
}
function getTexelEncodingFunction(e, t) {
  const n = getEncodingComponents(t);
  return "vec4 " + e + "(vec4 value) { return LinearTo" + n[0] + n[1] + "; }";
}
function getToneMappingFunction(e, t) {
  let n;
  switch (t) {
    case 1:
      n = "Linear";
      break;
    case 2:
      n = "Reinhard";
      break;
    case 3:
      n = "OptimizedCineon";
      break;
    case 4:
      n = "ACESFilmic";
      break;
    case 5:
      n = "Custom";
      break;
    case 6:
      n = "LogarithmicMax";
      break;
    case 7:
      n = "PhysicalMax";
      break;
    case 8:
      n = "FilmicBlender";
      break;
    case 9:
      n = "AgX";
      break;
    case 10:
      n = "PbrNeutral";
      break;
    default:
      console.warn("v3d.WebGLProgram: Unsupported toneMapping:", t), n = "Linear";
  }
  return "vec3 " + e + "(vec3 color) { return " + n + "ToneMapping(color); }";
}
function genToneMappingLookDefine(e) {
  let t = "TONE_MAPPING_LOOK_NONE";
  return 1 === e && (t = "TONE_MAPPING_LOOK_AGX_PUNCHY"), t;
}
function generateExtensions(e) {
  return [e.extensionDerivatives || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID || "node" === e.shaderID || e.useSlopeScaledBias ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join("\n");
}
function generateDefines(e, t) {
  const n = [];
  for (const o in e) {
    const r = e[o];
    false === r || t && t.has(o) || n.push("#define " + o + " " + r);
  }
  return n.join("\n");
}
function fetchAttributeLocations(e, t) {
  const n = {}, o = e.getProgramParameter(t, 35721);
  for (let r = 0; r < o; r++) {
    const o2 = e.getActiveAttrib(t, r), i = o2.name;
    let a = 1;
    35674 === o2.type && (a = 2), 35675 === o2.type && (a = 3), 35676 === o2.type && (a = 4), n[i] = { type: o2.type, location: e.getAttribLocation(t, i), locationSize: a };
  }
  return n;
}
function filterEmptyLine(e) {
  return "" !== e;
}
function replaceLightNums(e, t) {
  return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows).replace(/NUM_RECT_AREA_LIGHT_SHADOWS/g, t.numRectAreaLightShadows).replace(/NUM_DIR_LIGHT_SHADOWS_CSM_WITH_FADE/g, t.numDirLightShadowsCSMWithFade).replace(/NUM_DIR_LIGHT_SHADOWS_CSM/g, t.numDirLightShadowsCSM).replace(/NUM_DIR_LIGHT_SHADOW_CASCADES_CSM/g, t.numDirLightShadowCSMCascades);
}
function replaceClippingPlaneNums(e, t) {
  return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
function replaceCustomTokens(e, t) {
  const n = Object.keys(t);
  if (n.length) {
    const o = new RegExp(n.join("|"), "g");
    return e.replace(o, function(e2) {
      return t[e2];
    });
  }
  return e;
}
function getMaterialProfile(e) {
  switch (e) {
    case "blender":
      return "#define MT_BLENDER";
    case "max":
      return "#define MT_MAX";
    case "maya":
      return "#define MT_MAYA";
    default:
      return "";
  }
}
function replaceNodeChunks(e, t) {
  for (const n in t) {
    const o = "undefined" != typeof __V3D_DEVTOOLS__ ? `// included: "${n}"
` : "";
    e = e.replace(`#include <${n}>`, o + t[n]);
  }
  return e;
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(e) {
  return e.replace(includePattern, includeReplacer);
}
function includeReplacer(e, t) {
  const n = ShaderChunk[t];
  if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
  return resolveIncludes(("undefined" != typeof __V3D_DEVTOOLS__ ? `// included: "${t}"
` : "") + n);
}
function unrollLoops(e) {
  const t = new RegExp("#pragma unroll_loop[\\s]+?for \\(int (\\w+) \\= (\\d+)\\; (\\w+) <(=?) (\\w+)\\; (\\w+)\\+\\+\\) \\{"), n = new RegExp("\\{|\\}", "g");
  let o;
  for (; o = t.exec(e); ) {
    let t2, r;
    t2 = r = n.lastIndex = o.index + o[0].length;
    let i, a = 1;
    do {
      (i = n.exec(e)) && ("{" == i[0] ? a++ : "}" == i[0] && a--, r = i.index);
    } while (i && a > 0);
    if (0 == a) {
      const i2 = e.substring(o.index, n.lastIndex), a2 = e.substring(t2, r), s = new RegExp(`\\[${o[1]}\\]`, "g"), l = new RegExp(`\\(${o[1]}\\)`, "g");
      let c = "";
      const u = parseInt(o[2]), d = parseInt(o[5]) + ("=" === o[4] ? 1 : 0);
      for (let e2 = u; e2 < d; e2++) c += "{" + a2.replace(s, `[${e2}]`).replace(l, `(${e2})`) + "}";
      e = e.replace(i2, c);
    }
  }
  return e;
}
function generatePrecision(e) {
  let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
  return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t;
}
function generateShadowMapTypeDefine(e) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_BILINEAR" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_ESM"), t;
}
function generateEnvMapTypeDefine(e) {
  let t = "ENVMAP_TYPE_CUBE";
  if (e.envMap) switch (e.envMapMode) {
    case 301:
    case 302:
      t = "ENVMAP_TYPE_CUBE";
      break;
    case 306:
      t = "ENVMAP_TYPE_CUBE_UV";
  }
  return t;
}
function generateEnvMapModeDefine(e) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (e.envMap && 302 === e.envMapMode) t = "ENVMAP_MODE_REFRACTION";
  return t;
}
function generateEnvMapBlendingDefine(e) {
  let t = "ENVMAP_BLENDING_NONE";
  if (e.envMap) switch (e.combine) {
    case 0:
      t = "ENVMAP_BLENDING_MULTIPLY";
      break;
    case 1:
      t = "ENVMAP_BLENDING_MIX";
      break;
    case 2:
      t = "ENVMAP_BLENDING_ADD";
  }
  return t;
}
function WebGLProgram(e, t, n, o) {
  const r = e.getContext(), i = n.defines;
  let a = n.vertexShader, s = n.fragmentShader;
  const l = generateShadowMapTypeDefine(n), c = generateEnvMapTypeDefine(n), u = generateEnvMapModeDefine(n), d = generateEnvMapBlendingDefine(n), h = n.unitsScaleFactor % 1 ? String(n.unitsScaleFactor) : String(n.unitsScaleFactor) + ".0", f = n.isWebGL2 ? "" : generateExtensions(n), p = generateDefines(i), m = generateDefines(i, n.definesFragOnly), g = r.createProgram(), _ = this;
  let A, v, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
  n.isRawShaderMaterial ? (A = [m].filter(filterEmptyLine).join("\n"), A.length > 0 && (A += "\n"), v = [f, p].filter(filterEmptyLine).join("\n"), v.length > 0 && (v += "\n")) : (A = [generatePrecision(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && false === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", n.planeReflProbe ? "#define USE_PLANE_REFLECTION" : "", "\n            uniform mat4 modelMatrix;\n            uniform mat4 modelViewMatrix;\n            uniform mat4 projectionMatrix;\n            uniform mat4 viewMatrix;\n            uniform mat3 normalMatrix;\n            uniform vec3 cameraPosition;\n            uniform bool isOrthographic;\n\n            #ifdef USE_INSTANCING\n                attribute mat4 instanceMatrix;\n            #endif\n\n            #ifdef USE_INSTANCING_COLOR\n                attribute vec3 instanceColor;\n            #endif\n\n            attribute vec3 position;\n            attribute vec3 normal;\n            attribute vec2 uv;\n\n            #ifdef USE_TANGENT\n                attribute vec4 tangent;\n            #endif\n\n            #if defined(USE_COLOR_ALPHA)\n                attribute vec4 color;\n            #elif defined(USE_COLOR)\n                attribute vec3 color;\n            #endif\n\n            #if (defined(USE_MORPHTARGETS) && !defined(MORPHTARGETS_TEXTURE))\n                #if MORPHTARGETS_COUNT > 0\n                    attribute vec3 morphTarget0;\n                #endif\n                #if MORPHTARGETS_COUNT > 1\n                    attribute vec3 morphTarget1;\n                #endif\n                #if MORPHTARGETS_COUNT > 2\n                    attribute vec3 morphTarget2;\n                #endif\n                #if MORPHTARGETS_COUNT > 3\n                    attribute vec3 morphTarget3;\n                #endif\n                #if MORPHTARGETS_COUNT > 4\n                    attribute vec3 morphTarget4;\n                #endif\n                #if MORPHTARGETS_COUNT > 5\n                    attribute vec3 morphTarget5;\n                #endif\n\n                #ifdef USE_MORPHNORMALS\n                    #if MORPHTARGETS_COUNT > 0\n                        attribute vec3 morphNormal0;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 1\n                        attribute vec3 morphNormal1;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 2\n                        attribute vec3 morphNormal2;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 3\n                        attribute vec3 morphNormal3;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 4\n                        attribute vec3 morphNormal4;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 5\n                        attribute vec3 morphNormal5;\n                    #endif\n                #else\n                    #if MORPHTARGETS_COUNT > 6\n                        attribute vec3 morphTarget6;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 7\n                        attribute vec3 morphTarget7;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 8\n                        attribute vec3 morphTarget8;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 9\n                        attribute vec3 morphTarget9;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 10\n                        attribute vec3 morphTarget10;\n                    #endif\n                    #if MORPHTARGETS_COUNT > 11\n                        attribute vec3 morphTarget11;\n                    #endif\n                #endif\n            #endif\n\n            #ifdef USE_SKINNING\n                attribute vec4 skinIndex;\n                attribute vec4 skinWeight;\n            #endif\n            "].filter(filterEmptyLine).join("\n"), v = [f, generatePrecision(n), "#define SHADER_NAME " + n.shaderName, p, getMaterialProfile(n.materialProfile), n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", 0 !== n.envMapCubeUVTileSize ? `#define cubeUV_maxTileSize ${shaderFloatStr(n.envMapCubeUVTileSize)}` : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "#define UNITS_SCALE_FACTOR " + h, "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? "#define TONE_MAPPING_LOOK " + genToneMappingLookDefine(n.toneMappingLook) : "", 0 !== n.toneMapping ? ShaderChunk.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? getToneMappingFunction("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque && !n.alphaToCoverage ? "#define OPAQUE" : "", ShaderChunk.encodings_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", n.distancePacking ? "#define DISTANCE_PACKING " + n.distancePacking : "", n.useSlopeScaledBias ? "#define USE_SLOPE_SCALED_BIAS" : "", `#define ESM_DISTANCE_SCALE ${shaderFloatStr(n.esmDistanceScale)}`, n.planeReflProbe ? "#define USE_PLANE_REFLECTION" : "", n.useGTAO ? "#define USE_GTAO" : "", e.compatSettings.gtaoDisableBkgFix ? "#define GTAO_DISABLE_BKG_FIX" : "", n.dirLightShadowsCSMLUT && n.isWebGL2 ? `#define LUT_DIR_LIGHT_SHADOWS_CSM int[](${n.dirLightShadowsCSMLUT})` : "", "\n"].filter(filterEmptyLine).join("\n")), n.isWebGL2 || true === n.isRawShaderMaterial || (a = "#include <webgl1_compat>\n" + a, s = "#include <webgl1_compat>\n" + s), n.isMeshNodeMaterial && (a = replaceNodeChunks(a, n.nodeChunks), s = replaceNodeChunks(s, n.nodeChunks)), a = resolveIncludes(a), a = replaceLightNums(a, n), a = replaceClippingPlaneNums(a, n), n.customPrepTokens && (a = replaceCustomTokens(a, n.customPrepTokens)), s = resolveIncludes(s), s = replaceLightNums(s, n), s = replaceClippingPlaneNums(s, n), n.customPrepTokens && (s = replaceCustomTokens(s, n.customPrepTokens)), a = unrollLoops(a), s = unrollLoops(s), n.isWebGL2 && true !== n.isRawShaderMaterial && (x = "#version 300 es\n", A = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A, v = ["#define varying in", n.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
  let y = x + A + a, b = x + v + s;
  if (e.debug.disableCompiledShaderCache) {
    const e2 = b.lastIndexOf("}");
    b = b.substr(0, e2) + "    gl_FragColor += vec4(" + 1e-3 * Math.random() + ");\n" + b.substr(e2);
  }
  const C = WebGLShader(r, 35633, y), S = WebGLShader(r, 35632, b);
  "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: { shaderName: n.shaderName, materialName: n.materialName, vertex: y, fragment: b } })), r.attachShader(g, C), r.attachShader(g, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(g, 0, n.index0AttributeName) : true === n.morphTargets && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g);
  let M, E, T = true;
  function I() {
    if (T = false, e.debug.checkShaderErrors) {
      const e2 = r.getProgramInfoLog(g).trim(), t2 = r.getShaderInfoLog(C).trim(), n2 = r.getShaderInfoLog(S).trim();
      let o2 = true, i2 = true;
      if (false === r.getProgramParameter(g, 35714)) {
        o2 = false;
        const t3 = getShaderErrors(r, C, "vertex"), n3 = getShaderErrors(r, S, "fragment");
        console.error("v3d.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(g, 35715), "gl.getProgramInfoLog", e2, t3, n3);
      } else "" !== e2 ? console.warn("v3d.WebGLProgram: gl.getProgramInfoLog()", e2) : "" !== t2 && "" !== n2 || (i2 = false);
      i2 && (_.diagnostics = { runnable: o2, programLog: e2, vertexShader: { log: t2, prefix: A }, fragmentShader: { log: n2, prefix: v } });
    }
    r.deleteShader(C), r.deleteShader(S);
  }
  return this.getUniforms = function() {
    return void 0 === M && (T && I(), M = new WebGLUniforms(r, g)), M;
  }, this.getAttributes = function() {
    return void 0 === E && (T && I(), E = fetchAttributeLocations(r, g)), E;
  }, this.destroy = function() {
    o.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0;
  }, this.name = n.shaderName, this.id = programIdCount++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = C, this.fragmentShader = S, this.profile = { calcRenderTime: false, renderTime: 0, timerQueries: [], materials: /* @__PURE__ */ new Set() }, this.getTexUniformCount = function() {
    return this.getUniforms().seq.reduce(function(e2, t2) {
      if (t2.info) switch (t2.info.type) {
        case 35678:
        case 35679:
        case 35680:
        case 35682:
        case 36289:
        case 36292:
        case 36293:
        case 36298:
        case 36299:
        case 36300:
        case 36303:
        case 36306:
        case 36307:
        case 36308:
        case 36311:
          e2 += t2.info.size;
      }
      return e2;
    }, 0);
  }, this.beginTimerQuery = function(e2, t2) {
    if (!this.profile.calcRenderTime) return;
    const n2 = e2.getExtension(t2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
    if (!n2) return;
    let o2;
    t2 ? (o2 = e2.createQuery(), e2.beginQuery(n2.TIME_ELAPSED_EXT, o2)) : (o2 = n2.createQueryEXT(), n2.beginQueryEXT(n2.TIME_ELAPSED_EXT, o2)), this.profile.timerQueries.push(o2);
  }, this.endTimerQuery = function(e2, t2) {
    if (!this.profile.calcRenderTime) return;
    const n2 = e2.getExtension(t2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
    if (!n2) return;
    t2 ? e2.endQuery(n2.TIME_ELAPSED_EXT) : n2.endQueryEXT(n2.TIME_ELAPSED_EXT);
    const o2 = this.profile.timerQueries;
    for (let r2 = o2.length - 1; r2 >= 0; r2--) {
      const i2 = o2[r2], a2 = t2 ? e2.getQueryParameter(i2, 34919) : n2.getQueryObjectEXT(i2, n2.QUERY_RESULT_AVAILABLE_EXT), s2 = e2.getParameter(n2.GPU_DISJOINT_EXT);
      if (a2 && !s2) {
        const a3 = t2 ? e2.getQueryParameter(i2, 34918) : n2.getQueryObjectEXT(i2, n2.QUERY_RESULT_EXT);
        this.profile.renderTime += a3 / 1e6, o2.splice(r2, 1);
      }
    }
  }, this;
}
var _id = 0;
var WebGLShaderCache = class {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, o = this._getShaderStage(t), r = this._getShaderStage(n), i = this._getShaderCacheForMaterial(e);
    return false === i.has(o) && (i.add(o), o.usedTimes++), false === i.has(r) && (i.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const e2 of t) e2.usedTimes--, 0 === e2.usedTimes && this.shaderCache.delete(e2.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return void 0 === n && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return void 0 === n && (n = new WebGLShaderStage(e), t.set(e, n)), n;
  }
};
var WebGLShaderStage = class {
  constructor(e) {
    this.id = _id++, this.code = e, this.usedTimes = 0;
  }
};
function WebGLPrograms(e, t, n, o, r, i, a) {
  const s = new Layers(), l = new WebGLShaderCache(), c = [], u = r.isWebGL2, d = r.logarithmicDepthBuffer, h = r.vertexTextures;
  let f = r.precision, p = 0;
  const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite", MeshMaskMaterial: "mask", MeshNodeMaterial: "node" };
  return { getParameters: function(i2, s2, c2, p2, g, _) {
    const A = p2.fog, v = g.geometry, x = i2.isMeshNodeMaterial || i2.isMeshStandardMaterial ? p2.environment : null, y = (i2.isMeshNodeMaterial || i2.isMeshStandardMaterial ? n : t).get(i2.envMap || x), b = m[i2.type];
    null !== i2.precision && (f = r.getMaxPrecision(i2.precision), f !== i2.precision && console.warn("v3d.WebGLProgram.getParameters:", i2.precision, "not supported, using", f, "instead."));
    const C = v.morphAttributes.position || v.morphAttributes.normal || v.morphAttributes.color, S = void 0 !== C ? C.length : 0;
    let M, E, T, I, w = 0;
    if (void 0 !== v.morphAttributes.position && (w = 1), void 0 !== v.morphAttributes.normal && (w = 2), void 0 !== v.morphAttributes.color && (w = 3), b) {
      const e2 = ShaderLib[b];
      M = e2.vertexShader, E = e2.fragmentShader;
    } else M = i2.vertexShader, E = i2.fragmentShader, l.update(i2), T = l.getVertexShaderID(i2), I = l.getFragmentShaderID(i2);
    const R = e.getRenderTarget(), L = i2.alphaTest > 0, B = i2.clearcoat > 0;
    return { isWebGL2: u, shaderID: b, shaderName: i2.type, vertexShader: M, fragmentShader: E, defines: i2.defines, customVertexShaderID: T, customFragmentShaderID: I, isRawShaderMaterial: true === i2.isRawShaderMaterial, glslVersion: i2.glslVersion, precision: f, instancing: true === g.isInstancedMesh, instancingColor: true === g.isInstancedMesh && null !== g.instanceColor, supportsVertexTextures: h, outputEncoding: null === R ? e.outputEncoding : true === R.isXRRenderTarget ? R.texture.encoding : 3e3, map: !!i2.map, envMap: !!y, envMapMode: y && y.mapping, lightMap: !!i2.lightMap, aoMap: !!i2.aoMap, emissiveMap: !!i2.emissiveMap, bumpMap: !!i2.bumpMap, normalMap: !!i2.normalMap, objectSpaceNormalMap: 1 === i2.normalMapType, tangentSpaceNormalMap: 0 === i2.normalMapType, decodeVideoTexture: !!i2.map && true === i2.map.isVideoTexture && 3001 === i2.map.encoding, clearcoat: B, clearcoatMap: B && !!i2.clearcoatMap, clearcoatRoughnessMap: B && !!i2.clearcoatRoughnessMap, clearcoatNormalMap: B && !!i2.clearcoatNormalMap, displacementMap: !!i2.displacementMap, roughnessMap: !!i2.roughnessMap, metalnessMap: !!i2.metalnessMap, specularMap: !!i2.specularMap, specularIntensityMap: !!i2.specularIntensityMap, specularColorMap: !!i2.specularColorMap, opaque: false === i2.transparent && 1 === i2.blending, alphaMap: !!i2.alphaMap, alphaTest: L, transmission: i2.transmission > 0, transmissionMap: !!i2.transmissionMap, thicknessMap: !!i2.thicknessMap, combine: i2.combine, vertexTangents: !!i2.normalMap && !!v.attributes.tangent, vertexColors: i2.vertexColors, vertexAlphas: true === i2.vertexColors && !!v.attributes.color && 4 === v.attributes.color.itemSize, vertexUvs: !!(i2.map || i2.bumpMap || i2.normalMap || i2.specularMap || i2.alphaMap || i2.emissiveMap || i2.roughnessMap || i2.metalnessMap || i2.clearcoatMap || i2.clearcoatRoughnessMap || i2.clearcoatNormalMap || i2.displacementMap || i2.transmissionMap || i2.thicknessMap || i2.specularIntensityMap || i2.specularColorMap), uvsVertexOnly: !(i2.map || i2.bumpMap || i2.normalMap || i2.specularMap || i2.alphaMap || i2.emissiveMap || i2.roughnessMap || i2.metalnessMap || i2.clearcoatNormalMap || i2.transmission > 0 || i2.transmissionMap || i2.thicknessMap || i2.specularIntensityMap || i2.specularColorMap || !i2.displacementMap), fog: !!A, useFog: true === i2.fog, fogExp2: A && A.isFogExp2, flatShading: !!i2.flatShading, sizeAttenuation: i2.sizeAttenuation, logarithmicDepthBuffer: d, skinning: true === g.isSkinnedMesh, morphTargets: void 0 !== v.morphAttributes.position, morphNormals: void 0 !== v.morphAttributes.normal, morphColors: void 0 !== v.morphAttributes.color, morphTargetsCount: S, morphTextureStride: w, numDirLights: s2.directional.length, numPointLights: s2.point.length, numSpotLights: s2.spot.length, numRectAreaLights: s2.rectArea.length, numHemiLights: s2.hemi.length, numPointLightShadows: s2.pointShadowMap.length, numSpotLightShadows: s2.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: i2.dithering, shadowMapEnabled: e.shadowMap.enabled && c2.length > 0, shadowMapType: e.shadowMap.type, toneMapping: i2.toneMapped ? e.toneMapping : 0, toneMappingLook: i2.toneMapped ? e.toneMappingLook : 0, premultipliedAlpha: i2.premultipliedAlpha, doubleSided: 2 === i2.side, flipSided: 1 === i2.side, useDepthPacking: !!i2.depthPacking, depthPacking: i2.depthPacking || 0, envMapCubeUVTileSize: y && 306 === y.mapping && void 0 !== y.image ? y.image.width / 3 : 0, distancePacking: void 0 !== i2.distancePacking && i2.distancePacking, useSlopeScaledBias: void 0 !== i2.useSlopeScaledBias && i2.useSlopeScaledBias, esmDistanceScale: e.shadowMap.esmDistanceScale, numRectAreaLightShadows: s2.rectAreaShadowMap.length, numDirLightShadowsCSM: s2.directionalShadowCSM.length, numDirLightShadowCSMCascades: s2.directionalShadowCSMCascade.length, numDirLightShadowsCSMWithFade: s2.numDirectionalShadowsCSMWithFade, dirLightShadowsCSMLUT: s2.directionalShadowCSMLUT, planeReflProbe: !!_, materialName: i2.name, materialProfile: i2.profile, unitsScaleFactor: e.unitsScaleFactor, alphaToCoverage: !!i2.alphaToCoverage, customPrepTokens: i2.customPrepTokens, definesFragOnly: i2.definesFragOnly, isMeshNodeMaterial: i2.isMeshNodeMaterial, nodeChunks: i2.nodeChunks, nodeChunksHash: i2.nodeChunksHash, useGTAO: e.canUseGTAO() && i2.isMeshNodeMaterial && i2.canUseGTAO(), index0AttributeName: i2.index0AttributeName, extensionDerivatives: i2.extensions && i2.extensions.derivatives, extensionFragDepth: i2.extensions && i2.extensions.fragDepth, extensionDrawBuffers: i2.extensions && i2.extensions.drawBuffers, extensionShaderTextureLOD: i2.extensions && i2.extensions.shaderTextureLOD, rendererExtensionFragDepth: u || o.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u || o.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u || o.has("EXT_shader_texture_lod"), customProgramCacheKey: i2.customProgramCacheKey() };
  }, getProgramCacheKey: function(t2) {
    const n2 = [];
    t2.shaderID ? n2.push(t2.shaderID) : (n2.push(t2.customVertexShaderID), n2.push(t2.customFragmentShaderID));
    for (const e2 in t2.defines) n2.push(e2), n2.push(t2.defines[e2]);
    if (void 0 !== t2.customPrepTokens) for (const e2 in t2.customPrepTokens) n2.push(e2), n2.push(t2.customPrepTokens[e2]);
    return false === t2.isRawShaderMaterial && (!function(e2, t3) {
      e2.push(t3.precision), e2.push(t3.outputEncoding), e2.push(t3.envMapMode), e2.push(t3.combine), e2.push(t3.vertexUvs), e2.push(t3.fogExp2), e2.push(t3.sizeAttenuation), e2.push(t3.morphTargetsCount), e2.push(t3.morphAttributeCount), e2.push(t3.numDirLights), e2.push(t3.numPointLights), e2.push(t3.numSpotLights), e2.push(t3.numHemiLights), e2.push(t3.numRectAreaLights), e2.push(t3.numPointLightShadows), e2.push(t3.numSpotLightShadows), e2.push(t3.shadowMapType), e2.push(t3.toneMapping), e2.push(t3.toneMappingLook), e2.push(t3.numClippingPlanes), e2.push(t3.numClipIntersection), e2.push(t3.depthPacking), e2.push(t3.envMapCubeUVTileSize), e2.push(t3.unitsScaleFactor), e2.push(t3.esmDistanceScale), e2.push(t3.numRectAreaLightShadows), e2.push(t3.numDirLightShadowsCSM), e2.push(t3.numDirLightShadowCSMCascades), e2.push(t3.numDirLightShadowsCSMWithFade), e2.push(t3.dirLightShadowsCSMLUT);
    }(n2, t2), function(e2, t3) {
      s.disableAll(), t3.isWebGL2 && s.enable(0);
      t3.supportsVertexTextures && s.enable(1);
      t3.instancing && s.enable(2);
      t3.instancingColor && s.enable(3);
      t3.map && s.enable(4);
      t3.envMap && s.enable(5);
      t3.lightMap && s.enable(6);
      t3.aoMap && s.enable(7);
      t3.emissiveMap && s.enable(8);
      t3.bumpMap && s.enable(9);
      t3.normalMap && s.enable(10);
      t3.objectSpaceNormalMap && s.enable(11);
      t3.tangentSpaceNormalMap && s.enable(12);
      t3.clearcoat && s.enable(13);
      t3.clearcoatMap && s.enable(14);
      t3.clearcoatRoughnessMap && s.enable(15);
      t3.clearcoatNormalMap && s.enable(16);
      t3.displacementMap && s.enable(17);
      t3.specularMap && s.enable(18);
      t3.roughnessMap && s.enable(19);
      t3.metalnessMap && s.enable(20);
      t3.alphaMap && s.enable(21);
      t3.alphaTest && s.enable(22);
      t3.vertexColors && s.enable(23);
      t3.vertexAlphas && s.enable(24);
      t3.vertexUvs && s.enable(25);
      t3.vertexTangents && s.enable(26);
      t3.uvsVertexOnly && s.enable(27);
      e2.push(s.mask), s.disableAll(), t3.fog && s.enable(0);
      t3.useFog && s.enable(1);
      t3.flatShading && s.enable(2);
      t3.logarithmicDepthBuffer && s.enable(3);
      t3.skinning && s.enable(4);
      t3.morphTargets && s.enable(5);
      t3.morphNormals && s.enable(6);
      t3.morphColors && s.enable(7);
      t3.premultipliedAlpha && s.enable(8);
      t3.shadowMapEnabled && s.enable(9);
      t3.doubleSided && s.enable(10);
      t3.flipSided && s.enable(11);
      t3.useDepthPacking && s.enable(12);
      t3.dithering && s.enable(13);
      t3.specularIntensityMap && s.enable(14);
      t3.specularColorMap && s.enable(15);
      t3.transmission && s.enable(16);
      t3.transmissionMap && s.enable(17);
      t3.thicknessMap && s.enable(18);
      t3.decodeVideoTexture && s.enable(19);
      t3.opaque && s.enable(20);
      t3.distancePacking && s.enable(21);
      t3.useSlopeScaledBias && s.enable(22);
      t3.useGTAO && s.enable(23);
      t3.planeReflProbe && s.enable(24);
      t3.alphaToCoverage && s.enable(25);
      e2.push(s.mask);
    }(n2, t2), n2.push(e.outputEncoding)), n2.push(t2.customProgramCacheKey), void 0 !== t2.nodeChunksHash && n2.push(t2.nodeChunksHash), n2.join();
  }, getUniforms: function(e2) {
    const t2 = m[e2.type];
    let n2;
    if (t2) {
      const e3 = ShaderLib[t2];
      n2 = UniformsUtils.clone(e3.uniforms);
    } else n2 = e2.uniforms;
    return n2;
  }, acquireProgram: function(t2, n2) {
    let o2;
    for (let e2 = 0, t3 = c.length; e2 < t3; e2++) {
      const t4 = c[e2];
      if (t4.cacheKey === n2) {
        o2 = t4, ++o2.usedTimes;
        break;
      }
    }
    void 0 === o2 && (o2 = new WebGLProgram(e, n2, t2, i), c.push(o2), p++);
    const r2 = o2.profile.materials;
    return t2.materialName && !r2.has(t2.materialName) && r2.add(t2.materialName), o2;
  }, releaseProgram: function(e2) {
    if (0 == --e2.usedTimes) {
      const t2 = c.indexOf(e2);
      c[t2] = c[c.length - 1], c.pop(), e2.destroy();
    }
  }, releaseShaderCache: function(e2) {
    l.remove(e2);
  }, programs: c, getNumShaderCompiles: function() {
    return p;
  }, dispose: function() {
    l.dispose();
  } };
}
function WebGLProperties() {
  let e = /* @__PURE__ */ new WeakMap();
  return { get: function(t) {
    let n = e.get(t);
    return void 0 === n && (n = {}, e.set(t, n)), n;
  }, remove: function(t) {
    e.delete(t);
  }, update: function(t, n, o) {
    e.get(t)[n] = o;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
function painterSortStable(e, t) {
  return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
}
function reversePainterSortStable(e, t) {
  return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
}
function WebGLRenderList() {
  const e = [];
  let t = 0;
  const n = [], o = [], r = [];
  function i(n2, o2, r2, i2, a, s) {
    let l = e[t];
    return void 0 === l ? (l = { id: n2.id, object: n2, geometry: o2, material: r2, groupOrder: i2, renderOrder: n2.renderOrder, z: a, group: s }, e[t] = l) : (l.id = n2.id, l.object = n2, l.geometry = o2, l.material = r2, l.groupOrder = i2, l.renderOrder = n2.renderOrder, l.z = a, l.group = s), t++, l;
  }
  return { opaque: n, transmissive: o, transparent: r, init: function() {
    t = 0, n.length = 0, o.length = 0, r.length = 0;
  }, push: function(e2, t2, a, s, l, c) {
    const u = i(e2, t2, a, s, l, c);
    a.transmission > 0 ? o.push(u) : true === a.transparent ? r.push(u) : n.push(u);
  }, unshift: function(e2, t2, a, s, l, c) {
    const u = i(e2, t2, a, s, l, c);
    a.transmission > 0 ? o.unshift(u) : true === a.transparent ? r.unshift(u) : n.unshift(u);
  }, finish: function() {
    for (let n2 = t, o2 = e.length; n2 < o2; n2++) {
      const t2 = e[n2];
      if (null === t2.id) break;
      t2.id = null, t2.object = null, t2.geometry = null, t2.material = null, t2.group = null;
    }
  }, sort: function(e2, t2) {
    n.length > 1 && n.sort(e2 || painterSortStable), o.length > 1 && o.sort(t2 || reversePainterSortStable), r.length > 1 && r.sort(t2 || reversePainterSortStable);
  } };
}
function WebGLRenderLists() {
  let e = /* @__PURE__ */ new WeakMap();
  return { get: function(t, n) {
    const o = e.get(t);
    let r;
    return void 0 === o ? (r = new WebGLRenderList(), e.set(t, [r])) : n >= o.length ? (r = new WebGLRenderList(), o.push(r)) : r = o[n], r;
  }, dispose: function() {
    e = /* @__PURE__ */ new WeakMap();
  } };
}
function UniformsCache() {
  const e = {};
  return { get: function(t) {
    if (void 0 !== e[t.id]) return e[t.id];
    let n;
    switch (t.type) {
      case "DirectionalLight":
        n = { direction: new Vector3(), color: new Color() };
        break;
      case "SpotLight":
        n = { position: new Vector3(), direction: new Vector3(), color: new Color(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        n = { position: new Vector3(), color: new Color(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        n = { direction: new Vector3(), skyColor: new Color(), groundColor: new Color() };
        break;
      case "RectAreaLight":
        n = { color: new Color(), position: new Vector3(), halfWidth: new Vector3(), halfHeight: new Vector3() };
    }
    return e[t.id] = n, n;
  } };
}
function ShadowUniformsCache() {
  const e = {};
  return { get: function(t) {
    if (void 0 !== e[t.id]) return e[t.id];
    let n;
    switch (t.type) {
      case "DirectionalLight":
        n = { cascadeIdxEnd: 1, cameraNear: 1, shadowFar: 0, fade: 0.25 };
        break;
      case "SpotLight":
        n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2(), shadow: 0, shadowCameraNear: 1, shadowCameraFar: 1e3, expBias: 1 };
        break;
      case "PointLight":
      case "RectAreaLight":
        n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2(), shadowCameraNear: 1, shadowCameraFar: 1e3, expBias: 1 };
    }
    return e[t.id] = n, n;
  } };
}
var nextVersion = 0;
function sortOrderOfLights(e, t) {
  const n = e.shadow, o = t.shadow;
  let r = 0;
  return n && n.isDirectionalLightShadowCSM && o && o.isDirectionalLightShadowCSM && (r += (0 != o.fade ? 1 : 0) - (0 != n.fade ? 1 : 0)), (t.castShadow ? 4 : 0) - (e.castShadow ? 4 : 0) + (t.map ? 2 : 0) - (e.map ? 2 : 0) + r;
}
function WebGLLights(e, t) {
  const n = new UniformsCache(), o = ShadowUniformsCache(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numPointShadows: -1, numSpotShadows: -1, numRectAreaShadows: -1, numDirectionalShadowsCSM: -1, numDirectionalShadowsCSMCascade: -1, numDirectionalShadowsCSMWithFade: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], rectAreaShadow: [], rectAreaShadowMap: [], rectAreaShadowMatrix: [], directionalShadowCSM: [], directionalShadowCSMMap: [], directionalShadowCSMMatrix: [], directionalShadowCSMCascade: [], directionalShadowCSMLUT: [], numDirectionalShadowsCSMWithFade: 0 };
  for (let e2 = 0; e2 < 9; e2++) r.probe.push(new Vector3());
  const i = new Vector3(), a = new Matrix4(), s = new Matrix4();
  return { setup: function(i2) {
    let a2 = 0, s2 = 0, l = 0;
    for (let e2 = 0; e2 < 9; e2++) r.probe[e2].set(0, 0, 0);
    let c = 0, u = 0, d = 0, h = 0, f = 0, p = 0, m = 0, g = 0, _ = 0, A = 0, v = 0;
    i2.sort(sortOrderOfLights);
    for (let e2 = 0, t2 = i2.length; e2 < t2; e2++) {
      const t3 = i2[e2], x2 = t3.color, y = t3.intensity, b = t3.distance, C = t3.shadow && t3.shadow.map ? t3.shadow.map.texture : null;
      if (t3.isAmbientLight) a2 += x2.r * y, s2 += x2.g * y, l += x2.b * y;
      else if (t3.isLightProbe) for (let e3 = 0; e3 < 9; e3++) r.probe[e3].addScaledVector(t3.sh.coefficients[e3], y);
      else if (t3.isDirectionalLight) {
        const e3 = n.get(t3);
        if (e3.color.copy(t3.color).multiplyScalar(t3.intensity), t3.castShadow) {
          const e4 = t3.shadow, n2 = o.get(t3);
          n2.cascadeIdxEnd = v + e4.numCascades, n2.fade = e4.fade, A += 0 != e4.fade ? e4.numCascades : 0;
          for (let t4 = 0; t4 < e4.numCascades; t4++) {
            let n3 = v + t4;
            r.directionalShadowCSMCascade[n3] || (r.directionalShadowCSMCascade[n3] = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2(), shadowCameraNear: 1, shadowCameraFar: 1, cascade: new Vector2(), expBias: 1, position: new Vector3(), csmIdx: 0 }, r.directionalShadowCSMMap[n3] = null, r.directionalShadowCSMMatrix[n3] = e4.matrix);
          }
          for (let t4 = 0; t4 < e4.numCascades; t4++) {
            const n3 = v + t4, o2 = r.directionalShadowCSMCascade[n3], i3 = e4._cascades[t4], a3 = i3.map ? i3.map.texture : null;
            r.directionalShadowCSMMap[n3] = a3, r.directionalShadowCSMMatrix[n3] = i3.matrix, o2.shadowBias = i3.bias, o2.shadowNormalBias = i3.normalBias, o2.shadowRadius = i3.radius, o2.shadowMapSize = i3.mapSize, o2.position.setFromMatrixPosition(i3.camera.matrixWorld), o2.shadowCameraNear = i3.camera.near, o2.shadowCameraFar = i3.camera.far, e4.getCascadeRange(o2.cascade, t4), o2.expBias = i3.expBias, o2.csmIdx = _, r.directionalShadowCSMLUT[n3] = _;
          }
          v += e4.numCascades, r.directionalShadowCSM[_] = n2, _++;
        }
        r.directional[c] = e3, c++;
      } else if (t3.isSpotLight) {
        const e3 = n.get(t3);
        if (e3.position.setFromMatrixPosition(t3.matrixWorld), e3.color.copy(x2).multiplyScalar(y), e3.distance = b, e3.coneCos = Math.cos(t3.angle), e3.penumbraCos = Math.cos(t3.angle * (1 - t3.penumbra)), e3.decay = t3.decay, r.spot[d] = e3, t3.castShadow) {
          const e4 = t3.shadow, n2 = o.get(t3);
          n2.shadowBias = e4.bias, n2.shadowNormalBias = e4.normalBias, n2.shadowRadius = e4.radius, n2.shadowMapSize = e4.mapSize, r.spotShadow[d] = n2, r.spotShadowMap[d] = C, r.spotShadowMatrix[d] = e4.matrix, n2.shadow = t3.castShadow ? e4.calcUseOmniMaps(t3.angle) ? 2 : 1 : 0, n2.shadowCameraNear = e4.camera.near, n2.shadowCameraFar = e4.camera.far, n2.expBias = e4.expBias, m++;
        }
        d++;
      } else if (t3.isRectAreaLight) {
        const e3 = n.get(t3);
        if (e3.color.copy(x2).multiplyScalar(y), e3.halfWidth.set(0.5 * t3.width, 0, 0), e3.halfHeight.set(0, 0.5 * t3.height, 0), t3.castShadow) {
          const e4 = t3.shadow, n2 = o.get(t3);
          n2.shadowBias = e4.bias, n2.shadowNormalBias = e4.normalBias, n2.shadowRadius = e4.radius, n2.shadowMapSize = e4.mapSize, n2.shadowCameraNear = e4.camera.near, n2.shadowCameraFar = e4.camera.far, n2.expBias = e4.expBias, r.rectAreaShadow[h] = n2, r.rectAreaShadowMap[h] = C, r.rectAreaShadowMatrix[h] = e4.matrix, g++;
        }
        r.rectArea[h] = e3, h++;
      } else if (t3.isPointLight) {
        const e3 = n.get(t3);
        if (e3.color.copy(t3.color).multiplyScalar(t3.intensity), e3.distance = t3.distance, e3.decay = t3.decay, t3.castShadow) {
          const e4 = t3.shadow, n2 = o.get(t3);
          n2.shadowBias = e4.bias, n2.shadowNormalBias = e4.normalBias, n2.shadowRadius = e4.radius, n2.shadowMapSize = e4.mapSize, n2.shadowCameraNear = e4.camera.near, n2.shadowCameraFar = e4.camera.far, n2.expBias = e4.expBias, r.pointShadow[u] = n2, r.pointShadowMap[u] = C, r.pointShadowMatrix[u] = e4.matrix, p++;
        }
        r.point[u] = e3, u++;
      } else if (t3.isHemisphereLight) {
        const e3 = n.get(t3);
        e3.skyColor.copy(t3.color).multiplyScalar(y), e3.groundColor.copy(t3.groundColor).multiplyScalar(y), r.hemi[f] = e3, f++;
      }
    }
    h > 0 && (t.isWebGL2 || true === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, r.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : true === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = UniformsLib.LTC_HALF_1, r.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("v3d.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a2, r.ambient[1] = s2, r.ambient[2] = l;
    const x = r.hash;
    x.directionalLength === c && x.pointLength === u && x.spotLength === d && x.rectAreaLength === h && x.hemiLength === f && x.numPointShadows === p && x.numSpotShadows === m && x.numRectAreaShadows === g && x.numDirectionalShadowsCSM === _ && x.numDirectionalShadowsCSMCascade === v && x.numDirectionalShadowsCSMWithFade === A || (r.directional.length = c, r.spot.length = d, r.rectArea.length = h, r.point.length = u, r.hemi.length = f, r.pointShadow.length = p, r.pointShadowMap.length = p, r.spotShadow.length = m, r.spotShadowMap.length = m, r.pointShadowMatrix.length = p, r.spotShadowMatrix.length = m, x.directionalLength = c, x.pointLength = u, x.spotLength = d, x.rectAreaLength = h, x.hemiLength = f, x.numPointShadows = p, x.numSpotShadows = m, r.rectAreaShadow.length = g, r.rectAreaShadowMap.length = g, r.rectAreaShadowMatrix.length = g, r.directionalShadowCSM.length = _, r.directionalShadowCSMMap.length = v, r.directionalShadowCSMMatrix.length = v, r.directionalShadowCSMCascade.length = v, r.directionalShadowCSMLUT.length = v, r.numDirectionalShadowsCSMWithFade = A, x.numRectAreaShadows = g, x.numDirectionalShadowsCSM = _, x.numDirectionalShadowsCSMCascade = v, x.numDirectionalShadowsCSMWithFade = A, r.version = nextVersion++);
  }, setupView: function(e2, t2) {
    let n2 = 0, l = 0, c = 0, u = 0, d = 0, h = 0;
    const f = t2.matrixWorldInverse;
    for (let p = 0, m = e2.length; p < m; p++) {
      const m2 = e2[p];
      if (m2.isDirectionalLight) {
        const e3 = r.directional[n2];
        if (e3.direction.setFromMatrixPosition(m2.matrixWorld), i.setFromMatrixPosition(m2.target.matrixWorld), e3.direction.sub(i), e3.direction.transformDirection(f), m2.castShadow) {
          const e4 = m2.shadow, n3 = o.get(m2);
          n3.cameraNear = Math.min(e4.maxDistance, t2.near), n3.shadowFar = Math.min(e4.maxDistance, t2.far);
          for (let t3 = 0; t3 < e4.numCascades; t3++) {
            const n4 = h + t3, o2 = r.directionalShadowCSMCascade[n4], i2 = e4._cascades[t3];
            o2.shadowCameraFar = i2.camera.far, o2.position.setFromMatrixPosition(i2.camera.matrixWorld), o2.position.applyMatrix4(f);
          }
          h += e4.numCascades;
        }
        n2++;
      } else if (m2.isSpotLight) {
        const e3 = r.spot[c];
        e3.position.setFromMatrixPosition(m2.matrixWorld), e3.position.applyMatrix4(f), e3.direction.setFromMatrixPosition(m2.matrixWorld), i.setFromMatrixPosition(m2.target.matrixWorld), e3.direction.sub(i), e3.direction.transformDirection(f), c++;
      } else if (m2.isRectAreaLight) {
        const e3 = r.rectArea[u];
        e3.position.setFromMatrixPosition(m2.matrixWorld), e3.position.applyMatrix4(f), s.identity(), a.copy(m2.matrixWorld), a.premultiply(f), s.extractRotation(a), e3.halfWidth.set(0.5 * m2.width, 0, 0), e3.halfHeight.set(0, 0.5 * m2.height, 0), e3.halfWidth.applyMatrix4(s), e3.halfHeight.applyMatrix4(s), u++;
      } else if (m2.isPointLight) {
        const e3 = r.point[l];
        e3.position.setFromMatrixPosition(m2.matrixWorld), e3.position.applyMatrix4(f), l++;
      } else if (m2.isHemisphereLight) {
        const e3 = r.hemi[d];
        e3.direction.setFromMatrixPosition(m2.matrixWorld), e3.direction.transformDirection(f), d++;
      }
    }
  }, state: r };
}
function WebGLRenderState(e, t) {
  const n = new WebGLLights(e, t), o = [], r = [], i = [], a = [];
  return { init: function() {
    o.length = 0, r.length = 0, i.length = 0, a.length = 0;
  }, state: { lightsArray: o, shadowsArray: r, envMapProbeArray: i, planeReflProbeArray: a, lights: n }, setupLights: function() {
    n.setup(o);
  }, setupLightsView: function(e2) {
    n.setupView(o, e2);
  }, pushLight: function(e2) {
    o.push(e2);
  }, pushShadow: function(e2) {
    r.push(e2);
  }, pushEnvMapProbe: function(e2) {
    i.push(e2);
  }, sortEnvMapProbes: function() {
    i.sort((e2, t2) => e2.influenceDistance - t2.influenceDistance);
  }, pushPlaneReflProbe: function(e2) {
    a.push(e2);
  } };
}
function WebGLRenderStates(e, t) {
  let n = /* @__PURE__ */ new WeakMap();
  return { get: function(o, r = 0) {
    const i = n.get(o);
    let a;
    return void 0 === i ? (a = new WebGLRenderState(e, t), n.set(o, [a])) : r >= i.length ? (a = new WebGLRenderState(e, t), i.push(a)) : a = i[r], a;
  }, dispose: function() {
    n = /* @__PURE__ */ new WeakMap();
  } };
}
var MeshDepthMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.useSlopeScaledBias = false, this.slopeScaledBias = 0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.useSlopeScaledBias = e.useSlopeScaledBias, this.slopeScaledBias = e.slopeScaledBias, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
};
var MeshDistanceMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.defines = { DISTANCE_SCALE: "1.0" }, this.distancePacking = 3301, this.useSlopeScaledBias = false, this.slopeScaledBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.distancePacking = e.distancePacking, this.useSlopeScaledBias = e.useSlopeScaledBias, this.slopeScaledBias = e.slopeScaledBias, this;
  }
};
var _projScreenMatrix$2 = new Matrix4();
var _lightPositionWorld$2 = new Vector3();
var _lookTarget$2 = new Vector3();
var LightShadow = class {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)], this.expBias = 1, this.slopeScaledBias = 0, this._additionalMap2D = null, this._additionalMapCube = null, this.isLightShadow = true;
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    _lightPositionWorld$2.setFromMatrixPosition(e.matrixWorld), t.position.copy(_lightPositionWorld$2), _lookTarget$2.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(_lookTarget$2), t.updateMatrixWorld(), _projScreenMatrix$2.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$2), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(_projScreenMatrix$2);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose(), null !== this._additionalMap2D && this._additionalMap2D.dispose(), null !== this._additionalMapCube && this._additionalMapCube.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this.expBias = e.expBias, this.slopeScaledBias = e.slopeScaledBias, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var OMNI_MAP_ANGLE = Math.PI / 4;
var _projScreenMatrix$1 = new Matrix4();
var _lightPositionWorld$1 = new Vector3();
var _lookTarget$1 = new Vector3();
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1, this.useOmniMaps = false, this.useMinFov90 = false, this._frameExtentsOmni = new Vector2(4, 2), this._viewportCountOmni = 6, this._viewportsOmni = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
  }
  updateMatrices(e, t = 0) {
    if (this.useOmniMaps) {
      const n = this.camera, o = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld), n.position.copy(_lightPositionWorld$1), _lookTarget$1.copy(n.position), _lookTarget$1.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(_lookTarget$1), n.updateMatrixWorld(), o.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z), _projScreenMatrix$1.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    } else {
      const t2 = this.camera, n = 2 * RAD2DEG * e.angle * this.focus, o = this.mapSize.width / this.mapSize.height, r = e.distance || t2.far;
      n === t2.fov && o === t2.aspect && r === t2.far || (t2.fov = n, t2.aspect = o, t2.far = r, t2.updateProjectionMatrix()), super.updateMatrices(e);
    }
  }
  getViewportCount() {
    return this.useOmniMaps ? this._viewportCountOmni : super.getViewportCount();
  }
  getViewport(e) {
    return this.useOmniMaps ? this._viewportsOmni[e] : super.getViewport(e);
  }
  getFrameExtents() {
    return this.useOmniMaps ? this._frameExtentsOmni : super.getFrameExtents();
  }
  calcUseOmniMaps(e) {
    return this.useOmniMaps = e > OMNI_MAP_ANGLE, this.useOmniMaps;
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this.useOmniMaps = e.useOmniMaps, this.useMinFov90 = e.useMinFov90, this;
  }
};
function WebGLShadowMap(e, t, n) {
  let o = new Frustum();
  const r = new Vector2(), i = new Vector2(), a = new Vector4(), s = new MeshDepthMaterial({ depthPacking: 3201 }), l = new MeshDistanceMaterial(), c = {}, u = n.maxTextureSize, d = n.isWebGL2, h = { 0: 1, 1: 0, 2: 2 }, f = new Matrix4();
  new Matrix4();
  const p = new Vector2(u, u), m = new Vector3(), g = new Vector3();
  new Vector3();
  const _ = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)], A = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, 1, 0)];
  new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Sphere(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3();
  const v = new Mesh(new PlaneGeometry(1, 1, 1, 1));
  v.name = "esmFarPlane", v.castShadow = true, v.material.shadowSide = 0;
  const x = new OrthographicCamera(-1, 1, 1, -1, 0, 10), y = new Mesh(new PlaneGeometry(2, 2)), b = new ShaderMaterial({ type: "ShadowCubeOctahedral", defines: Object.assign({}, ShaderLib.cubeOctahedral.defines), uniforms: UniformsUtils.clone(ShaderLib.cubeOctahedral.uniforms), vertexShader: ShaderLib.cubeOctahedral.vertexShader, fragmentShader: ShaderLib.cubeOctahedral.fragmentShader }), C = {}, S = {}, M = this;
  function E(t2, n2, o2, r2, i2, a2, u2, d2, f2) {
    let p2 = null;
    const m2 = d2 || 3 === u2 ? t2.customDistanceMaterial : t2.customDepthMaterial;
    if (p2 = void 0 !== m2 ? m2 : d2 || 3 === u2 ? l : s, e.localClippingEnabled && true === o2.clipShadows && Array.isArray(o2.clippingPlanes) && 0 !== o2.clippingPlanes.length || o2.displacementMap && 0 !== o2.displacementScale || o2.alphaMap && o2.alphaTest > 0 || o2.map && o2.alphaTest > 0) {
      const e2 = p2.uuid, t3 = o2.uuid;
      let n3 = c[e2];
      void 0 === n3 && (n3 = {}, c[e2] = n3);
      let r3 = n3[t3];
      void 0 === r3 && (r3 = p2.clone(), n3[t3] = r3), p2 = r3;
    }
    switch (p2.visible = o2.visible, p2.wireframe = o2.wireframe, p2.side = null !== o2.shadowSide ? o2.shadowSide : h[o2.side], p2.alphaMap = o2.alphaMap, p2.alphaTest = o2.alphaTest, p2.map = o2.map, p2.clipShadows = o2.clipShadows, p2.clippingPlanes = o2.clippingPlanes, p2.clipIntersection = o2.clipIntersection, p2.displacementMap = o2.displacementMap, p2.displacementScale = o2.displacementScale, p2.displacementBias = o2.displacementBias, p2.wireframeLinewidth = o2.wireframeLinewidth, p2.linewidth = o2.linewidth, !d2 && 3 !== u2 || true !== p2.isMeshDistanceMaterial || (p2.referencePosition.copy(f2), p2.nearDistance = i2, p2.farDistance = a2, p2.distancePacking = 3 === u2 ? 3302 : 3301), 3 === u2 && (p2.defines.DISTANCE_SCALE = shaderFloatStr(M.esmDistanceScale)), r2.shadow.isDirectionalLightShadowCascade && r2.shadow.pancakeDepth && (p2.defines.PANCAKE_DEPTH = "", p2.defines.CAM_WIDTH = shaderFloatStr(r2.shadow.camera.right), p2.defines.CAM_HEIGHT = shaderFloatStr(r2.shadow.camera.top)), u2) {
      case 0:
      case 1:
      case 2:
        p2.useSlopeScaledBias = true, p2.slopeScaledBias = r2.shadow.slopeScaledBias;
        break;
      case 3:
        p2.useSlopeScaledBias = true, p2.slopeScaledBias = 0.5;
    }
    return p2;
  }
  function T(n2, r2, i2, a2, s2, l2) {
    if (false === n2.visible) return;
    if ((r2.ignoreShadowLayers || n2.layers.test(r2.layers)) && (n2.isMesh || n2.isLine || n2.isPoints) && n2.castShadow && (!n2.frustumCulled || o.intersectsObject(n2))) {
      n2.modelViewMatrix.multiplyMatrices(i2.matrixWorldInverse, n2.matrixWorld);
      const o2 = t.update(n2), r3 = n2.material;
      if (Array.isArray(r3)) {
        const t2 = o2.groups;
        for (let c3 = 0, u2 = t2.length; c3 < u2; c3++) {
          const u3 = t2[c3], d2 = r3[u3.materialIndex];
          if (d2 && d2.visible) {
            const t3 = E(n2, 0, d2, a2, i2.near, i2.far, s2, l2, g);
            e.renderBufferDirect(i2, null, o2, t3, n2, u3);
          }
        }
      } else if (r3.visible) {
        const t2 = E(n2, 0, r3, a2, i2.near, i2.far, s2, l2, g);
        e.renderBufferDirect(i2, null, o2, t2, n2, null);
      }
    }
    const c2 = n2.children;
    for (let e2 = 0, t2 = c2.length; e2 < t2; e2++) T(c2[e2], r2, i2, a2, s2, l2);
  }
  function I(t2, n2, s2, l2) {
    const c2 = s2.shadow, d2 = c2.camera;
    c2.isDirectionalLightShadowCascade ? g.setFromMatrixPosition(d2.matrixWorld) : g.setFromMatrixPosition(s2.matrixWorld), r.copy(c2.mapSize);
    const h2 = c2.getFrameExtents();
    if (r.multiply(h2), i.copy(c2.mapSize), (r.x > u || r.y > u) && (r.x > u && (i.x = Math.floor(u / h2.x), r.x = i.x * h2.x, c2.mapSize.x = i.x), r.y > u && (i.y = Math.floor(u / h2.y), r.y = i.y * h2.y, c2.mapSize.y = i.y)), s2.isSpotLight && c2.map && c2.map.width / c2.map.height != 2) {
      const e2 = c2.map;
      c2.map = c2._additionalMap2D, c2._additionalMap2D = e2;
    }
    const f2 = s2.isPointLight || s2.isRectAreaLight || s2.isSpotLight && c2.useOmniMaps;
    if (f2 ? s2.isSpotLight && (d2.fov = 90, d2.updateProjectionMatrix()) : s2.isSpotLight && c2.useMinFov90 && (d2.fov = 90, d2.updateProjectionMatrix()), null === c2.map) {
      const e2 = { minFilter: 1003, magFilter: 1003, format: 1023 };
      c2.map = new WebGLRenderTarget(r.x, r.y, e2), c2.map.texture.name = s2.name + ".shadowMap", d2.updateProjectionMatrix();
    }
    e.state.buffers.color.setClear(1, 1, 1, 1), e.setRenderTarget(c2.map), e.clear();
    const p2 = c2.getViewportCount();
    for (let r2 = 0; r2 < p2; r2++) {
      const u2 = c2.getViewport(r2);
      a.set(i.x * u2.x, i.y * u2.y, i.x * u2.z, i.y * u2.w), e.state.viewport(a), c2.updateMatrices(s2, r2), o.copy(c2.getFrustum()), T(t2, n2, c2.camera, s2, l2, f2);
    }
  }
  function w(t2, n2, i2, a2) {
    const s2 = i2.shadow, l2 = s2.camera, c2 = s2.matrix, u2 = i2.isPointLight || i2.isRectAreaLight ? 2 : 1, h2 = r.copy(s2.mapSize).multiplyScalar(u2).min(p).multiplyScalar(1 / u2);
    null === s2._additionalMapCube && (s2._additionalMapCube = new WebGLCubeRenderTarget(h2.x, { minFilter: 1006, magFilter: 1006, format: d ? 1028 : 1023, type: 1016 }), s2._additionalMapCube.texture.name = i2.name + ".shadowMap.tmpCube"), null === s2._additionalMap2D && (s2._additionalMap2D = new WebGLRenderTarget(h2.x * u2, h2.y * u2, { minFilter: 1006, magFilter: 1006, format: d ? 1028 : 1023, type: 1016 }), s2._additionalMap2D.texture.name = i2.name + ".shadowMap.tmp2D"), null === s2.map && (s2.map = new WebGLRenderTarget(h2.x * u2, h2.y * u2, { minFilter: 1006, magFilter: 1006, format: d ? 1028 : 1023, type: 1016 }), s2.map.texture.name = i2.name + ".shadowMap"), g.setFromMatrixPosition(i2.matrixWorld), l2.position.copy(g), i2.isSpotLight && (l2.fov = 90, l2.updateProjectionMatrix()), c2.makeTranslation(-g.x, -g.y, -g.z);
    for (let r2 = 0; r2 < 6; r2++) m.copy(l2.position), m.add(_[r2]), l2.up.copy(A[r2]), 2 !== r2 && 3 !== r2 && l2.up.multiplyScalar(-1), l2.lookAt(m), l2.updateMatrixWorld(), f.multiplyMatrices(l2.projectionMatrix, l2.matrixWorldInverse), o.setFromProjectionMatrix(f), e.setRenderTarget(s2._additionalMapCube, r2), e.clearDepth(), B(n2, l2, i2, a2), T(t2, n2, l2, i2, a2, true);
    const v2 = Math.max(s2.radius * u2, 1e-3), C2 = function(e2) {
      return Math.ceil(0.2 * e2);
    }(v2);
    !function(e2, t3, n3) {
      const o2 = y.material = b;
      o2.uniforms.tCube.value = t3.texture, o2.uniforms.texelSize.value.set(1 / n3.width, 1 / n3.height), o2.uniformsNeedUpdate = true, e2.setRenderTarget(n3), e2.clear(), e2.updateGeometry(y), e2.renderBufferDirect(x, null, y.geometry, o2, y, null);
    }(e, s2._additionalMapCube, s2.map), R(e, s2.map, s2._additionalMap2D, C2, v2, 1, 0), R(e, s2._additionalMap2D, s2.map, C2, v2, 0, 0);
  }
  function R(e2, t2, n2, o2, r2, i2, a2) {
    const s2 = y.material = 0 === a2 ? function(e3) {
      if (!(e3 in C)) {
        (C[e3] = new ShaderMaterial({ type: "ShadowBlur", defines: Object.assign({}, ShaderLib.blur.defines, { LOG_SPACE: 1, OCTAHEDRAL_MAP: 1 }), uniforms: UniformsUtils.clone(ShaderLib.blur.uniforms), customPrepTokens: Object.assign({}, ShaderLib.blur.customPrepTokens), vertexShader: ShaderLib.blur.vertexShader, fragmentShader: ShaderLib.blur.fragmentShader })).customPrepTokens.MAX_SAMPLE_RADIUS = e3;
      }
      return C[e3];
    }(o2) : function(e3) {
      if (!(e3 in S)) {
        (S[e3] = new ShaderMaterial({ type: "ShadowBlur", defines: Object.assign({}, ShaderLib.blur.defines, { LOG_SPACE: 1 }), uniforms: UniformsUtils.clone(ShaderLib.blur.uniforms), customPrepTokens: Object.assign({}, ShaderLib.blur.customPrepTokens), vertexShader: ShaderLib.blur.vertexShader, fragmentShader: ShaderLib.blur.fragmentShader })).customPrepTokens.MAX_SAMPLE_RADIUS = e3;
      }
      return S[e3];
    }(o2);
    s2.uniforms.direction.value.set(+(0 === i2), +(1 === i2)), s2.uniforms.colorTexture.value = t2.texture, s2.uniforms.texSize.value.set(t2.width, t2.height), s2.uniforms.kernelRadius.value = r2, s2.uniformsNeedUpdate = true, e2.setRenderTarget(n2), e2.clear(), e2.updateGeometry(y), e2.renderBufferDirect(x, null, y.geometry, s2, y, null);
  }
  function L(t2, n2, i2, a2) {
    const s2 = i2.shadow, l2 = s2.camera, c2 = s2.matrix, u2 = r.copy(s2.mapSize).min(p);
    let h2;
    null === s2._additionalMap2D && (s2._additionalMap2D = new WebGLRenderTarget(u2.x, u2.y, { minFilter: 1006, magFilter: 1006, format: d ? 1028 : 1023, type: 1016 }), s2._additionalMap2D.texture.name = i2.name + ".shadowMap.tmp2D"), null === s2.map && (s2.map = new WebGLRenderTarget(u2.x, u2.y, { minFilter: 1006, magFilter: 1006, format: d ? 1028 : 1023, type: 1016 }), s2.map.texture.name = i2.name + ".shadowMap"), s2.isDirectionalLightShadowCascade ? g.setFromMatrixPosition(l2.matrixWorld) : (g.setFromMatrixPosition(i2.matrixWorld), l2.position.copy(g), m.setFromMatrixPosition(i2.target.matrixWorld), l2.lookAt(m), l2.updateMatrixWorld()), i2.isSpotLight && s2.useMinFov90 && (l2.fov = 90, l2.updateProjectionMatrix()), s2.isDirectionalLightShadowCascade ? (s2.updateMatrices(i2), o.copy(s2.getFrustum())) : (c2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), c2.multiply(l2.projectionMatrix), c2.multiply(l2.matrixWorldInverse), f.multiplyMatrices(l2.projectionMatrix, l2.matrixWorldInverse), o.setFromProjectionMatrix(f)), e.setRenderTarget(s2.map), e.clearDepth(), B(n2, l2, i2, a2), T(t2, n2, l2, i2, a2, false), h2 = i2.isDirectionalLight && i2.shadow.isDirectionalLightShadowCascade ? 50 * s2.esmBlurRadius : i2.isSpotLight ? 0.8 * s2.radius : s2.radius, h2 = Math.max(h2, 1e-3);
    const _2 = function(e2) {
      return Math.ceil(0.8 * e2);
    }(h2);
    R(e, s2.map, s2._additionalMap2D, _2, h2, 0, 1), R(e, s2._additionalMap2D, s2.map, _2, h2, 1, 1);
  }
  function B(e2, t2, n2, o2) {
    let r2, i2, a2, s2, l2, c2;
    t2.isPerspectiveCamera ? (r2 = i2 = 0, a2 = -0.999 * t2.far, s2 = l2 = 2 * -a2 * Math.tan(degToRad(t2.fov) / 2), c2 = 1) : t2.isOrthographicCamera && (r2 = (t2.right + t2.left) / 2, i2 = (t2.top + t2.bottom) / 2, a2 = -0.999 * t2.far, s2 = t2.right - t2.left, l2 = t2.top - t2.bottom, c2 = 1), t2.add(v), v.scale.set(s2, l2, c2), v.position.set(r2, i2, a2), v.updateMatrixWorld(), T(v, e2, t2, n2, o2, true);
  }
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 2, this.esmDistanceScale = 1, this.render = function(t2, n2, o2) {
    if (false === M.enabled) return;
    if (false === M.autoUpdate && false === M.needsUpdate) return;
    if (0 === t2.length) return;
    const r2 = e.getRenderTarget(), i2 = e.getActiveCubeFace(), a2 = e.getActiveMipmapLevel(), s2 = e.state;
    s2.setBlending(0), s2.buffers.color.setClear(1, 1, 1, 1), s2.buffers.depth.setTest(true), s2.setScissorTest(false);
    for (let e2 = 0, r3 = t2.length; e2 < r3; e2++) {
      const r4 = t2[e2], i3 = r4.shadow;
      if (void 0 !== i3) {
        if (false !== i3.autoUpdate || false !== i3.needsUpdate) {
          if (r4.isSpotLight && i3.calcUseOmniMaps(r4.angle), r4.isPointLight || r4.isRectAreaLight || r4.isSpotLight && i3.useOmniMaps) switch (M.type) {
            case 0:
            case 1:
            case 2:
              I(n2, o2, r4, M.type);
              break;
            case 3:
              w(n2, o2, r4, M.type);
              break;
            default:
              continue;
          }
          else {
            if (!r4.isSpotLight && !r4.isDirectionalLight) continue;
            switch (M.type) {
              case 0:
              case 1:
              case 2:
                if (i3.isDirectionalLightShadowCSM) {
                  i3.update(o2, r4);
                  const e3 = r4.shadow;
                  for (let t3 = 0; t3 < e3.numCascades; t3++) r4.shadow = e3._cascades[t3], I(n2, o2, r4, M.type);
                  r4.shadow = e3;
                } else I(n2, o2, r4, M.type);
                break;
              case 3:
                if (i3.isDirectionalLightShadowCSM) {
                  i3.update(o2, r4);
                  const e3 = r4.shadow;
                  for (let t3 = 0; t3 < e3.numCascades; t3++) r4.shadow = e3._cascades[t3], L(n2, o2, r4, M.type);
                  r4.shadow = e3;
                } else L(n2, o2, r4, M.type);
                break;
              default:
                continue;
            }
          }
          i3.needsUpdate = false;
        }
      } else console.warn("v3d.WebGLShadowMap:", r4, "has no shadow.");
    }
    M.needsUpdate = false, e.setRenderTarget(r2, i2, a2);
  };
}
function WebGLState(e, t, n) {
  const o = n.isWebGL2;
  const r = new function() {
    let t2 = false;
    const n2 = new Vector4();
    let o2 = null;
    const r2 = new Vector4(0, 0, 0, 0);
    return { setMask: function(n3) {
      o2 === n3 || t2 || (e.colorMask(n3, n3, n3, n3), o2 = n3);
    }, getMask: function() {
      return o2;
    }, setLocked: function(e2) {
      t2 = e2;
    }, setClear: function(t3, o3, i2, a2, s2) {
      true === s2 && (t3 *= a2, o3 *= a2, i2 *= a2), n2.set(t3, o3, i2, a2), false === r2.equals(n2) && (e.clearColor(t3, o3, i2, a2), r2.copy(n2));
    }, reset: function() {
      t2 = false, o2 = null, r2.set(-1, 0, 0, 0);
    } };
  }(), i = new function() {
    let t2 = false, n2 = null, o2 = null, r2 = null, i2 = null;
    return { setTest: function(e2) {
      e2 !== i2 && (e2 ? G(2929) : z(2929), i2 = e2);
    }, getTest: function() {
      return i2;
    }, setMask: function(o3) {
      n2 === o3 || t2 || (e.depthMask(o3), n2 = o3);
    }, setFunc: function(t3) {
      if (o2 !== t3) {
        switch (t3) {
          case 0:
            e.depthFunc(512);
            break;
          case 1:
            e.depthFunc(519);
            break;
          case 2:
            e.depthFunc(513);
            break;
          case 3:
          default:
            e.depthFunc(515);
            break;
          case 4:
            e.depthFunc(514);
            break;
          case 5:
            e.depthFunc(518);
            break;
          case 6:
            e.depthFunc(516);
            break;
          case 7:
            e.depthFunc(517);
        }
        o2 = t3;
      }
    }, setLocked: function(e2) {
      t2 = e2;
    }, setClear: function(t3) {
      r2 !== t3 && (e.clearDepth(t3), r2 = t3);
    }, reset: function() {
      t2 = false, n2 = null, o2 = null, r2 = null;
    } };
  }(), a = new function() {
    let t2 = false, n2 = null, o2 = null, r2 = null, i2 = null, a2 = null, s2 = null, l2 = null, c2 = null;
    return { setTest: function(e2) {
      t2 || (e2 ? G(2960) : z(2960));
    }, setMask: function(o3) {
      n2 === o3 || t2 || (e.stencilMask(o3), n2 = o3);
    }, setFunc: function(t3, n3, a3) {
      o2 === t3 && r2 === n3 && i2 === a3 || (e.stencilFunc(t3, n3, a3), o2 = t3, r2 = n3, i2 = a3);
    }, setOp: function(t3, n3, o3) {
      a2 === t3 && s2 === n3 && l2 === o3 || (e.stencilOp(t3, n3, o3), a2 = t3, s2 = n3, l2 = o3);
    }, setLocked: function(e2) {
      t2 = e2;
    }, setClear: function(t3) {
      c2 !== t3 && (e.clearStencil(t3), c2 = t3);
    }, reset: function() {
      t2 = false, n2 = null, o2 = null, r2 = null, i2 = null, a2 = null, s2 = null, l2 = null, c2 = null;
    } };
  }(), s = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
  let c = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), h = [], f = null, p = false, m = null, g = null, _ = null, A = null, v = null, x = null, y = null, b = false, C = null, S = null, M = null, E = null, T = null;
  const I = e.getParameter(35661);
  let w = false, R = 0;
  const L = e.getParameter(7938);
  -1 !== L.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(L)[1]), w = R >= 1) : -1 !== L.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), w = R >= 2);
  let B = null, P = {};
  const N = e.getParameter(3088), D = e.getParameter(2978), O = new Vector4().fromArray(N), F = new Vector4().fromArray(D);
  function V(t2, n2, o2) {
    const r2 = new Uint8Array(4), i2 = e.createTexture();
    e.bindTexture(t2, i2), e.texParameteri(t2, 10241, 9728), e.texParameteri(t2, 10240, 9728);
    for (let t3 = 0; t3 < o2; t3++) e.texImage2D(n2 + t3, 0, 6408, 1, 1, 0, 6408, 5121, r2);
    return i2;
  }
  const U = {};
  function G(t2) {
    true !== c[t2] && (e.enable(t2), c[t2] = true);
  }
  function z(t2) {
    false !== c[t2] && (e.disable(t2), c[t2] = false);
  }
  U[3553] = V(3553, 3553, 1), U[34067] = V(34067, 34069, 6), r.setClear(0, 0, 0, 1), i.setClear(1), a.setClear(0), G(2929), i.setFunc(3), H(false), X(1), G(2884), Q(0);
  const k = { [AddEquation]: 32774, [SubtractEquation]: 32778, [ReverseSubtractEquation]: 32779 };
  if (o) k[103] = 32775, k[104] = 32776;
  else {
    const e2 = t.get("EXT_blend_minmax");
    null !== e2 && (k[103] = e2.MIN_EXT, k[104] = e2.MAX_EXT);
  }
  const W = { [ZeroFactor]: 0, [OneFactor]: 1, [SrcColorFactor]: 768, [SrcAlphaFactor]: 770, [SrcAlphaSaturateFactor]: 776, [DstColorFactor]: 774, [DstAlphaFactor]: 772, [OneMinusSrcColorFactor]: 769, [OneMinusSrcAlphaFactor]: 771, [OneMinusDstColorFactor]: 775, [OneMinusDstAlphaFactor]: 773 };
  function Q(t2, n2, o2, r2, i2, a2, s2, l2) {
    if (0 !== t2) {
      if (false === p && (G(3042), p = true), 5 === t2) i2 = i2 || n2, a2 = a2 || o2, s2 = s2 || r2, n2 === g && i2 === v || (e.blendEquationSeparate(k[n2], k[i2]), g = n2, v = i2), o2 === _ && r2 === A && a2 === x && s2 === y || (e.blendFuncSeparate(W[o2], W[r2], W[a2], W[s2]), _ = o2, A = r2, x = a2, y = s2), m = t2, b = false;
      else if (t2 !== m || l2 !== b) {
        if (100 === g && 100 === v || (e.blendEquation(32774), g = 100, v = 100), l2) switch (t2) {
          case 1:
            e.blendFuncSeparate(1, 771, 1, 771);
            break;
          case 2:
            e.blendFunc(1, 1);
            break;
          case 3:
            e.blendFuncSeparate(0, 769, 0, 1);
            break;
          case 4:
            e.blendFuncSeparate(0, 768, 0, 770);
            break;
          default:
            console.error("v3d.WebGLState: Invalid blending: ", t2);
        }
        else switch (t2) {
          case 1:
            e.blendFuncSeparate(770, 771, 1, 771);
            break;
          case 2:
            e.blendFunc(770, 1);
            break;
          case 3:
            e.blendFuncSeparate(0, 769, 0, 1);
            break;
          case 4:
            e.blendFunc(0, 768);
            break;
          default:
            console.error("v3d.WebGLState: Invalid blending: ", t2);
        }
        _ = null, A = null, x = null, y = null, m = t2, b = l2;
      }
    } else true === p && (z(3042), p = false);
  }
  function H(t2) {
    C !== t2 && (t2 ? e.frontFace(2304) : e.frontFace(2305), C = t2);
  }
  function X(t2) {
    0 !== t2 ? (G(2884), t2 !== S && (1 === t2 ? e.cullFace(1029) : 2 === t2 ? e.cullFace(1028) : e.cullFace(1032))) : z(2884), S = t2;
  }
  function Y(t2, n2, o2) {
    t2 ? (G(32823), E === n2 && T === o2 || (e.polygonOffset(n2, o2), E = n2, T = o2)) : z(32823);
  }
  return { buffers: { color: r, depth: i, stencil: a }, enable: G, disable: z, bindFramebuffer: function(t2, n2) {
    return u[t2] !== n2 && (e.bindFramebuffer(t2, n2), u[t2] = n2, o && (36009 === t2 && (u[36160] = n2), 36160 === t2 && (u[36009] = n2)), true);
  }, drawBuffers: function(o2, r2) {
    let i2 = h, a2 = false;
    if (o2) if (i2 = d.get(r2), void 0 === i2 && (i2 = [], d.set(r2, i2)), o2.isWebGLMultipleRenderTargets) {
      const e2 = o2.texture;
      if (i2.length !== e2.length || 36064 !== i2[0]) {
        for (let t2 = 0, n2 = e2.length; t2 < n2; t2++) i2[t2] = 36064 + t2;
        i2.length = e2.length, a2 = true;
      }
    } else 36064 !== i2[0] && (i2[0] = 36064, a2 = true);
    else 1029 !== i2[0] && (i2[0] = 1029, a2 = true);
    a2 && (n.isWebGL2 ? e.drawBuffers(i2) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(i2));
  }, useProgram: function(t2) {
    return f !== t2 && (e.useProgram(t2), f = t2, true);
  }, setBlending: Q, setMaterial: function(e2, t2) {
    2 === e2.side ? z(2884) : G(2884);
    let n2 = 1 === e2.side;
    t2 && (n2 = !n2), H(n2), 1 === e2.blending && false === e2.transparent ? Q(0) : Q(e2.blending, e2.blendEquation, e2.blendSrc, e2.blendDst, e2.blendEquationAlpha, e2.blendSrcAlpha, e2.blendDstAlpha, e2.premultipliedAlpha), i.setFunc(e2.depthFunc), i.setTest(e2.depthTest), i.setMask(e2.depthWrite), r.setMask(e2.colorWrite);
    const o2 = e2.stencilWrite;
    a.setTest(o2), o2 && (a.setMask(e2.stencilWriteMask), a.setFunc(e2.stencilFunc, e2.stencilRef, e2.stencilFuncMask), a.setOp(e2.stencilFail, e2.stencilZFail, e2.stencilZPass)), Y(e2.polygonOffset, e2.polygonOffsetFactor, e2.polygonOffsetUnits), true === e2.alphaToCoverage ? G(32926) : z(32926);
  }, setFlipSided: H, setCullFace: X, setLineWidth: function(t2) {
    t2 !== M && (w && e.lineWidth(t2), M = t2);
  }, setPolygonOffset: Y, setScissorTest: function(e2) {
    e2 ? G(3089) : z(3089);
  }, activeTexture: function(t2) {
    void 0 === t2 && (t2 = 33984 + I - 1), B !== t2 && (e.activeTexture(t2), B = t2);
  }, bindTexture: function(t2, n2, o2) {
    void 0 === o2 && (o2 = null === B ? 33984 + I - 1 : B);
    let r2 = P[o2];
    void 0 === r2 && (r2 = { type: void 0, texture: void 0 }, P[o2] = r2), r2.type === t2 && r2.texture === n2 || (B !== o2 && (e.activeTexture(o2), B = o2), e.bindTexture(t2, n2 || U[t2]), r2.type = t2, r2.texture = n2);
  }, unbindTexture: function() {
    const t2 = P[B];
    void 0 !== t2 && void 0 !== t2.type && (e.bindTexture(t2.type, null), t2.type = void 0, t2.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      e.compressedTexImage2D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, compressedTexImage3D: function() {
    try {
      e.compressedTexImage3D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, texImage2D: function() {
    try {
      e.texImage2D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, texImage3D: function() {
    try {
      e.texImage3D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, updateUBOMapping: function(t2, n2) {
    let o2 = l.get(n2);
    void 0 === o2 && (o2 = /* @__PURE__ */ new WeakMap(), l.set(n2, o2));
    let r2 = o2.get(t2);
    void 0 === r2 && (r2 = e.getUniformBlockIndex(n2, t2.name), o2.set(t2, r2));
  }, uniformBlockBinding: function(t2, n2) {
    const o2 = l.get(n2).get(t2);
    s.get(t2) !== o2 && (e.uniformBlockBinding(n2, o2, t2.__bindingPointIndex), s.set(t2, o2));
  }, texStorage2D: function() {
    try {
      e.texStorage2D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, texStorage3D: function() {
    try {
      e.texStorage3D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, texSubImage2D: function() {
    try {
      e.texSubImage2D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, texSubImage3D: function() {
    try {
      e.texSubImage3D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, compressedTexSubImage2D: function() {
    try {
      e.compressedTexSubImage2D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, compressedTexSubImage3D: function() {
    try {
      e.compressedTexSubImage3D.apply(e, arguments);
    } catch (e2) {
      console.error("v3d.WebGLState:", e2);
    }
  }, scissor: function(t2) {
    false === O.equals(t2) && (e.scissor(t2.x, t2.y, t2.z, t2.w), O.copy(t2));
  }, viewport: function(t2) {
    false === F.equals(t2) && (e.viewport(t2.x, t2.y, t2.z, t2.w), F.copy(t2));
  }, reset: function() {
    e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(true, true, true, true), e.clearColor(0, 0, 0, 0), e.depthMask(true), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), true === o && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), c = {}, B = null, P = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), h = [], f = null, p = false, m = null, g = null, _ = null, A = null, v = null, x = null, y = null, b = false, C = null, S = null, M = null, E = null, T = null, O.set(0, 0, e.canvas.width, e.canvas.height), F.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), i.reset(), a.reset();
  } };
}
function WebGLTextures(e, t, n, o, r, i, a) {
  const s = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, u = r.maxTextureSize, d = r.maxSamples, h = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, f = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), p = /* @__PURE__ */ new WeakMap();
  let m;
  const g = /* @__PURE__ */ new WeakMap();
  let _ = false;
  try {
    _ = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (e2) {
  }
  function A(e2, t2) {
    return _ ? new OffscreenCanvas(e2, t2) : createElementNS("canvas");
  }
  function v(e2, t2, n2, o2) {
    let r2 = 1;
    if ((e2.width > o2 || e2.height > o2) && (r2 = o2 / Math.max(e2.width, e2.height)), r2 < 1 || true === t2) {
      if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap) {
        const o3 = t2 ? floorPowerOfTwo : Math.floor, i2 = o3(r2 * e2.width), a2 = o3(r2 * e2.height);
        void 0 === m && (m = A(i2, a2));
        const s2 = n2 ? A(i2, a2) : m;
        s2.width = i2, s2.height = a2;
        return s2.getContext("2d").drawImage(e2, 0, 0, i2, a2), console.warn("v3d.WebGLRenderer: Texture has been resized from (" + e2.width + "x" + e2.height + ") to (" + i2 + "x" + a2 + ")."), s2;
      }
      return "data" in e2 && console.warn("v3d.WebGLRenderer: Image in DataTexture is too big (" + e2.width + "x" + e2.height + ")."), e2;
    }
    return e2;
  }
  function x(e2) {
    return isPowerOfTwo(e2.width) && isPowerOfTwo(e2.height);
  }
  function y(e2, t2) {
    return e2.generateMipmaps && t2 && 1003 !== e2.minFilter && 1006 !== e2.minFilter;
  }
  function b(t2) {
    e.generateMipmap(t2);
  }
  function C(n2, o2, r2, i2, a2 = false) {
    if (false === s) return o2;
    if (null !== n2) {
      if (void 0 !== e[n2]) return e[n2];
      console.warn("v3d.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n2 + "'");
    }
    let l2 = o2;
    return 6403 === o2 && (5126 === r2 && (l2 = 33326), 5131 === r2 && (l2 = 33325), 5121 === r2 && (l2 = 33321)), 33319 === o2 && (5126 === r2 && (l2 = 33328), 5131 === r2 && (l2 = 33327), 5121 === r2 && (l2 = 33323)), 6408 === o2 && (5126 === r2 && (l2 = 34836), 5131 === r2 && (l2 = 34842), 5121 === r2 && (l2 = 3001 === i2 && false === a2 ? 35907 : 32856), 32819 === r2 && (l2 = 32854), 32820 === r2 && (l2 = 32855)), 33325 !== l2 && 33326 !== l2 && 33327 !== l2 && 33328 !== l2 && 34842 !== l2 && 34836 !== l2 || t.get("EXT_color_buffer_float"), l2;
  }
  function S(e2, t2, n2) {
    return true === y(e2, n2) || e2.isFramebufferTexture && 1003 !== e2.minFilter && 1006 !== e2.minFilter ? Math.log2(Math.max(t2.width, t2.height)) + 1 : void 0 !== e2.mipmaps && e2.mipmaps.length > 0 ? e2.mipmaps.length : e2.isCompressedTexture && Array.isArray(e2.image) ? t2.mipmaps.length : 1;
  }
  function M(e2) {
    return 1003 === e2 || 1004 === e2 || 1005 === e2 ? 9728 : 9729;
  }
  function E(e2) {
    const t2 = e2.target;
    t2.removeEventListener("dispose", E), function(e3) {
      const t3 = o.get(e3);
      if (void 0 === t3.__webglInit) return;
      const n2 = e3.source, r2 = g.get(n2);
      if (r2) {
        const o2 = r2[t3.__cacheKey];
        o2.usedTimes--, 0 === o2.usedTimes && I(e3), 0 === Object.keys(r2).length && g.delete(n2);
      }
      o.remove(e3);
    }(t2), t2.isVideoTexture && p.delete(t2);
  }
  function T(t2) {
    const n2 = t2.target;
    n2.removeEventListener("dispose", T), function(t3) {
      const n3 = t3.texture, r2 = o.get(t3), i2 = o.get(n3);
      void 0 !== i2.__webglTexture && (e.deleteTexture(i2.__webglTexture), a.memory.textures--);
      t3.depthTexture && t3.depthTexture.dispose();
      if (t3.isWebGLCubeRenderTarget) for (let t4 = 0; t4 < 6; t4++) e.deleteFramebuffer(r2.__webglFramebuffer[t4]), r2.__webglDepthbuffer && e.deleteRenderbuffer(r2.__webglDepthbuffer[t4]);
      else {
        if (e.deleteFramebuffer(r2.__webglFramebuffer), r2.__webglDepthbuffer && e.deleteRenderbuffer(r2.__webglDepthbuffer), r2.__webglMultisampledFramebuffer && e.deleteFramebuffer(r2.__webglMultisampledFramebuffer), r2.__webglColorRenderbuffer) for (let t4 = 0; t4 < r2.__webglColorRenderbuffer.length; t4++) r2.__webglColorRenderbuffer[t4] && e.deleteRenderbuffer(r2.__webglColorRenderbuffer[t4]);
        r2.__webglDepthRenderbuffer && e.deleteRenderbuffer(r2.__webglDepthRenderbuffer);
      }
      if (t3.isWebGLMultipleRenderTargets) for (let t4 = 0, r3 = n3.length; t4 < r3; t4++) {
        const r4 = o.get(n3[t4]);
        r4.__webglTexture && (e.deleteTexture(r4.__webglTexture), a.memory.textures--), o.remove(n3[t4]);
      }
      o.remove(n3), o.remove(t3);
    }(n2), a.removeTextureSpec(n2);
  }
  function I(t2) {
    const n2 = o.get(t2);
    e.deleteTexture(n2.__webglTexture);
    const r2 = t2.source;
    delete g.get(r2)[n2.__cacheKey], a.memory.textures--, a.removeTextureSpec(t2);
  }
  let w = 0;
  function R(e2, t2) {
    const r2 = o.get(e2);
    if (e2.isVideoTexture && function(e3) {
      const t3 = a.render.frame;
      p.get(e3) !== t3 && (p.set(e3, t3), e3.update());
    }(e2), false === e2.isRenderTargetTexture && e2.version > 0 && r2.__version !== e2.version) {
      const n2 = e2.image;
      if (null === n2) console.warn("v3d.WebGLRenderer: Texture marked for update but no image data found.");
      else {
        if (false !== n2.complete) return void D(r2, e2, t2);
        console.warn("v3d.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    n.bindTexture(3553, r2.__webglTexture, 33984 + t2);
  }
  const L = { [RepeatWrapping]: 10497, [ClampToEdgeWrapping]: 33071, [MirroredRepeatWrapping]: 33648 }, B = { [NearestFilter]: 9728, [NearestMipmapNearestFilter]: 9984, [NearestMipmapLinearFilter]: 9986, [LinearFilter]: 9729, [LinearMipmapNearestFilter]: 9985, [LinearMipmapLinearFilter]: 9987 };
  function P(n2, i2, a2) {
    if (a2 ? (e.texParameteri(n2, 10242, L[i2.wrapS]), e.texParameteri(n2, 10243, L[i2.wrapT]), 32879 !== n2 && 35866 !== n2 || e.texParameteri(n2, 32882, L[i2.wrapR]), e.texParameteri(n2, 10240, B[i2.magFilter]), e.texParameteri(n2, 10241, B[i2.minFilter])) : (e.texParameteri(n2, 10242, 33071), e.texParameteri(n2, 10243, 33071), 32879 !== n2 && 35866 !== n2 || e.texParameteri(n2, 32882, 33071), 1001 === i2.wrapS && 1001 === i2.wrapT || console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to v3d.ClampToEdgeWrapping."), e.texParameteri(n2, 10240, M(i2.magFilter)), e.texParameteri(n2, 10241, M(i2.minFilter)), 1003 !== i2.minFilter && 1006 !== i2.minFilter && console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to v3d.NearestFilter or v3d.LinearFilter.")), true === t.has("EXT_texture_filter_anisotropic")) {
      const a3 = t.get("EXT_texture_filter_anisotropic");
      if (1003 === i2.magFilter) return;
      if (1005 !== i2.minFilter && 1008 !== i2.minFilter) return;
      if (1015 === i2.type && false === t.has("OES_texture_float_linear")) return;
      if (false === s && 1016 === i2.type && false === t.has("OES_texture_half_float_linear")) return;
      (i2.anisotropy > 1 || o.get(i2).__currentAnisotropy) && (e.texParameterf(n2, a3.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i2.anisotropy, r.getMaxAnisotropy())), o.get(i2).__currentAnisotropy = i2.anisotropy);
    }
  }
  function N(t2, n2) {
    let o2 = false;
    void 0 === t2.__webglInit && (t2.__webglInit = true, n2.addEventListener("dispose", E));
    const r2 = n2.source;
    let i2 = g.get(r2);
    void 0 === i2 && (i2 = {}, g.set(r2, i2));
    const s2 = function(e2) {
      const t3 = [];
      return t3.push(e2.wrapS), t3.push(e2.wrapT), t3.push(e2.wrapR || 0), t3.push(e2.magFilter), t3.push(e2.minFilter), t3.push(e2.anisotropy), t3.push(e2.internalFormat), t3.push(e2.format), t3.push(e2.type), t3.push(e2.generateMipmaps), t3.push(e2.premultiplyAlpha), t3.push(e2.flipY), t3.push(e2.unpackAlignment), t3.push(e2.encoding), t3.join();
    }(n2);
    if (s2 !== t2.__cacheKey) {
      void 0 === i2[s2] && (i2[s2] = { texture: e.createTexture(), usedTimes: 0 }, a.memory.textures++, a.addTextureSpec(n2), o2 = true), i2[s2].usedTimes++;
      const r3 = i2[t2.__cacheKey];
      void 0 !== r3 && (i2[t2.__cacheKey].usedTimes--, 0 === r3.usedTimes && I(n2)), t2.__cacheKey = s2, t2.__webglTexture = i2[s2].texture;
    }
    return o2;
  }
  function D(t2, r2, a2) {
    let l2 = 3553;
    (r2.isDataArrayTexture || r2.isCompressedArrayTexture) && (l2 = 35866), r2.isData3DTexture && (l2 = 32879);
    const c2 = N(t2, r2), d2 = r2.source;
    n.bindTexture(l2, t2.__webglTexture, 33984 + a2);
    const h2 = o.get(d2);
    if (d2.version !== h2.__version || true === c2) {
      n.activeTexture(33984 + a2), e.pixelStorei(37440, r2.flipY), e.pixelStorei(37441, r2.premultiplyAlpha), e.pixelStorei(3317, r2.unpackAlignment), e.pixelStorei(37443, 0);
      const t3 = function(e2) {
        return !s && (1001 !== e2.wrapS || 1001 !== e2.wrapT || 1003 !== e2.minFilter && 1006 !== e2.minFilter);
      }(r2) && false === x(r2.image);
      let o2 = v(r2.image, t3, false, u);
      o2 = z(r2, o2);
      const f2 = x(o2) || s, p2 = i.convert(r2.format, r2.encoding);
      let m2, g2 = i.convert(r2.type), _2 = C(r2.internalFormat, p2, g2, r2.encoding, r2.isVideoTexture);
      P(l2, r2, f2);
      const A2 = r2.mipmaps, M2 = s && true !== r2.isVideoTexture, E2 = void 0 === h2.__version || true === c2, T2 = S(r2, o2, f2);
      if (r2.isDepthTexture) _2 = 6402, s ? _2 = 1015 === r2.type ? 36012 : 1014 === r2.type ? 33190 : 1020 === r2.type ? 35056 : 33189 : 1015 === r2.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === r2.format && 6402 === _2 && 1012 !== r2.type && 1014 !== r2.type && (console.warn("v3d.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r2.type = 1014, g2 = i.convert(r2.type)), 1027 === r2.format && 6402 === _2 && (_2 = 34041, 1020 !== r2.type && (console.warn("v3d.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r2.type = 1020, g2 = i.convert(r2.type))), E2 && (M2 ? n.texStorage2D(3553, 1, _2, o2.width, o2.height) : n.texImage2D(3553, 0, _2, o2.width, o2.height, 0, p2, g2, null));
      else if (r2.isDataTexture) if (A2.length > 0 && f2) {
        M2 && E2 && n.texStorage2D(3553, T2, _2, A2[0].width, A2[0].height);
        for (let e2 = 0, t4 = A2.length; e2 < t4; e2++) m2 = A2[e2], M2 ? n.texSubImage2D(3553, e2, 0, 0, m2.width, m2.height, p2, g2, m2.data) : n.texImage2D(3553, e2, _2, m2.width, m2.height, 0, p2, g2, m2.data);
        r2.generateMipmaps = false;
      } else M2 ? (E2 && n.texStorage2D(3553, T2, _2, o2.width, o2.height), n.texSubImage2D(3553, 0, 0, 0, o2.width, o2.height, p2, g2, o2.data)) : n.texImage2D(3553, 0, _2, o2.width, o2.height, 0, p2, g2, o2.data);
      else if (r2.isCompressedTexture) if (r2.isCompressedArrayTexture) {
        M2 && E2 && n.texStorage3D(35866, T2, _2, A2[0].width, A2[0].height, o2.depth);
        for (let e2 = 0, t4 = A2.length; e2 < t4; e2++) m2 = A2[e2], 1023 !== r2.format ? null !== p2 ? M2 ? n.compressedTexSubImage3D(35866, e2, 0, 0, 0, m2.width, m2.height, o2.depth, p2, m2.data, 0, 0) : n.compressedTexImage3D(35866, e2, _2, m2.width, m2.height, o2.depth, 0, m2.data, 0, 0) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M2 ? n.texSubImage3D(35866, e2, 0, 0, 0, m2.width, m2.height, o2.depth, p2, g2, m2.data) : n.texImage3D(35866, e2, _2, m2.width, m2.height, o2.depth, 0, p2, g2, m2.data);
      } else {
        M2 && E2 && n.texStorage2D(3553, T2, _2, A2[0].width, A2[0].height);
        for (let e2 = 0, t4 = A2.length; e2 < t4; e2++) m2 = A2[e2], 1023 !== r2.format ? null !== p2 ? M2 ? n.compressedTexSubImage2D(3553, e2, 0, 0, m2.width, m2.height, p2, m2.data) : n.compressedTexImage2D(3553, e2, _2, m2.width, m2.height, 0, m2.data) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M2 ? n.texSubImage2D(3553, e2, 0, 0, m2.width, m2.height, p2, g2, m2.data) : n.texImage2D(3553, e2, _2, m2.width, m2.height, 0, p2, g2, m2.data);
      }
      else if (r2.isDataArrayTexture) M2 ? (E2 && n.texStorage3D(35866, T2, _2, o2.width, o2.height, o2.depth), n.texSubImage3D(35866, 0, 0, 0, 0, o2.width, o2.height, o2.depth, p2, g2, o2.data)) : n.texImage3D(35866, 0, _2, o2.width, o2.height, o2.depth, 0, p2, g2, o2.data);
      else if (r2.isData3DTexture) M2 ? (E2 && n.texStorage3D(32879, T2, _2, o2.width, o2.height, o2.depth), n.texSubImage3D(32879, 0, 0, 0, 0, o2.width, o2.height, o2.depth, p2, g2, o2.data)) : n.texImage3D(32879, 0, _2, o2.width, o2.height, o2.depth, 0, p2, g2, o2.data);
      else if (r2.isFramebufferTexture) {
        if (E2) if (M2) n.texStorage2D(3553, T2, _2, o2.width, o2.height);
        else {
          let e2 = o2.width, t4 = o2.height;
          for (let o3 = 0; o3 < T2; o3++) n.texImage2D(3553, o3, _2, e2, t4, 0, p2, g2, null), e2 >>= 1, t4 >>= 1;
        }
      } else if (A2.length > 0 && f2) {
        M2 && E2 && n.texStorage2D(3553, T2, _2, A2[0].width, A2[0].height);
        for (let e2 = 0, t4 = A2.length; e2 < t4; e2++) m2 = A2[e2], M2 ? n.texSubImage2D(3553, e2, 0, 0, p2, g2, m2) : n.texImage2D(3553, e2, _2, p2, g2, m2);
        r2.generateMipmaps = false;
      } else M2 ? (E2 && n.texStorage2D(3553, T2, _2, o2.width, o2.height), n.texSubImage2D(3553, 0, 0, 0, p2, g2, o2)) : n.texImage2D(3553, 0, _2, p2, g2, o2);
      y(r2, f2) && b(l2), h2.__version = d2.version, r2.onUpdate && r2.onUpdate(r2);
    }
    t2.__version = r2.version;
  }
  function O(t2, r2, a2, s2, l2) {
    const c2 = i.convert(a2.format, a2.encoding), u2 = i.convert(a2.type), d2 = C(a2.internalFormat, c2, u2, a2.encoding);
    o.get(r2).__hasExternalTextures || (32879 === l2 || 35866 === l2 ? n.texImage3D(l2, 0, d2, r2.width, r2.height, r2.depth, 0, c2, u2, null) : n.texImage2D(l2, 0, d2, r2.width, r2.height, 0, c2, u2, null)), n.bindFramebuffer(36160, t2), G(r2) ? h.framebufferTexture2DMultisampleEXT(36160, s2, l2, o.get(a2).__webglTexture, 0, U(r2)) : (3553 === l2 || l2 >= 34069 && l2 <= 34074) && e.framebufferTexture2D(36160, s2, l2, o.get(a2).__webglTexture, 0), n.bindFramebuffer(36160, null);
  }
  function F(t2, n2, o2) {
    if (e.bindRenderbuffer(36161, t2), n2.depthBuffer && !n2.stencilBuffer) {
      let r2 = 33189;
      if (s && (r2 = 33190), o2 || G(n2)) {
        const t3 = n2.depthTexture;
        t3 && t3.isDepthTexture && (1015 === t3.type ? r2 = 36012 : 1014 === t3.type && (r2 = 33190));
        const o3 = U(n2);
        G(n2) ? h.renderbufferStorageMultisampleEXT(36161, o3, r2, n2.width, n2.height) : e.renderbufferStorageMultisample(36161, o3, r2, n2.width, n2.height);
      } else e.renderbufferStorage(36161, r2, n2.width, n2.height);
      e.framebufferRenderbuffer(36160, 36096, 36161, t2);
    } else if (n2.depthBuffer && n2.stencilBuffer) {
      const r2 = U(n2);
      o2 && false === G(n2) ? e.renderbufferStorageMultisample(36161, r2, 35056, n2.width, n2.height) : G(n2) ? h.renderbufferStorageMultisampleEXT(36161, r2, 35056, n2.width, n2.height) : e.renderbufferStorage(36161, 34041, n2.width, n2.height), e.framebufferRenderbuffer(36160, 33306, 36161, t2);
    } else {
      const t3 = true === n2.isWebGLMultipleRenderTargets ? n2.texture : [n2.texture];
      for (let r2 = 0; r2 < t3.length; r2++) {
        const a2 = t3[r2], s2 = i.convert(a2.format, a2.encoding), l2 = i.convert(a2.type), c2 = C(a2.internalFormat, s2, l2, a2.encoding), u2 = U(n2);
        o2 && false === G(n2) ? e.renderbufferStorageMultisample(36161, u2, c2, n2.width, n2.height) : G(n2) ? h.renderbufferStorageMultisampleEXT(36161, u2, c2, n2.width, n2.height) : e.renderbufferStorage(36161, c2, n2.width, n2.height);
      }
    }
    e.bindRenderbuffer(36161, null);
  }
  function V(t2) {
    const r2 = o.get(t2), i2 = true === t2.isWebGLCubeRenderTarget;
    if (t2.depthTexture && !r2.__autoAllocateDepthBuffer) {
      if (i2) throw new Error("target.depthTexture not supported in Cube render targets");
      !function(t3, r3) {
        if (r3 && r3.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(36160, t3), !r3.depthTexture || !r3.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of v3d.DepthTexture");
        o.get(r3.depthTexture).__webglTexture && r3.depthTexture.image.width === r3.width && r3.depthTexture.image.height === r3.height || (r3.depthTexture.image.width = r3.width, r3.depthTexture.image.height = r3.height, r3.depthTexture.needsUpdate = true), R(r3.depthTexture, 0);
        const i3 = o.get(r3.depthTexture).__webglTexture, a2 = U(r3);
        if (1026 === r3.depthTexture.format) G(r3) ? h.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, i3, 0, a2) : e.framebufferTexture2D(36160, 36096, 3553, i3, 0);
        else {
          if (1027 !== r3.depthTexture.format) throw new Error("Unknown depthTexture format");
          G(r3) ? h.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, i3, 0, a2) : e.framebufferTexture2D(36160, 33306, 3553, i3, 0);
        }
      }(r2.__webglFramebuffer, t2);
    } else if (i2) {
      r2.__webglDepthbuffer = [];
      for (let o2 = 0; o2 < 6; o2++) n.bindFramebuffer(36160, r2.__webglFramebuffer[o2]), r2.__webglDepthbuffer[o2] = e.createRenderbuffer(), F(r2.__webglDepthbuffer[o2], t2, false);
    } else n.bindFramebuffer(36160, r2.__webglFramebuffer), r2.__webglDepthbuffer = e.createRenderbuffer(), F(r2.__webglDepthbuffer, t2, false);
    n.bindFramebuffer(36160, null);
  }
  function U(e2) {
    return Math.min(d, e2.samples);
  }
  function G(e2) {
    const n2 = o.get(e2);
    return s && e2.samples > 0 && true === t.has("WEBGL_multisampled_render_to_texture") && false !== n2.__useRenderToTexture;
  }
  function z(e2, n2) {
    const o2 = e2.encoding, r2 = e2.format, i2 = e2.type;
    return true === e2.isCompressedTexture || true === e2.isVideoTexture || 1035 === e2.format || 3e3 !== o2 && (3001 === o2 ? false === s ? true === t.has("EXT_sRGB") && 1023 === r2 ? (e2.format = 1035, e2.minFilter = 1006, e2.generateMipmaps = false) : n2 = ImageUtils.sRGBToLinear(n2) : 1023 === r2 && 1009 === i2 || console.warn("v3d.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType. Perhaps you've set sRGB color space for an HDR image?") : console.error("v3d.WebGLTextures: Unsupported texture encoding:", o2)), n2;
  }
  this.allocateTextureUnit = function() {
    const e2 = w;
    return e2 >= l && console.warn("v3d.WebGLTextures: Trying to use " + e2 + " texture units while this GPU supports only " + l), w += 1, e2;
  }, this.resetTextureUnits = function() {
    w = 0;
  }, this.setTexture2D = R, this.setTexture2DArray = function(e2, t2) {
    const r2 = o.get(e2);
    e2.version > 0 && r2.__version !== e2.version ? D(r2, e2, t2) : n.bindTexture(35866, r2.__webglTexture, 33984 + t2);
  }, this.setTexture3D = function(e2, t2) {
    const r2 = o.get(e2);
    e2.version > 0 && r2.__version !== e2.version ? D(r2, e2, t2) : n.bindTexture(32879, r2.__webglTexture, 33984 + t2);
  }, this.setTextureCube = function(t2, r2) {
    const a2 = o.get(t2);
    t2.version > 0 && a2.__version !== t2.version ? function(t3, r3, a3) {
      if (6 !== r3.image.length) return;
      const l2 = N(t3, r3), u2 = r3.source;
      n.bindTexture(34067, t3.__webglTexture, 33984 + a3);
      const d2 = o.get(u2);
      if (u2.version !== d2.__version || true === l2) {
        n.activeTexture(33984 + a3), e.pixelStorei(37440, r3.flipY), e.pixelStorei(37441, r3.premultiplyAlpha), e.pixelStorei(3317, r3.unpackAlignment), e.pixelStorei(37443, 0);
        const t4 = r3.isCompressedTexture || r3.image[0].isCompressedTexture, o2 = r3.image[0] && r3.image[0].isDataTexture, h2 = [];
        for (let e2 = 0; e2 < 6; e2++) h2[e2] = t4 || o2 ? o2 ? r3.image[e2].image : r3.image[e2] : v(r3.image[e2], false, true, c), h2[e2] = z(r3, h2[e2]);
        const f2 = h2[0], p2 = x(f2) || s, m2 = i.convert(r3.format, r3.encoding), g2 = i.convert(r3.type), _2 = C(r3.internalFormat, m2, g2, r3.encoding), A2 = s && true !== r3.isVideoTexture, M2 = void 0 === d2.__version || true === l2;
        let E2, T2 = S(r3, f2, p2);
        if (P(34067, r3, p2), t4) {
          A2 && M2 && n.texStorage2D(34067, T2, _2, f2.width, f2.height);
          for (let e2 = 0; e2 < 6; e2++) {
            E2 = h2[e2].mipmaps;
            for (let t5 = 0; t5 < E2.length; t5++) {
              const o3 = E2[t5];
              1023 !== r3.format ? null !== m2 ? A2 ? n.compressedTexSubImage2D(34069 + e2, t5, 0, 0, o3.width, o3.height, m2, o3.data) : n.compressedTexImage2D(34069 + e2, t5, _2, o3.width, o3.height, 0, o3.data) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : A2 ? n.texSubImage2D(34069 + e2, t5, 0, 0, o3.width, o3.height, m2, g2, o3.data) : n.texImage2D(34069 + e2, t5, _2, o3.width, o3.height, 0, m2, g2, o3.data);
            }
          }
        } else {
          E2 = r3.mipmaps, A2 && M2 && (E2.length > 0 && T2++, n.texStorage2D(34067, T2, _2, h2[0].width, h2[0].height));
          for (let e2 = 0; e2 < 6; e2++) if (o2) {
            A2 ? n.texSubImage2D(34069 + e2, 0, 0, 0, h2[e2].width, h2[e2].height, m2, g2, h2[e2].data) : n.texImage2D(34069 + e2, 0, _2, h2[e2].width, h2[e2].height, 0, m2, g2, h2[e2].data);
            for (let t5 = 0; t5 < E2.length; t5++) {
              const o3 = E2[t5].image[e2].image;
              A2 ? n.texSubImage2D(34069 + e2, t5 + 1, 0, 0, o3.width, o3.height, m2, g2, o3.data) : n.texImage2D(34069 + e2, t5 + 1, _2, o3.width, o3.height, 0, m2, g2, o3.data);
            }
          } else {
            A2 ? n.texSubImage2D(34069 + e2, 0, 0, 0, m2, g2, h2[e2]) : n.texImage2D(34069 + e2, 0, _2, m2, g2, h2[e2]);
            for (let t5 = 0; t5 < E2.length; t5++) {
              const o3 = E2[t5];
              A2 ? n.texSubImage2D(34069 + e2, t5 + 1, 0, 0, m2, g2, o3.image[e2]) : n.texImage2D(34069 + e2, t5 + 1, _2, m2, g2, o3.image[e2]);
            }
          }
        }
        y(r3, p2) && b(34067), d2.__version = u2.version, r3.onUpdate && r3.onUpdate(r3);
      }
      t3.__version = r3.version;
    }(a2, t2, r2) : n.bindTexture(34067, a2.__webglTexture, 33984 + r2);
  }, this.rebindTextures = function(e2, t2, n2) {
    const r2 = o.get(e2);
    void 0 !== t2 && O(r2.__webglFramebuffer, e2, e2.texture, 36064, 3553), void 0 !== n2 && V(e2);
  }, this.setupRenderTarget = function(t2) {
    const l2 = t2.texture, c2 = o.get(t2), u2 = o.get(l2);
    t2.addEventListener("dispose", T), true !== t2.isWebGLMultipleRenderTargets && (void 0 === u2.__webglTexture && (u2.__webglTexture = e.createTexture()), u2.__version = l2.version, a.memory.textures++), a.addTextureSpec(t2);
    const d2 = true === t2.isWebGLCubeRenderTarget, h2 = true === t2.isWebGLMultipleRenderTargets, f2 = x(t2) || s;
    if (d2) {
      c2.__webglFramebuffer = [];
      for (let t3 = 0; t3 < 6; t3++) c2.__webglFramebuffer[t3] = e.createFramebuffer();
    } else {
      if (c2.__webglFramebuffer = e.createFramebuffer(), h2) if (r.drawBuffers) {
        const n2 = t2.texture;
        for (let t3 = 0, r2 = n2.length; t3 < r2; t3++) {
          const r3 = o.get(n2[t3]);
          void 0 === r3.__webglTexture && (r3.__webglTexture = e.createTexture(), a.memory.textures++);
        }
      } else console.warn("v3d.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (s && t2.samples > 0 && false === G(t2)) {
        const o2 = h2 ? l2 : [l2];
        c2.__webglMultisampledFramebuffer = e.createFramebuffer(), c2.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, c2.__webglMultisampledFramebuffer);
        for (let n2 = 0; n2 < o2.length; n2++) {
          const r2 = o2[n2];
          c2.__webglColorRenderbuffer[n2] = e.createRenderbuffer(), e.bindRenderbuffer(36161, c2.__webglColorRenderbuffer[n2]);
          const a2 = i.convert(r2.format, r2.encoding), s2 = i.convert(r2.type), l3 = C(r2.internalFormat, a2, s2, r2.encoding, true === t2.isXRRenderTarget), u3 = U(t2);
          e.renderbufferStorageMultisample(36161, u3, l3, t2.width, t2.height), e.framebufferRenderbuffer(36160, 36064 + n2, 36161, c2.__webglColorRenderbuffer[n2]);
        }
        e.bindRenderbuffer(36161, null), t2.depthBuffer && (c2.__webglDepthRenderbuffer = e.createRenderbuffer(), F(c2.__webglDepthRenderbuffer, t2, true)), n.bindFramebuffer(36160, null);
      }
    }
    if (d2) {
      n.bindTexture(34067, u2.__webglTexture), P(34067, l2, f2);
      for (let e2 = 0; e2 < 6; e2++) O(c2.__webglFramebuffer[e2], t2, l2, 36064, 34069 + e2);
      y(l2, f2) && b(34067), n.unbindTexture();
    } else if (h2) {
      const e2 = t2.texture;
      for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
        const i3 = e2[r2], a2 = o.get(i3);
        n.bindTexture(3553, a2.__webglTexture), P(3553, i3, f2), O(c2.__webglFramebuffer, t2, i3, 36064 + r2, 3553), y(i3, f2) && b(3553);
      }
      n.unbindTexture();
    } else {
      let e2 = 3553;
      (t2.isWebGL3DRenderTarget || t2.isWebGLArrayRenderTarget) && (s ? e2 = t2.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("v3d.WebGLTextures: v3d.Data3DTexture and v3d.DataArrayTexture only supported with WebGL2.")), n.bindTexture(e2, u2.__webglTexture), P(e2, l2, f2), O(c2.__webglFramebuffer, t2, l2, 36064, e2), y(l2, f2) && b(e2), n.unbindTexture();
    }
    t2.depthBuffer && V(t2);
  }, this.updateRenderTargetMipmap = function(e2) {
    const t2 = x(e2) || s, r2 = true === e2.isWebGLMultipleRenderTargets ? e2.texture : [e2.texture];
    for (let i2 = 0, a2 = r2.length; i2 < a2; i2++) {
      const a3 = r2[i2];
      if (y(a3, t2)) {
        const t3 = e2.isWebGLCubeRenderTarget ? 34067 : 3553, r3 = o.get(a3).__webglTexture;
        n.bindTexture(t3, r3), b(t3), n.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(t2) {
    if (s && t2.samples > 0 && false === G(t2)) {
      const r2 = t2.isWebGLMultipleRenderTargets ? t2.texture : [t2.texture], i2 = t2.width, a2 = t2.height;
      let s2 = 16384;
      const l2 = [], c2 = t2.stencilBuffer ? 33306 : 36096, u2 = o.get(t2), d2 = true === t2.isWebGLMultipleRenderTargets;
      if (d2) for (let t3 = 0; t3 < r2.length; t3++) n.bindFramebuffer(36160, u2.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t3, 36161, null), n.bindFramebuffer(36160, u2.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t3, 3553, null, 0);
      n.bindFramebuffer(36008, u2.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, u2.__webglFramebuffer);
      for (let n2 = 0; n2 < r2.length; n2++) {
        l2.push(36064 + n2), t2.depthBuffer && l2.push(c2);
        const h2 = void 0 !== u2.__ignoreDepthValues && u2.__ignoreDepthValues;
        if (false === h2 && (t2.depthBuffer && (s2 |= 256), t2.stencilBuffer && (s2 |= 1024)), d2 && e.framebufferRenderbuffer(36008, 36064, 36161, u2.__webglColorRenderbuffer[n2]), true === h2 && (e.invalidateFramebuffer(36008, [c2]), e.invalidateFramebuffer(36009, [c2])), d2) {
          const t3 = o.get(r2[n2]).__webglTexture;
          e.framebufferTexture2D(36009, 36064, 3553, t3, 0);
        }
        e.blitFramebuffer(0, 0, i2, a2, 0, 0, i2, a2, s2, 9728), f && e.invalidateFramebuffer(36008, l2);
      }
      if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), d2) for (let t3 = 0; t3 < r2.length; t3++) {
        n.bindFramebuffer(36160, u2.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t3, 36161, u2.__webglColorRenderbuffer[t3]);
        const i3 = o.get(r2[t3]).__webglTexture;
        n.bindFramebuffer(36160, u2.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t3, 3553, i3, 0);
      }
      n.bindFramebuffer(36009, u2.__webglMultisampledFramebuffer);
    }
  }, this.setupDepthRenderbuffer = V, this.setupFrameBufferTexture = O, this.useMultisampledRTT = G;
}
function WebGLUniformsGroups(e, t, n, o) {
  let r = {}, i = {}, a = [];
  const s = n.isWebGL2 ? e.getParameter(35375) : 0;
  function l(e2, t2, n2) {
    const o2 = e2.value;
    if (void 0 === n2[t2]) {
      if ("number" == typeof o2) n2[t2] = o2;
      else {
        const e3 = Array.isArray(o2) ? o2 : [o2], r2 = [];
        for (let t3 = 0; t3 < e3.length; t3++) r2.push(e3[t3].clone());
        n2[t2] = r2;
      }
      return true;
    }
    if ("number" == typeof o2) {
      if (n2[t2] !== o2) return n2[t2] = o2, true;
    } else {
      const e3 = Array.isArray(n2[t2]) ? n2[t2] : [n2[t2]], r2 = Array.isArray(o2) ? o2 : [o2];
      for (let t3 = 0; t3 < e3.length; t3++) {
        const n3 = e3[t3];
        if (false === n3.equals(r2[t3])) return n3.copy(r2[t3]), true;
      }
    }
    return false;
  }
  function c(e2) {
    const t2 = { boundary: 0, storage: 0 };
    return "number" == typeof e2 ? (t2.boundary = 4, t2.storage = 4) : e2.isVector2 ? (t2.boundary = 8, t2.storage = 8) : e2.isVector3 || e2.isColor ? (t2.boundary = 16, t2.storage = 12) : e2.isVector4 ? (t2.boundary = 16, t2.storage = 16) : e2.isMatrix3 ? (t2.boundary = 48, t2.storage = 48) : e2.isMatrix4 ? (t2.boundary = 64, t2.storage = 64) : e2.isTexture ? console.warn("v3d.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("v3d.WebGLRenderer: Unsupported uniform value type.", e2), t2;
  }
  function u(t2) {
    const n2 = t2.target;
    n2.removeEventListener("dispose", u);
    const o2 = a.indexOf(n2.__bindingPointIndex);
    a.splice(o2, 1), e.deleteBuffer(r[n2.id]), delete r[n2.id], delete i[n2.id];
  }
  return { bind: function(e2, t2) {
    const n2 = t2.program;
    o.uniformBlockBinding(e2, n2);
  }, update: function(n2, d) {
    let h = r[n2.id];
    void 0 === h && (!function(e2) {
      const t2 = e2.uniforms;
      let n3 = 0;
      const o2 = 16;
      let r2 = 0;
      for (let e3 = 0, i2 = t2.length; e3 < i2; e3++) {
        const i3 = t2[e3], a2 = { boundary: 0, storage: 0 }, s2 = Array.isArray(i3.value) ? i3.value : [i3.value];
        for (let e4 = 0, t3 = s2.length; e4 < t3; e4++) {
          const t4 = c(s2[e4]);
          a2.boundary += t4.boundary, a2.storage += t4.storage;
        }
        if (i3.__data = new Float32Array(a2.storage / Float32Array.BYTES_PER_ELEMENT), i3.__offset = n3, e3 > 0) {
          r2 = n3 % o2;
          0 !== r2 && o2 - r2 - a2.boundary < 0 && (n3 += o2 - r2, i3.__offset = n3);
        }
        n3 += a2.storage;
      }
      r2 = n3 % o2, r2 > 0 && (n3 += o2 - r2);
      e2.__size = n3, e2.__cache = {};
    }(n2), h = function(t2) {
      const n3 = function() {
        for (let e2 = 0; e2 < s; e2++) if (-1 === a.indexOf(e2)) return a.push(e2), e2;
        return console.error("v3d.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
      }();
      t2.__bindingPointIndex = n3;
      const o2 = e.createBuffer(), r2 = t2.__size, i2 = t2.usage;
      return e.bindBuffer(35345, o2), e.bufferData(35345, r2, i2), e.bindBuffer(35345, null), e.bindBufferBase(35345, n3, o2), o2;
    }(n2), r[n2.id] = h, n2.addEventListener("dispose", u));
    const f = d.program;
    o.updateUBOMapping(n2, f);
    const p = t.render.frame;
    i[n2.id] !== p && (!function(t2) {
      const n3 = r[t2.id], o2 = t2.uniforms, i2 = t2.__cache;
      e.bindBuffer(35345, n3);
      for (let t3 = 0, n4 = o2.length; t3 < n4; t3++) {
        const n5 = o2[t3];
        if (true === l(n5, t3, i2)) {
          const t4 = n5.__offset, o3 = Array.isArray(n5.value) ? n5.value : [n5.value];
          let r2 = 0;
          for (let i3 = 0; i3 < o3.length; i3++) {
            const a2 = o3[i3], s2 = c(a2);
            "number" == typeof a2 ? (n5.__data[0] = a2, e.bufferSubData(35345, t4 + r2, n5.__data)) : a2.isMatrix3 ? (n5.__data[0] = a2.elements[0], n5.__data[1] = a2.elements[1], n5.__data[2] = a2.elements[2], n5.__data[3] = a2.elements[0], n5.__data[4] = a2.elements[3], n5.__data[5] = a2.elements[4], n5.__data[6] = a2.elements[5], n5.__data[7] = a2.elements[0], n5.__data[8] = a2.elements[6], n5.__data[9] = a2.elements[7], n5.__data[10] = a2.elements[8], n5.__data[11] = a2.elements[0]) : (a2.toArray(n5.__data, r2), r2 += s2.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          e.bufferSubData(35345, t4, n5.__data);
        }
      }
      e.bindBuffer(35345, null);
    }(n2), i[n2.id] = p);
  }, dispose: function() {
    for (const t2 in r) e.deleteBuffer(r[t2]);
    a = [], r = {}, i = {};
  } };
}
function WebGLUtils(e, t, n) {
  const o = n.isWebGL2;
  return { convert: function(n2, r = null) {
    let i;
    if (1009 === n2) return 5121;
    if (1017 === n2) return 32819;
    if (1018 === n2) return 32820;
    if (1010 === n2) return 5120;
    if (1011 === n2) return 5122;
    if (1012 === n2) return 5123;
    if (1013 === n2) return 5124;
    if (1014 === n2) return 5125;
    if (1015 === n2) return 5126;
    if (1016 === n2) return o ? 5131 : (i = t.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
    if (1021 === n2) return 6406;
    if (1023 === n2) return 6408;
    if (1024 === n2) return 6409;
    if (1025 === n2) return 6410;
    if (1026 === n2) return 6402;
    if (1027 === n2) return 34041;
    if (1035 === n2) return i = t.get("EXT_sRGB"), null !== i ? i.SRGB_ALPHA_EXT : null;
    if (1028 === n2) return 6403;
    if (1029 === n2) return 36244;
    if (1030 === n2) return 33319;
    if (1031 === n2) return 33320;
    if (1033 === n2) return 36249;
    if (33776 === n2 || 33777 === n2 || 33778 === n2 || 33779 === n2) if (3001 === r) {
      if (i = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === i) return null;
      if (33776 === n2) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (33777 === n2) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (33778 === n2) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (33779 === n2) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else {
      if (i = t.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
      if (33776 === n2) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (33777 === n2) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (33778 === n2) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (33779 === n2) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if (35840 === n2 || 35841 === n2 || 35842 === n2 || 35843 === n2) {
      if (i = t.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
      if (35840 === n2) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (35841 === n2) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (35842 === n2) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (35843 === n2) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (36196 === n2) return i = t.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (37492 === n2 || 37496 === n2) {
      if (i = t.get("WEBGL_compressed_texture_etc"), null === i) return null;
      if (37492 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
      if (37496 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (37808 === n2 || 37809 === n2 || 37810 === n2 || 37811 === n2 || 37812 === n2 || 37813 === n2 || 37814 === n2 || 37815 === n2 || 37816 === n2 || 37817 === n2 || 37818 === n2 || 37819 === n2 || 37820 === n2 || 37821 === n2) {
      if (i = t.get("WEBGL_compressed_texture_astc"), null === i) return null;
      if (37808 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (37809 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (37810 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (37811 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (37812 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (37813 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (37814 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (37815 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (37816 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (37817 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (37818 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (37819 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (37820 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (37821 === n2) return 3001 === r ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR;
    }
    if (36492 === n2) {
      if (i = t.get("EXT_texture_compression_bptc"), null === i) return null;
      if (36492 === n2) return 3001 === r ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT;
    }
    return 1020 === n2 ? o ? 34042 : (i = t.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n2] ? e[n2] : null;
  } };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(e = []) {
    super(), this.isArrayCamera = true, this.cameras = e;
  }
};
var Group = class extends Object3D {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
};
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return null === this._hand && (this._hand = new Group(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace(e) {
    return null === this._targetRay && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Vector3(), this._targetRay.name = "XR_CONTROLLER_" + String(e)), this._targetRay;
  }
  getGripSpace() {
    return null === this._grip && (this._grip = new Group(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Vector3()), this._grip;
  }
  dispatchEvent(e) {
    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
  }
  update(e, t, n) {
    let o = null, r = null, i = null;
    const a = this._targetRay, s = this._grip, l = this._hand;
    if (e && "visible-blurred" !== t.session.visibilityState) {
      if (l && e.hand) {
        i = true;
        for (const o3 of e.hand.values()) {
          const e2 = t.getJointPose(o3, n), r3 = this._getHandJoint(l, o3);
          null !== e2 && (r3.matrix.fromArray(e2.transform.matrix), r3.matrix.decompose(r3.position, r3.rotation, r3.scale), r3.jointRadius = e2.radius), r3.visible = null !== e2;
        }
        const o2 = l.joints["index-finger-tip"], r2 = l.joints["thumb-tip"], a2 = o2.position.distanceTo(r2.position), s2 = 0.02, c = 5e-3;
        l.inputState.pinching && a2 > s2 + c ? (l.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && a2 <= s2 - c && (l.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else null !== s && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), r.linearVelocity ? (s.hasLinearVelocity = true, s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = false, r.angularVelocity ? (s.hasAngularVelocity = true, s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = false));
      null !== a && (o = t.getPose(e.targetRaySpace, n), null === o && null !== r && (o = r), null !== o && (a.matrix.fromArray(o.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), o.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(o.linearVelocity)) : a.hasLinearVelocity = false, o.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(o.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(_moveEvent)));
    }
    return null !== a && (a.visible = null !== o), null !== s && (s.visible = null !== r), null !== l && (l.visible = null !== i), this;
  }
  _getHandJoint(e, t) {
    if (void 0 === e.joints[t.jointName]) {
      const n = new Group();
      n.matrixAutoUpdate = false, n.visible = false, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
};
var Raycaster = class {
  constructor(e, t, n = 0, o = 1 / 0) {
    this.ray = new Ray(e, t), this.near = n, this.far = o, this.camera = null, this.layers = new Layers(), this.params = { Mesh: { omitGeometry: false }, Line: { threshold: 0.1 }, LOD: {}, Points: { threshold: 0.1 }, Sprite: {}, checkVisibility: true }, this.layers.enable(3), this.layers.enable(4), this.layers.enable(5), this.layers.enable(6), this.layers.enable(7);
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("v3d.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = true, n = []) {
    return intersectObject(e, this, n, t, this.params.checkVisibility), n.sort(ascSort), n;
  }
  intersectObjects(e, t = true, n = []) {
    for (let o = 0, r = e.length; o < r; o++) intersectObject(e[o], this, n, t, this.params.checkVisibility);
    return n.sort(ascSort), n;
  }
};
function ascSort(e, t) {
  return e.distance - t.distance;
}
function intersectObject(e, t, n, o, r) {
  if (!(r && (false === e.visible || e.isMesh && e.isMaterialGeneratedMesh && e.parent && !e.parent.visible) || (e.layers.test(t.layers) && e.raycast(t, n), true !== o))) {
    const o2 = e.children;
    for (let e2 = 0, i = o2.length; e2 < i; e2++) intersectObject(o2[e2], t, n, true, r);
  }
}
var WebXRManager = class extends EventDispatcher {
  constructor(e, t) {
    super();
    const n = this;
    let o = null, r = 1, i = null, a = "local-floor", s = null, l = null, c = null, u = null, d = null, h = null;
    const f = t.getContextAttributes();
    let p = null, m = null;
    const g = [], _ = [], A = /* @__PURE__ */ new Set(), v = /* @__PURE__ */ new Map(), x = new Vector2();
    let y = null;
    const b = new PerspectiveCamera();
    b.layers.enable(1), b.viewport = new Vector4();
    const C = new PerspectiveCamera();
    C.layers.enable(2), C.viewport = new Vector4();
    const S = [b, C], M = new ArrayCamera();
    M.layers.enable(1), M.layers.enable(2), M.matrixAutoUpdate = false;
    let E = null, T = null, I = null, w = null, R = null, L = new Matrix4();
    const B = new Vector3(), P = new Vector3(), N = new Quaternion();
    function D(e2) {
      const t2 = _.indexOf(e2.inputSource);
      if (-1 === t2) return;
      const n2 = g[t2];
      void 0 !== n2 && n2.dispatchEvent({ type: e2.type, data: e2.inputSource });
    }
    function O() {
      o.removeEventListener("select", D), o.removeEventListener("selectstart", D), o.removeEventListener("selectend", D), o.removeEventListener("squeeze", D), o.removeEventListener("squeezestart", D), o.removeEventListener("squeezeend", D), o.removeEventListener("end", O), o.removeEventListener("inputsourceschange", F);
      for (let e2 = 0; e2 < g.length; e2++) {
        const t2 = _[e2];
        null !== t2 && (_[e2] = null, g[e2].disconnect(t2));
      }
      E = null, T = null, e.setRenderTarget(p), d = null, u = null, c = null, o = null, m = null, I = null, k.stop(), n.isPresenting = false, e.setPixelRatio(y), e.setSize(x.width, x.height, false), n.dispatchEvent({ type: "sessionend" });
    }
    function F(e2) {
      for (let t2 = 0; t2 < e2.removed.length; t2++) {
        const n2 = e2.removed[t2], o2 = _.indexOf(n2);
        o2 >= 0 && (_[o2] = null, g[o2].disconnect(n2));
      }
      for (let t2 = 0; t2 < e2.added.length; t2++) {
        const n2 = e2.added[t2];
        let o2 = _.indexOf(n2);
        if (-1 === o2) {
          for (let e3 = 0; e3 < g.length; e3++) {
            if (e3 >= _.length) {
              _.push(n2), o2 = e3;
              break;
            }
            if (null === _[e3]) {
              _[e3] = n2, o2 = e3;
              break;
            }
          }
          if (-1 === o2) break;
        }
        const r2 = g[o2];
        r2 && r2.connect(n2);
      }
    }
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(e2) {
      let t2 = g[e2];
      return void 0 === t2 && (t2 = new WebXRController(), g[e2] = t2), t2.getTargetRaySpace(e2);
    }, this.getControllerGrip = function(e2) {
      let t2 = g[e2];
      return void 0 === t2 && (t2 = new WebXRController(), g[e2] = t2), t2.getGripSpace();
    }, this.getHand = function(e2) {
      let t2 = g[e2];
      return void 0 === t2 && (t2 = new WebXRController(), g[e2] = t2), t2.getHandSpace();
    }, this.setFramebufferScaleFactor = function(e2) {
      r = e2, true === n.isPresenting && console.warn("v3d.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(e2) {
      a = e2, true === n.isPresenting && console.warn("v3d.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return s || i;
    }, this.setReferenceSpace = function(e2) {
      s = e2;
    }, this.getBaseLayer = function() {
      return null !== u ? u : d;
    }, this.getBinding = function() {
      return c;
    }, this.getFrame = function() {
      return h;
    }, this.getSession = function() {
      return o;
    }, this.setSession = async function(l2) {
      if (o = l2, null !== o) {
        if (p = e.getRenderTarget(), o.addEventListener("select", D), o.addEventListener("selectstart", D), o.addEventListener("selectend", D), o.addEventListener("squeeze", D), o.addEventListener("squeezestart", D), o.addEventListener("squeezeend", D), o.addEventListener("end", O), o.addEventListener("inputsourceschange", F), true !== f.xrCompatible && await t.makeXRCompatible(), y = e.getPixelRatio(), e.getSize(x), void 0 === o.renderState.layers || false === e.capabilities.isWebGL2) {
          const n2 = { antialias: void 0 !== o.renderState.layers || f.antialias, alpha: f.alpha, depth: f.depth, stencil: f.stencil, framebufferScaleFactor: r };
          d = new XRWebGLLayer(o, t, n2), o.updateRenderState({ baseLayer: d }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, false), m = new WebGLRenderTarget(d.framebufferWidth, d.framebufferHeight, { format: 1023, type: 1009, encoding: e.outputEncoding, stencilBuffer: f.stencil });
        } else {
          let n2 = null, i2 = null, a2 = null;
          f.depth && (a2 = f.stencil ? 35056 : 33190, n2 = f.stencil ? 1027 : 1026, i2 = f.stencil ? 1020 : 1014);
          const s2 = { colorFormat: 32856, depthFormat: a2, scaleFactor: r };
          c = new XRWebGLBinding(o, t), u = c.createProjectionLayer(s2), o.updateRenderState({ layers: [u] }), e.setPixelRatio(1), e.setSize(u.textureWidth, u.textureHeight, false), m = new WebGLRenderTarget(u.textureWidth, u.textureHeight, { format: 1023, type: 1009, depthTexture: new DepthTexture(u.textureWidth, u.textureHeight, i2, void 0, void 0, void 0, void 0, void 0, void 0, n2), stencilBuffer: f.stencil, encoding: e.outputEncoding, samples: f.antialias ? 4 : 0 });
          e.properties.get(m).__ignoreDepthValues = u.ignoreDepthValues;
        }
        m.isXRRenderTarget = true, this.setFoveation(1), s = null, i = await o.requestReferenceSpace(a), k.setContext(o), k.start(), n.isPresenting = true, n.dispatchEvent({ type: "sessionstart" });
      }
    };
    const V = new Vector3(), U = new Vector3();
    function G(e2, t2) {
      if (null === t2) e2.matrixWorld.copy(e2.matrix), L.identity(), s = null;
      else {
        e2.matrixWorld.copy(e2.matrix), L.copy(t2.matrixWorld).invert().decompose(B, N, P);
        var n2 = new XRRigidTransform({ x: B.x, y: B.y, z: B.z }, { x: N.x, y: N.y, z: N.z, w: N.w });
        s = i.getOffsetReferenceSpace(n2);
      }
      e2.matrixWorldInverse.copy(e2.matrixWorld).invert();
    }
    this.updateCamera = function(e2) {
      if (null === o) return;
      M.near = C.near = b.near = e2.near, M.far = C.far = b.far = e2.far, E === M.near && T === M.far || (o.updateRenderState({ depthNear: M.near, depthFar: M.far }), E = M.near, T = M.far);
      const t2 = e2.parent, n2 = M.cameras;
      G(M, t2);
      for (let e3 = 0; e3 < n2.length; e3++) G(n2[e3], t2);
      M.matrixWorld.decompose(M.position, M.quaternion, M.scale), e2.matrixWorld.copy(M.matrixWorld), null === t2 ? e2.matrix.copy(e2.matrixWorld) : (e2.matrix.copy(t2.matrixWorld).invert(), e2.matrix.multiply(e2.matrixWorld)), e2.matrix.decompose(e2.position, e2.quaternion, e2.scale);
      const r2 = e2.children;
      for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) r2[e3].updateWorldMatrix(false, true);
      2 === n2.length ? function(e3, t3, n3) {
        V.setFromMatrixPosition(t3.matrixWorld), U.setFromMatrixPosition(n3.matrixWorld);
        const o2 = V.distanceTo(U), r3 = t3.projectionMatrix.elements, i3 = n3.projectionMatrix.elements, a2 = r3[14] / (r3[10] - 1), s2 = r3[14] / (r3[10] + 1), l2 = (r3[9] + 1) / r3[5], c2 = (r3[9] - 1) / r3[5], u2 = (r3[8] - 1) / r3[0], d2 = (i3[8] + 1) / i3[0], h2 = a2 * u2, f2 = a2 * d2, p2 = o2 / (-u2 + d2), m2 = p2 * -u2;
        t3.matrixWorld.decompose(e3.position, e3.quaternion, e3.scale), e3.translateX(m2), e3.translateZ(p2), e3.matrixWorld.compose(e3.position, e3.quaternion, e3.scale), e3.matrixWorldInverse.copy(e3.matrixWorld).invert();
        const g2 = a2 + p2, _2 = s2 + p2, A2 = h2 - m2, v2 = f2 + (o2 - m2), x2 = l2 * s2 / _2 * g2, y2 = c2 * s2 / _2 * g2;
        e3.projectionMatrix.makePerspective(A2, v2, x2, y2, g2, _2);
      }(M, b, C) : M.projectionMatrix.copy(b.projectionMatrix);
      const i2 = M.projectionMatrix.elements;
      M.fov = radToDeg(2 * Math.atan(1 / i2[5])), M.aspect = i2[5] / i2[0], M.projectionMatrixInverse.copy(M.projectionMatrix).invert();
    }, this.getCamera = function() {
      return M;
    }, this.getFoveation = function() {
      return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0;
    }, this.setFoveation = function(e2) {
      null !== u && (u.fixedFoveation = e2), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e2);
    }, this.getPlanes = function() {
      return A;
    };
    let z = null;
    const k = new WebGLAnimation();
    function W(e2) {
      if (I) {
        const t2 = e2.getHitTestResults(I);
        if (t2.length) {
          const e3 = t2[0].getPose(n.getReferenceSpace()), o2 = new Matrix4().fromArray(e3.transform.matrix), r2 = new Vector3();
          r2.setFromMatrixPosition(o2);
          const i2 = new Vector3(0, 1, 0);
          i2.applyNormalMatrix(new Matrix3().setFromMatrix4(o2)), w(r2, i2);
        } else R();
      }
    }
    k.setAnimationLoop(function(t2, o2) {
      if (l = o2.getViewerPose(s || i), h = o2, null !== l) {
        const t3 = l.views;
        null !== d && (e.setRenderTargetFramebuffer(m, d.framebuffer), e.setRenderTarget(m));
        let n2 = false;
        t3.length !== M.cameras.length && (M.cameras.length = 0, n2 = true);
        for (let o3 = 0; o3 < t3.length; o3++) {
          const r2 = t3[o3];
          let i2 = null;
          if (null !== d) i2 = d.getViewport(r2);
          else {
            const t4 = c.getViewSubImage(u, r2);
            i2 = t4.viewport, 0 === o3 && (e.setRenderTargetTextures(m, t4.colorTexture, u.ignoreDepthValues ? void 0 : t4.depthStencilTexture), e.setRenderTarget(m));
          }
          let a2 = S[o3];
          void 0 === a2 && (a2 = new PerspectiveCamera(), a2.layers.enable(o3), a2.viewport = new Vector4(), S[o3] = a2), a2.matrix.fromArray(r2.transform.matrix), a2.projectionMatrix.fromArray(r2.projectionMatrix), a2.viewport.set(i2.x, i2.y, i2.width, i2.height), 0 === o3 && M.matrix.copy(a2.matrix), true === n2 && M.cameras.push(a2);
        }
      }
      for (let e2 = 0; e2 < g.length; e2++) {
        const t3 = _[e2], n2 = g[e2];
        null !== t3 && void 0 !== n2 && n2.update(t3, o2, s || i), W(o2);
      }
      if (z && z(t2, o2), o2.detectedPlanes) {
        n.dispatchEvent({ type: "planesdetected", data: o2.detectedPlanes });
        let e2 = null;
        for (const t3 of A) o2.detectedPlanes.has(t3) || (null === e2 && (e2 = []), e2.push(t3));
        if (null !== e2) for (const t3 of e2) A.delete(t3), v.delete(t3), n.dispatchEvent({ type: "planeremoved", data: t3 });
        for (const e3 of o2.detectedPlanes) if (A.has(e3)) {
          const t3 = v.get(e3);
          e3.lastChangedTime > t3 && (v.set(e3, e3.lastChangedTime), n.dispatchEvent({ type: "planechanged", data: e3 }));
        } else A.add(e3), v.set(e3, o2.lastChangedTime), n.dispatchEvent({ type: "planeadded", data: e3 });
      }
      h = null;
    }), this.setAnimationLoop = function(e2) {
      z = e2;
    }, this.dispose = function() {
    }, this.arHitTest = function(e2, t2, n2, r2) {
      if (!o || !XRSession.prototype.requestHitTestSource) return;
      w = n2 || function() {
      }, R = r2 || function() {
      }, this.raycaster = this.raycaster || new Raycaster(), this.raycaster.setFromCamera({ x: e2, y: t2 }, S[0]);
      const i2 = this.raycaster.ray;
      new XRRay(i2.origin, i2.direction), o.requestReferenceSpace("viewer").then(function(e3) {
        const t3 = { space: e3 };
        o.requestHitTestSource(t3).then(function(e4) {
          I = e4;
        });
      });
    };
  }
};
function createCanvasElement() {
  const e = createElementNS("canvas");
  return e.style.display = "block", e;
}
function WebGLRenderer(e = {}) {
  this.isWebGLRenderer = true;
  const t = void 0 !== e.canvas ? e.canvas : createCanvasElement(), n = void 0 !== e.context ? e.context : null, o = void 0 === e.depth || e.depth, r = void 0 === e.stencil || e.stencil, i = void 0 !== e.antialias && e.antialias, a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, s = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, l = void 0 !== e.powerPreference ? e.powerPreference : "default", c = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
  let u;
  u = null !== n ? n.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
  let d = null, h = null;
  const f = [], p = [];
  this.domElement = t, this.debug = { checkShaderErrors: true, disableCompiledShaderCache: false }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = 3e3, this.unitsScaleFactor = 1, this.toneMapping = 0, this.toneMappingLook = 0, this.toneMappingExposure = 1, this.gtaoMap = null, this.gtaoMapEnabled = false, this.compatSettings = { gtaoDisableBkgFix: false };
  const m = this;
  let g = false, _ = 0, A = 0, v = null, x = -1, y = null;
  const b = new Vector4(), C = new Vector4();
  let S = null, M = t.width, E = t.height, T = 1, I = null, w = null;
  const R = new Vector4(0, 0, M, E), L = new Vector4(0, 0, M, E);
  let B = false;
  const P = new Frustum();
  let N = false, D = false, O = null;
  const F = new Matrix4(), V = new Vector2(), U = new Vector3(), G = new Scene(), z = new Matrix4(), k = new Matrix4(), W = new Vector4(), Q = new Matrix4();
  new Box3();
  let H = false;
  function X() {
    return null === v ? T : 1;
  }
  this.oitRenderer = new WebGLOITRenderer(new Vector2(M, E));
  let Y, j, $, K, q, Z, J, ee, te2, ne, oe, re, ie, ae, se, le, ce, ue, de, he, fe, pe, me, ge, _e = n;
  function Ae(e2, n2) {
    for (let o2 = 0; o2 < e2.length; o2++) {
      const r2 = e2[o2], i2 = t.getContext(r2, n2);
      if (null !== i2) return i2;
    }
    return null;
  }
  try {
    const e2 = { alpha: true, depth: o, stencil: r, antialias: i, premultipliedAlpha: a, preserveDrawingBuffer: s, powerPreference: l, xrCompatible: !Detector.checkSafari(), failIfMajorPerformanceCaveat: c };
    if ("setAttribute" in t && t.setAttribute("data-engine", "Verge3D 4.9.2"), t.addEventListener("webglcontextlost", ye, false), t.addEventListener("webglcontextrestored", be, false), t.addEventListener("webglcontextcreationerror", Ce, false), null === _e) {
      const t2 = ["webgl2", "webgl", "experimental-webgl"];
      if (_e = Ae(t2, e2), null === _e) throw Ae(t2) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      const n2 = "undefined" != typeof WebGL2RenderingContext && _e instanceof WebGL2RenderingContext;
      console.log("Verge3D 4.9.2 " + getVerge3DVariantName() + " (" + (3483952072 == hashString(V3DL) ? "Trial" : "License") + ", " + (n2 ? "WebGL 2.0" : "WebGL 1.0") + ")");
    }
    void 0 === _e.getShaderPrecisionFormat && (_e.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (e2) {
    throw console.error("v3d.WebGLRenderer: " + e2.message), e2;
  }
  function ve() {
    Y = new WebGLExtensions(_e), j = new WebGLCapabilities(_e, Y, e), Y.init(j), pe = new WebGLUtils(_e, Y, j), $ = new WebGLState(_e, Y, j), K = new WebGLInfo(), q = new WebGLProperties(), Z = new WebGLTextures(_e, Y, $, q, j, pe, K), J = new WebGLCubeMaps(m), ee = new WebGLCubeUVMaps(m), te2 = new WebGLAttributes(_e, j), me = new WebGLBindingStates(_e, Y, te2, j), ne = new WebGLGeometries(_e, te2, K, me), oe = new WebGLObjects(_e, ne, te2, K), de = new WebGLMorphtargets(_e, j, Z), le = new WebGLClipping(q), re = new WebGLPrograms(m, J, ee, Y, j, me, le), ie = new WebGLMaterials(m, q), ae = new WebGLRenderLists(), se = new WebGLRenderStates(Y, j), ue = new WebGLBackground(m, J, ee, $, oe, u, a), ce = new WebGLShadowMap(m, oe, j), ge = new WebGLUniformsGroups(_e, K, j, $), he = new WebGLBufferRenderer(_e, Y, K, j), fe = new WebGLIndexedBufferRenderer(_e, Y, K, j), K.programs = re.programs, m.capabilities = j, m.extensions = Y, m.properties = q, m.renderLists = ae, m.shadowMap = ce, m.state = $, m.info = K;
  }
  ve();
  const xe = new WebXRManager(m, _e);
  function ye(e2) {
    e2.preventDefault(), console.log("v3d.WebGLRenderer: Context Lost."), g = true;
  }
  function be() {
    console.log("v3d.WebGLRenderer: Context Restored."), g = false;
    const e2 = ce.enabled, t2 = ce.autoUpdate, n2 = ce.needsUpdate, o2 = ce.type;
    ve(), ce.enabled = e2, ce.autoUpdate = t2, ce.needsUpdate = n2, ce.type = o2;
  }
  function Ce(e2) {
    console.error("v3d.WebGLRenderer: A WebGL context could not be created. Reason:", e2.statusMessage);
  }
  function Se(e2) {
    const t2 = e2.target;
    t2.removeEventListener("dispose", Se), function(e3) {
      (function(e4) {
        const t3 = q.get(e4).programs;
        void 0 !== t3 && (t3.forEach(function(e5) {
          re.releaseProgram(e5);
        }), e4.isShaderMaterial && re.releaseShaderCache(e4));
      })(e3), q.remove(e3);
    }(t2);
  }
  this.xr = xe, this.getContext = function() {
    return _e;
  }, this.getContextAttributes = function() {
    return _e.getContextAttributes();
  }, this.forceContextLoss = function() {
    const e2 = Y.get("WEBGL_lose_context");
    e2 && e2.loseContext();
  }, this.forceContextRestore = function() {
    const e2 = Y.get("WEBGL_lose_context");
    e2 && e2.restoreContext();
  }, this.getTextureUtils = function() {
    return Z;
  }, this.getPixelRatio = function() {
    return T;
  }, this.setPixelRatio = function(e2) {
    void 0 !== e2 && (T = e2, this.setSize(M, E, false));
  }, this.getSize = function(e2) {
    return e2.set(M, E);
  }, this.setSize = function(e2, n2, o2) {
    xe.isPresenting ? console.warn("v3d.WebGLRenderer: Can't change size while VR device is presenting.") : (M = e2, E = n2, t.width = Math.floor(e2 * T), t.height = Math.floor(n2 * T), false !== o2 && (t.style.width = e2 + "px", t.style.height = n2 + "px"), this.setViewport(0, 0, e2, n2), this.oitRenderer && (this.getDrawingBufferSize(V), this.oitRenderer.setSize(V.x, V.y)));
  }, this.getDrawingBufferSize = function(e2) {
    return e2.set(M * T, E * T).floor();
  }, this.setDrawingBufferSize = function(e2, n2, o2) {
    M = e2, E = n2, T = o2, t.width = Math.floor(e2 * o2), t.height = Math.floor(n2 * o2), this.setViewport(0, 0, e2, n2);
  }, this.getCurrentViewport = function(e2) {
    return e2.copy(b);
  }, this.getViewport = function(e2) {
    return e2.copy(R);
  }, this.setViewport = function(e2, t2, n2, o2) {
    e2.isVector4 ? R.set(e2.x, e2.y, e2.z, e2.w) : R.set(e2, t2, n2, o2), $.viewport(b.copy(R).multiplyScalar(T).floor());
  }, this.getScissor = function(e2) {
    return e2.copy(L);
  }, this.setScissor = function(e2, t2, n2, o2) {
    e2.isVector4 ? L.set(e2.x, e2.y, e2.z, e2.w) : L.set(e2, t2, n2, o2), $.scissor(C.copy(L).multiplyScalar(T).floor());
  }, this.getScissorTest = function() {
    return B;
  }, this.setScissorTest = function(e2) {
    $.setScissorTest(B = e2);
  }, this.setOpaqueSort = function(e2) {
    I = e2;
  }, this.setTransparentSort = function(e2) {
    w = e2;
  }, this.getClearColor = function(e2) {
    return e2.copy(ue.getClearColor());
  }, this.setClearColor = function() {
    ue.setClearColor.apply(ue, arguments);
  }, this.getClearAlpha = function() {
    return ue.getClearAlpha();
  }, this.setClearAlpha = function() {
    ue.setClearAlpha.apply(ue, arguments);
  }, this.clear = function(e2 = true, t2 = true, n2 = true) {
    let o2 = 0;
    e2 && (o2 |= 16384), t2 && (o2 |= 256), n2 && (o2 |= 1024), _e.clear(o2);
  }, this.clearColor = function() {
    this.clear(true, false, false);
  }, this.clearDepth = function() {
    this.clear(false, true, false);
  }, this.clearStencil = function() {
    this.clear(false, false, true);
  }, this.dispose = function() {
    t.removeEventListener("webglcontextlost", ye, false), t.removeEventListener("webglcontextrestored", be, false), t.removeEventListener("webglcontextcreationerror", Ce, false), this.disposeGTAO(), this.disposeOIT(), this.disposeInternalCaches(), xe.dispose(), xe.removeEventListener("sessionstart", Ee), xe.removeEventListener("sessionend", Te), O && (O.dispose(), O = null), Ie.stop();
  }, this.canUseGTAO = function() {
    return this.gtaoMap && this.gtaoMapEnabled;
  }, this.disposeGTAO = function() {
    var _a2;
    (_a2 = this.gtaoMap) == null ? void 0 : _a2.dispose(), this.gtaoMap = null;
  }, this.disposeOIT = function() {
    this.oitRenderer && this.oitRenderer.dispose(), this.useOIT = false;
  }, this.disposeInternalCaches = function() {
    ae.dispose(), se.dispose(), q.dispose(), J.dispose(), ee.dispose(), oe.dispose(), me.dispose(), re.dispose(), ge.dispose(), ue.dispose(), te2.dispose();
  }, this.renderBufferDirect = function(e2, t2, n2, o2, r2, i2) {
    null === t2 && (t2 = G);
    const a2 = r2.isMesh && r2.matrixWorld.determinant() < 0, s2 = function(e3, t3, n3, o3, r3) {
      var _a2;
      true !== t3.isScene && (t3 = G);
      Z.resetTextureUnits();
      const i3 = t3.fog, a3 = o3.isMeshNodeMaterial || o3.isMeshStandardMaterial ? t3.environment : null, s3 = null === v ? m.outputEncoding : true === v.isXRRenderTarget ? v.texture.encoding : 3e3;
      if (o3.envMapAutoAssign && (o3.isMeshNodeMaterial || o3.isMeshStandardMaterial)) {
        const e4 = h.state.envMapProbeArray.find((e5) => {
          if (null === e5.influenceGroup) return e5.intersectsMesh(r3);
          return r3.groupNames.includes(e5.influenceGroup) ^ e5.influenceGroupInv;
        }) || t3.worldEnvMapProbe;
        if (e4) {
          o3.envMap = ((_a2 = e4.renderTarget) == null ? void 0 : _a2.texture) || null;
          const t4 = e4.parallaxDistance;
          o3.envMapParallaxMatrix.copy(e4.matrixWorldInverse).premultiply(Q.makeScale(1 / t4, 1 / t4, 1 / t4)), o3.envMapParallaxMatrixInv.copy(e4.matrixWorld).multiply(Q.makeScale(t4, t4, t4)), o3.envMapParallaxType = e4.parallaxType;
        }
      }
      const l3 = (o3.isMeshNodeMaterial || o3.isMeshStandardMaterial ? ee : J).get(o3.envMap || a3), c3 = true === o3.vertexColors && !!n3.attributes.color && 4 === n3.attributes.color.itemSize, u3 = !!o3.normalMap && !!n3.attributes.tangent, d3 = !!n3.morphAttributes.position, f3 = !!n3.morphAttributes.normal, p3 = !!n3.morphAttributes.color, g3 = o3.toneMapped ? m.toneMapping : 0, _3 = n3.morphAttributes.position || n3.morphAttributes.normal || n3.morphAttributes.color, A3 = void 0 !== _3 ? _3.length : 0, C2 = 1 === o3.side, S2 = q.get(o3), I2 = h.state.lights;
      if (true === N && (true === D || e3 !== y)) {
        const t4 = e3 === y && o3.id === x;
        le.setState(o3, e3, t4);
      }
      const w2 = Oe(r3, o3, h), R2 = m.canUseGTAO() && o3.isMeshNodeMaterial && o3.canUseGTAO();
      let L2 = false, B2 = false;
      o3.version === S2.__version ? S2.needsLights && S2.lightsStateVersion !== I2.state.version || S2.outputEncoding !== s3 || r3.isInstancedMesh && false === S2.instancing ? L2 = true : r3.isInstancedMesh || true !== S2.instancing ? r3.isSkinnedMesh && false === S2.skinning ? L2 = true : r3.isSkinnedMesh || true !== S2.skinning ? S2.envMap !== l3 ? (L2 = true, B2 = true) : true === o3.fog && S2.fog !== i3 ? L2 = true : void 0 === S2.numClippingPlanes || S2.numClippingPlanes === le.numPlanes && S2.numIntersection === le.numIntersection ? (S2.vertexAlphas !== c3 || S2.vertexTangents !== u3 || S2.morphTargets !== d3 || S2.morphNormals !== f3 || S2.morphColors !== p3 || S2.toneMapping !== g3 || true === j.isWebGL2 && S2.morphTargetsCount !== A3 || S2.planeReflProbe !== w2 || o3.isMeshNormalMaterial && S2.flipSided !== C2 || S2.useGTAO !== R2) && (L2 = true) : L2 = true : L2 = true : L2 = true : L2 = true;
      let P2 = S2.currentProgram;
      true === L2 && (P2 = Pe(o3, t3, r3, h));
      let F2 = false, H2 = false, X2 = false;
      const Y2 = P2.getUniforms(), K2 = S2.uniforms;
      $.useProgram(P2.program) && (F2 = true, H2 = true, X2 = true);
      o3.id !== x && (x = o3.id, H2 = true);
      B2 && (H2 = true);
      if (F2 || y !== e3) {
        if (Y2.setValue(_e, "projectionMatrix", e3.projectionMatrix), j.logarithmicDepthBuffer && Y2.setValue(_e, "logDepthBufFC", 2 / (Math.log(e3.far + 1) / Math.LN2)), y !== e3 && (y = e3, H2 = true, X2 = true), o3.isMeshNodeMaterial || o3.isShaderMaterial || o3.isMeshStandardMaterial || o3.envMap) {
          const t4 = Y2.map.cameraPosition;
          void 0 !== t4 && t4.setValue(_e, U.setFromMatrixPosition(e3.matrixWorld));
        }
        (o3.isMeshNodeMaterial || o3.isMeshLambertMaterial || o3.isMeshBasicMaterial || o3.isMeshStandardMaterial || o3.isShaderMaterial) && Y2.setValue(_e, "isOrthographic", true === e3.isOrthographicCamera), (o3.isMeshNodeMaterial || o3.isMeshLambertMaterial || o3.isMeshBasicMaterial || o3.isMeshStandardMaterial || o3.isShaderMaterial || o3.isShadowMaterial || r3.isSkinnedMesh) && Y2.setValue(_e, "viewMatrix", e3.matrixWorldInverse), (o3.isMeshNodeMaterial || o3.isMeshLambertMaterial || o3.isMeshStandardMaterial || o3.isShadowMaterial) && Y2.setValue(_e, "invViewMatrix", e3.matrixWorld);
      }
      if (r3.isSkinnedMesh) {
        Y2.setOptional(_e, r3, "bindMatrix"), Y2.setOptional(_e, r3, "bindMatrixInverse");
        const e4 = r3.skeleton;
        e4 && (j.floatVertexTextures ? (null === e4.boneTexture && e4.computeBoneTexture(), Y2.setValue(_e, "boneTexture", e4.boneTexture, Z), Y2.setValue(_e, "boneTextureSize", e4.boneTextureSize)) : console.warn("v3d.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const te3 = n3.morphAttributes;
      (void 0 !== te3.position || void 0 !== te3.normal || void 0 !== te3.color && true === j.isWebGL2) && de.update(r3, n3, o3, P2);
      (H2 || S2.receiveShadow !== r3.receiveShadow) && (S2.receiveShadow = r3.receiveShadow, Y2.setValue(_e, "receiveShadow", r3.receiveShadow));
      if (H2) {
        if (Y2.setValue(_e, "toneMappingExposure", m.toneMappingExposure), 6 == m.toneMapping ? (Y2.setValue(_e, "toneMappingBrightness", m.toneMappingBrightness), Y2.setValue(_e, "toneMappingContrast", m.toneMappingContrast), Y2.setValue(_e, "toneMappingMidTones", m.toneMappingMidTones), Y2.setValue(_e, "toneMappingPhysicalScale", m.toneMappingPhysicalScale), Y2.setValue(_e, "toneMappingChromaticAdaptation", m.toneMappingChromaticAdaptation), Y2.setValue(_e, "toneMappingWhiteColor", m.toneMappingWhiteColor), Y2.setValue(_e, "toneMappingColorDifferentiation", m.toneMappingColorDifferentiation), Y2.setValue(_e, "toneMappingExteriorDaylight", m.toneMappingExteriorDaylight)) : 7 == m.toneMapping && (Y2.setValue(_e, "toneMappingResolution", V.set(M, E)), Y2.setValue(_e, "toneMappingWhiteBalance", m.toneMappingWhiteBalance), Y2.setValue(_e, "toneMappingHighlights", m.toneMappingHighlights), Y2.setValue(_e, "toneMappingMidTones", m.toneMappingMidTones), Y2.setValue(_e, "toneMappingShadows", m.toneMappingShadows), Y2.setValue(_e, "toneMappingSaturation", m.toneMappingSaturation), Y2.setValue(_e, "toneMappingPhysicalScale", m.toneMappingPhysicalScale), Y2.setValue(_e, "toneMappingAperture", m.toneMappingAperture), Y2.setValue(_e, "toneMappingShutter", m.toneMappingShutter), Y2.setValue(_e, "toneMappingISO", m.toneMappingISO), Y2.setValue(_e, "toneMappingVignetting", m.toneMappingVignetting)), S2.needsLights && (oe2 = X2, (ne2 = K2).ambientLightColor.needsUpdate = oe2, ne2.lightProbe.needsUpdate = oe2, ne2.directionalLights.needsUpdate = oe2, ne2.directionalLightShadowsCSM.needsUpdate = oe2, ne2.directionalLightShadowsCSMCascade.needsUpdate = oe2, ne2.pointLights.needsUpdate = oe2, ne2.pointLightShadows.needsUpdate = oe2, ne2.spotLights.needsUpdate = oe2, ne2.spotLightShadows.needsUpdate = oe2, ne2.rectAreaLights.needsUpdate = oe2, ne2.rectAreaLightShadows.needsUpdate = oe2, ne2.hemisphereLights.needsUpdate = oe2), i3 && true === o3.fog && ie.refreshFogUniforms(K2, i3), S2.useGTAO) {
          const e4 = (v == null ? void 0 : v.width) ?? M, t4 = (v == null ? void 0 : v.height) ?? E;
          Y2.setValue(_e, "currResolution", V.set(e4, t4)), ie.refreshGTAOUniforms(K2, m.gtaoMap);
        }
        if (ie.refreshMaterialUniforms(K2, o3, T, E, O), w2 && ie.refreshPlaneReflProbeUniforms(K2, w2), o3.isMeshNodeMaterial) for (const e4 in o3.nodeTextures) Y2.setValue(_e, e4, o3.nodeTextures[e4], Z);
        o3.isMeshLineMaterial && Y2.setValue(_e, "resolution", V.set(M, E)), WebGLUniforms.upload(_e, Ne(S2), K2, Z);
      }
      var ne2, oe2;
      o3.isShaderMaterial && true === o3.uniformsNeedUpdate && (WebGLUniforms.upload(_e, Ne(S2), K2, Z), o3.uniformsNeedUpdate = false);
      o3.isSpriteMaterial && Y2.setValue(_e, "center", r3.center);
      if (o3.isMeshNodeMaterial) {
        o3.needsBoundingBox && (null === n3.boundingBox && n3.computeBoundingBox(), Y2.setValue(_e, "boundingBoxMin", n3.boundingBox.min), Y2.setValue(_e, "boundingBoxMax", n3.boundingBox.max)), Y2.setValue(_e, "viewWidthHeight", V.set(b.z - b.x, b.w - b.y));
        const e4 = Y2.map.invModelMatrix;
        (e4 || o3.nodeTexCoordObject.includes(null)) && (z.copy(r3.matrixWorld).invert(), e4 && e4.setValue(_e, z)), o3.nodeTexCoordObject.forEach(function(e5, t5) {
          (null === e5 ? z : k.copy(e5.matrixWorld).invert()).toArray(S2.nodeTexCoordObjectMatrices, 16 * t5);
        }), Y2.setValue(_e, "nodeTexCoordObjectMatrices", S2.nodeTexCoordObjectMatrices), Y2.setValue(_e, "objectIndex", r3.objectIndex);
        const t4 = r3.objectColor;
        Y2.setValue(_e, "objectColor", W.set(t4.r, t4.g, t4.b, r3.objectAlpha)), Y2.setValue(_e, "objectRandom", hashString(r3.uuid) / Math.pow(2, 32));
      }
      if (Y2.setValue(_e, "modelViewMatrix", r3.modelViewMatrix), Y2.setValue(_e, "normalMatrix", r3.normalMatrix), Y2.setValue(_e, "modelMatrix", r3.matrixWorld), o3.isShaderMaterial || o3.isRawShaderMaterial) {
        const e4 = o3.uniformsGroups;
        for (let t4 = 0, n4 = e4.length; t4 < n4; t4++) if (j.isWebGL2) {
          const n5 = e4[t4];
          ge.update(n5, P2), ge.bind(n5, P2);
        } else console.warn("v3d.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return P2;
    }(e2, t2, n2, o2, r2);
    $.setMaterial(o2, a2);
    let l2 = n2.index, c2 = 1;
    true === o2.wireframe && (l2 = ne.getWireframeAttribute(n2), c2 = 2);
    const u2 = n2.drawRange, d2 = n2.attributes.position;
    let f2 = u2.start * c2, p2 = (u2.start + u2.count) * c2;
    null !== i2 && (f2 = Math.max(f2, i2.start * c2), p2 = Math.min(p2, (i2.start + i2.count) * c2)), null !== l2 ? (f2 = Math.max(f2, 0), p2 = Math.min(p2, l2.count)) : null != d2 && (f2 = Math.max(f2, 0), p2 = Math.min(p2, d2.count));
    const g2 = p2 - f2;
    if (g2 < 0 || g2 === 1 / 0) return;
    let _2;
    me.setup(r2, o2, s2, n2, l2);
    let A2 = he;
    if (null !== l2 && (_2 = te2.get(l2), A2 = fe, A2.setIndex(_2)), r2.isMesh) true === o2.wireframe ? ($.setLineWidth(o2.wireframeLinewidth * X()), A2.setMode(1)) : A2.setMode(4);
    else if (r2.isLine) {
      let e3 = o2.linewidth;
      void 0 === e3 && (e3 = 1), $.setLineWidth(e3 * X()), r2.isLineSegments ? A2.setMode(1) : r2.isLineLoop ? A2.setMode(2) : A2.setMode(3);
    } else r2.isPoints ? A2.setMode(0) : r2.isSprite && A2.setMode(4);
    if (s2.beginTimerQuery(_e, j.isWebGL2), o2.depthPrepass && o2.transparent) {
      const e3 = $.buffers.depth.getTest(), t3 = $.buffers.color.getMask();
      if ($.buffers.depth.setTest(true), $.buffers.color.setMask(0), r2.isInstancedMesh) A2.renderInstances(f2, g2, r2.count);
      else if (n2.isInstancedBufferGeometry) {
        const e4 = void 0 !== n2._maxInstanceCount ? n2._maxInstanceCount : 1 / 0, t4 = Math.min(n2.instanceCount, e4);
        A2.renderInstances(f2, g2, t4);
      } else A2.render(f2, g2);
      $.buffers.depth.setTest(e3), $.buffers.color.setMask(t3);
    }
    if (r2.isInstancedMesh) A2.renderInstances(f2, g2, r2.count);
    else if (n2.isInstancedBufferGeometry) {
      const e3 = void 0 !== n2._maxInstanceCount ? n2._maxInstanceCount : 1 / 0, t3 = Math.min(n2.instanceCount, e3);
      A2.renderInstances(f2, g2, t3);
    } else A2.render(f2, g2);
    s2.endTimerQuery(_e, j.isWebGL2);
  }, this._compilePrepareRenderState = function(e2, t2, n2) {
    n2.init(), e2.traverse((e3) => {
      e3.isLight ? (n2.pushLight(e3), e3.castShadow && n2.pushShadow(e3)) : e3.isCubeReflectionProbe ? n2.pushEnvMapProbe(e3) : e3.isPlaneReflectionProbe && n2.pushPlaneReflProbe(e3);
    }), n2.setupLights(), n2.sortEnvMapProbes();
    let o2 = null;
    return e2.worldEnvMapProbe && null !== e2.worldEnvMapProbe.renderTarget && (o2 = e2.worldEnvMapProbe.renderTarget.texture), e2.traverse((e3) => {
      if (e3.material) {
        (Array.isArray(e3.material) ? e3.material : [e3.material]).forEach((t3) => {
          (t3.isMeshNodeMaterial || t3.isMeshStandardMaterial) && (e3.material.envMap = o2, e3.material.needsUpdate = true);
        });
      }
    }), n2;
  }, this.compile = function(e2, t2) {
    this.gtaoMapEnabled = true;
    const n2 = se.get(e2, p.length);
    this._compilePrepareRenderState(e2, t2, n2);
    const o2 = {};
    e2.traverse(function(t3) {
      const r2 = t3.material;
      if (r2) if (Array.isArray(r2)) for (let i2 = 0; i2 < r2.length; i2++) {
        const a2 = r2[i2];
        a2.uuid in o2 == false && (Pe(a2, e2, t3, n2), o2[a2.uuid] = true);
      }
      else r2.uuid in o2 == false && (Pe(r2, e2, t3, n2), o2[r2.uuid] = true);
    }), this.gtaoMapEnabled = false;
  }, this.compileAsync = function(e2, t2, n2) {
    const o2 = new WebGLRenderState(Y, j);
    this._compilePrepareRenderState(e2, t2, o2);
    const r2 = [];
    if (e2.traverse(function(t3) {
      if (t3.material) {
        (Array.isArray(t3.material) ? t3.material : [t3.material]).forEach(function(n3) {
          r2.push({ scene: e2, obj: t3, mat: n3 });
        });
      }
    }), 0 === r2.length) n2(1);
    else {
      const e3 = Y.get("KHR_parallel_shader_compile"), t3 = (null === e3 ? 1 : 2) * r2.length;
      let i2 = 0, a2 = 0;
      const s2 = {};
      if (arrayForEachPromise(r2, function(r3, l2, c2) {
        m.gtaoMapEnabled = true;
        var u2 = Pe(r3.mat, r3.scene, r3.obj, o2);
        if (m.gtaoMapEnabled = false, e3) {
          const e4 = u2.id;
          e4 in s2 || (s2[e4] = { program: u2, weight: 0 }), s2[e4].weight++;
        }
        n2 && (i2++, n2((i2 + a2) / t3));
      }, 16), e3) {
        const o3 = setInterval(function() {
          let l2 = 0;
          for (let t4 in s2) {
            const n3 = s2[t4];
            (void 0 === n3.program.program || _e.getProgramParameter(n3.program.program, e3.COMPLETION_STATUS_KHR)) && (l2 += n3.weight);
          }
          a2 = Math.max(a2, l2), n2 && n2((i2 + a2) / t3), a2 === r2.length && clearInterval(o3);
        }, 16);
      }
    }
  };
  let Me = null;
  function Ee() {
    Ie.stop();
  }
  function Te() {
    Ie.start();
  }
  const Ie = new WebGLAnimation();
  function we(e2, t2, n2, o2) {
    e2.isAnnotationControl && e2.update(t2);
    let r2 = false;
    if (e2.visible && (r2 = e2.layers.test(t2.layers), r2)) {
      if (e2.isGroup) n2 = e2.renderOrder;
      else if (e2.isLOD) true === e2.autoUpdate && e2.update(t2);
      else if (e2.isLight) h.pushLight(e2), e2.castShadow && h.pushShadow(e2);
      else if (e2.isCubeReflectionProbe) h.pushEnvMapProbe(e2);
      else if (e2.isPlaneReflectionProbe) h.pushPlaneReflProbe(e2);
      else if (e2.isSprite) {
        if (!e2.frustumCulled || P.intersectsSprite(e2)) {
          o2 && U.setFromMatrixPosition(e2.matrixWorld).applyMatrix4(F);
          const t3 = oe.update(e2), r3 = e2.material;
          d.push(e2, t3, r3, n2, U.z, null);
        }
      } else if ((e2.isMesh || e2.isLine || e2.isPoints) && (e2.isSkinnedMesh && e2.skeleton.frame !== K.render.frame && (e2.skeleton.update(), e2.skeleton.frame = K.render.frame), !e2.frustumCulled || P.intersectsObject(e2))) {
        o2 && U.setFromMatrixPosition(e2.matrixWorld).applyMatrix4(F);
        const t3 = oe.update(e2), r3 = e2.material;
        if (Array.isArray(r3)) {
          const o3 = t3.groups;
          for (let i3 = 0, a2 = o3.length; i3 < a2; i3++) {
            const a3 = o3[i3], s2 = r3[a3.materialIndex];
            s2 && s2.visible && d.push(e2, t3, s2, n2, U.z, a3);
          }
        } else r3.visible && d.push(e2, t3, r3, n2, U.z, null);
      }
    }
    if (e2.disableChildRendering) return;
    const i2 = e2.children;
    for (let e3 = 0, a2 = i2.length; e3 < a2; e3++) {
      const a3 = i2[e3];
      !r2 && a3.isMesh && a3.isMaterialGeneratedMesh || we(a3, t2, n2, o2);
    }
  }
  function Re(e2, t2, n2, o2) {
    const r2 = e2.opaque, a2 = e2.transmissive, s2 = e2.transparent;
    h.setupLightsView(n2), a2.length > 0 && function(e3, t3, n3) {
      const o3 = j.isWebGL2;
      null === O && (O = new WebGLRenderTarget(1, 1, { generateMipmaps: true, type: Y.has("EXT_color_buffer_half_float") ? 1016 : 1009, minFilter: 1008, samples: o3 && true === i ? 4 : 0 }));
      m.getDrawingBufferSize(V), o3 ? O.setSize(V.x, V.y) : O.setSize(floorPowerOfTwo(V.x), floorPowerOfTwo(V.y));
      const r3 = m.getRenderTarget();
      m.setRenderTarget(O), m.clear();
      const a3 = m.toneMapping;
      m.toneMapping = 0, Le(e3, t3, n3), m.toneMapping = a3, Z.updateMultisampleRenderTarget(O), Z.updateRenderTargetMipmap(O), m.setRenderTarget(r3);
    }(r2, t2, n2), o2 && $.viewport(b.copy(o2)), r2.length > 0 && Le(r2, t2, n2), a2.length > 0 && Le(a2, t2, n2), s2.length > 0 && (H && 0 !== m.oitRenderer.method ? m.oitRenderer.render(m, Le, s2, t2, n2) : Le(s2, t2, n2)), $.buffers.depth.setTest(true), $.buffers.depth.setMask(true), $.buffers.color.setMask(true), $.setPolygonOffset(false);
  }
  function Le(e2, t2, n2) {
    const o2 = true === t2.isScene ? t2.overrideMaterial : null;
    for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
      const i3 = e2[r2], a2 = i3.object, s2 = i3.geometry, l2 = null === o2 ? i3.material : o2, c2 = i3.group;
      a2.layers.test(n2.layers) && Be(a2, t2, n2, s2, l2, c2);
    }
  }
  function Be(e2, t2, n2, o2, r2, i2) {
    e2.onBeforeRender(m, t2, n2, o2, r2, i2), e2.modelViewMatrix.multiplyMatrices(n2.matrixWorldInverse, e2.matrixWorld), e2.normalMatrix.getNormalMatrix(e2.modelViewMatrix), r2.onBeforeRender(m, t2, n2, o2, e2, i2), true === r2.transparent && 3 === r2.side ? (r2.side = 1, r2.needsUpdate = true, m.renderBufferDirect(n2, t2, o2, r2, e2, i2), r2.side = 0, r2.needsUpdate = true, m.renderBufferDirect(n2, t2, o2, r2, e2, i2), r2.side = 3) : m.renderBufferDirect(n2, t2, o2, r2, e2, i2), e2.onAfterRender(m, t2, n2, o2, r2, i2);
  }
  function Pe(e2, t2, n2, o2) {
    true !== t2.isScene && (t2 = G);
    const r2 = q.get(e2);
    r2.__version = e2.version;
    const i2 = o2.state.lights, a2 = o2.state.shadowsArray, s2 = i2.state.version, l2 = Oe(n2, e2, o2);
    r2.planeReflProbe = l2;
    const c2 = re.getParameters(e2, i2.state, a2, t2, n2, l2), u2 = re.getProgramCacheKey(c2);
    let d2 = r2.programs;
    r2.environment = e2.isMeshNodeMaterial || e2.isMeshStandardMaterial ? t2.environment : null, r2.fog = t2.fog, r2.envMap = (e2.isMeshNodeMaterial || e2.isMeshStandardMaterial ? ee : J).get(e2.envMap || r2.environment), r2.useGTAO = m.canUseGTAO() && e2.isMeshNodeMaterial && e2.canUseGTAO(), void 0 === d2 && (e2.addEventListener("dispose", Se), d2 = /* @__PURE__ */ new Map(), r2.programs = d2);
    let h2 = d2.get(u2);
    if (void 0 !== h2) {
      if (r2.currentProgram === h2 && r2.lightsStateVersion === s2) return De(e2, c2), h2;
    } else c2.uniforms = re.getUniforms(e2), e2.onBuild(n2, c2, m), e2.onBeforeCompile(c2, m), h2 = re.acquireProgram(c2, u2), d2.set(u2, h2), K.numShaderCompiles = re.getNumShaderCompiles(), r2.uniforms = c2.uniforms;
    const f2 = r2.uniforms;
    if ((e2.isShaderMaterial || e2.isRawShaderMaterial) && true !== e2.clipping || e2.defines.WORLD_NODES || (f2.clippingPlanes = le.uniform), De(e2, c2), r2.needsLights = function(e3) {
      return e3.isMeshNodeMaterial || e3.isMeshLambertMaterial || e3.isMeshStandardMaterial || e3.isShadowMaterial || e3.isShaderMaterial && true === e3.lights;
    }(e2), r2.lightsStateVersion = s2, r2.needsLights && (f2.ambientLightColor.value = i2.state.ambient, f2.lightProbe.value = i2.state.probe, f2.directionalLights.value = i2.state.directional, f2.spotLights.value = i2.state.spot, f2.spotLightShadows.value = i2.state.spotShadow, f2.rectAreaLights.value = i2.state.rectArea, f2.ltc_1.value = i2.state.rectAreaLTC1, f2.ltc_2.value = i2.state.rectAreaLTC2, f2.pointLights.value = i2.state.point, f2.pointLightShadows.value = i2.state.pointShadow, f2.hemisphereLights.value = i2.state.hemi, f2.spotShadowMap.value = i2.state.spotShadowMap, f2.spotShadowMatrix.value = i2.state.spotShadowMatrix, f2.pointShadowMap.value = i2.state.pointShadowMap, f2.pointShadowMatrix.value = i2.state.pointShadowMatrix, f2.rectAreaLightShadows.value = i2.state.rectAreaShadow, f2.rectAreaShadowMap.value = i2.state.rectAreaShadowMap, f2.rectAreaShadowMatrix.value = i2.state.rectAreaShadowMatrix, f2.directionalLightShadowsCSM.value = i2.state.directionalShadowCSM, f2.directionalShadowCSMMap.value = i2.state.directionalShadowCSMMap, f2.directionalShadowCSMMatrix.value = i2.state.directionalShadowCSMMatrix, f2.directionalLightShadowsCSMCascade.value = i2.state.directionalShadowCSMCascade), e2.isMeshNodeMaterial) {
      f2.nodeRGB.value !== 4 * e2.nodeRGB.length && (f2.nodeRGB.value = new Float32Array(4 * e2.nodeRGB.length)), f2.nodeValue.value.length !== e2.nodeValue.length && (f2.nodeValue.value = new Float32Array(e2.nodeValue.length));
      for (const t3 in e2.nodeInputs) {
        const n3 = `nodeInputs${strTitle(t3)}`;
        f2[n3].value.length !== e2.nodeInputs[t3] && (f2[n3].value = e2.nodeInputs[t3]);
      }
      r2.nodeTexCoordObjectMatrices && r2.nodeTexCoordObjectMatrices.length === 16 * e2.nodeTexCoordObject.length || (r2.nodeTexCoordObjectMatrices = new Float32Array(16 * e2.nodeTexCoordObject.length));
    } else r2.nodeTexCoordObjectMatrices = new Float32Array(0);
    return r2.currentProgram = h2, r2.uniformsList = null, h2;
  }
  function Ne(e2) {
    if (null === e2.uniformsList) {
      const t2 = e2.currentProgram.getUniforms();
      e2.uniformsList = WebGLUniforms.seqWithValue(t2.seq, e2.uniforms);
    }
    return e2.uniformsList;
  }
  function De(e2, t2) {
    const n2 = q.get(e2);
    n2.outputEncoding = t2.outputEncoding, n2.instancing = t2.instancing, n2.skinning = t2.skinning, n2.morphTargets = t2.morphTargets, n2.morphNormals = t2.morphNormals, n2.morphColors = t2.morphColors, n2.morphTargetsCount = t2.morphTargetsCount, n2.numClippingPlanes = t2.numClippingPlanes, n2.numIntersection = t2.numClipIntersection, n2.vertexAlphas = t2.vertexAlphas, n2.vertexTangents = t2.vertexTangents, n2.toneMapping = t2.toneMapping, n2.flipSided = t2.flipSided;
  }
  function Oe(e2, t2, n2) {
    return (t2.isMeshNodeMaterial || t2.isMeshStandardMaterial) && n2.state.planeReflProbeArray.find((t3) => t3.intersectsMesh(e2)) || null;
  }
  Ie.setAnimationLoop(function(e2) {
    Me && Me(e2);
  }), "undefined" != typeof self && Ie.setContext(self), this.setAnimationLoop = function(e2) {
    Me = e2, xe.setAnimationLoop(e2), null === e2 ? Ie.stop() : Ie.start();
  }, xe.addEventListener("sessionstart", Ee), xe.addEventListener("sessionend", Te), this.render = function(e2, t2) {
    if (void 0 !== t2 && true !== t2.isCamera) return void console.error("v3d.WebGLRenderer.render: camera is not an instance of v3d.Camera.");
    if (true === g) return;
    true === e2.matrixWorldAutoUpdate && e2.updateMatrixWorld(), null === t2.parent && true === t2.matrixWorldAutoUpdate && t2.updateMatrixWorld(), true === xe.enabled && true === xe.isPresenting && (true === xe.cameraAutoUpdate && xe.updateCamera(t2), t2 = xe.getCamera()), true === e2.isScene && e2.onBeforeRender(m, e2, t2, v), h = se.get(e2, p.length), h.init(), p.push(h), F.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), P.setFromProjectionMatrix(F), D = this.localClippingEnabled, N = le.init(this.clippingPlanes, D, t2), d = ae.get(e2, f.length), d.init(), f.push(d), we(e2, t2, 0, m.sortObjects), d.finish(), true === m.sortObjects && d.sort(I, w), true === N && le.beginShadows();
    const n2 = h.state.shadowsArray;
    if (ce.render(n2, e2, t2), true === N && le.endShadows(), this.info.render.frame++, ue.render(d, e2), h.setupLights(), h.sortEnvMapProbes(), t2.isArrayCamera) {
      const n3 = t2.cameras;
      for (let t3 = 0, o2 = n3.length; t3 < o2; t3++) {
        const o3 = n3[t3];
        Re(d, e2, o3, o3.viewport);
      }
    } else Re(d, e2, t2);
    null !== v && (Z.updateMultisampleRenderTarget(v), Z.updateRenderTargetMipmap(v)), true === e2.isScene && e2.onAfterRender(m, e2, t2), me.resetDefaultState(), x = -1, y = null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null;
  }, this.getActiveCubeFace = function() {
    return _;
  }, this.getActiveMipmapLevel = function() {
    return A;
  }, this.getRenderTarget = function() {
    return v;
  }, this.setRenderTargetTextures = function(e2, t2, n2) {
    q.get(e2.texture).__webglTexture = t2, q.get(e2.depthTexture).__webglTexture = n2;
    const o2 = q.get(e2);
    o2.__hasExternalTextures = true, o2.__hasExternalTextures && (o2.__autoAllocateDepthBuffer = void 0 === n2, o2.__autoAllocateDepthBuffer || true === Y.has("WEBGL_multisampled_render_to_texture") && (console.warn("v3d.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), o2.__useRenderToTexture = false));
  }, this.setRenderTargetFramebuffer = function(e2, t2) {
    const n2 = q.get(e2);
    n2.__webglFramebuffer = t2, n2.__useDefaultFramebuffer = void 0 === t2;
  }, this.setRenderTarget = function(e2, t2 = 0, n2 = 0) {
    v = e2, _ = t2, A = n2;
    let o2 = true, r2 = null, i2 = false, a2 = false;
    if (e2) {
      const n3 = q.get(e2);
      void 0 !== n3.__useDefaultFramebuffer ? ($.bindFramebuffer(36160, null), o2 = false) : void 0 === n3.__webglFramebuffer ? Z.setupRenderTarget(e2) : n3.__hasExternalTextures && Z.rebindTextures(e2, q.get(e2.texture).__webglTexture, q.get(e2.depthTexture).__webglTexture);
      const s2 = e2.texture;
      (s2.isData3DTexture || s2.isDataArrayTexture || s2.isCompressedArrayTexture) && (a2 = true);
      const l2 = q.get(e2).__webglFramebuffer;
      e2.isWebGLCubeRenderTarget ? (r2 = l2[t2], i2 = true) : r2 = j.isWebGL2 && e2.samples > 0 && false === Z.useMultisampledRTT(e2) ? q.get(e2).__webglMultisampledFramebuffer : l2, b.copy(e2.viewport), C.copy(e2.scissor), S = e2.scissorTest;
    } else b.copy(R).multiplyScalar(T).floor(), C.copy(L).multiplyScalar(T).floor(), S = B;
    if ($.bindFramebuffer(36160, r2) && j.drawBuffers && o2 && $.drawBuffers(e2, r2), $.viewport(b), $.scissor(C), $.setScissorTest(S), i2) {
      const o3 = q.get(e2.texture);
      _e.framebufferTexture2D(36160, 36064, 34069 + t2, o3.__webglTexture, n2);
    } else if (a2) {
      const o3 = q.get(e2.texture), r3 = t2 || 0;
      _e.framebufferTextureLayer(36160, 36064, o3.__webglTexture, n2 || 0, r3);
    }
    x = -1;
  }, this.readRenderTargetPixels = function(e2, t2, n2, o2, r2, i2, a2) {
    if (!e2 || !e2.isWebGLRenderTarget) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not v3d.WebGLRenderTarget.");
    let s2 = q.get(e2).__webglFramebuffer;
    if (e2.isWebGLCubeRenderTarget && void 0 !== a2 && (s2 = s2[a2]), s2) {
      $.bindFramebuffer(36160, s2);
      try {
        const a3 = e2.texture, s3 = a3.format, l2 = a3.type;
        if (1023 !== s3 && pe.convert(s3) !== _e.getParameter(35739)) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
        const c2 = 1016 === l2 && (Y.has("EXT_color_buffer_half_float") || j.isWebGL2 && Y.has("EXT_color_buffer_float"));
        if (!(1009 === l2 || pe.convert(l2) === _e.getParameter(35738) || 1015 === l2 && (j.isWebGL2 || Y.has("OES_texture_float") || Y.has("WEBGL_color_buffer_float")) || c2)) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        t2 >= 0 && t2 <= e2.width - o2 && n2 >= 0 && n2 <= e2.height - r2 && _e.readPixels(t2, n2, o2, r2, pe.convert(s3), pe.convert(l2), i2);
      } finally {
        const e3 = null !== v ? q.get(v).__webglFramebuffer : null;
        $.bindFramebuffer(36160, e3);
      }
    }
  }, this.copyFramebufferToTexture = function(e2, t2, n2 = 0) {
    const o2 = Math.pow(2, -n2), r2 = Math.floor(t2.image.width * o2), i2 = Math.floor(t2.image.height * o2);
    Z.setTexture2D(t2, 0), _e.copyTexSubImage2D(3553, n2, 0, 0, e2.x, e2.y, r2, i2), $.unbindTexture();
  }, this.copyTextureToTexture = function(e2, t2, n2, o2 = 0) {
    const r2 = t2.image.width, i2 = t2.image.height, a2 = pe.convert(n2.format), s2 = pe.convert(n2.type);
    Z.setTexture2D(n2, 0), _e.pixelStorei(37440, n2.flipY), _e.pixelStorei(37441, n2.premultiplyAlpha), _e.pixelStorei(3317, n2.unpackAlignment), t2.isDataTexture ? _e.texSubImage2D(3553, o2, e2.x, e2.y, r2, i2, a2, s2, t2.image.data) : t2.isCompressedTexture ? _e.compressedTexSubImage2D(3553, o2, e2.x, e2.y, t2.mipmaps[0].width, t2.mipmaps[0].height, a2, t2.mipmaps[0].data) : _e.texSubImage2D(3553, o2, e2.x, e2.y, a2, s2, t2.image), 0 === o2 && n2.generateMipmaps && _e.generateMipmap(3553), $.unbindTexture();
  }, this.copyTextureToTexture3D = function(e2, t2, n2, o2, r2 = 0) {
    if (!j.isWebGL2) return void console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
    const i2 = e2.max.x - e2.min.x + 1, a2 = e2.max.y - e2.min.y + 1, s2 = e2.max.z - e2.min.z + 1, l2 = pe.convert(o2.format), c2 = pe.convert(o2.type);
    let u2;
    if (o2.isData3DTexture) Z.setTexture3D(o2, 0), u2 = 32879;
    else {
      if (!o2.isDataArrayTexture) return void console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: only supports v3d.DataTexture3D and v3d.DataTexture2DArray.");
      Z.setTexture2DArray(o2, 0), u2 = 35866;
    }
    _e.pixelStorei(37440, o2.flipY), _e.pixelStorei(37441, o2.premultiplyAlpha), _e.pixelStorei(3317, o2.unpackAlignment);
    const d2 = _e.getParameter(3314), h2 = _e.getParameter(32878), f2 = _e.getParameter(3316), p2 = _e.getParameter(3315), m2 = _e.getParameter(32877), g2 = n2.isCompressedTexture ? n2.mipmaps[0] : n2.image;
    _e.pixelStorei(3314, g2.width), _e.pixelStorei(32878, g2.height), _e.pixelStorei(3316, e2.min.x), _e.pixelStorei(3315, e2.min.y), _e.pixelStorei(32877, e2.min.z), n2.isDataTexture || n2.isData3DTexture ? _e.texSubImage3D(u2, r2, t2.x, t2.y, t2.z, i2, a2, s2, l2, c2, g2.data) : n2.isCompressedArrayTexture ? (console.warn("v3d.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), _e.compressedTexSubImage3D(u2, r2, t2.x, t2.y, t2.z, i2, a2, s2, l2, g2.data)) : _e.texSubImage3D(u2, r2, t2.x, t2.y, t2.z, i2, a2, s2, l2, c2, g2), _e.pixelStorei(3314, d2), _e.pixelStorei(32878, h2), _e.pixelStorei(3316, f2), _e.pixelStorei(3315, p2), _e.pixelStorei(32877, m2), 0 === r2 && o2.generateMipmaps && _e.generateMipmap(u2), $.unbindTexture();
  }, this.initTexture = function(e2) {
    e2.isCubeTexture ? Z.setTextureCube(e2, 0) : e2.isData3DTexture ? Z.setTexture3D(e2, 0) : e2.isDataArrayTexture || e2.isCompressedArrayTexture ? Z.setTexture2DArray(e2, 0) : Z.setTexture2D(e2, 0), $.unbindTexture();
  }, this.resetState = function() {
    _ = 0, A = 0, v = null, $.reset(), me.reset();
  }, "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })), this.updateGeometry = function(e2) {
    return oe.update(e2);
  }, this.setOIT = function(e2, t2) {
    this.oitRenderer.setSize(M, E), this.oitRenderer.texType = null !== pe.convert(1016) ? 1016 : 1009;
    let n2 = t2 || (true === i ? 4 : 0);
    this.oitRenderer.isMethodCompatible(e2, j) ? this.oitRenderer.setMethod(e2, n2) : console.log("v3d.WebGLRenderer: the OIT method is not compatible.");
  }, this.getOIT = function() {
    return this.oitRenderer.method;
  }, Object.defineProperty(this, "useOIT", { get: function() {
    return H;
  }, set: function(e2) {
    this.setTransparentSort(e2 ? function() {
    } : null), H = e2;
  } });
}
var FogExp2 = class _FogExp2 {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = true, this.name = "", this.color = new Color(e), this.density = t;
  }
  clone() {
    return new _FogExp2(this.color, this.density);
  }
};
var Fog = class _Fog {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = true, this.name = "", this.color = new Color(e), this.near = t, this.far = n;
  }
  clone() {
    return new _Fog(this.color, this.near, this.far);
  }
};
var InterleavedBuffer = class {
  constructor(e, t) {
    this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    true === e && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let o = 0, r = this.stride; o < r; o++) this.array[e + o] = t.array[n + o];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
};
var _vector$6 = new Vector3();
var InterleavedBufferAttribute = class _InterleavedBufferAttribute {
  constructor(e, t, n, o = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = o;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++) _vector$6.fromBufferAttribute(this, t), _vector$6.applyMatrix4(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++) _vector$6.fromBufferAttribute(this, t), _vector$6.applyNormalMatrix(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++) _vector$6.fromBufferAttribute(this, t), _vector$6.transformDirection(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = normalize(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = normalize(t, this.array), n = normalize(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = normalize(t, this.array), n = normalize(n, this.array), o = normalize(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = o, this;
  }
  setXYZW(e, t, n, o, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = normalize(t, this.array), n = normalize(n, this.array), o = normalize(o, this.array), r = normalize(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = o, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (void 0 === e) {
      console.log("v3d.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const e2 = [];
      for (let t = 0; t < this.count; t++) {
        const n = t * this.data.stride + this.offset;
        for (let t2 = 0; t2 < this.itemSize; t2++) e2.push(this.data.array[n + t2]);
      }
      return new BufferAttribute(new this.array.constructor(e2), this.itemSize, this.normalized);
    }
    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new _InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
};
var SpriteMaterial = class extends Material {
  constructor(e) {
    super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
};
var _geometry;
var _intersectPoint = new Vector3();
var _worldScale$1 = new Vector3();
var _mvPosition = new Vector3();
var _alignedPosition = new Vector2();
var _rotatedPosition = new Vector2();
var _viewWorldMatrix = new Matrix4();
var _vA$1 = new Vector3();
var _vB$1 = new Vector3();
var _vC$1 = new Vector3();
var _uvA$1 = new Vector2();
var _uvB$1 = new Vector2();
var _uvC$1 = new Vector2();
var Sprite = class extends Object3D {
  constructor(e) {
    if (super(), this.isSprite = true, this.type = "Sprite", void 0 === _geometry) {
      _geometry = new BufferGeometry();
      const e2 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), t = new InterleavedBuffer(e2, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(t, 3, 0, false)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(t, 2, 3, false));
    }
    this.geometry = _geometry, this.material = void 0 !== e ? e : new SpriteMaterial(), this.center = new Vector2(0.5, 0.5);
  }
  raycast(e, t) {
    if (null === e.camera) return void console.error('v3d.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    _worldScale$1.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && _worldScale$1.multiplyScalar(-_mvPosition.z);
    const n = this.material.rotation;
    let o, r;
    0 !== n && (r = Math.cos(n), o = Math.sin(n));
    const i = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, i, _worldScale$1, o, r), transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, i, _worldScale$1, o, r), transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, i, _worldScale$1, o, r), _uvA$1.set(0, 0), _uvB$1.set(1, 0), _uvC$1.set(1, 1);
    let a = e.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
    if (null === a && (transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, i, _worldScale$1, o, r), _uvB$1.set(0, 1), a = e.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint), null === a)) return;
    const s = e.ray.origin.distanceTo(_intersectPoint);
    s < e.near || s > e.far || t.push({ distance: s, point: _intersectPoint.clone(), uv: Triangle.getInterpolation(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()), face: null, object: this });
  }
  copy(e, t) {
    return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this;
  }
};
function transformVertex(e, t, n, o, r, i) {
  _alignedPosition.subVectors(e, n).addScalar(0.5).multiply(o), void 0 !== r ? (_rotatedPosition.x = i * _alignedPosition.x - r * _alignedPosition.y, _rotatedPosition.y = r * _alignedPosition.x + i * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), e.copy(t), e.x += _rotatedPosition.x, e.y += _rotatedPosition.y, e.applyMatrix4(_viewWorldMatrix);
}
var _v1$3 = new Vector3();
var _v2$2 = new Vector3();
var LOD = class extends Object3D {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
  }
  copy(e) {
    super.copy(e, false);
    const t = e.levels;
    for (let e2 = 0, n = t.length; e2 < n; e2++) {
      const n2 = t[e2];
      this.addLevel(n2.object.clone(), n2.distance, n2.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const o = this.levels;
    let r;
    for (r = 0; r < o.length && !(t < o[r].distance); r++) ;
    return o.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, o;
      for (n = 1, o = t.length; n < o; n++) {
        let o2 = t[n].distance;
        if (t[n].object.visible && (o2 -= o2 * t[n].hysteresis), e < o2) break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      _v1$3.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(_v1$3);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      _v1$3.setFromMatrixPosition(e.matrixWorld), _v2$2.setFromMatrixPosition(this.matrixWorld);
      const n = _v1$3.distanceTo(_v2$2) / e.zoom;
      let o, r;
      for (t[0].object.visible = true, o = 1, r = t.length; o < r; o++) {
        let e2 = t[o].distance;
        if (t[o].object.visible && (e2 -= e2 * t[o].hysteresis), !(n >= e2)) break;
        t[o - 1].object.visible = false, t[o].object.visible = true;
      }
      for (this._currentLevel = o - 1; o < r; o++) t[o].object.visible = false;
    }
  }
};
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector$5 = new Vector3();
var _matrix$1 = new Matrix4();
var SkinnedMesh = class extends Mesh {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4(), this.normalizeSkinWeights();
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Vector4(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, o = t.count; n < o; n++) {
      e.fromBufferAttribute(t, n);
      const o2 = 1 / e.manhattanLength();
      o2 !== 1 / 0 ? e.multiplyScalar(o2) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("v3d.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const n = this.skeleton, o = this.geometry;
    _skinIndex.fromBufferAttribute(o.attributes.skinIndex, e), _skinWeight.fromBufferAttribute(o.attributes.skinWeight, e), _basePosition.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let e2 = 0; e2 < 4; e2++) {
      const o2 = _skinWeight.getComponent(e2);
      if (0 !== o2) {
        const r = _skinIndex.getComponent(e2);
        _matrix$1.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix$1), o2);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
};
var Bone = class extends Object3D {
  constructor() {
    super(), this.isBone = true, this.type = "Bone";
  }
};
var DataTexture = class extends Texture {
  constructor(e = null, t = 1, n = 1, o, r, i, a, s, l = 1003, c = 1003, u, d) {
    super(null, i, a, s, l, c, o, r, u, d), this.isDataTexture = true, this.image = { data: e, width: t, height: n }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
var _offsetMatrix = new Matrix4();
var _identityMatrix = new Matrix4();
var Skeleton = class _Skeleton {
  constructor(e = [], t = []) {
    this.uuid = generateUUID(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("v3d.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t2 = new Matrix4();
      this.bones[e] && t2.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t2);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t2 = this.bones[e];
      t2 && t2.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t2 = this.bones[e];
      t2 && (t2.parent && t2.parent.isBone ? (t2.matrix.copy(t2.parent.matrixWorld).invert(), t2.matrix.multiply(t2.matrixWorld)) : t2.matrix.copy(t2.matrixWorld), t2.matrix.decompose(t2.position, t2.quaternion, t2.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, o = this.boneTexture;
    for (let o2 = 0, r = e.length; o2 < r; o2++) {
      const r2 = e[o2] ? e[o2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(r2, t[o2]), _offsetMatrix.toArray(n, 16 * o2);
    }
    null !== o && (o.needsUpdate = true);
  }
  clone() {
    return new _Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(4 * this.bones.length);
    e = ceilPowerOfTwo(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new DataTexture(t, e, e, 1023, 1015);
    return n.name = "Skeleton.bone", n.needsUpdate = true, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const n2 = this.bones[t];
      if (n2.name === e) return n2;
    }
  }
  dispose() {
    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
  }
};
var InstancedBufferAttribute$1 = class extends BufferAttribute {
  constructor(e, t, n, o = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = true, this.meshPerAttribute = o;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
};
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _identity = new Matrix4();
var _mesh$1 = new Mesh();
var InstancedMesh = class extends Mesh {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new InstancedBufferAttribute$1(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = false;
    for (let e2 = 0; e2 < n; e2++) this.setMatrixAt(e2, _identity);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, 3 * e);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  raycast(e, t) {
    const n = this.matrixWorld, o = this.count;
    if (_mesh$1.geometry = this.geometry, _mesh$1.material = this.material, void 0 !== _mesh$1.material) for (let r = 0; r < o; r++) {
      this.getMatrixAt(r, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(n, _instanceLocalMatrix), _mesh$1.matrixWorld = _instanceWorldMatrix, _mesh$1.raycast(e, _instanceIntersects);
      for (let e2 = 0, n2 = _instanceIntersects.length; e2 < n2; e2++) {
        const n3 = _instanceIntersects[e2];
        n3.instanceId = r, n3.object = this, t.push(n3);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(e, t) {
    null === this.instanceColor && (this.instanceColor = new InstancedBufferAttribute$1(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, 16 * e);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var LineBasicMaterial = class extends Material {
  constructor(e) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
};
var _start$1 = new Vector3();
var _end$1 = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();
var Line = class extends Object3D {
  constructor(e = new BufferGeometry(), t = new LineBasicMaterial()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (null === e.index) {
      const t = e.attributes.position, n = [0];
      for (let e2 = 1, o = t.count; e2 < o; e2++) _start$1.fromBufferAttribute(t, e2 - 1), _end$1.fromBufferAttribute(t, e2), n[e2] = n[e2 - 1], n[e2] += _start$1.distanceTo(_end$1);
      e.setAttribute("lineDistance", new Float32BufferAttribute(n, 1));
    } else console.warn("v3d.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, o = this.matrixWorld, r = e.params.Line.threshold, i = n.drawRange;
    if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere$2.copy(n.boundingSphere), _sphere$2.applyMatrix4(o), _sphere$2.radius += r, false === e.ray.intersectsSphere(_sphere$2)) return;
    _inverseMatrix$1.copy(o).invert(), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = a * a, l = new Vector3(), c = new Vector3(), u = new Vector3(), d = new Vector3(), h = this.isLineSegments ? 2 : 1, f = n.index, p = n.attributes.position;
    if (null !== f) {
      for (let n2 = Math.max(0, i.start), o2 = Math.min(f.count, i.start + i.count) - 1; n2 < o2; n2 += h) {
        const o3 = f.getX(n2), r2 = f.getX(n2 + 1);
        l.fromBufferAttribute(p, o3), c.fromBufferAttribute(p, r2);
        if (_ray$1.distanceSqToSegment(l, c, d, u) > s) continue;
        d.applyMatrix4(this.matrixWorld);
        const i2 = e.ray.origin.distanceTo(d);
        i2 < e.near || i2 > e.far || t.push({ distance: i2, point: u.clone().applyMatrix4(this.matrixWorld), index: n2, face: null, faceIndex: null, object: this });
      }
    } else {
      for (let n2 = Math.max(0, i.start), o2 = Math.min(p.count, i.start + i.count) - 1; n2 < o2; n2 += h) {
        l.fromBufferAttribute(p, n2), c.fromBufferAttribute(p, n2 + 1);
        if (_ray$1.distanceSqToSegment(l, c, d, u) > s) continue;
        d.applyMatrix4(this.matrixWorld);
        const o3 = e.ray.origin.distanceTo(d);
        o3 < e.near || o3 > e.far || t.push({ distance: o3, point: u.clone().applyMatrix4(this.matrixWorld), index: n2, face: null, faceIndex: null, object: this });
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (void 0 !== n) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let e2 = 0, t2 = n.length; e2 < t2; e2++) {
          const t3 = n[e2].name || String(e2);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t3] = e2;
        }
      }
    }
  }
};
var _start = new Vector3();
var _end = new Vector3();
var LineSegments = class extends Line {
  constructor(e, t) {
    super(e, t), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (null === e.index) {
      const t = e.attributes.position, n = [];
      for (let e2 = 0, o = t.count; e2 < o; e2 += 2) _start.fromBufferAttribute(t, e2), _end.fromBufferAttribute(t, e2 + 1), n[e2] = 0 === e2 ? 0 : n[e2 - 1], n[e2 + 1] = n[e2] + _start.distanceTo(_end);
      e.setAttribute("lineDistance", new Float32BufferAttribute(n, 1));
    } else console.warn("v3d.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
};
var LineLoop = class extends Line {
  constructor(e, t) {
    super(e, t), this.isLineLoop = true, this.type = "LineLoop";
  }
};
var PointsMaterial = class extends Material {
  constructor(e) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
};
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere$1 = new Sphere();
var _position$2 = new Vector3();
var Points = class extends Object3D {
  constructor(e = new BufferGeometry(), t = new PointsMaterial()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, o = this.matrixWorld, r = e.params.Points.threshold, i = n.drawRange;
    if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere$1.copy(n.boundingSphere), _sphere$1.applyMatrix4(o), _sphere$1.radius += r, false === e.ray.intersectsSphere(_sphere$1)) return;
    _inverseMatrix.copy(o).invert(), _ray.copy(e.ray).applyMatrix4(_inverseMatrix);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = a * a, l = n.index, c = n.attributes.position;
    if (null !== l) {
      for (let n2 = Math.max(0, i.start), r2 = Math.min(l.count, i.start + i.count); n2 < r2; n2++) {
        const r3 = l.getX(n2);
        _position$2.fromBufferAttribute(c, r3), testPoint(_position$2, r3, s, o, e, t, this);
      }
    } else {
      for (let n2 = Math.max(0, i.start), r2 = Math.min(c.count, i.start + i.count); n2 < r2; n2++) _position$2.fromBufferAttribute(c, n2), testPoint(_position$2, n2, s, o, e, t, this);
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (void 0 !== n) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let e2 = 0, t2 = n.length; e2 < t2; e2++) {
          const t3 = n[e2].name || String(e2);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t3] = e2;
        }
      }
    }
  }
};
function testPoint(e, t, n, o, r, i, a) {
  const s = _ray.distanceSqToPoint(e);
  if (s < n) {
    const n2 = new Vector3();
    _ray.closestPointToPoint(e, n2), n2.applyMatrix4(o);
    const l = r.ray.origin.distanceTo(n2);
    if (l < r.near || l > r.far) return;
    i.push({ distance: l, distanceToRay: Math.sqrt(s), point: n2, index: t, face: null, object: a });
  }
}
var VideoTexture = class extends Texture {
  constructor(e, t, n, o, r, i, a, s, l) {
    super(e, t, n, o, r, i, a, s, l), this.isVideoTexture = true, this.minFilter = void 0 !== i ? i : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = false;
    const c = this;
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t2() {
      c.needsUpdate = true, e.requestVideoFrameCallback(t2);
    });
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    false === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  }
};
var FramebufferTexture = class extends Texture {
  constructor(e, t, n) {
    super({ width: e, height: t }), this.isFramebufferTexture = true, this.format = n, this.magFilter = 1003, this.minFilter = 1003, this.generateMipmaps = false, this.needsUpdate = true;
  }
};
var CompressedTexture = class extends Texture {
  constructor(e, t, n, o, r, i, a, s, l, c, u, d) {
    super(null, i, a, s, l, c, o, r, u, d), this.isCompressedTexture = true, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false;
  }
};
var CompressedArrayTexture = class extends CompressedTexture {
  constructor(e, t, n, o, r, i) {
    super(e, t, n, r, i), this.isCompressedArrayTexture = true, this.image.depth = o, this.wrapR = 1001;
  }
};
var CanvasTexture = class extends Texture {
  constructor(e, t, n, o, r, i, a, s, l) {
    super(e, t, n, o, r, i, a, s, l), this.isCanvasTexture = true, this.needsUpdate = true;
  }
};
var Curve = class {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("v3d.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    const t = [];
    let n, o = this.getPoint(0), r = 0;
    t.push(0);
    for (let i = 1; i <= e; i++) n = this.getPoint(i / e), r += n.distanceTo(o), t.push(r), o = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let o = 0;
    const r = n.length;
    let i;
    i = t || e * n[r - 1];
    let a, s = 0, l = r - 1;
    for (; s <= l; ) if (o = Math.floor(s + (l - s) / 2), a = n[o] - i, a < 0) s = o + 1;
    else {
      if (!(a > 0)) {
        l = o;
        break;
      }
      l = o - 1;
    }
    if (o = l, n[o] === i) return o / (r - 1);
    const c = n[o];
    return (o + (i - c) / (n[o + 1] - c)) / (r - 1);
  }
  getTangent(e, t) {
    const n = 1e-4;
    let o = e - n, r = e + n;
    o < 0 && (o = 0), r > 1 && (r = 1);
    const i = this.getPoint(o), a = this.getPoint(r), s = t || (i.isVector2 ? new Vector2() : new Vector3());
    return s.copy(a).sub(i).normalize(), s;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new Vector3(), o = [], r = [], i = [], a = new Vector3(), s = new Matrix4();
    for (let t2 = 0; t2 <= e; t2++) {
      const n2 = t2 / e;
      o[t2] = this.getTangentAt(n2, new Vector3());
    }
    r[0] = new Vector3(), i[0] = new Vector3();
    let l = Number.MAX_VALUE;
    const c = Math.abs(o[0].x), u = Math.abs(o[0].y), d = Math.abs(o[0].z);
    c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), d <= l && n.set(0, 0, 1), a.crossVectors(o[0], n).normalize(), r[0].crossVectors(o[0], a), i[0].crossVectors(o[0], r[0]);
    for (let t2 = 1; t2 <= e; t2++) {
      if (r[t2] = r[t2 - 1].clone(), i[t2] = i[t2 - 1].clone(), a.crossVectors(o[t2 - 1], o[t2]), a.length() > Number.EPSILON) {
        a.normalize();
        const e2 = Math.acos(clamp(o[t2 - 1].dot(o[t2]), -1, 1));
        r[t2].applyMatrix4(s.makeRotationAxis(a, e2));
      }
      i[t2].crossVectors(o[t2], r[t2]);
    }
    if (true === t) {
      let t2 = Math.acos(clamp(r[0].dot(r[e]), -1, 1));
      t2 /= e, o[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t2 = -t2);
      for (let n2 = 1; n2 <= e; n2++) r[n2].applyMatrix4(s.makeRotationAxis(o[n2], t2 * n2)), i[n2].crossVectors(o[n2], r[n2]);
    }
    return { tangents: o, normals: r, binormals: i };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(e = 0, t = 0, n = 1, o = 1, r = 0, i = 2 * Math.PI, a = false, s = 0) {
    super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = o, this.aStartAngle = r, this.aEndAngle = i, this.aClockwise = a, this.aRotation = s;
  }
  getPoint(e, t) {
    const n = t || new Vector2(), o = 2 * Math.PI;
    let r = this.aEndAngle - this.aStartAngle;
    const i = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += o;
    for (; r > o; ) r -= o;
    r < Number.EPSILON && (r = i ? 0 : o), true !== this.aClockwise || i || (r === o ? r = -o : r -= o);
    const a = this.aStartAngle + e * r;
    let s = this.aX + this.xRadius * Math.cos(a), l = this.aY + this.yRadius * Math.sin(a);
    if (0 !== this.aRotation) {
      const e2 = Math.cos(this.aRotation), t2 = Math.sin(this.aRotation), n2 = s - this.aX, o2 = l - this.aY;
      s = n2 * e2 - o2 * t2 + this.aX, l = n2 * t2 + o2 * e2 + this.aY;
    }
    return n.set(s, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
};
var ArcCurve = class extends EllipseCurve {
  constructor(e, t, n, o, r, i) {
    super(e, t, n, n, o, r, i), this.isArcCurve = true, this.type = "ArcCurve";
  }
};
function CubicPoly() {
  let e = 0, t = 0, n = 0, o = 0;
  function r(r2, i, a, s) {
    e = r2, t = a, n = -3 * r2 + 3 * i - 2 * a - s, o = 2 * r2 - 2 * i + a + s;
  }
  return { initCatmullRom: function(e2, t2, n2, o2, i) {
    r(t2, n2, i * (n2 - e2), i * (o2 - t2));
  }, initNonuniformCatmullRom: function(e2, t2, n2, o2, i, a, s) {
    let l = (t2 - e2) / i - (n2 - e2) / (i + a) + (n2 - t2) / a, c = (n2 - t2) / a - (o2 - t2) / (a + s) + (o2 - n2) / s;
    l *= a, c *= a, r(t2, n2, l, c);
  }, calc: function(r2) {
    const i = r2 * r2;
    return e + t * r2 + n * i + o * (i * r2);
  } };
}
var tmp$1 = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(e = [], t = false, n = "centripetal", o = 0.5) {
    super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = o;
  }
  getPoint(e, t = new Vector3()) {
    const n = t, o = this.points, r = o.length, i = (r - (this.closed ? 0 : 1)) * e;
    let a, s, l = Math.floor(i), c = i - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = o[(l - 1) % r] : (tmp$1.subVectors(o[0], o[1]).add(o[0]), a = tmp$1);
    const u = o[l % r], d = o[(l + 1) % r];
    if (this.closed || l + 2 < r ? s = o[(l + 2) % r] : (tmp$1.subVectors(o[r - 1], o[r - 2]).add(o[r - 1]), s = tmp$1), "centripetal" === this.curveType || "chordal" === this.curveType) {
      const e2 = "chordal" === this.curveType ? 0.5 : 0.25;
      let t2 = Math.pow(a.distanceToSquared(u), e2), n2 = Math.pow(u.distanceToSquared(d), e2), o2 = Math.pow(d.distanceToSquared(s), e2);
      n2 < 1e-4 && (n2 = 1), t2 < 1e-4 && (t2 = n2), o2 < 1e-4 && (o2 = n2), px.initNonuniformCatmullRom(a.x, u.x, d.x, s.x, t2, n2, o2), py.initNonuniformCatmullRom(a.y, u.y, d.y, s.y, t2, n2, o2), pz.initNonuniformCatmullRom(a.z, u.z, d.z, s.z, t2, n2, o2);
    } else "catmullrom" === this.curveType && (px.initCatmullRom(a.x, u.x, d.x, s.x, this.tension), py.initCatmullRom(a.y, u.y, d.y, s.y, this.tension), pz.initCatmullRom(a.z, u.z, d.z, s.z, this.tension));
    return n.set(px.calc(c), py.calc(c), pz.calc(c)), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const n2 = e.points[t];
      this.points.push(n2.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
};
function CatmullRom(e, t, n, o, r) {
  const i = 0.5 * (o - t), a = 0.5 * (r - n), s = e * e;
  return (2 * n - 2 * o + i + a) * (e * s) + (-3 * n + 3 * o - 2 * i - a) * s + i * e + n;
}
function QuadraticBezierP0(e, t) {
  const n = 1 - e;
  return n * n * t;
}
function QuadraticBezierP1(e, t) {
  return 2 * (1 - e) * e * t;
}
function QuadraticBezierP2(e, t) {
  return e * e * t;
}
function QuadraticBezier(e, t, n, o) {
  return QuadraticBezierP0(e, t) + QuadraticBezierP1(e, n) + QuadraticBezierP2(e, o);
}
function CubicBezierP0(e, t) {
  const n = 1 - e;
  return n * n * n * t;
}
function CubicBezierP1(e, t) {
  const n = 1 - e;
  return 3 * n * n * e * t;
}
function CubicBezierP2(e, t) {
  return 3 * (1 - e) * e * e * t;
}
function CubicBezierP3(e, t) {
  return e * e * e * t;
}
function CubicBezier(e, t, n, o, r) {
  return CubicBezierP0(e, t) + CubicBezierP1(e, n) + CubicBezierP2(e, o) + CubicBezierP3(e, r);
}
var CubicBezierCurve = class extends Curve {
  constructor(e = new Vector2(), t = new Vector2(), n = new Vector2(), o = new Vector2()) {
    super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = o;
  }
  getPoint(e, t = new Vector2()) {
    const n = t, o = this.v0, r = this.v1, i = this.v2, a = this.v3;
    return n.set(CubicBezier(e, o.x, r.x, i.x, a.x), CubicBezier(e, o.y, r.y, i.y, a.y)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
};
var CubicBezierCurve3 = class extends Curve {
  constructor(e = new Vector3(), t = new Vector3(), n = new Vector3(), o = new Vector3()) {
    super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = o;
  }
  getPoint(e, t = new Vector3()) {
    const n = t, o = this.v0, r = this.v1, i = this.v2, a = this.v3;
    return n.set(CubicBezier(e, o.x, r.x, i.x, a.x), CubicBezier(e, o.y, r.y, i.y, a.y), CubicBezier(e, o.z, r.z, i.z, a.z)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
};
var LineCurve = class extends Curve {
  constructor(e = new Vector2(), t = new Vector2()) {
    super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Vector2()) {
    const n = t;
    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const n = t || new Vector2();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
};
var LineCurve3 = class extends Curve {
  constructor(e = new Vector3(), t = new Vector3()) {
    super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Vector3()) {
    const n = t;
    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(e = new Vector2(), t = new Vector2(), n = new Vector2()) {
    super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Vector2()) {
    const n = t, o = this.v0, r = this.v1, i = this.v2;
    return n.set(QuadraticBezier(e, o.x, r.x, i.x), QuadraticBezier(e, o.y, r.y, i.y)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
};
var QuadraticBezierCurve3 = class extends Curve {
  constructor(e = new Vector3(), t = new Vector3(), n = new Vector3()) {
    super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Vector3()) {
    const n = t, o = this.v0, r = this.v1, i = this.v2;
    return n.set(QuadraticBezier(e, o.x, r.x, i.x), QuadraticBezier(e, o.y, r.y, i.y), QuadraticBezier(e, o.z, r.z, i.z)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
};
var SplineCurve = class extends Curve {
  constructor(e = []) {
    super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Vector2()) {
    const n = t, o = this.points, r = (o.length - 1) * e, i = Math.floor(r), a = r - i, s = o[0 === i ? i : i - 1], l = o[i], c = o[i > o.length - 2 ? o.length - 1 : i + 1], u = o[i > o.length - 3 ? o.length - 1 : i + 2];
    return n.set(CatmullRom(a, s.x, l.x, c.x, u.x), CatmullRom(a, s.y, l.y, c.y, u.y)), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const n2 = e.points[t];
      this.points.push(n2.clone());
    }
    return this;
  }
};
var CurvePath = class extends Curve {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new LineCurve(t, e));
  }
  getPoint(e, t) {
    const n = e * this.getLength(), o = this.getCurveLengths();
    let r = 0;
    for (; r < o.length; ) {
      if (o[r] >= n) {
        const e2 = o[r] - n, i = this.curves[r], a = i.getLength(), s = 0 === a ? 0 : 1 - e2 / a;
        return i.getPointAt(s, t);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, o = this.curves.length; n < o; n++) t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let o = 0, r = this.curves; o < r.length; o++) {
      const i = r[o], a = i.isEllipseCurve ? 2 * e : i.isLineCurve || i.isLineCurve3 ? 1 : i.isSplineCurve ? e * i.points.length : e, s = i.getPoints(a);
      for (let e2 = 0; e2 < s.length; e2++) {
        const o2 = s[e2];
        n && n.equals(o2) || (t.push(o2), n = o2);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const n2 = e.curves[t];
      this.curves.push(n2.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
};
var Path = class extends CurvePath {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Vector2(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new LineCurve(this.currentPoint.clone(), new Vector2(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, o) {
    const r = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(e, t), new Vector2(n, o));
    return this.curves.push(r), this.currentPoint.set(n, o), this;
  }
  bezierCurveTo(e, t, n, o, r, i) {
    const a = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(e, t), new Vector2(n, o), new Vector2(r, i));
    return this.curves.push(a), this.currentPoint.set(r, i), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new SplineCurve(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, o, r, i) {
    const a = this.currentPoint.x, s = this.currentPoint.y;
    return this.absarc(e + a, t + s, n, o, r, i), this;
  }
  absarc(e, t, n, o, r, i) {
    return this.absellipse(e, t, n, n, o, r, i), this;
  }
  ellipse(e, t, n, o, r, i, a, s) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absellipse(e + l, t + c, n, o, r, i, a, s), this;
  }
  absellipse(e, t, n, o, r, i, a, s) {
    const l = new EllipseCurve(e, t, n, o, r, i, a, s);
    if (this.curves.length > 0) {
      const e2 = l.getPoint(0);
      e2.equals(this.currentPoint) || this.lineTo(e2.x, e2.y);
    }
    this.curves.push(l);
    const c = l.getPoint(1);
    return this.currentPoint.copy(c), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
};
var LatheGeometry = class extends BufferGeometry {
  constructor(e = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], t = 12, n = 0, o = 2 * Math.PI) {
    super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: o }, t = Math.floor(t), o = clamp(o, 0, 2 * Math.PI);
    const r = [], i = [], a = [], s = [], l = [], c = 1 / t, u = new Vector3(), d = new Vector2(), h = new Vector3(), f = new Vector3(), p = new Vector3();
    let m = 0, g = 0;
    for (let t2 = 0; t2 <= e.length - 1; t2++) switch (t2) {
      case 0:
        m = e[t2 + 1].x - e[t2].x, g = e[t2 + 1].y - e[t2].y, h.x = 1 * g, h.y = -m, h.z = 0 * g, p.copy(h), h.normalize(), s.push(h.x, h.y, h.z);
        break;
      case e.length - 1:
        s.push(p.x, p.y, p.z);
        break;
      default:
        m = e[t2 + 1].x - e[t2].x, g = e[t2 + 1].y - e[t2].y, h.x = 1 * g, h.y = -m, h.z = 0 * g, f.copy(h), h.x += p.x, h.y += p.y, h.z += p.z, h.normalize(), s.push(h.x, h.y, h.z), p.copy(f);
    }
    for (let r2 = 0; r2 <= t; r2++) {
      const h2 = n + r2 * c * o, f2 = Math.sin(h2), p2 = Math.cos(h2);
      for (let n2 = 0; n2 <= e.length - 1; n2++) {
        u.x = e[n2].x * f2, u.y = e[n2].y, u.z = e[n2].x * p2, i.push(u.x, u.y, u.z), d.x = r2 / t, d.y = n2 / (e.length - 1), a.push(d.x, d.y);
        const o2 = s[3 * n2 + 0] * f2, c2 = s[3 * n2 + 1], h3 = s[3 * n2 + 0] * p2;
        l.push(o2, c2, h3);
      }
    }
    for (let n2 = 0; n2 < t; n2++) for (let t2 = 0; t2 < e.length - 1; t2++) {
      const o2 = t2 + n2 * e.length, i2 = o2, a2 = o2 + e.length, s2 = o2 + e.length + 1, l2 = o2 + 1;
      r.push(i2, a2, l2), r.push(s2, l2, a2);
    }
    this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(i, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)), this.setAttribute("normal", new Float32BufferAttribute(l, 3));
  }
};
var CapsuleGeometry = class extends LatheGeometry {
  constructor(e = 1, t = 1, n = 4, o = 8) {
    const r = new Path();
    r.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), r.absarc(0, t / 2, e, 0, 0.5 * Math.PI), super(r.getPoints(n), o), this.type = "CapsuleGeometry", this.parameters = { radius: e, height: t, capSegments: n, radialSegments: o };
  }
};
var CircleGeometry = class extends BufferGeometry {
  constructor(e = 1, t = 32, n = 0, o = 2 * Math.PI) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: o }, t = Math.max(3, t);
    const r = [], i = [], a = [], s = [], l = new Vector3(), c = new Vector2();
    i.push(0, 0, 0), a.push(0, 0, 1), s.push(0.5, 0.5);
    for (let r2 = 0, u = 3; r2 <= t; r2++, u += 3) {
      const d = n + r2 / t * o;
      l.x = e * Math.cos(d), l.y = e * Math.sin(d), i.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (i[u] / e + 1) / 2, c.y = (i[u + 1] / e + 1) / 2, s.push(c.x, c.y);
    }
    for (let e2 = 1; e2 <= t; e2++) r.push(e2, e2 + 1, 0);
    this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(i, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2));
  }
};
var CylinderGeometry = class extends BufferGeometry {
  constructor(e = 1, t = 1, n = 1, o = 32, r = 1, i = false, a = 0, s = 2 * Math.PI) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: o, heightSegments: r, openEnded: i, thetaStart: a, thetaLength: s };
    const l = this;
    o = Math.floor(o), r = Math.floor(r);
    const c = [], u = [], d = [], h = [];
    let f = 0;
    const p = [], m = n / 2;
    let g = 0;
    function _(n2) {
      const r2 = f, i2 = new Vector2(), p2 = new Vector3();
      let _2 = 0;
      const A = true === n2 ? e : t, v = true === n2 ? 1 : -1;
      for (let e2 = 1; e2 <= o; e2++) u.push(0, m * v, 0), d.push(0, v, 0), h.push(0.5, 0.5), f++;
      const x = f;
      for (let e2 = 0; e2 <= o; e2++) {
        const t2 = e2 / o * s + a, n3 = Math.cos(t2), r3 = Math.sin(t2);
        p2.x = A * r3, p2.y = m * v, p2.z = A * n3, u.push(p2.x, p2.y, p2.z), d.push(0, v, 0), i2.x = 0.5 * n3 + 0.5, i2.y = 0.5 * r3 * v + 0.5, h.push(i2.x, i2.y), f++;
      }
      for (let e2 = 0; e2 < o; e2++) {
        const t2 = r2 + e2, o2 = x + e2;
        true === n2 ? c.push(o2, o2 + 1, t2) : c.push(o2 + 1, o2, t2), _2 += 3;
      }
      l.addGroup(g, _2, true === n2 ? 1 : 2), g += _2;
    }
    !function() {
      const i2 = new Vector3(), _2 = new Vector3();
      let A = 0;
      const v = (t - e) / n;
      for (let l2 = 0; l2 <= r; l2++) {
        const c2 = [], g2 = l2 / r, A2 = g2 * (t - e) + e;
        for (let e2 = 0; e2 <= o; e2++) {
          const t2 = e2 / o, r2 = t2 * s + a, l3 = Math.sin(r2), p2 = Math.cos(r2);
          _2.x = A2 * l3, _2.y = -g2 * n + m, _2.z = A2 * p2, u.push(_2.x, _2.y, _2.z), i2.set(l3, v, p2).normalize(), d.push(i2.x, i2.y, i2.z), h.push(t2, 1 - g2), c2.push(f++);
        }
        p.push(c2);
      }
      for (let e2 = 0; e2 < o; e2++) for (let t2 = 0; t2 < r; t2++) {
        const n2 = p[t2][e2], o2 = p[t2 + 1][e2], r2 = p[t2 + 1][e2 + 1], i3 = p[t2][e2 + 1];
        c.push(n2, o2, i3), c.push(o2, r2, i3), A += 6;
      }
      l.addGroup(g, A, 0), g += A;
    }(), false === i && (e > 0 && _(true), t > 0 && _(false)), this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(d, 3)), this.setAttribute("uv", new Float32BufferAttribute(h, 2));
  }
};
var ConeGeometry = class extends CylinderGeometry {
  constructor(e = 1, t = 1, n = 32, o = 1, r = false, i = 0, a = 2 * Math.PI) {
    super(0, e, t, n, o, r, i, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: o, openEnded: r, thetaStart: i, thetaLength: a };
  }
};
var PolyhedronGeometry = class extends BufferGeometry {
  constructor(e = [], t = [], n = 1, o = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: o };
    const r = [], i = [];
    function a(e2, t2, n2, o2) {
      const r2 = o2 + 1, i2 = [];
      for (let o3 = 0; o3 <= r2; o3++) {
        i2[o3] = [];
        const a2 = e2.clone().lerp(n2, o3 / r2), s2 = t2.clone().lerp(n2, o3 / r2), l2 = r2 - o3;
        for (let e3 = 0; e3 <= l2; e3++) i2[o3][e3] = 0 === e3 && o3 === r2 ? a2 : a2.clone().lerp(s2, e3 / l2);
      }
      for (let e3 = 0; e3 < r2; e3++) for (let t3 = 0; t3 < 2 * (r2 - e3) - 1; t3++) {
        const n3 = Math.floor(t3 / 2);
        t3 % 2 == 0 ? (s(i2[e3][n3 + 1]), s(i2[e3 + 1][n3]), s(i2[e3][n3])) : (s(i2[e3][n3 + 1]), s(i2[e3 + 1][n3 + 1]), s(i2[e3 + 1][n3]));
      }
    }
    function s(e2) {
      r.push(e2.x, e2.y, e2.z);
    }
    function l(t2, n2) {
      const o2 = 3 * t2;
      n2.x = e[o2 + 0], n2.y = e[o2 + 1], n2.z = e[o2 + 2];
    }
    function c(e2, t2, n2, o2) {
      o2 < 0 && 1 === e2.x && (i[t2] = e2.x - 1), 0 === n2.x && 0 === n2.z && (i[t2] = o2 / 2 / Math.PI + 0.5);
    }
    function u(e2) {
      return Math.atan2(e2.z, -e2.x);
    }
    !function(e2) {
      const n2 = new Vector3(), o2 = new Vector3(), r2 = new Vector3();
      for (let i2 = 0; i2 < t.length; i2 += 3) l(t[i2 + 0], n2), l(t[i2 + 1], o2), l(t[i2 + 2], r2), a(n2, o2, r2, e2);
    }(o), function(e2) {
      const t2 = new Vector3();
      for (let n2 = 0; n2 < r.length; n2 += 3) t2.x = r[n2 + 0], t2.y = r[n2 + 1], t2.z = r[n2 + 2], t2.normalize().multiplyScalar(e2), r[n2 + 0] = t2.x, r[n2 + 1] = t2.y, r[n2 + 2] = t2.z;
    }(n), function() {
      const e2 = new Vector3();
      for (let n2 = 0; n2 < r.length; n2 += 3) {
        e2.x = r[n2 + 0], e2.y = r[n2 + 1], e2.z = r[n2 + 2];
        const o2 = u(e2) / 2 / Math.PI + 0.5, a2 = (t2 = e2, Math.atan2(-t2.y, Math.sqrt(t2.x * t2.x + t2.z * t2.z)) / Math.PI + 0.5);
        i.push(o2, 1 - a2);
      }
      var t2;
      (function() {
        const e3 = new Vector3(), t3 = new Vector3(), n2 = new Vector3(), o2 = new Vector3(), a2 = new Vector2(), s2 = new Vector2(), l2 = new Vector2();
        for (let d = 0, h = 0; d < r.length; d += 9, h += 6) {
          e3.set(r[d + 0], r[d + 1], r[d + 2]), t3.set(r[d + 3], r[d + 4], r[d + 5]), n2.set(r[d + 6], r[d + 7], r[d + 8]), a2.set(i[h + 0], i[h + 1]), s2.set(i[h + 2], i[h + 3]), l2.set(i[h + 4], i[h + 5]), o2.copy(e3).add(t3).add(n2).divideScalar(3);
          const f = u(o2);
          c(a2, h + 0, e3, f), c(s2, h + 2, t3, f), c(l2, h + 4, n2, f);
        }
      })(), function() {
        for (let e3 = 0; e3 < i.length; e3 += 6) {
          const t3 = i[e3 + 0], n2 = i[e3 + 2], o2 = i[e3 + 4], r2 = Math.max(t3, n2, o2), a2 = Math.min(t3, n2, o2);
          r2 > 0.9 && a2 < 0.1 && (t3 < 0.2 && (i[e3 + 0] += 1), n2 < 0.2 && (i[e3 + 2] += 1), o2 < 0.2 && (i[e3 + 4] += 1));
        }
      }();
    }(), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(r.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(i, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals();
  }
};
var DodecahedronGeometry = class extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, o = 1 / n;
    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -o, -n, 0, -o, n, 0, o, -n, 0, o, n, -o, -n, 0, -o, n, 0, o, -n, 0, o, n, 0, -n, 0, -o, n, 0, -o, -n, 0, o, n, 0, o], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t };
  }
};
var _v0 = new Vector3();
var _v1$2 = new Vector3();
var _normal = new Vector3();
var _triangle = new Triangle();
var EdgesGeometry = class extends BufferGeometry {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, null !== e) {
      const n = 4, o = Math.pow(10, n), r = Math.cos(DEG2RAD * t), i = e.getIndex(), a = e.getAttribute("position"), s = i ? i.count : a.count, l = [0, 0, 0], c = ["a", "b", "c"], u = new Array(3), d = {}, h = [];
      for (let e2 = 0; e2 < s; e2 += 3) {
        i ? (l[0] = i.getX(e2), l[1] = i.getX(e2 + 1), l[2] = i.getX(e2 + 2)) : (l[0] = e2, l[1] = e2 + 1, l[2] = e2 + 2);
        const { a: t2, b: n2, c: s2 } = _triangle;
        if (t2.fromBufferAttribute(a, l[0]), n2.fromBufferAttribute(a, l[1]), s2.fromBufferAttribute(a, l[2]), _triangle.getNormal(_normal), u[0] = `${Math.round(t2.x * o)},${Math.round(t2.y * o)},${Math.round(t2.z * o)}`, u[1] = `${Math.round(n2.x * o)},${Math.round(n2.y * o)},${Math.round(n2.z * o)}`, u[2] = `${Math.round(s2.x * o)},${Math.round(s2.y * o)},${Math.round(s2.z * o)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0]) for (let e3 = 0; e3 < 3; e3++) {
          const t3 = (e3 + 1) % 3, n3 = u[e3], o2 = u[t3], i2 = _triangle[c[e3]], a2 = _triangle[c[t3]], s3 = `${n3}_${o2}`, f = `${o2}_${n3}`;
          f in d && d[f] ? (_normal.dot(d[f].normal) <= r && (h.push(i2.x, i2.y, i2.z), h.push(a2.x, a2.y, a2.z)), d[f] = null) : s3 in d || (d[s3] = { index0: l[e3], index1: l[t3], normal: _normal.clone() });
        }
      }
      for (const e2 in d) if (d[e2]) {
        const { index0: t2, index1: n2 } = d[e2];
        _v0.fromBufferAttribute(a, t2), _v1$2.fromBufferAttribute(a, n2), h.push(_v0.x, _v0.y, _v0.z), h.push(_v1$2.x, _v1$2.y, _v1$2.z);
      }
      this.setAttribute("position", new Float32BufferAttribute(h, 3));
    }
  }
};
var Shape = class extends Path {
  constructor(e) {
    super(e), this.uuid = generateUUID(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, o = this.holes.length; n < o; n++) t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const n2 = e.holes[t];
      this.holes.push(n2.clone());
    }
    return this;
  }
};
var Earcut = { triangulate: function(e, t, n = 2) {
  const o = t && t.length, r = o ? t[0] * n : e.length;
  let i = linkedList(e, 0, r, n, true);
  const a = [];
  if (!i || i.next === i.prev) return a;
  let s, l, c, u, d, h, f;
  if (o && (i = eliminateHoles(e, t, i, n)), e.length > 80 * n) {
    s = c = e[0], l = u = e[1];
    for (let t2 = n; t2 < r; t2 += n) d = e[t2], h = e[t2 + 1], d < s && (s = d), h < l && (l = h), d > c && (c = d), h > u && (u = h);
    f = Math.max(c - s, u - l), f = 0 !== f ? 32767 / f : 0;
  }
  return earcutLinked(i, a, n, s, l, f, 0), a;
} };
function linkedList(e, t, n, o, r) {
  let i, a;
  if (r === signedArea(e, t, n, o) > 0) for (i = t; i < n; i += o) a = insertNode(i, e[i], e[i + 1], a);
  else for (i = n - o; i >= t; i -= o) a = insertNode(i, e[i], e[i + 1], a);
  return a && equals(a, a.next) && (removeNode(a), a = a.next), a;
}
function filterPoints(e, t) {
  if (!e) return e;
  t || (t = e);
  let n, o = e;
  do {
    if (n = false, o.steiner || !equals(o, o.next) && 0 !== area(o.prev, o, o.next)) o = o.next;
    else {
      if (removeNode(o), o = t = o.prev, o === o.next) break;
      n = true;
    }
  } while (n || o !== t);
  return t;
}
function earcutLinked(e, t, n, o, r, i, a) {
  if (!e) return;
  !a && i && indexCurve(e, o, r, i);
  let s, l, c = e;
  for (; e.prev !== e.next; ) if (s = e.prev, l = e.next, i ? isEarHashed(e, o, r, i) : isEar(e)) t.push(s.i / n | 0), t.push(e.i / n | 0), t.push(l.i / n | 0), removeNode(e), e = l.next, c = l.next;
  else if ((e = l) === c) {
    a ? 1 === a ? earcutLinked(e = cureLocalIntersections(filterPoints(e), t, n), t, n, o, r, i, 2) : 2 === a && splitEarcut(e, t, n, o, r, i) : earcutLinked(filterPoints(e), t, n, o, r, i, 1);
    break;
  }
}
function isEar(e) {
  const t = e.prev, n = e, o = e.next;
  if (area(t, n, o) >= 0) return false;
  const r = t.x, i = n.x, a = o.x, s = t.y, l = n.y, c = o.y, u = r < i ? r < a ? r : a : i < a ? i : a, d = s < l ? s < c ? s : c : l < c ? l : c, h = r > i ? r > a ? r : a : i > a ? i : a, f = s > l ? s > c ? s : c : l > c ? l : c;
  let p = o.next;
  for (; p !== t; ) {
    if (p.x >= u && p.x <= h && p.y >= d && p.y <= f && pointInTriangle(r, s, i, l, a, c, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(e, t, n, o) {
  const r = e.prev, i = e, a = e.next;
  if (area(r, i, a) >= 0) return false;
  const s = r.x, l = i.x, c = a.x, u = r.y, d = i.y, h = a.y, f = s < l ? s < c ? s : c : l < c ? l : c, p = u < d ? u < h ? u : h : d < h ? d : h, m = s > l ? s > c ? s : c : l > c ? l : c, g = u > d ? u > h ? u : h : d > h ? d : h, _ = zOrder(f, p, t, n, o), A = zOrder(m, g, t, n, o);
  let v = e.prevZ, x = e.nextZ;
  for (; v && v.z >= _ && x && x.z <= A; ) {
    if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== r && v !== a && pointInTriangle(s, u, l, d, c, h, v.x, v.y) && area(v.prev, v, v.next) >= 0) return false;
    if (v = v.prevZ, x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== r && x !== a && pointInTriangle(s, u, l, d, c, h, x.x, x.y) && area(x.prev, x, x.next) >= 0) return false;
    x = x.nextZ;
  }
  for (; v && v.z >= _; ) {
    if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== r && v !== a && pointInTriangle(s, u, l, d, c, h, v.x, v.y) && area(v.prev, v, v.next) >= 0) return false;
    v = v.prevZ;
  }
  for (; x && x.z <= A; ) {
    if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== r && x !== a && pointInTriangle(s, u, l, d, c, h, x.x, x.y) && area(x.prev, x, x.next) >= 0) return false;
    x = x.nextZ;
  }
  return true;
}
function cureLocalIntersections(e, t, n) {
  let o = e;
  do {
    const r = o.prev, i = o.next.next;
    !equals(r, i) && intersects(r, o, o.next, i) && locallyInside(r, i) && locallyInside(i, r) && (t.push(r.i / n | 0), t.push(o.i / n | 0), t.push(i.i / n | 0), removeNode(o), removeNode(o.next), o = e = i), o = o.next;
  } while (o !== e);
  return filterPoints(o);
}
function splitEarcut(e, t, n, o, r, i) {
  let a = e;
  do {
    let e2 = a.next.next;
    for (; e2 !== a.prev; ) {
      if (a.i !== e2.i && isValidDiagonal(a, e2)) {
        let s = splitPolygon(a, e2);
        return a = filterPoints(a, a.next), s = filterPoints(s, s.next), earcutLinked(a, t, n, o, r, i, 0), void earcutLinked(s, t, n, o, r, i, 0);
      }
      e2 = e2.next;
    }
    a = a.next;
  } while (a !== e);
}
function eliminateHoles(e, t, n, o) {
  const r = [];
  let i, a, s, l, c;
  for (i = 0, a = t.length; i < a; i++) s = t[i] * o, l = i < a - 1 ? t[i + 1] * o : e.length, c = linkedList(e, s, l, o, false), c === c.next && (c.steiner = true), r.push(getLeftmost(c));
  for (r.sort(compareX), i = 0; i < r.length; i++) n = eliminateHole(r[i], n);
  return n;
}
function compareX(e, t) {
  return e.x - t.x;
}
function eliminateHole(e, t) {
  const n = findHoleBridge(e, t);
  if (!n) return t;
  const o = splitPolygon(n, e);
  return filterPoints(o, o.next), filterPoints(n, n.next);
}
function findHoleBridge(e, t) {
  let n, o = t, r = -1 / 0;
  const i = e.x, a = e.y;
  do {
    if (a <= o.y && a >= o.next.y && o.next.y !== o.y) {
      const e2 = o.x + (a - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
      if (e2 <= i && e2 > r && (r = e2, n = o.x < o.next.x ? o : o.next, e2 === i)) return n;
    }
    o = o.next;
  } while (o !== t);
  if (!n) return null;
  const s = n, l = n.x, c = n.y;
  let u, d = 1 / 0;
  o = n;
  do {
    i >= o.x && o.x >= l && i !== o.x && pointInTriangle(a < c ? i : r, a, l, c, a < c ? r : i, a, o.x, o.y) && (u = Math.abs(a - o.y) / (i - o.x), locallyInside(o, e) && (u < d || u === d && (o.x > n.x || o.x === n.x && sectorContainsSector(n, o))) && (n = o, d = u)), o = o.next;
  } while (o !== s);
  return n;
}
function sectorContainsSector(e, t) {
  return area(e.prev, e, t.prev) < 0 && area(t.next, e, e.next) < 0;
}
function indexCurve(e, t, n, o) {
  let r = e;
  do {
    0 === r.z && (r.z = zOrder(r.x, r.y, t, n, o)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  } while (r !== e);
  r.prevZ.nextZ = null, r.prevZ = null, sortLinked(r);
}
function sortLinked(e) {
  let t, n, o, r, i, a, s, l, c = 1;
  do {
    for (n = e, e = null, i = null, a = 0; n; ) {
      for (a++, o = n, s = 0, t = 0; t < c && (s++, o = o.nextZ, o); t++) ;
      for (l = c; s > 0 || l > 0 && o; ) 0 !== s && (0 === l || !o || n.z <= o.z) ? (r = n, n = n.nextZ, s--) : (r = o, o = o.nextZ, l--), i ? i.nextZ = r : e = r, r.prevZ = i, i = r;
      n = o;
    }
    i.nextZ = null, c *= 2;
  } while (a > 1);
  return e;
}
function zOrder(e, t, n, o, r) {
  return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - o) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
}
function getLeftmost(e) {
  let t = e, n = e;
  do {
    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
  } while (t !== e);
  return n;
}
function pointInTriangle(e, t, n, o, r, i, a, s) {
  return (r - a) * (t - s) >= (e - a) * (i - s) && (e - a) * (o - s) >= (n - a) * (t - s) && (n - a) * (i - s) >= (r - a) * (o - s);
}
function isValidDiagonal(e, t) {
  return e.next.i !== t.i && e.prev.i !== t.i && !intersectsPolygon(e, t) && (locallyInside(e, t) && locallyInside(t, e) && middleInside(e, t) && (area(e.prev, e, t.prev) || area(e, t.prev, t)) || equals(e, t) && area(e.prev, e, e.next) > 0 && area(t.prev, t, t.next) > 0);
}
function area(e, t, n) {
  return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
}
function equals(e, t) {
  return e.x === t.x && e.y === t.y;
}
function intersects(e, t, n, o) {
  const r = sign(area(e, t, n)), i = sign(area(e, t, o)), a = sign(area(n, o, e)), s = sign(area(n, o, t));
  return r !== i && a !== s || (!(0 !== r || !onSegment(e, n, t)) || (!(0 !== i || !onSegment(e, o, t)) || (!(0 !== a || !onSegment(n, e, o)) || !(0 !== s || !onSegment(n, t, o)))));
}
function onSegment(e, t, n) {
  return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);
}
function sign(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}
function intersectsPolygon(e, t) {
  let n = e;
  do {
    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && intersects(n, n.next, e, t)) return true;
    n = n.next;
  } while (n !== e);
  return false;
}
function locallyInside(e, t) {
  return area(e.prev, e, e.next) < 0 ? area(e, t, e.next) >= 0 && area(e, e.prev, t) >= 0 : area(e, t, e.prev) < 0 || area(e, e.next, t) < 0;
}
function middleInside(e, t) {
  let n = e, o = false;
  const r = (e.x + t.x) / 2, i = (e.y + t.y) / 2;
  do {
    n.y > i != n.next.y > i && n.next.y !== n.y && r < (n.next.x - n.x) * (i - n.y) / (n.next.y - n.y) + n.x && (o = !o), n = n.next;
  } while (n !== e);
  return o;
}
function splitPolygon(e, t) {
  const n = new Node(e.i, e.x, e.y), o = new Node(t.i, t.x, t.y), r = e.next, i = t.prev;
  return e.next = t, t.prev = e, n.next = r, r.prev = n, o.next = n, n.prev = o, i.next = o, o.prev = i, o;
}
function insertNode(e, t, n, o) {
  const r = new Node(e, t, n);
  return o ? (r.next = o.next, r.prev = o, o.next.prev = r, o.next = r) : (r.prev = r, r.next = r), r;
}
function removeNode(e) {
  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function Node(e, t, n) {
  this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
function signedArea(e, t, n, o) {
  let r = 0;
  for (let i = t, a = n - o; i < n; i += o) r += (e[a] - e[i]) * (e[i + 1] + e[a + 1]), a = i;
  return r;
}
var ShapeUtils = class _ShapeUtils {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let o = t - 1, r = 0; r < t; o = r++) n += e[o].x * e[r].y - e[r].x * e[o].y;
    return 0.5 * n;
  }
  static isClockWise(e) {
    return _ShapeUtils.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], o = [], r = [];
    removeDupEndPts(e), addContour(n, e);
    let i = e.length;
    t.forEach(removeDupEndPts);
    for (let e2 = 0; e2 < t.length; e2++) o.push(i), i += t[e2].length, addContour(n, t[e2]);
    const a = Earcut.triangulate(n, o);
    for (let e2 = 0; e2 < a.length; e2 += 3) r.push(a.slice(e2, e2 + 3));
    return r;
  }
};
function removeDupEndPts(e) {
  const t = e.length;
  t > 2 && e[t - 1].equals(e[0]) && e.pop();
}
function addContour(e, t) {
  for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
}
var ExtrudeGeometry = class extends BufferGeometry {
  constructor(e = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
    const n = this, o = [], r = [];
    for (let t2 = 0, n2 = e.length; t2 < n2; t2++) {
      i(e[t2]);
    }
    function i(e2) {
      const i2 = [], a = void 0 !== t.curveSegments ? t.curveSegments : 12, s = void 0 !== t.steps ? t.steps : 1, l = void 0 !== t.depth ? t.depth : 1;
      let c = void 0 === t.bevelEnabled || t.bevelEnabled, u = void 0 !== t.bevelThickness ? t.bevelThickness : 0.2, d = void 0 !== t.bevelSize ? t.bevelSize : u - 0.1, h = void 0 !== t.bevelOffset ? t.bevelOffset : 0, f = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
      const p = t.extrudePath, m = void 0 !== t.UVGenerator ? t.UVGenerator : WorldUVGenerator;
      let g, _, A, v, x, y = false;
      p && (g = p.getSpacedPoints(s), y = true, c = false, _ = p.computeFrenetFrames(s, false), A = new Vector3(), v = new Vector3(), x = new Vector3()), c || (f = 0, u = 0, d = 0, h = 0);
      const b = e2.extractPoints(a);
      let C = b.shape;
      const S = b.holes;
      if (!ShapeUtils.isClockWise(C)) {
        C = C.reverse();
        for (let e3 = 0, t2 = S.length; e3 < t2; e3++) {
          const t3 = S[e3];
          ShapeUtils.isClockWise(t3) && (S[e3] = t3.reverse());
        }
      }
      const M = ShapeUtils.triangulateShape(C, S), E = C;
      for (let e3 = 0, t2 = S.length; e3 < t2; e3++) {
        const t3 = S[e3];
        C = C.concat(t3);
      }
      function T(e3, t2, n2) {
        return t2 || console.error("v3d.ExtrudeGeometry: vec does not exist"), t2.clone().multiplyScalar(n2).add(e3);
      }
      const I = C.length, w = M.length;
      function R(e3, t2, n2) {
        let o2, r2, i3;
        const a2 = e3.x - t2.x, s2 = e3.y - t2.y, l2 = n2.x - e3.x, c2 = n2.y - e3.y, u2 = a2 * a2 + s2 * s2, d2 = a2 * c2 - s2 * l2;
        if (Math.abs(d2) > Number.EPSILON) {
          const d3 = Math.sqrt(u2), h2 = Math.sqrt(l2 * l2 + c2 * c2), f2 = t2.x - s2 / d3, p2 = t2.y + a2 / d3, m2 = ((n2.x - c2 / h2 - f2) * c2 - (n2.y + l2 / h2 - p2) * l2) / (a2 * c2 - s2 * l2);
          o2 = f2 + a2 * m2 - e3.x, r2 = p2 + s2 * m2 - e3.y;
          const g2 = o2 * o2 + r2 * r2;
          if (g2 <= 2) return new Vector2(o2, r2);
          i3 = Math.sqrt(g2 / 2);
        } else {
          let e4 = false;
          a2 > Number.EPSILON ? l2 > Number.EPSILON && (e4 = true) : a2 < -Number.EPSILON ? l2 < -Number.EPSILON && (e4 = true) : Math.sign(s2) === Math.sign(c2) && (e4 = true), e4 ? (o2 = -s2, r2 = a2, i3 = Math.sqrt(u2)) : (o2 = a2, r2 = s2, i3 = Math.sqrt(u2 / 2));
        }
        return new Vector2(o2 / i3, r2 / i3);
      }
      const L = [];
      for (let e3 = 0, t2 = E.length, n2 = t2 - 1, o2 = e3 + 1; e3 < t2; e3++, n2++, o2++) n2 === t2 && (n2 = 0), o2 === t2 && (o2 = 0), L[e3] = R(E[e3], E[n2], E[o2]);
      const B = [];
      let P, N = L.concat();
      for (let e3 = 0, t2 = S.length; e3 < t2; e3++) {
        const t3 = S[e3];
        P = [];
        for (let e4 = 0, n2 = t3.length, o2 = n2 - 1, r2 = e4 + 1; e4 < n2; e4++, o2++, r2++) o2 === n2 && (o2 = 0), r2 === n2 && (r2 = 0), P[e4] = R(t3[e4], t3[o2], t3[r2]);
        B.push(P), N = N.concat(P);
      }
      for (let e3 = 0; e3 < f; e3++) {
        const t2 = e3 / f, n2 = u * Math.cos(t2 * Math.PI / 2), o2 = d * Math.sin(t2 * Math.PI / 2) + h;
        for (let e4 = 0, t3 = E.length; e4 < t3; e4++) {
          const t4 = T(E[e4], L[e4], o2);
          F(t4.x, t4.y, -n2);
        }
        for (let e4 = 0, t3 = S.length; e4 < t3; e4++) {
          const t4 = S[e4];
          P = B[e4];
          for (let e5 = 0, r2 = t4.length; e5 < r2; e5++) {
            const r3 = T(t4[e5], P[e5], o2);
            F(r3.x, r3.y, -n2);
          }
        }
      }
      const D = d + h;
      for (let e3 = 0; e3 < I; e3++) {
        const t2 = c ? T(C[e3], N[e3], D) : C[e3];
        y ? (v.copy(_.normals[0]).multiplyScalar(t2.x), A.copy(_.binormals[0]).multiplyScalar(t2.y), x.copy(g[0]).add(v).add(A), F(x.x, x.y, x.z)) : F(t2.x, t2.y, 0);
      }
      for (let e3 = 1; e3 <= s; e3++) for (let t2 = 0; t2 < I; t2++) {
        const n2 = c ? T(C[t2], N[t2], D) : C[t2];
        y ? (v.copy(_.normals[e3]).multiplyScalar(n2.x), A.copy(_.binormals[e3]).multiplyScalar(n2.y), x.copy(g[e3]).add(v).add(A), F(x.x, x.y, x.z)) : F(n2.x, n2.y, l / s * e3);
      }
      for (let e3 = f - 1; e3 >= 0; e3--) {
        const t2 = e3 / f, n2 = u * Math.cos(t2 * Math.PI / 2), o2 = d * Math.sin(t2 * Math.PI / 2) + h;
        for (let e4 = 0, t3 = E.length; e4 < t3; e4++) {
          const t4 = T(E[e4], L[e4], o2);
          F(t4.x, t4.y, l + n2);
        }
        for (let e4 = 0, t3 = S.length; e4 < t3; e4++) {
          const t4 = S[e4];
          P = B[e4];
          for (let e5 = 0, r2 = t4.length; e5 < r2; e5++) {
            const r3 = T(t4[e5], P[e5], o2);
            y ? F(r3.x, r3.y + g[s - 1].y, g[s - 1].x + n2) : F(r3.x, r3.y, l + n2);
          }
        }
      }
      function O(e3, t2) {
        let n2 = e3.length;
        for (; --n2 >= 0; ) {
          const o2 = n2;
          let r2 = n2 - 1;
          r2 < 0 && (r2 = e3.length - 1);
          for (let e4 = 0, n3 = s + 2 * f; e4 < n3; e4++) {
            const n4 = I * e4, i3 = I * (e4 + 1);
            U(t2 + o2 + n4, t2 + r2 + n4, t2 + r2 + i3, t2 + o2 + i3);
          }
        }
      }
      function F(e3, t2, n2) {
        i2.push(e3), i2.push(t2), i2.push(n2);
      }
      function V(e3, t2, r2) {
        G(e3), G(t2), G(r2);
        const i3 = o.length / 3, a2 = m.generateTopUV(n, o, i3 - 3, i3 - 2, i3 - 1);
        z(a2[0]), z(a2[1]), z(a2[2]);
      }
      function U(e3, t2, r2, i3) {
        G(e3), G(t2), G(i3), G(t2), G(r2), G(i3);
        const a2 = o.length / 3, s2 = m.generateSideWallUV(n, o, a2 - 6, a2 - 3, a2 - 2, a2 - 1);
        z(s2[0]), z(s2[1]), z(s2[3]), z(s2[1]), z(s2[2]), z(s2[3]);
      }
      function G(e3) {
        o.push(i2[3 * e3 + 0]), o.push(i2[3 * e3 + 1]), o.push(i2[3 * e3 + 2]);
      }
      function z(e3) {
        r.push(e3.x), r.push(e3.y);
      }
      !function() {
        const e3 = o.length / 3;
        if (c) {
          let e4 = 0, t2 = I * e4;
          for (let e5 = 0; e5 < w; e5++) {
            const n2 = M[e5];
            V(n2[2] + t2, n2[1] + t2, n2[0] + t2);
          }
          e4 = s + 2 * f, t2 = I * e4;
          for (let e5 = 0; e5 < w; e5++) {
            const n2 = M[e5];
            V(n2[0] + t2, n2[1] + t2, n2[2] + t2);
          }
        } else {
          for (let e4 = 0; e4 < w; e4++) {
            const t2 = M[e4];
            V(t2[2], t2[1], t2[0]);
          }
          for (let e4 = 0; e4 < w; e4++) {
            const t2 = M[e4];
            V(t2[0] + I * s, t2[1] + I * s, t2[2] + I * s);
          }
        }
        n.addGroup(e3, o.length / 3 - e3, 0);
      }(), function() {
        const e3 = o.length / 3;
        let t2 = 0;
        O(E, t2), t2 += E.length;
        for (let e4 = 0, n2 = S.length; e4 < n2; e4++) {
          const n3 = S[e4];
          O(n3, t2), t2 += n3.length;
        }
        n.addGroup(e3, o.length / 3 - e3, 1);
      }();
    }
    this.setAttribute("position", new Float32BufferAttribute(o, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.computeVertexNormals();
  }
};
var WorldUVGenerator = { generateTopUV: function(e, t, n, o, r) {
  const i = t[3 * n], a = t[3 * n + 1], s = t[3 * o], l = t[3 * o + 1], c = t[3 * r], u = t[3 * r + 1];
  return [new Vector2(i, a), new Vector2(s, l), new Vector2(c, u)];
}, generateSideWallUV: function(e, t, n, o, r, i) {
  const a = t[3 * n], s = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * o], u = t[3 * o + 1], d = t[3 * o + 2], h = t[3 * r], f = t[3 * r + 1], p = t[3 * r + 2], m = t[3 * i], g = t[3 * i + 1], _ = t[3 * i + 2];
  return Math.abs(s - u) < Math.abs(a - c) ? [new Vector2(a, 1 - l), new Vector2(c, 1 - d), new Vector2(h, 1 - p), new Vector2(m, 1 - _)] : [new Vector2(s, 1 - l), new Vector2(u, 1 - d), new Vector2(f, 1 - p), new Vector2(g, 1 - _)];
} };
var IcosahedronGeometry = class extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2;
    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t };
  }
};
var OctahedronGeometry = class extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t };
  }
};
var RingGeometry = class extends BufferGeometry {
  constructor(e = 0.5, t = 1, n = 32, o = 1, r = 0, i = 2 * Math.PI) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: o, thetaStart: r, thetaLength: i }, n = Math.max(3, n);
    const a = [], s = [], l = [], c = [];
    let u = e;
    const d = (t - e) / (o = Math.max(1, o)), h = new Vector3(), f = new Vector2();
    for (let e2 = 0; e2 <= o; e2++) {
      for (let e3 = 0; e3 <= n; e3++) {
        const o2 = r + e3 / n * i;
        h.x = u * Math.cos(o2), h.y = u * Math.sin(o2), s.push(h.x, h.y, h.z), l.push(0, 0, 1), f.x = (h.x / t + 1) / 2, f.y = (h.y / t + 1) / 2, c.push(f.x, f.y);
      }
      u += d;
    }
    for (let e2 = 0; e2 < o; e2++) {
      const t2 = e2 * (n + 1);
      for (let e3 = 0; e3 < n; e3++) {
        const o2 = e3 + t2, r2 = o2, i2 = o2 + n + 1, s2 = o2 + n + 2, l2 = o2 + 1;
        a.push(r2, i2, l2), a.push(i2, s2, l2);
      }
    }
    this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
  }
};
var ShapeGeometry = class extends BufferGeometry {
  constructor(e = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
    const n = [], o = [], r = [], i = [];
    let a = 0, s = 0;
    if (false === Array.isArray(e)) l(e);
    else for (let t2 = 0; t2 < e.length; t2++) l(e[t2]), this.addGroup(a, s, t2), a += s, s = 0;
    function l(e2) {
      const a2 = o.length / 3, l2 = e2.extractPoints(t);
      let c = l2.shape;
      const u = l2.holes;
      false === ShapeUtils.isClockWise(c) && (c = c.reverse());
      for (let e3 = 0, t2 = u.length; e3 < t2; e3++) {
        const t3 = u[e3];
        true === ShapeUtils.isClockWise(t3) && (u[e3] = t3.reverse());
      }
      const d = ShapeUtils.triangulateShape(c, u);
      for (let e3 = 0, t2 = u.length; e3 < t2; e3++) {
        const t3 = u[e3];
        c = c.concat(t3);
      }
      for (let e3 = 0, t2 = c.length; e3 < t2; e3++) {
        const t3 = c[e3];
        o.push(t3.x, t3.y, 0), r.push(0, 0, 1), i.push(t3.x, t3.y);
      }
      for (let e3 = 0, t2 = d.length; e3 < t2; e3++) {
        const t3 = d[e3], o2 = t3[0] + a2, r2 = t3[1] + a2, i2 = t3[2] + a2;
        n.push(o2, r2, i2), s += 3;
      }
    }
    this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(o, 3)), this.setAttribute("normal", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(i, 2));
  }
};
var SphereGeometry = class extends BufferGeometry {
  constructor(e = 1, t = 32, n = 16, o = 0, r = 2 * Math.PI, i = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: o, phiLength: r, thetaStart: i, thetaLength: a }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const s = Math.min(i + a, Math.PI);
    let l = 0;
    const c = [], u = new Vector3(), d = new Vector3(), h = [], f = [], p = [], m = [];
    for (let h2 = 0; h2 <= n; h2++) {
      const g = [], _ = h2 / n;
      let A = 0;
      0 == h2 && 0 == i ? A = 0.5 / t : h2 == n && s == Math.PI && (A = -0.5 / t);
      for (let n2 = 0; n2 <= t; n2++) {
        const s2 = n2 / t;
        u.x = -e * Math.cos(o + s2 * r) * Math.sin(i + _ * a), u.y = e * Math.cos(i + _ * a), u.z = e * Math.sin(o + s2 * r) * Math.sin(i + _ * a), f.push(u.x, u.y, u.z), d.copy(u).normalize(), p.push(d.x, d.y, d.z), m.push(s2 + A, 1 - _), g.push(l++);
      }
      c.push(g);
    }
    for (let e2 = 0; e2 < n; e2++) for (let o2 = 0; o2 < t; o2++) {
      const t2 = c[e2][o2 + 1], r2 = c[e2][o2], a2 = c[e2 + 1][o2], l2 = c[e2 + 1][o2 + 1];
      (0 !== e2 || i > 0) && h.push(t2, r2, l2), (e2 !== n - 1 || s < Math.PI) && h.push(r2, a2, l2);
    }
    this.setIndex(h), this.setAttribute("position", new Float32BufferAttribute(f, 3)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2));
  }
};
var TetrahedronGeometry = class extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t };
  }
};
var TorusGeometry = class extends BufferGeometry {
  constructor(e = 1, t = 0.4, n = 12, o = 48, r = 2 * Math.PI) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: o, arc: r }, n = Math.floor(n), o = Math.floor(o);
    const i = [], a = [], s = [], l = [], c = new Vector3(), u = new Vector3(), d = new Vector3();
    for (let i2 = 0; i2 <= n; i2++) for (let h = 0; h <= o; h++) {
      const f = h / o * r, p = i2 / n * Math.PI * 2;
      u.x = (e + t * Math.cos(p)) * Math.cos(f), u.y = (e + t * Math.cos(p)) * Math.sin(f), u.z = t * Math.sin(p), a.push(u.x, u.y, u.z), c.x = e * Math.cos(f), c.y = e * Math.sin(f), d.subVectors(u, c).normalize(), s.push(d.x, d.y, d.z), l.push(h / o), l.push(i2 / n);
    }
    for (let e2 = 1; e2 <= n; e2++) for (let t2 = 1; t2 <= o; t2++) {
      const n2 = (o + 1) * e2 + t2 - 1, r2 = (o + 1) * (e2 - 1) + t2 - 1, a2 = (o + 1) * (e2 - 1) + t2, s2 = (o + 1) * e2 + t2;
      i.push(n2, r2, s2), i.push(r2, a2, s2);
    }
    this.setIndex(i), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2));
  }
};
var TorusKnotGeometry = class _TorusKnotGeometry extends BufferGeometry {
  constructor(e = 1, t = 0.4, n = 64, o = 8, r = 2, i = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: o, p: r, q: i }, n = Math.floor(n), o = Math.floor(o);
    const a = [], s = [], l = [], c = [], u = new Vector3(), d = new Vector3(), h = new Vector3(), f = new Vector3(), p = new Vector3(), m = new Vector3(), g = new Vector3();
    for (let a2 = 0; a2 <= n; ++a2) {
      const A = a2 / n * r * Math.PI * 2;
      _(A, r, i, e, h), _(A + 0.01, r, i, e, f), m.subVectors(f, h), g.addVectors(f, h), p.crossVectors(m, g), g.crossVectors(p, m), p.normalize(), g.normalize();
      for (let e2 = 0; e2 <= o; ++e2) {
        const r2 = e2 / o * Math.PI * 2, i2 = -t * Math.cos(r2), f2 = t * Math.sin(r2);
        u.x = h.x + (i2 * g.x + f2 * p.x), u.y = h.y + (i2 * g.y + f2 * p.y), u.z = h.z + (i2 * g.z + f2 * p.z), s.push(u.x, u.y, u.z), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(a2 / n), c.push(e2 / o);
      }
    }
    for (let e2 = 1; e2 <= n; e2++) for (let t2 = 1; t2 <= o; t2++) {
      const n2 = (o + 1) * (e2 - 1) + (t2 - 1), r2 = (o + 1) * e2 + (t2 - 1), i2 = (o + 1) * e2 + t2, s2 = (o + 1) * (e2 - 1) + t2;
      a.push(n2, r2, s2), a.push(r2, i2, s2);
    }
    function _(e2, t2, n2, o2, r2) {
      const i2 = Math.cos(e2), a2 = Math.sin(e2), s2 = n2 / t2 * e2, l2 = Math.cos(s2);
      r2.x = o2 * (2 + l2) * 0.5 * i2, r2.y = o2 * (2 + l2) * a2 * 0.5, r2.z = o2 * Math.sin(s2) * 0.5;
    }
    this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
  }
  static fromJSON(e) {
    return new _TorusKnotGeometry(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
};
var TubeGeometry = class extends BufferGeometry {
  constructor(e = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), t = 64, n = 1, o = 8, r = false) {
    super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: o, closed: r };
    const i = e.computeFrenetFrames(t, r);
    this.tangents = i.tangents, this.normals = i.normals, this.binormals = i.binormals;
    const a = new Vector3(), s = new Vector3(), l = new Vector2();
    let c = new Vector3();
    const u = [], d = [], h = [], f = [];
    function p(r2) {
      c = e.getPointAt(r2 / t, c);
      const l2 = i.normals[r2], h2 = i.binormals[r2];
      for (let e2 = 0; e2 <= o; e2++) {
        const t2 = e2 / o * Math.PI * 2, r3 = Math.sin(t2), i2 = -Math.cos(t2);
        s.x = i2 * l2.x + r3 * h2.x, s.y = i2 * l2.y + r3 * h2.y, s.z = i2 * l2.z + r3 * h2.z, s.normalize(), d.push(s.x, s.y, s.z), a.x = c.x + n * s.x, a.y = c.y + n * s.y, a.z = c.z + n * s.z, u.push(a.x, a.y, a.z);
      }
    }
    !function() {
      for (let e2 = 0; e2 < t; e2++) p(e2);
      p(false === r ? t : 0), function() {
        for (let e2 = 0; e2 <= t; e2++) for (let n2 = 0; n2 <= o; n2++) l.x = e2 / t, l.y = n2 / o, h.push(l.x, l.y);
      }(), function() {
        for (let e2 = 1; e2 <= t; e2++) for (let t2 = 1; t2 <= o; t2++) {
          const n2 = (o + 1) * (e2 - 1) + (t2 - 1), r2 = (o + 1) * e2 + (t2 - 1), i2 = (o + 1) * e2 + t2, a2 = (o + 1) * (e2 - 1) + t2;
          f.push(n2, r2, a2), f.push(r2, i2, a2);
        }
      }();
    }(), this.setIndex(f), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(d, 3)), this.setAttribute("uv", new Float32BufferAttribute(h, 2));
  }
};
var WireframeGeometry = class extends BufferGeometry {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, null !== e) {
      const t = [], n = /* @__PURE__ */ new Set(), o = new Vector3(), r = new Vector3();
      if (null !== e.index) {
        const i = e.attributes.position, a = e.index;
        let s = e.groups;
        0 === s.length && (s = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let e2 = 0, l = s.length; e2 < l; ++e2) {
          const l2 = s[e2], c = l2.start;
          for (let e3 = c, s2 = c + l2.count; e3 < s2; e3 += 3) for (let s3 = 0; s3 < 3; s3++) {
            const l3 = a.getX(e3 + s3), c2 = a.getX(e3 + (s3 + 1) % 3);
            o.fromBufferAttribute(i, l3), r.fromBufferAttribute(i, c2), true === isUniqueEdge(o, r, n) && (t.push(o.x, o.y, o.z), t.push(r.x, r.y, r.z));
          }
        }
      } else {
        const i = e.attributes.position;
        for (let e2 = 0, a = i.count / 3; e2 < a; e2++) for (let a2 = 0; a2 < 3; a2++) {
          const s = 3 * e2 + a2, l = 3 * e2 + (a2 + 1) % 3;
          o.fromBufferAttribute(i, s), r.fromBufferAttribute(i, l), true === isUniqueEdge(o, r, n) && (t.push(o.x, o.y, o.z), t.push(r.x, r.y, r.z));
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(t, 3));
    }
  }
};
function isUniqueEdge(e, t, n) {
  const o = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`, r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
  return true !== n.has(o) && true !== n.has(r) && (n.add(o), n.add(r), true);
}
var TeapotGeometry = class extends BufferGeometry {
  constructor(e = 50, t = 10, n = true, o = true, r = true, i = true, a = true) {
    const s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 3, 16, 17, 18, 7, 19, 20, 21, 11, 22, 23, 24, 15, 25, 26, 27, 18, 28, 29, 30, 21, 31, 32, 33, 24, 34, 35, 36, 27, 37, 38, 39, 30, 40, 41, 0, 33, 42, 43, 4, 36, 44, 45, 8, 39, 46, 47, 12, 12, 13, 14, 15, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 15, 25, 26, 27, 51, 60, 61, 62, 55, 63, 64, 65, 59, 66, 67, 68, 27, 37, 38, 39, 62, 69, 70, 71, 65, 72, 73, 74, 68, 75, 76, 77, 39, 46, 47, 12, 71, 78, 79, 48, 74, 80, 81, 52, 77, 82, 83, 56, 56, 57, 58, 59, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 59, 66, 67, 68, 87, 96, 97, 98, 91, 99, 100, 101, 95, 102, 103, 104, 68, 75, 76, 77, 98, 105, 106, 107, 101, 108, 109, 110, 104, 111, 112, 113, 77, 82, 83, 56, 107, 114, 115, 84, 110, 116, 117, 88, 113, 118, 119, 92, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 123, 136, 137, 120, 127, 138, 139, 124, 131, 140, 141, 128, 135, 142, 143, 132, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 68, 152, 153, 154, 135, 142, 143, 132, 147, 155, 156, 144, 151, 157, 158, 148, 154, 159, 160, 68, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 164, 177, 178, 161, 168, 179, 180, 165, 172, 181, 182, 169, 176, 183, 184, 173, 173, 174, 175, 176, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 176, 183, 184, 173, 188, 197, 198, 185, 192, 199, 200, 189, 196, 201, 202, 193, 203, 203, 203, 203, 204, 205, 206, 207, 208, 208, 208, 208, 209, 210, 211, 212, 203, 203, 203, 203, 207, 213, 214, 215, 208, 208, 208, 208, 212, 216, 217, 218, 203, 203, 203, 203, 215, 219, 220, 221, 208, 208, 208, 208, 218, 222, 223, 224, 203, 203, 203, 203, 221, 225, 226, 204, 208, 208, 208, 208, 224, 227, 228, 209, 209, 210, 211, 212, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 212, 216, 217, 218, 232, 241, 242, 243, 236, 244, 245, 246, 240, 247, 248, 249, 218, 222, 223, 224, 243, 250, 251, 252, 246, 253, 254, 255, 249, 256, 257, 258, 224, 227, 228, 209, 252, 259, 260, 229, 255, 261, 262, 233, 258, 263, 264, 237, 265, 265, 265, 265, 266, 267, 268, 269, 270, 271, 272, 273, 92, 119, 118, 113, 265, 265, 265, 265, 269, 274, 275, 276, 273, 277, 278, 279, 113, 112, 111, 104, 265, 265, 265, 265, 276, 280, 281, 282, 279, 283, 284, 285, 104, 103, 102, 95, 265, 265, 265, 265, 282, 286, 287, 266, 285, 288, 289, 270, 95, 94, 93, 92], l = [1.4, 0, 2.4, 1.4, -0.784, 2.4, 0.784, -1.4, 2.4, 0, -1.4, 2.4, 1.3375, 0, 2.53125, 1.3375, -0.749, 2.53125, 0.749, -1.3375, 2.53125, 0, -1.3375, 2.53125, 1.4375, 0, 2.53125, 1.4375, -0.805, 2.53125, 0.805, -1.4375, 2.53125, 0, -1.4375, 2.53125, 1.5, 0, 2.4, 1.5, -0.84, 2.4, 0.84, -1.5, 2.4, 0, -1.5, 2.4, -0.784, -1.4, 2.4, -1.4, -0.784, 2.4, -1.4, 0, 2.4, -0.749, -1.3375, 2.53125, -1.3375, -0.749, 2.53125, -1.3375, 0, 2.53125, -0.805, -1.4375, 2.53125, -1.4375, -0.805, 2.53125, -1.4375, 0, 2.53125, -0.84, -1.5, 2.4, -1.5, -0.84, 2.4, -1.5, 0, 2.4, -1.4, 0.784, 2.4, -0.784, 1.4, 2.4, 0, 1.4, 2.4, -1.3375, 0.749, 2.53125, -0.749, 1.3375, 2.53125, 0, 1.3375, 2.53125, -1.4375, 0.805, 2.53125, -0.805, 1.4375, 2.53125, 0, 1.4375, 2.53125, -1.5, 0.84, 2.4, -0.84, 1.5, 2.4, 0, 1.5, 2.4, 0.784, 1.4, 2.4, 1.4, 0.784, 2.4, 0.749, 1.3375, 2.53125, 1.3375, 0.749, 2.53125, 0.805, 1.4375, 2.53125, 1.4375, 0.805, 2.53125, 0.84, 1.5, 2.4, 1.5, 0.84, 2.4, 1.75, 0, 1.875, 1.75, -0.98, 1.875, 0.98, -1.75, 1.875, 0, -1.75, 1.875, 2, 0, 1.35, 2, -1.12, 1.35, 1.12, -2, 1.35, 0, -2, 1.35, 2, 0, 0.9, 2, -1.12, 0.9, 1.12, -2, 0.9, 0, -2, 0.9, -0.98, -1.75, 1.875, -1.75, -0.98, 1.875, -1.75, 0, 1.875, -1.12, -2, 1.35, -2, -1.12, 1.35, -2, 0, 1.35, -1.12, -2, 0.9, -2, -1.12, 0.9, -2, 0, 0.9, -1.75, 0.98, 1.875, -0.98, 1.75, 1.875, 0, 1.75, 1.875, -2, 1.12, 1.35, -1.12, 2, 1.35, 0, 2, 1.35, -2, 1.12, 0.9, -1.12, 2, 0.9, 0, 2, 0.9, 0.98, 1.75, 1.875, 1.75, 0.98, 1.875, 1.12, 2, 1.35, 2, 1.12, 1.35, 1.12, 2, 0.9, 2, 1.12, 0.9, 2, 0, 0.45, 2, -1.12, 0.45, 1.12, -2, 0.45, 0, -2, 0.45, 1.5, 0, 0.225, 1.5, -0.84, 0.225, 0.84, -1.5, 0.225, 0, -1.5, 0.225, 1.5, 0, 0.15, 1.5, -0.84, 0.15, 0.84, -1.5, 0.15, 0, -1.5, 0.15, -1.12, -2, 0.45, -2, -1.12, 0.45, -2, 0, 0.45, -0.84, -1.5, 0.225, -1.5, -0.84, 0.225, -1.5, 0, 0.225, -0.84, -1.5, 0.15, -1.5, -0.84, 0.15, -1.5, 0, 0.15, -2, 1.12, 0.45, -1.12, 2, 0.45, 0, 2, 0.45, -1.5, 0.84, 0.225, -0.84, 1.5, 0.225, 0, 1.5, 0.225, -1.5, 0.84, 0.15, -0.84, 1.5, 0.15, 0, 1.5, 0.15, 1.12, 2, 0.45, 2, 1.12, 0.45, 0.84, 1.5, 0.225, 1.5, 0.84, 0.225, 0.84, 1.5, 0.15, 1.5, 0.84, 0.15, -1.6, 0, 2.025, -1.6, -0.3, 2.025, -1.5, -0.3, 2.25, -1.5, 0, 2.25, -2.3, 0, 2.025, -2.3, -0.3, 2.025, -2.5, -0.3, 2.25, -2.5, 0, 2.25, -2.7, 0, 2.025, -2.7, -0.3, 2.025, -3, -0.3, 2.25, -3, 0, 2.25, -2.7, 0, 1.8, -2.7, -0.3, 1.8, -3, -0.3, 1.8, -3, 0, 1.8, -1.5, 0.3, 2.25, -1.6, 0.3, 2.025, -2.5, 0.3, 2.25, -2.3, 0.3, 2.025, -3, 0.3, 2.25, -2.7, 0.3, 2.025, -3, 0.3, 1.8, -2.7, 0.3, 1.8, -2.7, 0, 1.575, -2.7, -0.3, 1.575, -3, -0.3, 1.35, -3, 0, 1.35, -2.5, 0, 1.125, -2.5, -0.3, 1.125, -2.65, -0.3, 0.9375, -2.65, 0, 0.9375, -2, -0.3, 0.9, -1.9, -0.3, 0.6, -1.9, 0, 0.6, -3, 0.3, 1.35, -2.7, 0.3, 1.575, -2.65, 0.3, 0.9375, -2.5, 0.3, 1.125, -1.9, 0.3, 0.6, -2, 0.3, 0.9, 1.7, 0, 1.425, 1.7, -0.66, 1.425, 1.7, -0.66, 0.6, 1.7, 0, 0.6, 2.6, 0, 1.425, 2.6, -0.66, 1.425, 3.1, -0.66, 0.825, 3.1, 0, 0.825, 2.3, 0, 2.1, 2.3, -0.25, 2.1, 2.4, -0.25, 2.025, 2.4, 0, 2.025, 2.7, 0, 2.4, 2.7, -0.25, 2.4, 3.3, -0.25, 2.4, 3.3, 0, 2.4, 1.7, 0.66, 0.6, 1.7, 0.66, 1.425, 3.1, 0.66, 0.825, 2.6, 0.66, 1.425, 2.4, 0.25, 2.025, 2.3, 0.25, 2.1, 3.3, 0.25, 2.4, 2.7, 0.25, 2.4, 2.8, 0, 2.475, 2.8, -0.25, 2.475, 3.525, -0.25, 2.49375, 3.525, 0, 2.49375, 2.9, 0, 2.475, 2.9, -0.15, 2.475, 3.45, -0.15, 2.5125, 3.45, 0, 2.5125, 2.8, 0, 2.4, 2.8, -0.15, 2.4, 3.2, -0.15, 2.4, 3.2, 0, 2.4, 3.525, 0.25, 2.49375, 2.8, 0.25, 2.475, 3.45, 0.15, 2.5125, 2.9, 0.15, 2.475, 3.2, 0.15, 2.4, 2.8, 0.15, 2.4, 0, 0, 3.15, 0.8, 0, 3.15, 0.8, -0.45, 3.15, 0.45, -0.8, 3.15, 0, -0.8, 3.15, 0, 0, 2.85, 0.2, 0, 2.7, 0.2, -0.112, 2.7, 0.112, -0.2, 2.7, 0, -0.2, 2.7, -0.45, -0.8, 3.15, -0.8, -0.45, 3.15, -0.8, 0, 3.15, -0.112, -0.2, 2.7, -0.2, -0.112, 2.7, -0.2, 0, 2.7, -0.8, 0.45, 3.15, -0.45, 0.8, 3.15, 0, 0.8, 3.15, -0.2, 0.112, 2.7, -0.112, 0.2, 2.7, 0, 0.2, 2.7, 0.45, 0.8, 3.15, 0.8, 0.45, 3.15, 0.112, 0.2, 2.7, 0.2, 0.112, 2.7, 0.4, 0, 2.55, 0.4, -0.224, 2.55, 0.224, -0.4, 2.55, 0, -0.4, 2.55, 1.3, 0, 2.55, 1.3, -0.728, 2.55, 0.728, -1.3, 2.55, 0, -1.3, 2.55, 1.3, 0, 2.4, 1.3, -0.728, 2.4, 0.728, -1.3, 2.4, 0, -1.3, 2.4, -0.224, -0.4, 2.55, -0.4, -0.224, 2.55, -0.4, 0, 2.55, -0.728, -1.3, 2.55, -1.3, -0.728, 2.55, -1.3, 0, 2.55, -0.728, -1.3, 2.4, -1.3, -0.728, 2.4, -1.3, 0, 2.4, -0.4, 0.224, 2.55, -0.224, 0.4, 2.55, 0, 0.4, 2.55, -1.3, 0.728, 2.55, -0.728, 1.3, 2.55, 0, 1.3, 2.55, -1.3, 0.728, 2.4, -0.728, 1.3, 2.4, 0, 1.3, 2.4, 0.224, 0.4, 2.55, 0.4, 0.224, 2.55, 0.728, 1.3, 2.55, 1.3, 0.728, 2.55, 0.728, 1.3, 2.4, 1.3, 0.728, 2.4, 0, 0, 0, 1.425, 0, 0, 1.425, 0.798, 0, 0.798, 1.425, 0, 0, 1.425, 0, 1.5, 0, 0.075, 1.5, 0.84, 0.075, 0.84, 1.5, 0.075, 0, 1.5, 0.075, -0.798, 1.425, 0, -1.425, 0.798, 0, -1.425, 0, 0, -0.84, 1.5, 0.075, -1.5, 0.84, 0.075, -1.5, 0, 0.075, -1.425, -0.798, 0, -0.798, -1.425, 0, 0, -1.425, 0, -1.5, -0.84, 0.075, -0.84, -1.5, 0.075, 0, -1.5, 0.075, 0.798, -1.425, 0, 1.425, -0.798, 0, 0.84, -1.5, 0.075, 1.5, -0.84, 0.075];
    super(), t = Math.max(2, Math.floor(t));
    const c = 3.15 * (a ? 1 : 1.3) / 2, u = e / c;
    let d = n ? (8 * t - 4) * t : 0;
    d += o ? (16 * t - 4) * t : 0, d += r ? 40 * t * t : 0;
    const h = new Uint32Array(3 * d);
    let f = n ? 4 : 0;
    f += o ? 8 : 0, f += r ? 20 : 0, f *= (t + 1) * (t + 1);
    const p = new Float32Array(3 * f), m = new Float32Array(3 * f), g = new Float32Array(2 * f), _ = new Matrix4();
    _.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);
    const A = [], v = [], x = [], y = [], b = [], C = [], S = [], M = [], E = [], T = new Vector3();
    let I, w, R, L, B = 0, P = 0;
    const N = new Vector3(), D = new Matrix4(), O = new Matrix4(), F = new Vector4(), V = new Vector4(), U = new Vector4(), G = new Vector4(), z = new Vector3(), k = new Vector3(), W = _.clone();
    W.transpose();
    const Q = (e2, t2, n2) => !(p[3 * e2] === p[3 * t2] && p[3 * e2 + 1] === p[3 * t2 + 1] && p[3 * e2 + 2] === p[3 * t2 + 2] || p[3 * e2] === p[3 * n2] && p[3 * e2 + 1] === p[3 * n2 + 1] && p[3 * e2 + 2] === p[3 * n2 + 2] || p[3 * t2] === p[3 * n2] && p[3 * t2 + 1] === p[3 * n2 + 1] && p[3 * t2 + 2] === p[3 * n2 + 2]);
    for (let e2 = 0; e2 < 3; e2++) C[e2] = new Matrix4();
    const H = n ? 32 : 28, X = t + 1;
    let Y = 0, j = 0, $ = 0, K = 0, q = 0;
    for (let e2 = r ? 0 : 20; e2 < H; e2++) if (o || e2 < 20 || e2 >= 28) {
      for (let t2 = 0; t2 < 3; t2++) {
        for (let n2 = 0; n2 < 4; n2++) for (let o2 = 0; o2 < 4; o2++) A[4 * o2 + n2] = l[3 * s[16 * e2 + 4 * n2 + o2] + t2], i && e2 >= 20 && e2 < 28 && 2 !== t2 && (A[4 * o2 + n2] *= 1.077), a || 2 !== t2 || (A[4 * o2 + n2] *= 1.3);
        D.set(A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9], A[10], A[11], A[12], A[13], A[14], A[15]), O.multiplyMatrices(D, _), C[t2].multiplyMatrices(W, O);
      }
      for (let e3 = 0; e3 <= t; e3++) {
        const n2 = e3 / t;
        for (let e4 = 0; e4 <= t; e4++) {
          const o2 = e4 / t;
          for (L = 4, w = R = 1; L--; ) v[L] = w, x[L] = R, w *= n2, R *= o2, 3 === L ? (y[L] = b[L] = 0, B = P = 1) : (y[L] = B * (3 - L), b[L] = P * (3 - L), B *= n2, P *= o2);
          F.fromArray(v), V.fromArray(x), U.fromArray(y), G.fromArray(b);
          for (let e5 = 0; e5 < 3; e5++) I = F.clone(), I.applyMatrix4(C[e5]), S[e5] = I.dot(V), I = U.clone(), I.applyMatrix4(C[e5]), M[e5] = I.dot(V), I = F.clone(), I.applyMatrix4(C[e5]), E[e5] = I.dot(G);
          z.fromArray(M), k.fromArray(E), T.crossVectors(k, z), T.normalize(), 0 === S[0] && 0 === S[1] ? N.set(0, S[2] > c ? 1 : -1, 0) : N.set(T.x, T.z, -T.y), p[j++] = u * S[0], p[j++] = u * (S[2] - c), p[j++] = -u * S[1], m[$++] = N.x, m[$++] = N.y, m[$++] = N.z, g[K++] = 1 - o2, g[K++] = 1 - n2;
        }
      }
      for (let e3 = 0; e3 < t; e3++) for (let n2 = 0; n2 < t; n2++) {
        const t2 = Y * X * X + e3 * X + n2, o2 = t2 + 1, r2 = o2 + X, i2 = t2 + X;
        Q(t2, o2, r2) && (h[q++] = t2, h[q++] = o2, h[q++] = r2), Q(t2, r2, i2) && (h[q++] = t2, h[q++] = r2, h[q++] = i2);
      }
      Y++;
    }
    this.setIndex(new BufferAttribute(h, 1)), this.setAttribute("position", new BufferAttribute(p, 3)), this.setAttribute("normal", new BufferAttribute(m, 3)), this.setAttribute("uv", new BufferAttribute(g, 2)), this.computeBoundingSphere();
  }
};
var TextGeometry = class _TextGeometry extends ExtrudeGeometry {
  constructor(e, t = {}) {
    const n = t.font;
    if (!n || !n.isFont) return console.error("v3d.TextGeometry: font parameter is not an instance of v3d.Font."), new BufferGeometry();
    void 0 === t.alignX && (t.alignX = "left"), void 0 === t.alignY && (t.alignY = "topBaseline"), void 0 === t.lineHeight && (t.lineHeight = -1), void 0 === t.scaledEmSize && (t.scaledEmSize = false);
    const o = n.generateShapes(e, t.size, t.alignX, t.alignY, t.lineHeight, t.scaledEmSize);
    t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = false), super(o, t), this.type = "TextGeometry", this.parameters = { text: e, parameters: t };
  }
  cloneWithText(e) {
    const t = this.parameters.parameters;
    return new _TextGeometry(e, { font: t.font, size: t.size, height: t.height, curveSegments: t.curveSegments, bevelEnabled: t.bevelEnabled, bevelThickness: t.bevelThickness, bevelSize: t.bevelSize, alignX: t.alignX, alignY: t.alignY, lineHeight: t.lineHeight, scaledEmSize: t.scaledEmSize });
  }
};
var ShadowMaterial = class extends Material {
  constructor(e) {
    super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
};
var MeshStandardMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.fog = true, this.envMapParallaxType = 0, this.envMapParallaxMatrix = new Matrix4(), this.envMapParallaxMatrixInv = new Matrix4(), this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this.fog = e.fog, this.envMapParallaxType = e.envMapParallaxType, this.envMapParallaxMatrix.copy(e.envMapParallaxMatrix), this.envMapParallaxMatrixInv.copy(e.envMapParallaxMatrixInv), this;
  }
};
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(e2) {
      this.ior = (1 + 0.4 * e2) / (1 - 0.4 * e2);
    } }), this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0, this._transmission = 0, this.setValues(e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
};
var MeshNormalMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
};
var MeshLambertMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
};
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(e) {
    super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
};
var MeshLineMaterial = class extends RawShaderMaterial {
  constructor(e) {
    super(), this.isMeshLineMaterial = true, this.type = "MeshLineMaterial", this.lineWidth = 1, this.sizeAttenuation = 1, this.color = new Color(16777215), this.opacity = 1, this.useMap = 0, this.map = null, this.useAlphaMap = 0, this.alphaMap = null, this.visibility = 1, this.alphaTest = 0, this.repeat = new Vector2(1, 1), this.uniforms = { lineWidth: { value: 1 }, sizeAttenuation: { value: 1 }, color: { value: new Color(16777215) }, opacity: { value: 1 }, useMap: { value: 0 }, map: { value: null }, alphaMap: { value: null }, useAlphaMap: { value: 0 }, visibility: { value: 1 }, alphaTest: { value: 0 }, repeat: { value: new Vector2(1, 1) } }, this.vertexShader = ShaderChunk.raw_meshline_vert, this.fragmentShader = ShaderChunk.raw_meshline_frag, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.lineWidth = e.lineWidth, this.sizeAttenuation = e.sizeAttenuation, this.color.copy(e.color), this.opacity = e.opacity, this.useMap = e.useMap, this.map = e.map, this.useAlphaMap = e.useAlphaMap, this.alphaMap = e.alphaMap, this.visibility = e.visibility, this.alphaTest = e.alphaTest, this.repeat.copy(e.repeat), this;
  }
};
var MeshMaskMaterial = class extends Material {
  constructor(e) {
    super(), this.isMeshMaskMaterial = true, this.type = "MeshMaskMaterial", this.side = 2, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.lights = false, this.cameraNearFar = null, this.depthTexture = null, this.textureMatrix = null, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, e.cameraNearFar && (this.cameraNearFar = e.cameraNearFar.clone()), e.textureMatrix && (this.textureMatrix = e.textureMatrix.clone()), e.depthTexture && (this.depthTexture = e.depthTexture), this;
  }
};
var Interpolant = class {
  constructor(e, t, n, o) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== o ? o : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, o = t[n], r = t[n - 1];
    e: {
      t: {
        let i;
        n: {
          o: if (!(e < o)) {
            for (let i2 = n + 2; ; ) {
              if (void 0 === o) {
                if (e < r) break o;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === i2) break;
              if (r = o, o = t[++n], e < o) break t;
            }
            i = t.length;
            break n;
          }
          if (e >= r) break e;
          {
            const a = t[1];
            e < a && (n = 2, r = a);
            for (let i2 = n - 2; ; ) {
              if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === i2) break;
              if (o = r, r = t[--n - 1], e >= r) break t;
            }
            i = n, n = 0;
          }
        }
        for (; n < i; ) {
          const o2 = n + i >>> 1;
          e < t[o2] ? i = o2 : n = o2 + 1;
        }
        if (o = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
        if (void 0 === o) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, o);
    }
    return this.interpolate_(n, r, e, o);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, o = this.valueSize, r = e * o;
    for (let e2 = 0; e2 !== o; ++e2) t[e2] = n[r + e2];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(e, t, n, o) {
    super(e, t, n, o);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
};
var StackNode = function(e) {
  this.value = e, this.next = null;
};
var Stack = function() {
  this.N = 0, this.first = null;
};
Stack.prototype.push = function(e) {
  this.first = this._push(this.first, e);
}, Stack.prototype._push = function(e, t) {
  if (null == e) return this.N++, new StackNode(t);
  const n = e;
  return this.N++, (e = new StackNode(t)).next = n, e;
}, Stack.prototype.pop = function() {
  if (null == this.first) return;
  const e = this.first, t = e.value;
  return this.first = e.next, this.N--, t;
}, Stack.prototype.size = function() {
  return this.N;
}, Stack.prototype.isEmpty = function() {
  return 0 == this.N;
}, Stack.prototype.peep = function() {
  if (null != this.first) return this.first.value;
}, Stack.prototype.toArray = function() {
  const e = [];
  let t = this.first;
  for (; null != t; ) e.push(t.value), t = t.next;
  return e;
};
var LinkMapNode = function(e) {
  this.value = e, this.prev = null, this.next = null;
};
var LinkMap = function() {
  this.first = null, this.last = null, this.map = {};
};
LinkMap.prototype.push = function(e, t) {
  this.map[t] = e, null === this.first ? (this.first = e, this.last = e) : (this.last.next = e, e.prev = this.last, this.last = e);
}, LinkMap.prototype.removeNodeByKey = function(e) {
  const t = this.map[e], n = t.prev, o = t.next;
  null !== n && null !== o ? (n.next = o, o.prev = n) : null === n && null !== o ? (this.first = o, o.prev = null) : null !== n && null === o ? (this.last = n, n.next = null) : (this.first = null, this.last = null), delete this.map[e];
};
var DiGraph = function(e = 0) {
  this.V = e, this.adjList = [], this.nodeInfo = [], this.edges = {};
  for (let t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({});
};
DiGraph.prototype.removeAll = function() {
  this.V = 0, this.adjList = [], this.nodeInfo = [], this.edges = {};
}, DiGraph.prototype.addNode = function(e) {
  e = e || {}, this.V++, this.adjList.push([]), this.nodeInfo.push(e);
}, DiGraph.prototype.addNewEdge = function(e, t) {
  this.adjList[e].push(t);
  const n = e + "_" + t, o = new Edge(e, t, 0);
  return this.edges[n] = o, o;
}, DiGraph.prototype.addEdge = function(e) {
  const t = e.v, n = e.w;
  this.adjList[t].push(n);
  const o = t + "_" + n;
  this.edges[o] = e;
}, DiGraph.prototype.removeEdge = function(e, t) {
  const n = this.adjList[e];
  for (let e2 = 0; e2 < n.length; e2++) n[e2] == t && (n.splice(e2, 1), e2--);
  const o = e + "_" + t;
  o in this.edges && delete this.edges[o];
}, DiGraph.prototype.edge = function(e, t) {
  const n = e + "_" + t;
  return n in this.edges ? this.edges[n] : null;
}, DiGraph.prototype.adj = function(e) {
  return this.adjList[e];
}, DiGraph.prototype.node = function(e) {
  return this.nodeInfo[e];
}, DiGraph.prototype.nodeIndex = function(e) {
  for (let t = 0; t < this.V; ++t) if (this.nodeInfo[t] == e) return t;
  return -1;
}, DiGraph.prototype.reverse = function() {
  const e = new DiGraph(this.V);
  for (let t = 0; t < this.V; ++t) {
    const n = this.adjList[t];
    for (let o = 0; o < n.length; ++o) {
      const r = n[o];
      e.addNewEdge(r, t);
    }
  }
  return e;
}, DiGraph.prototype.len = function() {
  return this.V;
}, DiGraph.prototype.findInEdges = function(e) {
  const t = [];
  for (let n = 0; n < this.V; n++) {
    const o = this.adjList[n];
    for (let r = 0; r < o.length; r++) o[r] == e && t.push(this.edge(n, e));
  }
  return t;
}, DiGraph.prototype.findOutEdges = function(e) {
  const t = [], n = this.adjList[e];
  for (let o = 0; o < n.length; o++) t.push(this.edge(e, n[o]));
  return t;
}, DiGraph.prototype.disconnect = function(e, t) {
  this.adjList[e].splice(0);
  for (let t2 = 0; t2 < this.V; t2++) {
    const n = this.adjList[t2];
    for (let t3 = 0; t3 < n.length; t3++) n[t3] == e && (n.splice(t3, 1), t3--);
    let o = t2 + "_" + e;
    o in this.edges && delete this.edges[o], o = e + "_" + t2, o in this.edges && delete this.edges[o];
  }
  if (t) {
    const t2 = new DiGraph(this.V - 1);
    for (let n = 0; n < this.V; n++) {
      if (n == e) continue;
      const o = this.adjList[n];
      for (let r = 0; r < o.length; r++) {
        const i = o[r], a = n > e ? n - 1 : n, s = i > e ? i - 1 : i, l = this.edge(n, i).copy();
        l.v = a, l.w = s, t2.addEdge(l);
      }
    }
    this.V--, this.adjList = t2.adjList, this.nodeInfo.splice(e, 1), this.edges = t2.edges;
  }
}, DiGraph.prototype.insert = function(e, t, n, o = (e2) => e2, r = (e2) => e2) {
  const i = this.V, a = e.V;
  for (let t2 = 0; t2 < a; t2++) {
    this.adjList.push([]), this.nodeInfo.push(o(e.nodeInfo[t2]));
    const n2 = e.adjList[t2];
    for (let o2 = 0; o2 < n2.length; o2++) {
      const a2 = n2[o2], s = e.edge(t2, a2).copy(r);
      s.v += i, s.w += i, this.addEdge(s);
    }
  }
  this.V += a;
  for (let e2 = 0; e2 < t.length; e2++) {
    const n2 = t[e2].copy(r);
    n2.w += i, this.addEdge(n2);
  }
  for (let e2 = 0; e2 < n.length; e2++) {
    const t2 = n[e2].copy(r);
    t2.v += i, this.addEdge(t2);
  }
}, DiGraph.prototype.vis = function(e) {
  e = e || function(e2, t2) {
    return String(e2);
  };
  let t = "digraph G {";
  for (let n = 0; n < this.V; n++) {
    t += n + ' [label="' + e(n, this.nodeInfo[n]) + '"];';
    const o = this.adjList[n];
    for (let e2 = 0; e2 < o.length; e2++) {
      t += n + " -> " + o[e2] + ";";
    }
  }
  t += "}", console.log(t);
};
var Edge = function(e, t, n = 0) {
  this.v = e, this.w = t, this.weight = n;
};
Edge.prototype.either = function() {
  return this.v;
}, Edge.prototype.other = function(e) {
  return e == this.v ? this.w : this.v;
}, Edge.prototype.from = function() {
  return this.v;
}, Edge.prototype.to = function() {
  return this.w;
}, Edge.prototype.copy = function(e = (e2) => e2) {
  const t = new Edge(0, 0, 0);
  for (const n in this) this.hasOwnProperty(n) && ("object" == typeof this[n] ? t[n] = e(this[n]) : t[n] = this[n]);
  return t;
};
var WeightedGraph = function(e) {
  this.V = e, this.adjList = [], this.nodeInfo = [];
  for (let t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({});
};
WeightedGraph.prototype.adj = function(e) {
  return this.adjList[e];
}, WeightedGraph.prototype.edge = function(e, t) {
  const n = this.adjList[e];
  for (let o = 0; o < n.length; ++o) {
    if (n[o].other(e) == t) return n[o];
  }
  return null;
}, WeightedGraph.prototype.node = function(e) {
  return this.nodeInfo[e];
}, WeightedGraph.prototype.addNewEdge = function(e) {
  const t = e.either(), n = e.other(t);
  this.adjList[t].push(e), this.adjList[n].push(e);
};
var WeightedDiGraph = function(e) {
  WeightedGraph.call(this, e);
};
(WeightedDiGraph.prototype = Object.create(WeightedGraph.prototype)).addNewEdge = function(e) {
  const t = e.from();
  this.adjList[t].push(e);
}, WeightedDiGraph.prototype.edge = function(e, t) {
  const n = this.adjList[e];
  for (let o = 0; o < n.length; ++o) {
    if (n[o].other(e) == t) return n[o];
  }
  return null;
}, WeightedDiGraph.prototype.toDiGraph = function() {
  const e = new DiGraph(this.V);
  for (let t = 0; t < this.V; ++t) {
    const n = this.adjList[t];
    for (let o = 0; o < n.length; ++o) {
      const r = n[o].other(t);
      e.addNewEdge(t, r);
    }
  }
  return e;
};
var DepthFirstSearch = function(e, t) {
  this.s = t;
  const n = e.V;
  this.marked = [], this.edgeTo = [];
  for (let e2 = 0; e2 < n; ++e2) this.marked.push(false), this.edgeTo.push(-1);
  this.dfs(e, t);
};
DepthFirstSearch.prototype.dfs = function(e, t) {
  this.marked[t] = true;
  const n = e.adj(t);
  for (let o = 0; o < n.length; ++o) {
    const r = n[o];
    this.marked[r] || (this.edgeTo[r] = t, this.dfs(e, r));
  }
}, DepthFirstSearch.prototype.hasPathTo = function(e) {
  return this.marked[e];
}, DepthFirstSearch.prototype.pathTo = function(e) {
  const t = new Stack();
  if (e == this.s) return [e];
  for (let n = e; n != this.s; n = this.edgeTo[n]) t.push(n);
  return t.push(this.s), t.toArray();
};
var TopologicalSort = function(e) {
  this.postOrder = new Stack(), this.marked = [];
  const t = e.V;
  for (let e2 = 0; e2 < t; ++e2) this.marked.push(false);
  for (let n = 0; n < t; ++n) this.marked[n] || this.dfs(e, n);
};
TopologicalSort.prototype.dfs = function(e, t) {
  this.marked[t] = true;
  const n = e.adj(t);
  for (let t2 = 0; t2 < n.length; ++t2) {
    const o = n[t2];
    this.marked[o] || this.dfs(e, o);
  }
  this.postOrder.push(t);
}, TopologicalSort.prototype.order = function() {
  return this.postOrder.toArray();
};
var GraphUtils = Object.freeze({ __proto__: null, DepthFirstSearch, DiGraph, Edge, LinkMap, LinkMapNode, TopologicalSort });
var datasetXYZ1 = [-1.117001, -0.1867262, -11.13505, 12.59865, -0.03937339, 1.167571, 7100686e-9, 3.592678, 0.6083296, -1.152006, -0.1926669, 6.152049, -4.770802, -0.08704701, 0.7483626, 0.03372718, 4.464592, 0.4036546, -1.072371, -0.2696632, 0.2816168, 1.820571, -0.3742666, 2.080607, -0.07675295, -2.835366, 1.129329, -1.109935, -0.1532764, 1.198787, -0.9015183, 5173015e-9, 0.5749178, 0.1075633, 4.387949, 0.2650413, -1.052297, -0.2229452, 1.952347, 0.5727205, -4.88507, 1.984016, -0.1106197, -0.4898361, 0.8907873, -1.070108, -0.1600465, 1.593886, -4479251e-11, -3.306541, 0.9390193, 0.09513168, 2.343583, 0.5335404, -1.113253, -0.16996, -10.38822, 11.37513, -0.04040911, 1.037455, 0.04991792, 4.801919, 0.630271, -1.135747, -0.1678594, 4.970755, -4.43023, -0.06657408, 0.3636161, 0.1558009, 6.01337, 0.3959601, -1.095892, -0.2732595, 0.7666496, 1.350731, -0.4401401, 2.470135, -0.1707929, -3.260793, 1.170337, -1.073668, -0.02603929, -0.1944589, 0.4575207, 0.6878164, -0.139077, 0.3690299, 7.885781, 0.1877694, -1.070091, -0.2798957, 2.338478, -2.647221, -7.387808, 2.32921, -0.1644639, -2.00371, 0.9874527, -1.06712, -0.1418866, 1.25409, 6.053048, -2.918892, 0.5322812, 0.1613053, 3.018161, 0.527409, -1.129483, -0.1890619, -9.065101, 9.659923, -0.03607819, 0.8314359, 0.08181661, 4.768868, 0.6339777, -1.14642, -0.1883579, 3.309173, -3.127882, -0.06938176, 0.3987113, 0.1400581, 6.283042, 0.5267076, -1.128348, -0.2641305, 1.223176, 0.05514952, -0.3490649, 1.997784, -0.04123709, -2.251251, 0.9483466, -1.02582, 0.0140469, -1.187406, 2.7299, 0.5877588, -0.276114, 0.4602633, 8.305125, 0.3945001, -1.083957, -0.2606679, 2.207108, -7.202803, -5.968103, 2.129455, -0.07789512, -1.137688, 0.8871769, -1.062465, -0.1512189, 1.042881, 14.27839, -4.242214, 0.40381, 0.199778, 2.814449, 0.5803196, -1.175099, -0.2410789, -11.08587, 11.33404, -0.018193, 0.6772942, 0.09605043, 4.231166, 0.6239972, -1.224207, -0.2883527, 3.002206, -2.649612, -0.04795418, 0.4984398, 0.03251434, 4.851611, 0.6551019, -1.136955, -0.2423048, 1.058823, -0.2489236, -0.2462179, 1.93314, 0.09106828, -0.1905869, 0.8171065, -1.014535, -82625e-7, -1.448017, 2.295788, 0.3510334, -1.477418, 0.5432449, 5.762796, 0.4908751, -1.070666, -0.237978, 1.844589, -5.442448, -4.012768, 2.945275, 9854725e-9, 0.08455959, 0.814503, -1.071525, -0.1777132, 0.807659, 9.925865, -3.324623, -0.6367437, 0.2844581, 2.248384, 0.6544022, -1.218818, -0.2952382, -13.45975, 13.47153, -6814585e-9, 0.5079068, 0.119723, 3.776949, 0.5836961, -1.409868, -0.511433, 2.776539, -2.039001, -0.02673769, 0.4145288, 7829342e-10, 2.275883, 0.6629691, -1.069151, -0.09434247, 0.7293972, -1.222473, -0.1533461, 2.160357, 0.04626837, 3.852415, 0.859357, -1.021306, -0.1149551, -1.108414, 4.178343, 0.4013665, -2.222814, 0.6929462, 1.392652, 0.4401662, -1.074251, -0.2224002, 1.372356, -8.858704, -3.92266, 3.020018, -0.01458724, 1.511186, 0.8288064, -1.062048, -0.1526582, 0.4921067, 14.85522, -3.229936, -0.8426604, 0.3916243, 2.678994, 0.6689264, -1.257023, -0.33647, -15.27795, 15.04223, 2717715e-9, 0.302991, 0.1636851, 3.561663, 0.5283161, -1.635124, -0.7329993, 3.523939, -2.566337, -0.01902543, 0.5505483, -0.06242176, 1.065992, 0.6654236, -0.9295823, 0.04845834, -0.299299, -0.2001327, -0.08019339, 1.807806, 0.09020277, 5.095372, 0.8639936, -1.09374, -0.2148608, -0.521624, 2.119777, 0.09506454, -1.831439, 0.6961204, 0.1102084, 0.4384319, -1.044181, -0.1849257, 0.9071246, -4.648901, -2.279385, 2.356502, -0.04169147, 1.932557, 0.829655, -1.061451, -0.1458745, 0.2952267, 8.967214, -3.726228, -0.5022316, 0.5684877, 3.102347, 0.6658443, -1.332391, -0.4127769, -9.328643, 9.046194, 3457775e-9, 0.3377425, 0.1530909, 3.301209, 0.4997917, -1.932002, -0.9947777, -2.042329, 3.58694, -0.05642182, 0.8130478, -0.08195988, 0.1118294, 0.5617231, -0.8707374, 0.1286999, 1.820054, -4.674706, 3317471e-9, 0.5919018, 0.1975278, 6.686519, 0.9631727, -1.070378, -0.3030579, -0.9041938, 6.200201, 0.1232207, -0.3650628, 0.5029403, -2.903162, 0.3811408, -1.063035, -0.1637545, 0.5853072, -7.889906, -1.200641, 1.035018, 0.1192093, 3.267054, 0.8416151, -1.053655, -0.1562286, 0.2423683, 11.28575, -4.363262, -0.0731416, 0.5642088, 2.514023, 0.6670457, -1.366112, -0.4718287, -7.876222, 7.7469, -9182309e-9, 0.4716076, 0.08320252, 3.165603, 0.5392334, -2.468204, -1.33634, -5.386723, 7.072672, -0.08329266, 0.8636876, -0.01978177, -0.1326218, 0.2979222, -0.9653522, -0.02373416, 1.81025, -6.467262, 0.1410706, -0.4753717, 0.3003095, 6.551163, 1.151083, -0.8943186, -0.2487152, -0.230896, 8.512648, 0.1298402, 1.034705, 0.2303509, -3.924095, 0.2982717, -1.146999, -0.2318784, 0.08992419, -9.933614, -0.886092, -0.03071656, 0.2852012, 3.046199, 0.8599001, -1.032399, -0.1645145, 0.2683599, 13.27701, -4.40767, 0.07709869, 0.4951727, 1.957277, 0.6630943, -1.46907, -0.6135092, -6.506263, 6.661315, -0.03835383, 0.7150413, 7784318e-9, 2.820577, 0.6756784, -2.501583, -1.247404, -15.23462, 16.33191, -0.01204803, 0.5896471, -0.02002023, 1.144647, 0.06177874, -2.438672, -1.127291, 5.731172, -10.2135, 0.0616561, -0.7752641, 0.4708254, 4.176847, 1.200881, -0.1513427, 0.09792731, -1.612349, 9.814289, 0.05188921, 1.716403, -0.07039255, -2.815115, 0.3291874, -1.318511, -0.3650554, 0.4221268, -9.294529, -0.0439752, -0.8100625, 0.3742719, 1.834166, 0.822345, -1.016009, -0.1820264, 0.1278426, 11.82696, -4.801528, 0.4947899, 0.4660378, 1.601254, 0.6702359, -1.84131, -0.9781779, -4.610903, 4.824662, -0.05100806, 0.6463776, -6377724e-12, 2.216875, 0.861853, -2.376373, -1.108657, -14.89799, 15.46458, 0.04091025, 0.0976178, -0.01048958, 2.165834, -0.1609171, -4.710318, -2.261963, 6.947327, -10.34828, -0.1325542, 0.7508674, 0.2247553, 2.873142, 1.2971, 0.216375, -0.1944345, -2.43786, 10.11314, 0.44505, 0.3111492, 0.2751323, -1.627906, 0.2531213, -1.258794, -0.3524641, 0.8425444, -10.85313, -1.154381, -0.4638014, -2781115e-9, 0.4344498, 0.8507091, -1.018938, -0.1804153, -0.06354054, 15.7315, -4.386999, 0.6211115, 0.5294648, 1.580749, 0.6586655, -1.116416, -0.1917524, -10.68233, 12.22221, -0.03668978, 1.054022, 0.01592132, 3.180583, 0.562737, -1.132341, -0.1671286, 5.976499, -4.227366, -0.09542489, 0.8664938, 8351793e-9, 4.876068, 0.4492779, -1.087635, -0.3173679, 0.4314407, 1.100555, -0.4410057, 1.677253, -0.03005925, -4.201249, 1.070902, -1.083031, -0.08847705, 1.291773, 0.4546776, 0.3091894, 0.726176, 0.04203659, 5.990615, 0.3704756, -1.057899, -0.2246706, 2.329563, -1.219656, -5.33526, 0.8545378, -0.03906209, -0.9025499, 0.7797348, -1.073305, -0.1522553, 1.767063, 1.90428, -3.101673, 0.3995856, 0.02905192, 2.563977, 0.5753067, -1.113674, -0.1759694, -9.754125, 10.87391, -0.03841093, 0.9524272, 0.05680219, 4.227034, 0.6029571, -1.126496, -0.1680281, 5.332352, -4.575579, -0.06761755, 0.3295335, 0.1194896, 5.570901, 0.4536185, -1.103074, -0.2681801, 0.06571479, 2.396522, -0.455128, 2.466331, -0.1232022, -3.023201, 1.086379, -1.053299, -0.02697173, 0.8379121, -0.9681458, 0.5890692, -0.4872027, 0.2936929, 7.510139, 0.3079122, -1.079553, -0.2710448, 2.462379, -0.3713554, -8.534512, 1.828242, -0.1686398, -1.96134, 0.8941077, -1.069741, -0.1396394, 1.657868, 3.236313, -2.706344, -0.2948122, 0.1314816, 2.868457, 0.5413403, -1.131649, -0.1954455, -7.751595, 8.685861, -0.04910871, 0.8992952, 0.04710143, 4.254818, 0.6821116, -1.156689, -0.1884324, 3.163519, -3.091522, -0.06613927, -0.02575883, 0.1640065, 6.073643, 0.4453468, -1.079224, -0.2621389, 0.9446437, 1.448479, -0.3969384, 2.626638, -0.08101186, -3.016355, 1.076295, -1.080832, 0.01033057, -0.3500156, -0.03281419, 0.5655512, -1.156742, 0.453471, 8.774122, 0.2772869, -1.051202, -0.2679975, 2.719109, -2.190316, -6.878798, 2.250481, -0.2030252, -2.026527, 0.9701096, -1.089849, -0.1598589, 1.564748, 6.869187, -3.05367, -0.6110435, 0.1644472, 2.370452, 0.551177, -1.171419, -0.2429746, -8.991334, 9.571216, -0.02772861, 0.6688262, 0.07683478, 3.785611, 0.6347635, -1.228554, -0.2917562, 2.753986, -2.49178, -0.04663434, 0.3118303, 0.07546506, 4.463096, 0.5955071, -1.093124, -0.2447767, 0.9097406, 0.5448296, -0.2957824, 2.024167, -5152333e-10, -1.069081, 0.9369565, -1.056994, 0.01569507, -0.8217491, 1.870818, 0.706193, -1.483928, 0.5978206, 6.864902, 0.3673332, -1.054871, -0.2758129, 2.712807, -5.95011, -6.554039, 2.447523, -0.1895171, -1.454292, 0.9131738, -1.100218, -0.1746241, 1.438505, 11.15481, -3.266076, -0.8837357, 0.19701, 1.991595, 0.5907821, -1.207267, -0.291361, -11.03767, 11.40724, -0.014168, 0.5564047, 0.08476262, 3.371255, 0.6221335, -1.429698, -0.5374218, 2.837524, -2.221936, -0.02422337, 0.09313758, 0.0719025, 1.869022, 0.5609035, -1.002274, -0.0697281, 0.4031308, -0.3932997, -0.1521923, 2.390646, -0.0689399, 2.999661, 1.017843, -1.081168, -0.1178666, -0.496808, 3.919299, 0.6046866, -2.440615, 0.7891538, 2.140835, 0.274047, -1.050727, -0.2307688, 2.276396, -9.454407, -5.505176, 2.99262, -0.2450942, 0.6078372, 0.9606765, -1.103752, -0.1810202, 1.375044, 15.89095, -3.438954, -1.265669, 0.2475172, 1.680768, 0.5978056, -1.244324, -0.3378542, -11.11001, 11.37784, -7896794e-9, 0.4808023, 0.09249904, 3.025816, 0.5880239, -1.593165, -0.7027621, 2.220896, -1.437709, -0.01534738, 0.06286958, 0.06644555, 1.091727, 0.547008, -0.9136506, 0.01344874, 0.7772636, -1.209396, -0.1408978, 2.433718, -0.1041938, 3.791244, 1.037916, -1.134968, -0.1803315, -0.9267335, 4.57667, 0.6851928, -2.805, 0.8687208, 1.161483, 0.2571688, -1.017037, -0.2053943, 2.36164, -9.887818, -5.122889, 3.287088, -0.2594102, 0.8578927, 0.959234, -1.118723, -0.1934942, 1.226023, 16.7414, -3.277335, -1.629809, 0.2765232, 1.637713, 0.6113963, -1.314779, -0.4119915, -12.4115, 12.41578, 2344284e-9, 0.2980837, 0.1414613, 2.781731, 0.4998556, -1.926199, -1.020038, 2.5692, -1.081159, -0.02266833, 0.3588668, 8750078e-9, -0.2452171, 0.4796758, -0.7780002, 0.1850647, 0.04445456, -2.409297, -0.07816346, 1.54679, -0.02807227, 5.998176, 1.132396, -1.179326, -0.357833, -0.2392933, 6.467883, 0.5904596, -1.869975, 0.8045839, -2.498121, 0.1610633, -1.009956, -0.1311896, 1.726577, -12.19356, -3.466239, 2.343602, -0.2252205, 2.573681, 1.027109, -1.11246, -0.2063093, 1.233051, 20.58946, -4.578074, -1.145643, 0.3160192, 1.420159, 0.5860212, -1.371689, -0.4914196, -10.7661, 11.07405, -0.01485077, 0.5936218, 0.03685482, 2.599968, 0.6002204, -2.436997, -1.377939, 0.02130141, 1.079593, -0.01796232, -0.03933248, 0.1610711, -0.6901181, 0.1206416, -0.8743368, 0.0733137, 0.8734259, -3.743126, -0.03151167, 1.297596, -0.07634926, 6.532873, 1.435737, -0.9810197, -0.3521634, -0.2855205, 7.134674, 0.6839748, -1.394841, 0.6952036, -4.633104, -0.02173401, -1.122958, -0.1691536, 1.38236, -11.02913, -2.608171, 1.865111, -0.1345154, 3.112342, 1.094134, -1.075586, -0.2077415, 1.171477, 17.9327, -4.656858, -1.036839, 0.3338295, 1.042793, 0.5739374, -1.465871, -0.6364486, -8.833718, 9.34365, -0.032236, 0.7552848, -3121341e-12, 2.249164, 0.8094662, -2.448924, -1.270878, -4.823703, 5.853058, -0.02149127, 0.03581132, -1230276e-9, 0.4892553, -0.1597657, -2.419809, -1.071337, 1.575648, -4.98358, 9545185e-9, 0.5032615, 0.4186266, 4.634147, 1.433517, -0.1383278, -0.02797095, -0.1943067, 6.679623, 0.411828, -0.2744289, -0.02118722, -4.337025, 0.1505072, -1.341872, -0.2518572, 1.027009, -6.527103, -1.081271, 1.015465, 0.2845789, 2.470371, 0.927812, -1.04064, -0.2367454, 1.100744, 8.827253, -4.560794, -0.7287017, 0.2842503, 0.6336593, 0.6327335, -1.877993, -1.025135, -4.311037, 4.715016, -0.04711631, 0.6335844, -7665398e-12, 1.788017, 0.9001409, -2.28154, -1.137668, -10.36869, 11.36254, 0.01961739, -0.09836174, -6734567e-9, 1.320918, -0.2400807, -4.904054, -2.315781, 5.735999, -8.626257, -0.1255643, 1.545446, 0.139686, 2.972897, 1.429934, 0.4077067, -0.1833688, -2.450939, 9.119433, 0.4505361, -1.340828, 0.397369, -1.78537, 0.09628711, -1.296052, -0.3250526, 1.813294, -10.31485, -1.38869, 1.239733, -0.08989196, -0.3389637, 0.963956, -1.062181, -0.2423444, 0.7577592, 15.66938, -4.462264, -0.574281, 0.3262259, 0.9461672, 0.6232887];
var datasetXYZ2 = [-1.127942, -0.1905548, -12.52356, 13.75799, -0.03624732, 1.055453, 0.01385036, 4.17697, 0.5928345, -1.15526, -0.1778135, 6.216056, -5.254116, -0.08787445, 0.8434621, 0.04025734, 6.195322, 0.3111856, -1.125624, -0.3217593, 0.5043919, 1.686284, -0.3536071, 1.476321, -0.07899019, -4.522531, 1.271691, -1.081801, -0.1033234, 0.999555, 7482946e-9, -0.06776018, 1.463141, 0.09492021, 5.612723, 0.1298846, -1.07532, -0.2402711, 2.141284, -1.203359, -4.945188, 1.437221, -0.0809675, -1.028378, 1.004164, -1.073337, -0.1516517, 1.639379, 2.304669, -3.214244, 1.286245, 0.05613957, 2.480902, 0.4999363, -1.128399, -0.1857793, -10.89863, 11.72984, -0.03768099, 0.9439285, 0.04869335, 4.845114, 0.6119211, -1.114002, -0.139928, 4.9638, -4.6855, -0.07780879, 0.4049736, 0.1586297, 7.770264, 0.3449006, -1.185472, -0.3403543, 0.6588322, 1.133713, -0.4118674, 2.061191, -0.1882768, -4.372586, 1.22353, -1.002272, 0.02000703, 0.07073269, 1.485075, 0.5005589, 0.4301494, 0.3626541, 7.921098, 0.1574766, -1.121006, -0.3007777, 2.242051, -4.571561, -7.761071, 2.053404, -0.1524018, -1.886162, 1.018208, -1.058864, -0.1358673, 1.389667, 8.633409, -3.437249, 0.7295429, 0.15147, 2.842513, 0.5014325, -1.144464, -0.2043799, -10.20188, 10.71247, -0.03256693, 0.7860205, 0.06872719, 4.824771, 0.6259836, -1.170104, -0.2118626, 4.391405, -4.1989, -0.07111559, 0.3890442, 0.1024831, 6.282535, 0.5365688, -1.129171, -0.255288, 0.2238298, 0.7314295, -0.356273, 1.881931, -0.03078716, -1.03912, 0.9096301, -1.042294, 4450203e-9, -0.5116033, 2.627589, 0.6098996, -0.1264638, 0.4325281, 7.080503, 0.4583646, -1.082293, -0.2723056, 2.065076, -8.143133, -7.892212, 2.142231, -0.0710624, -1.122398, 0.8338505, -1.071715, -0.1426568, 1.095351, 17.29783, -3.851931, 0.4360514, 0.211444, 2.970832, 0.5944389, -1.195909, -0.2590449, -11.91037, 12.07947, -0.01589842, 0.6297846, 0.09054772, 4.285959, 0.5933752, -1.245763, -0.3316637, 4.29366, -3.694011, -0.04699947, 0.4843684, 0.02130425, 4.097549, 0.6530809, -1.148742, -0.1902509, -0.2393233, -0.2441254, -0.2610918, 1.846988, 0.03532866, 2.660106, 0.8358294, -1.01608, -0.0744496, -0.5053436, 4.388855, 0.6054987, -1.2083, 0.5817215, 2.54357, 0.4726568, -1.072027, -0.210144, 1.518378, -10.60119, -6.016546, 2.649475, -0.05166992, 1.571269, 0.8344622, -1.072365, -0.1511201, 0.747801, 19.00732, -3.950387, -0.3473907, 0.3797211, 2.782949, 0.6296808, -1.239423, -0.3136289, -13.511, 13.49468, -7070423e-9, 0.5012315, 0.1106008, 3.803619, 0.5577948, -1.452524, -0.5676944, 2.993153, -2.277288, -0.02168954, 0.305672, 0.01152338, 1.852697, 0.6427228, -1.061421, -0.04590521, 0.6057022, -1.096835, -0.1504952, 2.344921, -0.05491832, 5.268322, 0.9082253, -1.042373, -0.1769498, -1.075388, 3.831712, 0.315414, -2.416458, 0.7909032, -0.01492892, 0.3854049, -1.064159, -0.1892684, 1.438685, -8.166362, -3.616364, 3.275206, -0.1203825, 2.039491, 0.8688057, -1.07012, -0.1569508, 0.412476, 13.99683, -3.547085, -1.046326, 0.4973825, 2.791231, 0.6503286, -1.283579, -0.3609518, -13.35397, 13.15248, -4431938e-10, 0.3769526, 0.1429824, 3.573613, 0.4998696, -1.657952, -0.7627948, 1.958222, -0.7949816, -0.02882837, 0.5356149, -0.05191946, 0.8869955, 0.626332, -0.95276, 0.06494189, 0.5361303, -2.12959, -0.0925863, 1.604776, 0.0506777, 6.376055, 0.9138052, -1.080827, -0.252312, -0.7154262, 4.120085, 0.1878228, -1.492158, 0.6881655, -1.446611, 0.4040631, -1.054075, -0.1665498, 0.9191052, -6.636943, -1.894826, 2.10781, -0.03680499, 2.655452, 0.841384, -1.061127, -0.1448849, 0.2667493, 10.34103, -4.285769, -0.3874504, 0.5998752, 3.132426, 0.6652753, -1.347345, -0.4287832, -9.305553, 9.133813, -3173527e-9, 0.3977564, 0.115142, 3.320564, 0.4998134, -1.927296, -0.9901372, -2.593499, 4.087421, -0.05833993, 0.8158929, -0.04681279, 0.2423716, 0.4938052, -0.9470092, 0.07325237, 2.064735, -5.16754, -0.01313751, 0.4832169, 0.1126295, 6.970522, 1.035022, -1.022557, -0.2762616, -0.9375748, 6.696739, 0.2200765, -0.1133253, 0.5492505, -3.109391, 0.3321914, -1.087444, -0.1836263, 0.6225024, -8.576765, -1.107637, 0.7859427, 0.09910909, 3.112938, 0.8596261, -1.051544, -0.1546262, 0.2371731, 12.00502, -4.527291, 0.07268862, 0.5571478, 2.532873, 0.6662, -1.375576, -0.4840019, -8.12129, 8.05814, -0.01445661, 0.5123314, 0.05813321, 3.203219, 0.5442318, -2.325221, -1.241463, -7.06343, 8.741369, -0.0782995, 0.8844273, -0.03471106, 0.1740583, 0.2814079, -1.2287, -0.2013412, 2.949042, -7.371945, 0.1071753, -0.249197, 0.2265223, 6.391504, 1.172389, -0.7601786, -0.1680631, -0.7584444, 8.541356, 0.08222291, 0.6729633, 0.3206615, -3.70094, 0.2710054, -1.191166, -0.2672347, 0.2927498, -9.713613, -0.4783721, 0.2352803, 0.2161949, 2.691481, 0.8745447, -1.030135, -0.1653301, 0.2263443, 12.96157, -4.650644, 7055709e-9, 0.5091975, 2.00037, 0.6603839, -1.508018, -0.6460933, -6.402745, 6.545995, -0.0375032, 0.6921803, 3309819e-9, 2.797527, 0.6978446, -2.333308, -1.167837, -17.46787, 18.6863, -8948229e-9, 0.5621946, -0.03402626, 1.217943, 0.01149865, -2.665953, -1.226307, 7.169725, -11.59434, 0.0358342, -0.3074378, 0.3412248, 4.422122, 1.283791, -0.09705116, 0.08312991, -2.160462, 10.28235, 0.03543357, 1.032049, 0.105831, -2.972898, 0.2418628, -1.329617, -0.3699557, 0.5560117, -9.730113, 0.09938865, -0.3071488, 0.2510691, 1.777111, 0.8705142, -1.019387, -0.1893247, 0.1194079, 12.39436, -4.799224, 0.2940213, 0.4841268, 1.529724, 0.6582615, -1.896737, -1.005442, -6.411032, 6.54822, -0.03227596, 0.5717262, -8115192e-12, 2.296704, 0.9000749, -2.411116, -1.225587, -17.53629, 18.29393, 0.01247555, 0.2364616, -5114637e-9, 1.603778, -0.2224156, -4.707121, -2.074977, 7.9423, -11.32407, -0.05415654, 0.5446811, 0.1032493, 4.010235, 1.369802, 0.1010482, -0.4013305, -2.674579, 9.779409, 0.1782506, 0.7053045, 0.4200002, -2.400671, 0.1953165, -1.243526, -0.3391255, 0.8848882, -9.789025, -0.3997324, -0.9546227, -0.1044017, 0.6010593, 0.8714462, -1.014633, -0.1730009, -0.07738934, 13.90903, -4.847307, 1.076059, 0.5685743, 1.572992, 0.6561432, -1.122998, -0.1881183, -10.30709, 11.58932, -0.04079495, 0.9603774, 0.03079436, 4.009235, 0.5060745, -1.13479, -0.1539688, 5.478405, -4.21727, -0.1043858, 0.7165008, 0.01524765, 6.473623, 0.4207882, -1.134957, -0.3513318, 0.7393837, 1.354415, -0.4764078, 1.690441, -0.0549264, -5.563523, 1.145743, -1.058344, -0.05758503, 1.16823, 0.3269824, 0.1795193, 0.7849011, 0.07441853, 6.904804, 0.281879, -1.075194, -0.2355813, 2.463685, -1.536505, -7.505771, 0.9619712, -0.06465851, -1.355492, 0.8489847, -1.07903, -0.1465328, 1.773838, 2.310131, -3.136065, 0.3507952, 0.04435014, 2.819225, 0.5689008, -1.125833, -0.1870849, -9.555833, 10.59713, -0.04225402, 0.9164663, 0.04338796, 4.40098, 0.6056119, -1.12744, -0.1551891, 4.755621, -4.408806, -0.07851763, 0.2268284, 0.146007, 7.048003, 0.3525997, -1.143788, -0.3170178, 0.5480669, 2.04183, -0.4532139, 2.302233, -0.1887419, -4.489221, 1.250967, -1.032849, 7376031e-9, 0.5666073, -0.2312203, 0.4862894, -0.1748294, 0.357287, 8.380522, 0.1302333, -1.093728, -0.2786977, 2.641272, -1.507494, -8.731243, 1.684055, -0.2023377, -2.176398, 1.013249, -1.076578, -0.1456205, 1.693935, 2.945003, -2.822673, -0.2520033, 0.1517034, 2.649109, 0.5179094, -1.146417, -0.2119353, -7.187525, 8.058599, -0.05256438, 0.8375733, 0.03887093, 4.222111, 0.6695347, -1.173674, -0.2067025, 2.899359, -2.804918, -0.08473899, 3944225e-9, 0.1340641, 6.160887, 0.4527141, -1.090098, -0.2599633, 0.9180856, 1.09271, -0.4215019, 2.42766, -0.09277667, -2.123523, 1.058159, -1.08446, 8056181e-9, -0.245351, 0.6619567, 0.4668118, -0.9526719, 0.4648454, 8.001572, 0.3054194, -1.053728, -0.2765784, 2.792388, -3.489517, -8.150535, 2.195757, -0.2017234, -2.128017, 0.9326589, -1.099348, -0.1593939, 1.568292, 7.247853, -2.933, -0.5890481, 0.172444, 2.433484, 0.5736558, -1.185983, -0.2581184, -7.761056, 8.317053, -0.03351773, 0.6676667, 0.05941733, 3.820727, 0.6324032, -1.268591, -0.3398067, 2.348503, -2.023779, -0.05368458, 0.1083282, 0.08402858, 3.910254, 0.5577481, -1.071353, -0.1992459, 0.7878387, 0.1974702, -0.3033058, 2.335298, -0.08205259, 0.7954454, 0.9972312, -1.089513, -0.03104364, -0.5995746, 2.330281, 0.6581939, -1.821467, 0.6679973, 5.090195, 0.3125161, -1.040214, -0.2570934, 2.660489, -6.506045, -7.053586, 2.763153, -0.2433632, -0.7648176, 0.9452937, -1.116052, -0.1831993, 1.457694, 11.63608, -3.216426, -1.045594, 0.2285002, 1.817407, 0.5810396, -1.230134, -0.3136264, -8.909301, 9.145006, -0.01055387, 0.4467317, 0.1016826, 3.342964, 0.563384, -1.442907, -0.5593147, 2.156447, -1.241657, -0.0351213, 0.3050274, 0.01797175, 1.742358, 0.5977153, -1.027627, -0.06481539, 0.4351975, -1.051677, -0.2030672, 1.942684, -0.03615993, 4.050266, 0.9801624, -1.08211, -0.1578209, -0.3397511, 4.163851, 0.6650368, -1.84173, 0.7062544, 0.6789881, 0.3172623, -1.047447, -0.197756, 2.183364, -8.805249, -5.483962, 2.551309, -0.177964, 1.519501, 0.9212536, -1.111853, -0.1935736, 1.394408, 13.92405, -3.46543, -1.068432, 0.2388671, 1.455336, 0.6233425, -1.262238, -0.3546341, -10.08703, 10.20084, -1852187e-9, 0.353758, 0.1239199, 3.056093, 0.5132052, -1.61381, -0.7355585, 2.760123, -1.685253, -0.02517552, 0.2914258, 4743448e-9, 0.8689596, 0.5674192, -0.9462336, 0.02950767, -0.2613816, -0.7398653, -0.1315558, 1.901042, -0.06447844, 4.969341, 1.027342, -1.111481, -0.2194054, -0.09004538, 3.983442, 0.4871278, -1.965315, 0.7956121, -0.2363225, 0.2718037, -1.036397, -0.1827106, 1.964747, -8.870759, -4.208011, 2.461215, -0.2158905, 1.561676, 0.9436866, -1.113769, -0.1947819, 1.30072, 15.16476, -4.088732, -1.069384, 0.2836434, 1.671451, 0.6229612, -1.328069, -0.4244047, -8.41704, 8.552244, -6813504e-9, 0.4127422, 0.09619897, 2.854227, 0.505988, -1.927552, -1.02529, 0.9529576, 0.425595, -0.03738779, 0.2584586, 0.04911004, -0.2640913, 0.4138626, -0.8488094, 0.1435988, 0.6356807, -2.895732, -0.08473961, 1.701305, -0.1323908, 6.499338, 1.210928, -1.128313, -0.3397048, -0.404314, 6.265097, 0.5482395, -2.057614, 0.8884087, -2.943879, 0.09760301, -1.039764, -0.1494772, 1.781915, -11.53012, -3.379232, 2.517231, -0.2764393, 2.588849, 1.05212, -1.108447, -0.2012251, 1.19864, 19.25331, -4.423892, -1.257122, 0.339569, 1.48122, 0.5880175, -1.374185, -0.4967434, -7.401318, 7.724021, -0.02345723, 0.5979653, 0.02436346, 2.65897, 0.6014891, -2.310933, -1.29029, -1.301909, 2.557806, -0.03744449, 0.08982861, 0.1090613, -0.4398363, 0.1184329, -1.12473, -0.0992183, 1.366902, -4.172489, -0.05078016, 1.393597, -0.09323843, 6.452721, 1.435913, -0.8468477, -0.2744819, -0.43472, 6.713362, 0.6127133, -1.685634, 0.7360941, -4.535502, -0.02920866, -1.165242, -0.2008697, 1.438778, -10.08936, -2.214771, 2.102909, -0.1763085, 2.859075, 1.09347, -1.074614, -0.2066374, 1.131891, 16.30063, -4.801441, -1.11259, 0.3595785, 1.122227, 0.579461, -1.521515, -0.6835604, -5.571044, 6.028774, -0.04253715, 0.6875746, -5279456e-12, 2.18015, 0.8487705, -2.240415, -1.171166, -7.182771, 8.417068, -0.01932866, 0.1101887, -0.01098862, 0.6242195, -0.2393875, -2.712354, -1.19883, 3.1802, -6.76813, -2563386e-9, 0.7984607, 0.2764376, 4.695358, 1.557045, -0.03655172, -0.02142321, -0.913812, 7.932786, 0.3516542, -0.7994343, 0.1786761, -4.208399, 0.01820576, -1.36861, -0.2656212, 1.249397, -8.317818, -0.8962772, 1.423249, 0.1478381, 2.19166, 1.007748, -1.041753, -0.2453366, 1.061102, 11.30172, -4.739312, -0.9223334, 0.2982776, 0.6162931, 0.6080302, -1.989159, -1.09516, -2.91555, 3.275339, -0.05735765, 0.5742174, -7683288e-12, 1.7634, 0.9001342, -2.07002, -1.086338, -10.95898, 12.0696, 0.03780123, -0.01774699, -5881348e-10, 1.333819, -0.2605423, -5.249653, -2.38304, 6.160406, -9.097138, -0.1955319, 1.651785, 6016463e-10, 3.021824, 1.493574, 0.4685432, -0.2358662, -2.666433, 9.685763, 0.5804928, -1.521875, 0.5668989, -1.548136, 0.01688642, -1.296891, -0.3449031, 1.928548, -11.6756, -1.627615, 1.355603, -0.1929074, -0.6568952, 1.009774, -1.067288, -0.2410392, 0.7147961, 17.8384, -4.374399, -0.6588777, 0.3329831, 1.012066, 0.6118645];
var datasetXYZ3 = [-1.310023, -0.4407658, -36.4034, 36.83292, -8124762e-9, 0.5297961, 0.01188633, 3.13832, 0.5134778, -1.4241, -0.5501606, -17.5351, 18.22769, -0.01539272, 0.6366826, 2661996e-9, 2.659915, 0.4071138, -1.103436, -0.1884105, 6.425322, -6.910579, -0.02019861, 0.3553271, -0.01589061, 5.345985, 0.8790218, -1.1862, -0.4307514, -3.957947, 5.979352, -0.05348869, 1.736117, 0.03491346, -2.692261, 0.5610506, -1.006038, -0.1305995, 4.473513, -3.806719, 0.1419407, -0.02148238, -0.05081185, 3.735362, 0.535828, -1.078507, -0.1633754, -3.812368, 4.3817, 0.02988122, 1.754224, 0.1472376, 3.722798, 0.4999157, -1.333582, -0.4649908, -33.59528, 34.04375, -9384242e-9, 0.5587511, 572631e-8, 3.073145, 0.5425529, -1.562624, -0.7107068, -14.7817, 15.59839, -0.01462375, 0.5050133, 0.02516017, 1.604696, 0.2902403, -0.8930158, 0.04068077, 1.373481, -2.342752, -0.02098058, 0.6248686, -0.05258363, 7.058214, 1.150373, -1.262823, -0.4818353, 889261e-9, 1.92312, -0.04979718, 1.040693, 0.1558103, -2.85248, 0.2420691, -0.9968383, -0.1200648, 1.324342, -0.9430889, 0.1931098, 0.4436916, -0.07320456, 4.215931, 0.7898019, -1.078185, -0.1718192, -1.720191, 2.358918, 0.02765637, 1.260245, 0.2021941, 3.395483, 0.5173628, -1.353023, -0.4813523, -31.0492, 31.40156, -9510741e-9, 0.554203, 8135471e-9, 3.136646, 0.5215989, -1.624704, -0.7990201, -21.67125, 22.46341, -0.01163533, 0.5415746, 0.02618378, 1.139214, 0.3444357, -0.798361, 0.1417476, 9.914841, -10.81503, -0.01218845, 0.3411392, -0.06137698, 7.445848, 1.18008, -1.266679, -0.4288977, -5.818701, 6.986437, -0.08180711, 1.397403, 0.2016916, -1.275731, 0.2592773, -1.009707, -0.1537754, 3.496378, -3.013726, 0.242115, -0.2831925, 0.03003395, 3.702862, 0.774632, -1.075646, -0.1768747, -1.347762, 1.989004, 0.01375836, 1.76481, 0.1330018, 3.230864, 0.662621, -1.375269, -0.5103569, -34.42661, 34.78703, -8460009e-9, 0.5408643, 4813323e-9, 3.016078, 0.5062069, -1.821679, -0.9766461, -19.26488, 19.97912, -9822567e-9, 0.3649556, 0.04316092, 0.893019, 0.4166527, -0.6633542, 0.1997841, 2.395592, -3.117175, -0.01080884, 0.8983814, -0.1375825, 6.673463, 1.115663, -1.30324, -0.3612712, 0.08292959, 0.3381364, -0.06078648, 0.3229247, 0.3680987, 0.7046755, 0.3144924, -0.9952598, -0.2039076, 0.4026851, 0.2686684, 0.1640712, 0.5186341, -0.0120552, 2.659613, 0.8030394, -1.098579, -0.2151992, 0.6558198, -74369e-8, -1421817e-9, 1.073701, 0.1886875, 2.536857, 0.6673923, -1.457986, -0.5906842, -38.12464, 38.38539, -6024357e-9, 0.4741484, 0.01209223, 2.818432, 0.5012433, -1.835728, -1.003405, -6.848129, 7.601943, -0.01277375, 0.4785598, 0.03366853, 1.097701, 0.4636635, -0.8491348, 9466365e-9, -2.685226, 2.00406, -0.01168708, 0.6752316, -0.1543371, 5.674759, 1.039534, -1.083379, -0.150679, 0.7328236, -0.5095568, -0.08609153, 0.444882, 0.4174662, 1.481556, 0.3942551, -1.117089, -0.3337605, 0.2502281, 0.4036323, 0.2673899, 0.2829817, 0.0224245, 2.043207, 0.7706902, -1.071648, -0.21262, 0.6069466, -145629e-8, -0.551596, 1.046755, 0.1985021, 2.290245, 0.6876058, -1.483903, -0.6309647, -43.80213, 44.10537, -5712161e-9, 0.5195992, 2028428e-9, 2.687114, 0.5098321, -2.053976, -1.141473, 0.5109183, 0.08060391, -0.01033983, 0.4066532, 0.04869627, 1.161722, 0.4039525, -0.6348185, 0.07651292, -10.31327, 10.07598, -0.02083688, 0.7359516, -0.2029459, 5.013257, 1.077649, -1.22863, -0.1650496, 0.04077157, -0.7189167, -0.0509222, 0.2959814, 0.5111496, 2.540433, 0.361533, -1.041883, -0.3278413, -0.06691911, 1.307364, 0.2166663, 0.3000595, -3157136e-9, 1.389208, 0.7999026, -1.103556, -0.2443602, 0.4705347, -9296482e-10, -0.530992, 0.9654511, 0.2142587, 2.244723, 0.6839976, -1.555684, -0.6962113, -46.47983, 46.7427, -5034895e-9, 0.475509, -9502561e-13, 2.626569, 0.5056194, -1.998288, -1.12472, -1.629586, 2.187993, -8284384e-9, 0.3845258, 0.0572624, 1.185644, 0.4255812, -1.03257, -0.251385, -3.721112, 3.506967, -0.02186561, 0.9436049, -0.2451412, 4.725724, 1.039256, -0.8597532, 0.09073332, -2.553741, 1.993237, -0.04390891, -0.2046928, 0.5515623, 1.909127, 0.3948212, -1.210482, -0.4477622, -0.2267805, 1.219488, 0.1336186, 0.6866897, 0.02808997, 1.600403, 0.7816409, -1.078168, -0.2699261, 0.2537282, 0.3820684, -0.4425103, 0.5298235, 0.2185217, 1.728679, 0.6882743, -1.697968, -0.8391488, -57.90105, 58.1412, -340476e-8, 0.426514, -1796301e-12, 2.368442, 0.5324429, -2.141552, -1.17223, 16.77872, -16.4147, -5732425e-9, 0.2002199, 0.06841834, 1.485338, 0.3215763, -1.442946, -0.7264245, -9.503706, 9.650462, -0.02120995, 1.419263, -0.2893098, 3.860731, 1.120857, -0.5696752, 0.3411279, -0.2931035, -0.6512552, -0.1068437, -1.085661, 0.6107549, 1.459503, 0.3210336, -1.313839, -0.5921371, -0.2332222, 1.648196, 0.2492787, 1.381033, -0.01993392, 0.981256, 0.8316329, -1.087464, -0.3195534, 0.2902095, 0.3383709, -0.8798482, 0.01494668, 0.2529703, 1.452644, 0.669387, -2.068582, -1.118605, -50.81598, 50.97486, -3280669e-9, 0.4067371, -2544951e-12, 2.179497, 0.5778017, -1.744693, -0.8537207, 22.34361, -22.08318, -5932616e-9, 0.1035049, 0.05742772, 1.97788, 0.2124846, -3.287515, -2.140268, -12.49566, 12.40091, -0.02409349, 1.397821, -0.2371627, 2.771192, 1.170496, 0.5502311, 1.04663, 2.193517, -2.2204, -0.1064394, -1.017926, 0.4795457, 1.030644, 0.3177516, -1.719734, -0.9536198, -0.6586821, 1.386361, -0.02513065, 1.187011, 0.06542539, 0.5296055, 0.808266, -1.0057, -0.3028096, 0.04470957, 1.00776, -0.8119016, 0.03153338, 0.2311321, 1.182208, 0.6824758, -2.728867, -1.580388, -30.79627, 30.92586, -4197673e-9, 0.3154759, -3897675e-12, 1.920567, 0.6664791, -1.322495, -0.7249275, 14.7766, -14.68154, -9044857e-9, 0.05624314, 0.06498392, 2.047389, 0.0636754, -6.102376, -3.473018, -9.926071, 9.637797, -0.01097909, 1.103498, -0.2424521, 2.520748, 1.24026, 1.351796, 1.018588, 2.009081, -1.333394, -0.1979125, -0.3318292, 0.4476624, 0.9095235, 0.2955611, -1.774467, -1.07988, -0.0808468, 0.2577697, -0.1149295, 0.4975303, 2931611e-9, -0.3803171, 0.8002794, -0.9898401, -0.2542513, -0.07530911, 1.870355, -1.521918, 0.2405164, 0.2964615, 1.3348, 0.6789053, -1.27973, -0.4290674, -42.77972, 43.43305, -6541826e-9, 0.4945086, 0.01425338, 2.685244, 0.5011313, -1.449506, -0.5766374, -16.88496, 17.81118, -0.01121649, 0.354502, 0.02287338, 1.904281, 0.4936998, -1.02198, -0.1897574, 2.482462, -2.941725, -0.01570448, 0.7532578, -0.042568, 5.23966, 0.4983116, -1.162608, -0.3428049, 3.974358, -1.527935, -0.03919201, 0.8758593, 0.07291363, -3.455257, 0.8007426, -0.9929985, -0.08712006, -0.7397313, 1.348372, 0.09511685, 0.3233584, -0.07549148, 5.806452, 0.4990042, -1.084996, -0.1739767, 0.1580475, 0.908818, 0.06871433, 0.5933079, 0.1188921, 3.074079, 0.4999327, -1.317009, -0.4661946, -42.55347, 43.12782, -5727235e-9, 0.4285447, 0.02189854, 2.60831, 0.51907, -1.469236, -0.6282139, -12.41404, 13.48765, -0.0120477, 0.5070285, -7280216e-10, 1.491533, 0.3635064, -0.9713808, -0.08138038, 0.3709854, -1.041174, -0.01814075, 0.506086, -0.02053756, 6.161431, 1.093736, -1.159057, -0.3698074, 2.711209, -0.6006479, -0.04896926, 0.9273957, 0.1137712, -3.496828, 0.2867109, -1.011601, -0.0820189, 0.2105725, 0.459752, 0.1478925, 0.213894, -0.0566067, 6.057755, 0.7859121, -1.07802, -0.181158, 0.1646622, 0.8348426, 0.1149064, 0.4985738, 0.1376605, 2.746607, 0.4999626, -1.325672, -0.4769313, -41.11215, 41.68293, -6274997e-9, 0.4649469, 0.01119411, 2.631267, 0.5234546, -1.619391, -0.8000253, -15.34098, 16.32706, -0.01012023, 0.4242255, 0.02931597, 0.8925807, 0.3314765, -0.7356979, 0.1368406, 2.972579, -3.535359, -0.01318948, 0.460762, -0.07182778, 6.2541, 1.236299, -1.316217, -0.4194427, 0.03489902, 1.289849, -0.0475596, 1.138222, 0.1975992, -0.8991542, 0.2290572, -0.9502188, -0.1172703, 1.405202, -0.3061919, 0.1058772, -0.3760592, -0.01983179, 3.562353, 0.7895959, -1.100117, -0.1900567, 0.492503, 0.5250225, 0.1576804, 1.042701, 0.07330743, 2.796064, 0.6749783, -1.354183, -0.5130625, -42.19268, 42.71772, -5365373e-9, 0.4136743, 0.01235172, 2.520122, 0.5187269, -1.741434, -0.9589761, -8.230339, 9.296799, -9600162e-9, 0.4994969, 0.02955452, 0.3667099, 0.3526999, -0.6917347, 0.2154887, -0.8760264, 0.2334121, -0.01909621, 0.4748033, -0.1138514, 6.51536, 1.225097, -1.293189, -0.42187, 1.620952, -0.7858597, -0.0376941, 0.6636786, 0.3364945, -0.5341017, 0.2128347, -0.9735521, -0.1325495, 1.007517, 0.2598258, 0.06762169, 1421018e-9, -0.06915987, 3.185897, 0.8641956, -1.0948, -0.1962062, 0.5755591, 0.2906259, 0.2625748, 0.7644049, 0.1347492, 2.677126, 0.646546, -1.393063, -0.5578338, -41.85249, 42.33504, -543564e-8, 0.4743765, 7422477e-9, 2.442801, 0.5211707, -1.939487, -1.128509, -8.974257, 9.978383, -7965597e-9, 0.294883, 0.04436763, 0.2839868, 0.3440424, -0.6011562, 0.2354877, -3.07982, 2.585094, -0.02002701, 0.7793909, -0.1598414, 5.834678, 1.202856, -1.315676, -0.3903446, 1.7019, -1.304609, -0.01045121, 0.2747707, 0.4143967, 0.3197102, 0.263758, -0.9618628, -0.1625841, 1.187138, 0.1497802, -5590954e-12, 0.03178475, -0.04153145, 2.496096, 0.8195082, -1.111554, -0.2365546, 0.7831875, 0.2018684, 0.2074369, 0.7395978, 0.122573, 1.876478, 0.6821167, -1.427879, -0.5994879, -35.31016, 35.81581, -6431497e-9, 0.4554192, 7348731e-10, 2.334619, 0.5233377, -1.998177, -1.206633, -21.4651, 22.42237, -5857596e-9, 0.2755663, 0.06384795, 0.1358244, 0.3328437, -0.644063, 0.2058571, 2.155499, -2.587968, -0.01840023, 0.8826555, -0.2222452, 5.847073, 1.228387, -1.229071, -0.3360441, -0.3429599, 0.6179469, 202961e-8, 0.08899319, 0.5041624, 0.1882964, 0.225204, -1.022905, -0.2101621, 1.915689, -0.6498794, -0.03463651, 0.08954605, -0.06797854, 2.417705, 0.8568618, -1.082538, -0.2007723, 0.4731009, 0.4077267, 0.1324289, 0.651488, 0.1702912, 2.309383, 0.6600895, -1.472139, -0.6499815, -34.28465, 34.69659, -5747023e-9, 0.4174167, 1688597e-9, 2.323046, 0.5395191, -2.161176, -1.353089, -22.26827, 23.29138, -5583808e-9, 0.2364793, 0.06096656, 1944666e-9, 0.2861624, -0.6593044, 0.1393558, 4.698373, -5.193883, -0.0199839, 1.095635, -0.2391254, 5.598103, 1.236193, -1.195717, -0.2972715, 0.04648953, 0.3024588, 5003313e-9, -0.3754741, 0.5247265, -0.1381312, 0.2493896, -1.020139, -0.2253524, 0.3548437, 0.7030485, -0.02107076, 0.4581395, -0.03243757, 2.453259, 0.8323623, -1.09877, -0.243578, 0.8761614, 0.1941613, -0.1990692, 0.3761139, 0.1657412, 1.590503, 0.6741417, -1.648007, -0.8205121, -44.35106, 44.79801, -4181353e-9, 0.385483, -1842385e-12, 2.000281, 0.5518363, -2.140986, -1.282239, -3.979213, 4.672459, -5008582e-9, 0.242192, 0.06253602, 0.6612713, 0.2555851, -1.300502, -0.5137898, 0.5179821, -0.4032341, -0.02066785, 1.087929, -0.2615309, 4.225887, 1.229237, -0.696334, 0.0924106, 0.06936356, -0.3588571, -0.05461843, -0.5616643, 0.5484166, -0.04776267, 0.2414935, -1.233179, -0.4325498, 0.6479813, 0.8368356, 0.2458875, 0.6464752, -0.02897097, 1.561773, 0.8518598, -1.051023, -0.253369, 1.004294, 0.3028083, -1.520108, 0.1607013, 0.1619975, 1.131094, 0.6706655, -1.948249, -1.097383, -44.53697, 44.94902, -3579939e-9, 0.3491605, -2500253e-12, 1.740442, 0.6188022, -2.154253, -1.209559, 4.144894, -3.562411, -5638843e-9, 0.1067169, 0.07594858, 1.00528, 0.1072543, -2.513259, -1.507208, -1.602979, 1.404154, -556075e-8, 1.24049, -0.2852117, 3.485252, 1.349321, -0.07832214, 0.3655626, 0.3856288, 0.6867894, -0.1609523, -0.6704306, 0.5357301, -0.6457935, 0.1479503, -1.354784, -0.5454375, 0.8797469, -1.466514, 0.713442, 0.5934903, -0.02911178, 0.8643737, 0.9030724, -1.048324, -0.2738736, 0.8783074, 3.246188, -4.435369, 0.1251791, 0.1783486, 1.064657, 0.6522878, -2.770408, -1.618911, -25.04031, 25.31674, -4239279e-9, 0.3241013, -3764484e-12, 1.586843, 0.7035906, -1.9135, -1.144014, -10.80587, 11.53677, -0.01003197, 0.1577515, 0.05217789, 1.225278, 5172771e-9, -5.293208, -2.876463, 2.087053, -3.201552, 3892964e-9, 0.532393, -0.2034512, 2.61776, 1.273597, 0.906034, 0.3773409, -0.6399945, 3.213979, -0.09112172, 0.6494055, 0.395328, 0.5047796, 0.2998695, -1.482179, -0.677831, 1.161775, -3.004872, 0.4774797, -0.4969248, -3512074e-9, -1.30719, 0.7927378, -0.9863181, -0.1803364, 0.5810824, 4.58057, -3.863454, 0.5328174, 0.2272821, 1.771114, 0.6791814];
var datasetXYZRad1 = [1.560219, 1.417388, 1.206927, 10.91949, 5.931416, 7.304788, 1.533049, 1.560532, 0.3685059, 13.5504, 5.543711, 7.792189, 1.471043, 1.746088, -0.9299697, 17.20362, 5.473384, 8.336416, 1.355991, 2.109348, -3.295855, 22.64843, 5.454607, 9.304656, 1.244963, 2.547533, -5.841485, 27.56879, 5.576104, 10.43287, 1.175532, 2.784634, -7.212225, 29.75347, 6.47298, 10.92331, 1.082973, 3.118094, -8.934293, 31.86879, 8.473885, 11.74019, 0.96925, 3.349574, -10.0381, 31.47654, 13.38931, 12.72547, 0.8547044, 3.151538, -9.095567, 25.54995, 22.73219, 14.10398, 0.758034, 2.311153, -5.170814, 12.29669, 36.86529, 15.98882, 1.664273, 1.574468, 1.422078, 9.768247, 14.47338, 16.44988, 1.638295, 1.719586, 0.5786675, 12.39846, 14.15419, 17.28605, 1.572623, 1.921559, -0.7714802, 16.09246, 14.20954, 18.25908, 1.468395, 2.21197, -2.845869, 20.75027, 15.24822, 19.37622, 1.355047, 2.556469, -4.96092, 24.60237, 16.4836, 20.65648, 1.291642, 2.742036, -6.061967, 26.02002, 18.19144, 21.16712, 1.194565, 2.97212, -7.295779, 26.91805, 21.2488, 22.01819, 1.083631, 3.047021, -7.766096, 24.96261, 27.44264, 22.91875, 0.9707994, 2.736459, -6.308284, 17.6086, 37.76291, 23.9215, 0.8574294, 1.865155, -2.364707, 4.337793, 50.92831, 25.23432];
var datasetXYZRad2 = [1.632341, 1.39523, 1.375634, 12.38193, 5.921102, 7.766508, 1.597115, 1.554617, 0.3932382, 15.05284, 5.725234, 8.158155, 1.522034, 1.844545, -1.322862, 19.18382, 5.440769, 8.837119, 1.403048, 2.290852, -4.013792, 24.851, 5.521888, 9.845547, 1.286364, 2.774498, -6.648221, 29.64151, 5.923777, 10.97075, 1.213544, 3.040195, -8.092676, 31.86082, 6.789782, 11.58899, 1.122622, 3.347465, -9.649016, 33.43824, 9.347715, 12.31374, 1.007356, 3.543858, -10.5352, 32.39842, 14.83962, 13.31718, 0.8956642, 3.2787, -9.254933, 25.57923, 24.89677, 14.76166, 0.7985143, 2.340404, -4.928274, 11.41787, 39.61501, 16.82448, 1.745162, 1.639467, 1.342721, 11.66033, 14.90124, 17.74031, 1.708439, 1.819144, 0.2834399, 14.48066, 14.59214, 18.58679, 1.63172, 2.094799, -1.378825, 18.43198, 14.63173, 19.62881, 1.516536, 2.438729, -3.624121, 22.98621, 15.99782, 20.70027, 1.405863, 2.785191, -5.705236, 26.45121, 17.6833, 21.91903, 1.344052, 2.951807, -6.683851, 27.44271, 19.85706, 22.29452, 1.245827, 3.182923, -7.82296, 27.91395, 23.27254, 23.1591, 1.132305, 3.202593, -8.008429, 25.21093, 30.00014, 24.05306, 1.02033, 2.820556, -6.238704, 17.09276, 40.77916, 25.09949, 0.903157, 1.863917, -1.955738, 3.032665, 54.3429, 26.4178];
var datasetXYZRad3 = [1.168084, 2.156455, -3.980314, 19.89302, 13.28335, 14.35621, 1.135488, 2.294701, -4.585886, 20.90208, 13.4784, 14.67658, 1.107408, 2.382765, -5.112357, 21.47823, 14.93128, 14.60882, 1.054193, 2.592891, -6.115, 22.68967, 16.35672, 15.18999, 1.006946, 2.70542, -6.69893, 22.9183, 18.34324, 15.70651, 0.9794044, 2.74244, -6.805283, 22.25271, 20.50797, 15.6313, 0.9413577, 2.722009, -6.760707, 20.98242, 23.42588, 16.05011, 0.8917923, 2.59278, -6.152635, 17.74141, 28.58324, 16.5791, 0.8288391, 2.153434, -4.118327, 10.78118, 36.8171, 17.38139, 0.7623528, 1.418187, -0.8845235, 0.7590129, 46.29859, 19.21657, 1.352858, 2.048862, -2.053393, 14.05874, 30.45344, 30.4443, 1.330497, 2.126497, -2.466296, 14.67559, 30.90738, 30.69707, 1.286344, 2.200436, -2.877228, 14.92701, 32.36288, 30.77223, 1.234428, 2.289628, -3.404699, 14.99436, 34.6839, 30.84842, 1.17866, 2.306071, -3.549159, 14.11006, 37.54188, 30.7973, 1.151366, 2.333005, -3.728627, 13.63374, 39.05894, 30.92599, 1.101593, 2.299422, -3.565787, 11.96745, 41.88472, 31.02755, 1.038322, 2.083539, -2.649585, 8.037389, 47.00869, 30.65948, 0.9596146, 1.67147, -0.8751538, 1.679772, 53.45784, 30.5452, 0.8640731, 0.9858301, 1.854956, -6.798097, 59.36468, 31.10255];
var HWCoeffsXYZ = [datasetXYZ1, datasetXYZ2, datasetXYZ3];
var HWCoeffsXYZRad = [datasetXYZRad1, datasetXYZRad2, datasetXYZRad3];
var HosekWilkieSkyTables = { getTableValue: function(e, t, n, o, r) {
  var i = 540 * t, a = 54 * (n - 1), s = 9 * o;
  return HWCoeffsXYZ[e][i + a + s + r];
}, getTableValueRad: function(e, t, n, o) {
  var r = 60 * t, i = 6 * (n - 1);
  return HWCoeffsXYZRad[e][r + i + o];
} };
var HW_MODEL_DIST_PARAMS_COUNT = 9;
function getDistParamValue(e, t, n, o, r) {
  return getSolElevCoeffs(e).reduce(function(e2, i, a) {
    return e2 + i * HosekWilkieSkyTables.getTableValue(t, n, o, a, r);
  }, 0);
}
function getRadianceValue(e, t, n, o) {
  return getSolElevCoeffs(e).reduce(function(e2, r, i) {
    return e2 + r * HosekWilkieSkyTables.getTableValueRad(t, n, o, i);
  }, 0);
}
function getSolElevCoeffs(e) {
  var t = Math.pow(2 * e / Math.PI, 1 / 3);
  return [Math.pow(1 - t, 5), 5 * Math.pow(1 - t, 4) * t, 10 * Math.pow(1 - t, 3) * Math.pow(t, 2), 10 * Math.pow(1 - t, 2) * Math.pow(t, 3), 5 * (1 - t) * Math.pow(t, 4), Math.pow(t, 5)];
}
var HosekWilkieSkyModelUtils = { getDistParams: function(e, t, n, o) {
  for (var r = new Array(HW_MODEL_DIST_PARAMS_COUNT), i = Math.trunc(e), a = e - i, s = 0; s < HW_MODEL_DIST_PARAMS_COUNT; s++) {
    var l = getDistParamValue(n, o, 0, i, s), c = getDistParamValue(n, o, 1, i, s);
    if (r[s] = (1 - t) * (1 - a) * l + t * (1 - a) * c, 10 != i) {
      var u = getDistParamValue(n, o, 0, i + 1, s), d = getDistParamValue(n, o, 1, i + 1, s);
      r[s] += (1 - t) * a * u + t * a * d;
    }
  }
  return r;
}, getRadiance: function(e, t, n, o) {
  var r = Math.trunc(e), i = e - r, a = (1 - t) * (1 - i) * getRadianceValue(n, o, 0, r) + t * (1 - i) * getRadianceValue(n, o, 1, r);
  10 != r && (a += (1 - t) * i * getRadianceValue(n, o, 0, r + 1) + t * i * getRadianceValue(n, o, 1, r + 1));
  return a;
} };
var LinearInterpolant = class extends Interpolant {
  constructor(e, t, n, o) {
    super(e, t, n, o);
  }
  interpolate_(e, t, n, o) {
    const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = (n - t) / (o - t), u = 1 - c;
    for (let e2 = 0; e2 !== a; ++e2) r[e2] = i[l + e2] * u + i[s + e2] * c;
    return r;
  }
};
var datasetDistLum = [0.1787, -1.463, -0.3554, 0.4275, -0.0227, 5.3251, 0.1206, -2.5771, -0.067, 0.3703];
var datasetDistx = [-0.0193, -0.2592, -0.0665, 8e-4, -4e-4, 0.2125, -0.0641, -0.8989, -33e-4, 0.0452];
var datasetDisty = [-0.0167, -0.2608, -0.095, 92e-4, -79e-4, 0.2102, -0.0441, -1.6537, -0.0109, 0.0529];
var datasetZenLum = [4.0453, -4.971, -0.2155, 2.4192];
var datasetZenx = [166e-5, -375e-5, 209e-5, 0, -0.02903, 0.06377, -0.03202, 394e-5, 0.11693, -0.21196, 0.06052, 0.25886];
var datasetZeny = [275e-5, -61e-4, 317e-5, 0, -0.04214, 0.0897, -0.04153, 516e-5, 0.15346, -0.26756, 0.0667, 0.26688];
var PreethamCoeffsDist = [datasetDistLum, datasetDistx, datasetDisty];
var PreethamCoeffsZenith = [datasetZenLum, datasetZenx, datasetZeny];
var PreethamSkyTables = { getTableValue: function(e, t, n) {
  return PreethamCoeffsDist[e][2 * t + n];
}, getTableDataZenith: function(e) {
  return PreethamCoeffsZenith[e];
} };
var DIST_PARAMS_COUNT = 5;
var LUM_COEFF = 0.06;
function perez_model(e, t, n) {
  return (1 + e[0] * Math.exp(e[1] / Math.cos(t))) * (1 + e[2] * Math.exp(e[3] * n) + e[4] * Math.pow(Math.cos(n), 2));
}
function luminance(e) {
  return 0.212671 * e + 0.71516 * e + 0.072169 * e;
}
var PreethamSkyModelUtils = { getDistParams: function(e, t) {
  for (var n = new Array(DIST_PARAMS_COUNT), o = 0; o < DIST_PARAMS_COUNT; o++) n[o] = PreethamSkyTables.getTableValue(t, o, 0) * e + PreethamSkyTables.getTableValue(t, o, 1);
  return n;
}, getZenithParams: function(e, t, n) {
  switch (n) {
    case 0:
      var o = PreethamSkyTables.getTableDataZenith(n), r = new Vector4(o[0], o[1], o[2], o[3]), i = Math.tan((4 / 9 - e / 120) * (Math.PI - 2 * t)), a = new Vector4(e * i, i, e, 1);
      return r.dot(a) * LUM_COEFF / perez_model(this.getDistParams(e, n), 0, t);
    case 1:
    case 2:
      o = PreethamSkyTables.getTableDataZenith(n);
      var s = Math.pow(t, 2), l = Math.pow(t, 3), c = o[0] * l + o[1] * s + o[2] * t + o[3], u = o[4] * l + o[5] * s + o[6] * t + o[7], d = o[8] * l + o[9] * s + o[10] * t + o[11];
      r = new Vector3(c, u, d);
      return new Vector3(Math.pow(e, 2), e, 1).dot(r) / perez_model(this.getDistParams(e, n), 0, t);
  }
}, getSunIlluminance: function(e, t) {
  var n = [0, 0, 0];
  if (e[1] < 0) return n;
  for (var o = [0.605, 0.54, 0.445], r = [12.25, 7.5, 0.3], i = 0.04608 * t - 0.04586, a = 1 / (e[1] + 0.15 * Math.pow(93.885 - Math.acos(e[1]) * (180 / Math.PI), -1.253)), s = [1.05513096, 0.993359745, 0.903543472], l = 0; l < 3; l++) {
    var c = Math.exp(8735e-6 * -a * Math.pow(o[l], -4.08)), u = Math.exp(-a * i * Math.pow(o[l], -1.3)), d = Math.exp(35e-4 * -r[l] * a);
    n[l] = 128e3 * s[l] / luminance(s[l]), n[l] *= c * u * d;
  }
  return n;
}, getSunIntegral: function(e, t, n, o) {
  var r = e, i = t, a = n;
  function s(e2) {
    return e2 * e2;
  }
  var l = 1 - cos(r), c = ((s(Math.PI) - 2 * s(r - i)) * cos(r) - s(Math.PI) * cos(i)) / (2 * (r - i + Math.PI) * (-r + i + Math.PI)), u = a * ((0.0892351 - 247875e-8 * s(a)) * sin(a) + cube(a) + 24 * a + 0.029745 * a * cos(a)) / s(s(a) + 36);
  return 2 * Math.PI * (l + c + o * u);
} };
var Spherical = class {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    const e = 1e-6;
    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(clamp(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var N_IN = { BACKGROUND_BL: { color: 0, strength: 1 }, BSDF_DIFFUSE_BL: { color: 0, roughness: 1, normal: 2 }, BSDF_GLOSSY_BL: { color: 0, roughness: 1, anisotropy: 2, rotation: 3, normal: 4, tangent: 5 }, BSDF_METALLIC_BL: { baseColor: 0, edgeTint: 1, ior: 2, extinction: 3, roughness: 4, anisotropy: 5, rotation: 6, normal: 7, tangent: 8 }, BSDF_PRINCIPLED_BL: { baseColor: 0, metallic: 1, roughness: 2, ior: 3, alpha: 4, normal: 5, diffuseRoughness: 6, subsurface: 7, subsurfaceRadius: 8, subsurfaceScale: 9, subsurfaceIor: 10, subsurfaceAnisotropy: 11, specularIORLevel: 12, specularTint: 13, anisotropic: 14, anisotropicRotation: 15, tangent: 16, transmission: 17, clearcoat: 18, clearcoatRoughness: 19, clearcoatIor: 20, clearcoatTint: 21, clearcoatNormal: 22, sheen: 23, sheenRoughness: 24, sheenTint: 25, emission: 26, emissionStrength: 27, thinFilmThickness: 28, thinFilmIOR: 29 }, BSDF_PRINCIPLED_BF43_BL: { baseColor: 0, metallic: 1, roughness: 2, ior: 3, alpha: 4, normal: 5, subsurface: 6, subsurfaceRadius: 7, subsurfaceScale: 8, subsurfaceIor: 9, subsurfaceAnisotropy: 10, specularIORLevel: 11, specularTint: 12, anisotropic: 13, anisotropicRotation: 14, tangent: 15, transmission: 16, clearcoat: 17, clearcoatRoughness: 18, clearcoatIor: 19, clearcoatTint: 20, clearcoatNormal: 21, sheen: 22, sheenRoughness: 23, sheenTint: 24, emission: 25, emissionStrength: 26 }, BSDF_PRINCIPLED_BF40_BL: { baseColor: 0, subsurface: 1, subsurfaceRadius: 2, subsurfaceColor: 3, subsurfaceIOR: 4, subsurfaceAnisotropy: 5, metallic: 6, specular: 7, specularTint: 8, roughness: 9, anisotropic: 10, anisotropicRotation: 11, sheen: 12, sheenTint: 13, clearcoat: 14, clearcoatRoughness: 15, ior: 16, transmission: 17, transmissionRoughness: 18, emission: 19, emissionStrength: 20, alpha: 21, normal: 22, clearcoatNormal: 23, tangent: 24 }, BSDF_TRANSLUCENT_BL: { color: 0, normal: 1 }, BSDF_TRANSPARENT_BL: { color: 0 }, DIFFUSE_BSDF_BL: { color: 0, roughness: 1, normal: 2 }, EEVEE_SPECULAR_BL: { baseColor: 0, specular: 1, roughness: 2, emissiveColor: 3, transparency: 4, normal: 5, clearcoat: 6, clearcoatRoughness: 7, clearcoatNormal: 8, ambientOcclusion: 9 }, EMISSION_BL: { color: 0, strength: 1 }, LIGHT_PATH_BL: {}, MIX_BL: { fac: 0, col1: 1, col2: 2 }, MIX_SHADER_BL: { fac: 0, color1: 1, color2: 2 }, NEW_GEOMETRY_BL: {}, NORMAL_MAP_BL: { strength: 0, normalColor: 1 }, OUTPUT_MATERIAL_BL: { surface: 0, volume: 1, displacement: 2, thickness: 3 }, OUTPUT_WORLD_BL: { surface: 0, volume: 1 }, RGB_BL: {}, SEPARATE_COLOR_BL: { color: 0 }, TEX_COORD_BL: {}, TEX_ENVIRONMENT_BL: { vector: 0 }, TEX_IMAGE_BL: { vector: 0 }, UVMAP_BL: { uv: 0 }, VALUE_BL: {}, BITMAP_MX: { uOffset: 0, vOffset: 1, uTiling: 2, vTiling: 3, wAngle: 4 }, BITMAP_ENV_MX: { uOffset: 0, vOffset: 1, uTiling: 2, vTiling: 3, wAngle: 4, normal: 5 }, FALLOFF_MX: { normal: 2 }, MATERIAL_MX: { ambientColor: 0, diffuseColor: 1, specularColor: 2, glossiness: 3, specularLevel: 4, selfIllum: 5, opacity: 6, filterColor: 7, normal: 8, reflection: 9, refraction: 10, displacement: 11 }, NORMAL_BUMP_MX: { normalColor: 0, additionalBump: 1, normalMult: 2, addBumpMult: 3 }, OPENPBR_SURFACE_MX: { baseWeight: 0, baseColor: 1, baseMetalness: 2, baseDiffuseRoughness: 3, specularWeight: 4, specularColor: 5, specularRoughness: 6, specularIOR: 7, transmissionWeight: 8, transmissionColor: 9, transmissionDepth: 10, fuzzWeight: 11, fuzzColor: 12, fuzzRoughness: 13, coatWeight: 14, coatColor: 15, coatRoughness: 16, emissionWeight: 17, emissionColor: 18, emissionLuminance: 19, geometryOpacity: 20, normal: 21, clearcoatNormal: 22 }, OUTPUT_MX: { color: 0 }, PHYSICAL_MX: { base: 0, baseColor: 1, reflectivity: 2, reflColor: 3, roughness: 4, metalness: 5, diffRoughness: 6, anisotropy: 7, anisoangle: 8, transparency: 9, transColor: 10, transRoughness: 11, ior: 12, scattering: 13, sssColor: 14, sssScale: 15, emission: 16, emitColor: 17, clearcoat: 18, clearcoatColor: 19, clearcoatRoughness: 20, normal: 21, clearcoatNormal: 22, displacement: 23, opacity: 24 }, REFLECT_REFRACT_MX: { normal: 0 }, RGB_MX: {}, SUB_TRANSFORM_MX: { scale: 0, rotate: 1, offset: 2 }, VALUE_MX: {}, BUMP_2D_MY: { bumpDepth: 0, bumpValue: 1 }, COLOR_CONSTANT_MY: { color: 0, alpha: 1 }, FILE_MY: { uvCoord: 0 }, FLOAT_CONSTANT_MY: { value: 0 }, LAMBERT_MY: { color: 0, ambientColor: 1, incandescence: 2, matteOpacity: 3, diffuse: 4, normal: 5, translucence: 6, transparency: 7 }, OPENPBR_SURFACE_MY: { baseWeight: 0, baseColor: 1, baseDiffuseRoughness: 2, baseMetalness: 3, specularWeight: 4, specularColor: 5, specularRoughness: 6, specularIOR: 7, transmissionWeight: 8, transmissionColor: 9, transmissionDepth: 10, transmissionScatter: 11, fuzzWeight: 12, fuzzColor: 13, fuzzRoughness: 14, coatWeight: 15, coatColor: 16, coatRoughness: 17, emissionLuminance: 18, emissionColor: 19, geometryOpacity: 20, normal: 21 }, PLACE_2D_TEXTURE_MY: { offset: 0, repeatUv: 1, rotateUv: 2 }, RAMP_MY: { uvCoord: 0 }, SAMPLER_INFO_MY: { viewNorm: 0 }, SHADING_ENGINE_MY: { surface: 0, volume: 1, displacement: 2 }, SUB_TRANSFORM_MY: { scale: 0, rotate: 1, offset: 2 }, SURFACE_SHADER_MY: { color: 0, glowColor: 1, matteOpacity: 2, transparency: 3 }, IMAGE_AR: { multiply: 0, offset: 1, uvcoords: 2, soffset: 3, toffset: 4, sscale: 5, tscale: 6, sflip: 7, tflip: 8, swapSt: 9, duvdx: 10, duvdy: 11 }, LAMBERT_AR: { base: 0, baseColor: 1, normalCamera: 2, opacity: 3 }, MAP_TO_MTL_AR: { color: 0 }, NORMAL_MAP_AR: { inputVal: 0, normal: 1, strength: 2, tangent: 3 }, STANDARD_SURFACE_AR: { base: 0, baseColor: 1, diffuseRoughness: 2, metalness: 3, specular: 4, specularColor: 5, specularRoughness: 6, trans: 7, transColor: 8, transDepth: 9, transScatter: 10, transExtraRoughness: 11, subsurface: 12, subsurfaceColor: 13, subsurfaceRadius: 14, clearcoat: 15, clearcoatColor: 16, clearcoatRoughness: 17, sheen: 18, sheenColor: 19, sheenRoughness: 20, emission: 21, emissionColor: 22, opacity: 23, normal: 24, clearcoatNormal: 25, specularIOR: 26 }, TRIPLANAR_AR: { inputColor: 0, inputColorY: 1, inputColorZ: 2, scale: 3, rotate: 4, offset: 5, normal: 6 }, TRIPLANAR_UV_AR: { vector: 0, normal: 1 }, UV_PROJECTION_AR: { projectionColor: 0, uAngle: 1, vAngle: 2, matrix: 3 }, NORMAL: {}, RGB_ALPHA: {}, VALUE: {} };
var N_OUT = { BACKGROUND_BL: { color: 0 }, BSDF_DIFFUSE_BL: { color: 0 }, BSDF_GLOSSY_BL: { color: 0 }, BSDF_METALLIC_BL: { color: 0 }, BSDF_PRINCIPLED_BL: { color: 0 }, BSDF_PRINCIPLED_BF40_BL: { color: 0 }, BSDF_TRANSLUCENT_BL: { color: 0 }, BSDF_TRANSPARENT_BL: { color: 0 }, EEVEE_SPECULAR_BL: { color: 0 }, EMISSION_BL: { color: 0 }, DIFFUSE_BSDF_BL: { color: 0 }, LIGHT_PATH_BL: { isCameraRay: 0, isShadowRay: 1, isDiffuseRay: 2, isGlossyRay: 3, isSingularRay: 4, isReflectionRay: 5, isTransmissionRay: 6, rayLength: 7, rayDepth: 8, diffuseDepth: 9, glossyDepth: 10, transparentDepth: 11, transmissionDepth: 12 }, MIX_BL: { col: 0 }, MIX_SHADER_BL: { color: 0 }, NEW_GEOMETRY_BL: { position: 0, normal: 1, tangent: 2, trueNormal: 3, incoming: 4, parametric: 5, backfacing: 6, pointiness: 7, randomPerIsland: 8 }, NORMAL_MAP_BL: { normal: 0 }, OUTPUT_MATERIAL_BL: { outgoingLight: 0 }, OUTPUT_WORLD_BL: { outgoingLight: 0 }, RGB_BL: { color: 0 }, SEPARATE_COLOR_BL: { r: 0, g: 1, b: 2 }, TEX_COORD_BL: { generated: 0, normal: 1, uv: 2, object: 3, camera: 4, window: 5, reflection: 6 }, TEX_ENVIRONMENT_BL: { color: 0 }, TEX_IMAGE_BL: { color: 0, alpha: 0 }, UVMAP_BL: { uv: 0 }, VALUE_BL: { value: 0 }, BITMAP_MX: { color: 0, value: 1 }, BITMAP_ENV_MX: { color: 0, value: 1 }, FALLOFF_MX: { color: 0 }, MATERIAL_MX: { color: 0 }, NORMAL_BUMP_MX: { normal: 0 }, OPENPBR_SURFACE_MX: { color: 0 }, OUTPUT_MX: { outgoingLight: 0 }, PHYSICAL_MX: { color: 0 }, RGB_MX: { color: 0 }, REFLECT_REFRACT_MX: { color: 0 }, SUB_TRANSFORM_MX: { vector: 0, normal: 1 }, VALUE_MX: { value: 0 }, BUMP_2D_MY: { normal: 0 }, COLOR_CONSTANT_MY: { color: 0, alpha: 1 }, FILE_MY: { alpha: 0, color: 1, size: 2, transparency: 3 }, FLOAT_CONSTANT_MY: { value: 0 }, LAMBERT_MY: { color: 0 }, OPENPBR_SURFACE_MY: { color: 0 }, PLACE_2D_TEXTURE_MY: { uv: 0 }, RAMP_MY: { alpha: 0, color: 1 }, SAMPLER_INFO_MY: { facingRatio: 0, flippedNormal: 1, matrixEyeToWorld: 2, normalCamera: 3, pixelCenter: 4, pointCamera: 5, pointObj: 6, pointWorld: 7, tangentUCamera: 8, tangentVCamera: 9, uvCoord: 10 }, SHADING_ENGINE_MY: { outgoingLight: 0 }, SUB_TRANSFORM_MY: { vector: 0, normal: 1 }, SURFACE_SHADER_MY: { color: 0, glowColor: 1, matteOpacity: 2, transparency: 3 }, IMAGE_AR: { color: 0, alpha: 1, transparency: 2 }, LAMBERT_AR: { color: 0, alpha: 1, transparency: 2 }, MAP_TO_MTL_AR: { color: 0 }, NORMAL_MAP_AR: { value: 0 }, STANDARD_SURFACE_AR: { color: 0, transparency: 1 }, TRIPLANAR_AR: { color: 0 }, TRIPLANAR_UV_AR: { uv: 0, duvdx: 1, duvdy: 2 }, UV_PROJECTION_AR: { uv: 0 }, NORMAL: { normal: 0 }, RGB_ALPHA: { color: 0, alpha: 1 }, VALUE: { value: 0 } };
function createNode(e, t = "", n = {}) {
  let o;
  switch (e) {
    case "BACKGROUND_BL":
      o = { inputs: [[0, 0, 0, 1], 1], outputs: [[0, 0, 0, 0]] };
      break;
    case "BSDF_DIFFUSE_BL":
    case "DIFFUSE_BSDF_BL":
      o = { inputs: [[0.8, 0.8, 0.8, 1], 0, [0, 0, 0]], outputs: [[0, 0, 0, 0]] };
      break;
    case "BSDF_PRINCIPLED_BL":
      o = { inputs: [[0.8, 0.8, 0.8, 1], 0, 0.5, 1.5, 1, [0, 0, 0], 0, [1, 0.2, 0.1], 0.05, 1.4, 0, 0.5, [1, 1, 1, 1], 0, 0, [0, 0, 0], 0, 0, 0.03, 1.5, [1, 1, 1, 1], [0, 0, 0], 0, 0.5, [0, 0, 0, 1], [1, 1, 1, 1], 0], outputs: [[0, 0, 0, 0]] };
      break;
    case "BSDF_TRANSPARENT_BL":
      o = { inputs: [[1, 1, 1, 1]], outputs: [[0, 0, 0, 0]] };
      break;
    case "LIGHT_PATH_BL":
      o = { inputs: [], outputs: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      break;
    case "MIX_BL":
      o = { dataType: "RGBA", clampFactor: true, blendType: "MIX", clampResult: false, factorMode: "UNIFORM", inputs: [0.5, [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]], outputs: [[0, 0, 0, 0]] };
      break;
    case "MIX_SHADER_BL":
      o = { inputs: [0.5, [0, 0, 0, 0], [0, 0, 0, 0]], outputs: [[0, 0, 0, 0]] };
      break;
    case "OUTPUT_MATERIAL_BL":
      o = { inputs: [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0], 0], outputs: [] };
      break;
    case "OUTPUT_WORLD_BL":
      o = { inputs: [[0, 0, 0, 1], [0, 0, 0, 0]], outputs: [] };
      break;
    case "RGB_BL":
      o = { inputs: [], outputs: [[0.5, 0.5, 0.5, 1]] };
      break;
    case "TEX_ENVIRONMENT_BL":
      o = { projection: "EQUIRECTANGULAR", texture: -1, inputs: [[0, 0, 0]], outputs: [[0, 0, 0, 0]] };
      break;
    case "TEX_IMAGE_BL":
      o = { alphaMode: "STRAIGHT", clampToEdgeNoExtend: false, projection: "FLAT", projectionBlend: 0, texture: -1, inputs: [[0, 0, 0]], outputs: [[0, 0, 0, 0], 0] };
      break;
    case "UVMAP_BL":
      o = { uvLayer: "", inputs: [], outputs: [[0, 0, 0]] };
      break;
    case "VALUE_BL":
    case "VALUE_MX":
    case "VALUE":
      o = { inputs: [], outputs: [0] };
      break;
    case "BITMAP_MX":
      o = { alphaAsMono: false, alphaAsRGB: false, alphaSource: "NONE", axis: "XY", clampToEdgeNoExtend: [false, false], mapping: "EXPLICIT_MAP_CHANNEL", texture: -1, uvIndex: 0, inputs: [0, 0, 1, 1, 0], outputs: [[0, 0, 0, 0]] };
      break;
    case "PHYSICAL_MX":
      o = { brdfCurve: 5, brdfHigh: 1, brdfLow: 0.05, brdfMode: true, emitLuminance: 1500, roughnessInv: false, thinWalled: false, transRoughnessInv: false, transRoughnessLock: true, inputFactors: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], inputs: [1, [1, 1, 1, 1], 1, [1, 1, 1, 1], 0.5, 0, 0, 0, 0, 0, [1, 1, 1, 1], 0, 1.5, 0, [0, 0, 0, 0], 0, 0, [1, 1, 1, 1], 0, [1, 1, 1, 1], 0, [0, 0, 0], [0, 0, 0], 0, 1], outputs: [[0, 0, 0, 0]] };
      break;
    case "OUTPUT_MX":
      o = { inputs: [[0, 0, 0, 0]], outputs: [] };
      break;
    case "RGB_MX":
      o = { inputs: [], outputs: [[0, 0, 0, 1]] };
      break;
    case "COLOR_CONSTANT_MY":
      o = { inputs: [[0, 0, 0], 1], outputs: [[0, 0, 0], 0] };
      break;
    case "FILE_MY":
      o = { fileHasAlpha: false, texture: -1, inputs: [[0, 0]], outputs: [1, [0, 0, 0], [2048, 2048], [0, 0, 0]] };
      break;
    case "FLOAT_CONSTANT_MY":
      o = { inputs: [0], outputs: [0] };
      break;
    case "LAMBERT_MY":
      o = { inputs: [[0.5, 0.5, 0.5], [0, 0, 0], [0, 0, 0], 1, 0.8, [0, 0, 0], 0, [0, 0, 0]], outputs: [[0, 0, 0, 0]] };
      break;
    case "PLACE_2D_TEXTURE_MY":
      o = { uvIndex: 0, inputs: [[0, 0], [1, 1], 0], outputs: [[0, 0]] };
      break;
    case "SHADING_ENGINE_MY":
      o = { inputs: [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0]], outputs: [] };
      break;
    case "LAMBERT_AR":
      o = { inputs: [0.7, [1, 1, 1], [0, 0, 0], [0, 0, 0]], outputs: [[0, 0, 0, 0], 0, [0, 0, 0]] };
      break;
    case "STANDARD_SURFACE_AR":
      o = { thinWalled: true, inputs: [1, [0.8, 0.8, 0.8], 0, 0, 1, [1, 1, 1], 0.2, 0, [0, 0, 0], 0, [0, 0, 0], 0, 0, [1, 1, 1], [1, 1, 1], 0, [1, 1, 1], 0.1, 0, [1, 1, 1], 0.3, 0, [1, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0], 1.5], outputs: [[0, 0, 0, 0], [0, 0, 0]] };
      break;
    case "RGB_ALPHA":
      o = { inputs: [], outputs: [[0, 0, 0], 1] };
      break;
    default:
      console.error("v3d.NodeUtils.createNode: Invalid node:", e);
  }
  return o ? (o.name = t, o.type = e, ["OUTPUT_MATERIAL_BL", "OUTPUT_WORLD_BL", "OUTPUT_MX", "SHADING_ENGINE_MY"].includes(e) ? o.is_active_output = true : o.is_active_output = false, Object.assign(o, n), { originData: o }) : void 0;
}
function getNodeType(e) {
  return e.originData.type;
}
function getNodeTypeCompat(e) {
  let t = getNodeType(e);
  const n = e.originData;
  if ("BSDF_PRINCIPLED_BL" == t) switch (n.inputs.length) {
    case 27:
    case 29:
      t = "BSDF_PRINCIPLED_BF43_BL";
      break;
    case 25:
      t = "BSDF_PRINCIPLED_BF40_BL";
  }
  if ("BSDF_GLOSSY_BL" == t && 3 === n.inputs.length) t = "BSDF_GLOSSY_BF40_BL";
  if ("BUMP_BL" == t && 6 === n.inputs.length) t = "BUMP_BF32_BL";
  return t;
}
function nodeOfType(e, t) {
  const n = getNodeType(e);
  return Array.isArray(t) ? t.includes(n) : t === n;
}
function firstNodeType(e, t) {
  for (let n = 0; n < e.len(); n++) {
    if (getNodeType(e.node(n)) == t) return n;
  }
  return -1;
}
function firstNodeName(e, t) {
  for (let n = 0; n < e.len(); n++) {
    if (e.node(n).originData.name == t) return n;
  }
  return -1;
}
function findConnectedNode(e, t, n, o = "") {
  if (!Number.isFinite(n)) return console.error("v3d.NodeUtils.findConnectedNode: Invalid input index"), null;
  "object" == typeof t && (t = e.nodeIndex(t));
  for (let r in e.edges) {
    const i = e.edges[r];
    if (i.to() == t) {
      const t2 = e.node(i.from());
      for (let e2 = 0; e2 < i.connections.length; e2++) {
        if (i.connections[e2].to === n && ("" === o || nodeOfType(t2, o))) return t2;
      }
    }
  }
  return null;
}
function findAllConnectedNodes(e, t, n, o = "") {
  if (!Number.isFinite(n)) return console.error("v3d.NodeUtils.findAllConnectedNodes: Invalid input index"), null;
  "object" == typeof t && (t = e.nodeIndex(t));
  const r = [];
  for (let i in e.edges) {
    const a = e.edges[i];
    if (a.to() == t) {
      const t2 = e.node(a.from());
      if (o && !nodeOfType(t2, o)) continue;
      for (let e2 = 0; e2 < a.connections.length; e2++) {
        const o2 = a.connections[e2];
        o2.to === n && r.push({ node: t2, nodeIdx: a.from(), outputIdx: o2.from, channelMatrix: o2.channelMatrix });
      }
    }
  }
  return r;
}
function isConnInput(e, t, n) {
  if (!Number.isFinite(n)) return console.error("v3d.NodeUtils.isConnInput: Invalid input index"), false;
  const o = e.findInEdges(t);
  for (let e2 = 0; e2 < o.length; e2++) {
    const t2 = o[e2];
    for (let e3 = 0; e3 < t2.connections.length; e3++) {
      if (t2.connections[e3].to == n) return true;
    }
  }
  return false;
}
function isConnOutput(e, t, n) {
  if (!Number.isFinite(n)) return console.error("v3d.NodeUtils.isConnOutput: Invalid output index"), false;
  for (let o in e.edges) {
    const r = e.edges[o];
    if (r.from() == t) for (let e2 = 0; e2 < r.connections.length; e2++) {
      if (r.connections[e2].from == n) return true;
    }
  }
  return false;
}
function connectNodes(e, t, n, o, r, i) {
  if (!Number.isFinite(n) || !Number.isFinite(r)) return void console.error("v3d.NodeUtils.connectNodes: Invalid input/output index");
  e.edge(t, o) || e.addNewEdge(t, o);
  const a = e.edge(t, o);
  a.connections = a.connections || [];
  const s = { from: n, to: r };
  i && (s.channelMatrix = i), a.connections.push(s);
}
function nodeTypeStripSuffix(e) {
  return e.endsWith("_AR") || e.endsWith("_BL") || e.endsWith("_MX") || e.endsWith("_MY") ? e.slice(0, -3) : e;
}
function nodeTexUniName(e, t) {
  return strToCamel("NODE_" + nodeTypeStripSuffix(e)) + "Uni" + t;
}
function nodeGraphClone(e) {
  const t = new DiGraph(e.len());
  for (let n = 0; n < t.len(); n++) nodeClone(e.node(n), t.node(n));
  for (let n in e.edges) {
    const o = e.edges[n];
    t.addNewEdge(o.from(), o.to()).connections = o.connections.slice();
  }
  return t;
}
function nodeClone(e, t) {
  t || (t = {}), t.originData = {};
  for (const n in e.originData) t.originData[n] = "texture" == n ? e.originData[n] : JSON.parse(JSON.stringify(e.originData[n]));
  return e.attributes && (t.attributes = JSON.parse(JSON.stringify(e.attributes))), e.params && (t.params = JSON.parse(JSON.stringify(e.params))), e.inputFactors && (t.inputFactors = e.inputFactors.slice(0)), e.inputs && (t.inputs = JSON.parse(JSON.stringify(e.inputs))), e.outputs && (t.outputs = JSON.parse(JSON.stringify(e.outputs))), t;
}
function cleanupGraph(e) {
  let t = -1;
  for (let n = 0; n < e.len(); n++) if (e.node(n).originData.is_active_output) {
    t = n;
    break;
  }
  if (-1 == t) e.removeAll();
  else {
    const n = new DepthFirstSearch(e.reverse(), t), o = [];
    for (let t2 = 0; t2 < e.len(); t2++) n.hasPathTo(t2) || o.push(e.node(t2));
    o.forEach(function(t2) {
      e.disconnect(e.nodeIndex(t2), true);
    });
  }
}
function disconnectInputNode(e, t, n, o = "") {
  if (!Number.isFinite(n)) return console.error("v3d.NodeUtils.disconnectInputNode: Invalid input index"), null;
  "object" == typeof t && (t = e.nodeIndex(t));
  for (let r in e.edges) {
    const i = e.edges[r];
    if (i.to() == t) {
      const r2 = e.node(i.from());
      if (o && !nodeOfType(r2, o)) continue;
      for (let o2 = 0; o2 < i.connections.length; o2++) {
        const a = i.connections[o2];
        if (a.to === n) return e.removeEdge(i.from(), t), { node: r2, outputIdx: a.from };
      }
    }
  }
  return null;
}
function disconnectOutputNode(e, t, n, o = "") {
  if (!Number.isFinite(n)) return console.error("v3d.NodeUtils.disconnectOutputNode: Invalid output index"), null;
  "object" == typeof t && (t = e.nodeIndex(t));
  for (let r in e.edges) {
    const i = e.edges[r];
    if (i.from() == t) {
      const r2 = e.node(i.to());
      if (o && !nodeOfType(r2, o)) continue;
      for (let o2 = 0; o2 < i.connections.length; o2++) {
        const a = i.connections[o2];
        if (a.from == n) return e.removeEdge(t, i.to()), { node: r2, inputIdx: a.to };
      }
    }
  }
  return null;
}
var MAX_LIGHT_INT_MULT = 1500 / Math.PI;
var DEFAULT_NORMAL_INPUT_NUM = { LAMBERT_AR: 2, STANDARD_SURFACE_AR: 24, BEVEL_BL: 1, BSDF_DIFFUSE_BL: 2, BSDF_GLASS_BL: 3, BSDF_GLOSSY_BL: 4, BSDF_GLOSSY_BF40_BL: 2, BSDF_METALLIC_BL: 7, BSDF_PRINCIPLED_BL: 5, BSDF_PRINCIPLED_BF43_BL: 5, BSDF_PRINCIPLED_BF40_BL: 22, BSDF_REFRACTION_BL: 3, BSDF_SHEEN_BL: 2, BSDF_TRANSLUCENT_BL: 1, BUMP_BL: 3, BUMP_BF32_BL: 5, DIFFUSE_BSDF_BL: 2, EEVEE_SPECULAR_BL: 5, FRESNEL_BL: 1, LAYER_WEIGHT_BL: 1, BLINN_MY: 5, LAMBERT_MY: 5, OPENPBR_SURFACE_MY: 21, PHONG_MY: 5, PHONG_E_MY: 5, SAMPLER_INFO_MY: 0 };
var STD_SHADER_NODES_BL = ["BSDF_DIFFUSE_BL", "BSDF_GLOSSY_BL", "BSDF_METALLIC_BL", "BSDF_PRINCIPLED_BL", "DIFFUSE_BSDF_BL", "EEVEE_SPECULAR_BL", "EMISSION_BL"];
var STD_SHADER_NODES_MX = ["PHYSICAL_MX", "LAMBERT_AR", "OPENPBR_SURFACE_MX", "STANDARD_SURFACE_AR", "MAP_TO_MTL_AR"];
var STD_SHADER_NODES_MY = ["STANDARD_SURFACE_AR", "LAMBERT_MY", "LAMBERT_AR", "OPENPBR_SURFACE_MY", "SURFACE_SHADER_MY"];
var STD_PROP_DEFAULTS = { color: new Color(16777215), map: null, opacity: 1, alphaMap: null, metalness: 0.5, metalnessMap: null, roughness: 0.5, roughnessMap: null, normalMap: null, normalScale: new Vector2(1, 1), aoMap: null, aoMapIntensity: 1, emissive: new Color(0), emissiveMap: null, emissiveIntensity: 0 };
var MeshNodeMaterial = class extends Material {
  constructor(e) {
    super();
    const t = this;
    function n(e2, t2) {
      const n2 = e2.node(t2);
      n2.originData.type;
      for (let r2 = 0; r2 < n2.originData.inputs.length; r2++) o(e2, t2, n2.originData, r2);
    }
    function o(e2, t2, n2, o2, r2) {
      if (isConnInput(e2, t2, o2)) return false;
      const i2 = n2.name + " " + (r2 || "Input " + o2), a2 = n2.inputs[o2], s2 = w(a2);
      let l2, c2, u2 = n2.type.slice(-3);
      switch ("_BL" != u2 && "_MX" != u2 && (u2 = "float" == s2 ? "" : "_ALPHA"), s2) {
        case "float":
          l2 = createNode("VALUE" + u2, i2), c2 = N_OUT[getNodeType(l2)].value, l2.originData.outputs[c2] = a2;
          break;
        case "vec3":
          l2 = createNode("RGB" + u2, i2), c2 = N_OUT[getNodeType(l2)].color, l2.originData.outputs[c2][0] = a2[0], l2.originData.outputs[c2][1] = a2[1], l2.originData.outputs[c2][2] = a2[2];
          break;
        case "vec4":
          l2 = createNode("RGB" + u2, i2), c2 = N_OUT[getNodeType(l2)].color, l2.originData.outputs[c2][0] = a2[0], l2.originData.outputs[c2][1] = a2[1], l2.originData.outputs[c2][2] = a2[2], nodeOfType(l2, "RGB_ALPHA") ? l2.originData.outputs[N_OUT[getNodeType(l2)].alpha] = a2[3] : l2.originData.outputs[c2][3] = a2[3];
          break;
        default:
          throw new Error("Unsupported group input");
      }
      return e2.addNode(l2), connectNodes(e2, e2.len() - 1, c2, t2, o2), true;
    }
    function r(e2, t2, n2) {
      const o2 = { inputs: [], outputs: [], removedNodes: [] };
      o2.removedNodes.push(n2);
      const r2 = firstNodeType(t2, "GROUP_INPUT_BL");
      if (r2 > -1) {
        o2.removedNodes.push(r2 + e2.len());
        const i3 = e2.findInEdges(n2), s3 = t2.findOutEdges(r2);
        for (let e3 = 0; e3 < i3.length; e3++) {
          const t3 = i3[e3];
          for (let e4 = 0; e4 < s3.length; e4++) {
            const n3 = s3[e4];
            for (let e5 = 0; e5 < t3.connections.length; e5++) {
              const r3 = t3.connections[e5];
              for (let e6 = 0; e6 < n3.connections.length; e6++) {
                const i4 = n3.connections[e6];
                if (r3.to == i4.from) {
                  let e7 = a(o2.inputs, t3.from(), n3.to());
                  e7 || (e7 = new Edge(t3.from(), n3.to()), e7.connections = [], o2.inputs.push(e7));
                  const s4 = { from: r3.from, to: i4.to };
                  e7.connections.push(s4);
                }
              }
            }
          }
        }
      }
      const i2 = firstNodeType(t2, "GROUP_OUTPUT_BL");
      o2.removedNodes.push(i2 + e2.len());
      const s2 = e2.findOutEdges(n2), l2 = t2.findInEdges(i2);
      for (let e3 = 0; e3 < s2.length; e3++) {
        const t3 = s2[e3];
        for (let e4 = 0; e4 < l2.length; e4++) {
          const n3 = l2[e4];
          for (let e5 = 0; e5 < t3.connections.length; e5++) {
            const r3 = t3.connections[e5];
            for (let e6 = 0; e6 < n3.connections.length; e6++) {
              const i3 = n3.connections[e6];
              if (r3.from == i3.to) {
                let e7 = a(o2.outputs, n3.from(), t3.to());
                e7 || (e7 = new Edge(n3.from(), t3.to()), e7.connections = [], o2.outputs.push(e7));
                const s3 = { from: i3.from, to: r3.to };
                e7.connections.push(s3);
              }
            }
          }
        }
      }
      return o2;
    }
    function i(e2, t2) {
      Array.isArray(t2) || (t2 = [t2]);
      let n2 = 0;
      for (let o2 = 0; o2 < e2.len(); o2++) {
        const r2 = e2.node(o2);
        for (let e3 = 0; e3 < t2.length; e3++) {
          const o3 = t2[e3];
          r2.originData.type == o3 && n2++;
        }
      }
      return n2;
    }
    function a(e2, t2, n2) {
      for (let o2 = 0; o2 < e2.length; o2++) {
        const r2 = e2[o2];
        if (r2.from() == t2 && r2.to() == n2) return r2;
      }
      return null;
    }
    function s(e2, t2, n2) {
      const o2 = n2.type;
      let r2 = e2.findInEdges(t2);
      for (let i2 = 0; i2 < r2.length; i2++) {
        const a2 = r2[i2];
        let s2 = e2.node(a2.from()).originData;
        for (let d2 = 0; d2 < a2.connections.length; d2++) {
          const h2 = a2.connections[d2];
          if ("MATERIAL_MX" == o2 && c(s2.type) && (h2.to == N_IN[o2].reflection ? s2.reflectMode = "MAX_ENV_COORDS_REFLECT" : h2.to == N_IN[o2].refraction && (s2.reflectMode = "MAX_ENV_COORDS_REFRACT")), u(o2, h2.to)) {
            if ("BITMAP_MX" == s2.type || "OUTPUT_MAP_MX" == s2.type) {
              e2.removeEdge(a2.from(), a2.to()), "OUTPUT_MAP_MX" == s2.type && (s2 = findConnectedNode(e2, a2.from(), 0).originData);
              const n3 = { originData: { name: s2.name + "Bump" + i2, type: "BUMP_MX", texture: s2.texture, uvIndex: s2.uvIndex, inputs: JSON.parse(JSON.stringify(s2.inputs)), outputs: [[0, 0, 0]] } };
              e2.addNode(n3), connectNodes(e2, e2.len() - 1, 0, t2, h2.to), i2 = -1, r2 = e2.findInEdges(t2);
              break;
            }
            for (let t3 = 0; t3 < e2.len(); t3++) {
              const o3 = e2.node(t3).originData;
              if (l(o3.type)) {
                const r3 = o3.inputs.length - 1;
                connectNodes(e2, a2.from(), h2.from, t3, r3), o3.inputFactors[r3] = n2.inputFactors[h2.to];
              }
            }
          }
        }
      }
    }
    function l(e2) {
      return !(!c(e2) && "FALLOFF_MX" != e2);
    }
    function c(e2) {
      return "BITMAP_ENV_MX" == e2 || "REFLECT_REFRACT_MX" == e2;
    }
    function u(e2, t2) {
      switch (e2) {
        case "BITMAP_ENV_MX":
        case "FALLOFF_MX":
        case "MATERIAL_MX":
        case "REFLECT_REFRACT_MX":
          return t2 == N_IN[e2].normal;
        case "OPENPBR_SURFACE_MX":
        case "PHYSICAL_MX":
          return t2 == N_IN[e2].normal || t2 == N_IN[e2].clearcoatNormal;
        default:
          return false;
      }
    }
    function d(e2, t2, n2) {
      const o2 = n2.blendMode.length, r2 = e2.findInEdges(t2), i2 = e2.findOutEdges(t2);
      for (let t3 = 0; t3 < o2; t3++) {
        const o3 = { originData: { name: n2.name + "Layer" + t3, type: "COMPOSITE_LAYER_MX", blendMode: 0 != t3 ? n2.blendMode[t3] : 0, opacity: n2.opacity[t3], inputs: [[0, 0, 0, 0]].concat(n2.inputs.slice(2 * t3, 2 * t3 + 2)), outputs: [n2.outputs[t3]] } };
        e2.addNode(o3);
        for (let o4 = 0; o4 < r2.length; o4++) {
          const i3 = r2[o4];
          for (let o5 = 0; o5 < i3.connections.length; o5++) {
            const r3 = i3.connections[o5];
            r3.to == 2 * t3 && n2.mapEnabled[t3] ? connectNodes(e2, i3.from(), r3.from, e2.len() - 1, 1) : r3.to == 2 * t3 + 1 && n2.maskEnabled[t3] && connectNodes(e2, i3.from(), r3.from, e2.len() - 1, 2);
          }
        }
        t3 > 0 && connectNodes(e2, e2.len() - 2, 0, e2.len() - 1, 0);
      }
      for (let t3 = 0; t3 < i2.length; t3++) {
        const n3 = i2[t3];
        for (let t4 = 0; t4 < n3.connections.length; t4++) {
          const o3 = n3.connections[t4];
          connectNodes(e2, e2.len() - 1, 0, n3.to(), o3.to);
        }
      }
    }
    function h(e2, t2, n2) {
      const o2 = n2.output, r2 = e2.findInEdges(t2), i2 = e2.findOutEdges(t2), a2 = { originData: { name: n2.name + "Output", type: "OUTPUT_MAP_MX", invert: o2.invert, clamp: o2.clamp, alphaFromRGB: o2.alphaFromRGB, inputs: [[0, 0, 0, 0], o2.rgbLevel, o2.rgbOffset, o2.outputAmount, o2.bumpAmount], outputs: [[0, 0, 0, 0]] } };
      isDef(o2.colorMap) && (a2.originData.colorMap = o2.colorMap), e2.addNode(a2);
      for (let t3 = 0; t3 < i2.length; t3++) {
        const n3 = i2[t3];
        for (let t4 = 0; t4 < n3.connections.length; t4++) {
          const o3 = n3.connections[t4];
          connectNodes(e2, e2.len() - 1, 0, n3.to(), o3.to);
        }
      }
      e2.disconnect(t2, false);
      for (let t3 = 0; t3 < r2.length; t3++) e2.addEdge(r2[t3]);
      connectNodes(e2, t2, 0, e2.len() - 1, 0), delete n2.output;
    }
    function f(e2, t2, n2) {
      const o2 = n2.inputs.length / 4, r2 = e2.findInEdges(t2), i2 = e2.findOutEdges(t2);
      for (let t3 = 0; t3 < o2; t3++) {
        const o3 = { originData: { name: n2.name + "Layer" + t3, type: "LAYERED_TEXTURE_LAYER_MY", inputs: [0, [0, 0, 0]].concat(n2.inputs.slice(4 * t3, 4 * t3 + 4)), outputs: [0, [0, 0, 0]] } };
        e2.addNode(o3);
        for (let n3 = 0; n3 < r2.length; n3++) {
          const o4 = r2[n3];
          for (let n4 = 0; n4 < o4.connections.length; n4++) {
            const r3 = o4.connections[n4];
            r3.to == 4 * t3 ? connectNodes(e2, o4.from(), r3.from, e2.len() - 1, 2, r3.channelMatrix) : r3.to == 4 * t3 + 1 ? connectNodes(e2, o4.from(), r3.from, e2.len() - 1, 3, r3.channelMatrix) : r3.to == 4 * t3 + 2 ? connectNodes(e2, o4.from(), r3.from, e2.len() - 1, 4, r3.channelMatrix) : r3.to == 4 * t3 + 3 && connectNodes(e2, o4.from(), r3.from, e2.len() - 1, 5, r3.channelMatrix);
          }
        }
        t3 > 0 && (connectNodes(e2, e2.len() - 1, 0, e2.len() - 2, 0), connectNodes(e2, e2.len() - 1, 1, e2.len() - 2, 1));
      }
      for (let t3 = 0; t3 < i2.length; t3++) {
        const n3 = i2[t3];
        for (let t4 = 0; t4 < n3.connections.length; t4++) {
          const r3 = n3.connections[t4];
          connectNodes(e2, e2.len() - o2, r3.from, n3.to(), r3.to, r3.channelMatrix);
        }
      }
    }
    function p(e2) {
      return e2.type.indexOf("uniform") > -1;
    }
    function m(e2) {
      return e2.type.indexOf("varying") > -1;
    }
    function g(e2, n2) {
      return n2 = isDef(n2) ? n2 : "color", t.nodeVCAliases[e2] || n2;
    }
    function _(e2, t2, n2, o2) {
      const r2 = new DataTexture(e2, t2, 1, n2, o2, Texture.DEFAULT_MAPPING, 1001, 1001, 1006, 1006);
      return r2.name = "Node.parametric", r2.needsUpdate = true, r2;
    }
    function A(e2) {
      return true === e2.isVideoTexture && 3001 === e2.encoding ? "1" : !e2.isDataTexture || 3001 !== e2.encoding || 1015 != e2.type && 1016 != e2.type ? "0" : "1";
    }
    function v(e2, t2, n2, o2, r2) {
      let i2;
      return t2 == n2 ? i2 = e2 : "float" == t2 && "vec3" == n2 ? i2 = "vec3(" + [e2, e2, e2].join(",") + ")" : "float" == t2 && "vec4" == n2 ? i2 = "vec4(" + [e2, e2, e2, e2].join(",") + ")" : "vec3" == t2 && "float" == n2 || "vec4" == t2 && "float" == n2 ? i2 = "(" + [e2 + "[0]", e2 + "[1]", e2 + "[2]"].join("+") + ")/3.0" : "vec3" == t2 && "vec4" == n2 ? i2 = "vec4(" + e2 + ", 1.0)" : "vec4" == t2 && "vec3" == n2 ? i2 = "vec3(" + [e2 + "[0]", e2 + "[1]", e2 + "[2]"].join(",") + ")" : "float" == t2 && "int" == n2 ? i2 = "int(" + e2 + ")" : "int" == t2 && "float" == n2 || "bool" == t2 && "float" == n2 ? i2 = "float(" + e2 + ")" : console.error("MeshNodeMaterial: Missing type conversion: " + t2 + " -> " + n2), (r2 < 1 || 1 != r2 && "normal" == o2) && (i2 = "mix(" + o2 + "," + i2 + "," + P(r2) + ")", "normal" == o2 && (i2 = "normalize(" + i2 + ")")), i2;
    }
    function x(e2, t2, n2, o2, r2) {
      let i2;
      const a2 = [], s2 = L(n2), l2 = L(o2);
      for (let n3 = 0; n3 < l2; n3++) {
        let o3 = 1 == l2 ? r2 : r2 + "[" + n3 + "]";
        for (let r3 = 0; r3 < e2.length; r3++) {
          const i3 = e2[r3], a3 = t2[r3];
          for (let e3 = 0; e3 < s2; e3++) a3[e3][n3] && (o3 = 1 == s2 ? i3 : i3 + "[" + e3 + "]");
        }
        a2.push(o3);
      }
      return i2 = o2 + "(" + a2.join(",") + ")", i2;
    }
    function y(e2, t2, n2, o2, r2, i2) {
      for (let a2 in e2.edges) {
        const s2 = e2.edges[a2];
        if (s2.to() == t2) {
          const t3 = e2.node(s2.from());
          for (let e3 = 0; e3 < s2.connections.length; e3++) {
            const a3 = s2.connections[e3];
            if (a3.to == n2) {
              const e4 = t3.originData.type;
              "BITMAP_MX" != e4 && "BITMAP_ENV_MX" != e4 || "float" != w(o2) ? r2.push(t3.outputs[a3.from]) : r2.push(t3.outputs[a3.from + 1]), a3.channelMatrix && i2.push(a3.channelMatrix);
            }
          }
        }
      }
    }
    function b(e2) {
      return { name: "", type: w(e2), value: e2 };
    }
    function C(e2, n2) {
      const o2 = nodeTexUniName(e2, n2);
      return { name: o2, type: t.nodeTextures[o2].isCubeTexture ? "uniform samplerCube" : "uniform sampler2D", value: "" };
    }
    function S(e2) {
      return { name: "", type: "int", value: e2 };
    }
    function M(e2) {
      return E(e2 ? "true" : "false");
    }
    function E(e2) {
      return { name: e2, type: "", value: "" };
    }
    function T(e2, t2, n2) {
      return n2 = n2 || e2, { name: "nodeVaryParam" + strTitle(e2), type: "varying " + R(t2), value: "", attrBindName: n2 };
    }
    function I(e2) {
      return e2 ? 1 : 0;
    }
    function w(e2) {
      return "number" == typeof e2 ? "float" : "boolean" == typeof e2 ? "bool" : R(e2.length);
    }
    function R(e2) {
      switch (e2) {
        case 1:
          return "float";
        case 2:
          return "vec2";
        case 3:
          return "vec3";
        case 4:
          return "vec4";
        case 9:
          return "mat3";
        case 16:
          return "mat4";
      }
    }
    function L(e2) {
      switch (e2) {
        case "float":
        case "int":
        case "bool":
          return 1;
        case "vec2":
          return 2;
        case "vec3":
          return 3;
        case "vec4":
          return 4;
        case "mat3":
          return 9;
        case "mat4":
          return 16;
      }
    }
    function B(e2, t2) {
      switch (e2) {
        case "float":
          return P(t2);
        case "bool":
        case "int":
          return String(t2);
        default:
          const n2 = [];
          for (let e3 = 0; e3 < t2.length; e3++) n2.push(P(t2[e3]));
          return e2 + "(" + n2.join(",") + ")";
      }
    }
    function P(e2) {
      return e2 % 1 ? String(e2) : String(e2) + ".0";
    }
    this.isMeshNodeMaterial = true, this.type = "MeshNodeMaterial", this.defines = { LIGHT_PATH_IS_CAM_RAY: 1, WORLD_NODES: 0, NORMAL_OUTPUT: 0 }, this.definesFragOnly = /* @__PURE__ */ new Set(["LIGHT_PATH_IS_CAM_RAY", "WORLD_NODES", "NORMAL_OUTPUT"]), this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.fog = true, this.profile = "blender", this.nodeTextures = {}, this.nodeValue = [], this.nodeValueMap = {}, this.nodeRGB = [], this.nodeRGBMap = {}, this.nodeTexCoordObject = [], this.nodeTexCoordObjectMap = {}, this.nodeInputs = {}, this.needsBoundingBox = false, this.useFloatTex = false, this.nodeGraph = null, this.additionalNodeGraphs = {}, this.nodeChunks = {}, this.nodeChunksHash = 0, this.nodeVCAliases = {}, this.nodeUVAliases = {}, this.envMap = null, this.envMapIntensity = 1, this.envMapParallaxType = 0, this.envMapParallaxMatrix = new Matrix4(), this.envMapParallaxMatrixInv = new Matrix4(), this.materialIndex = 0, this.ssrParams = null, isDef(e) && this.setValues(e), this.nodeGraph || (this.nodeGraph = function() {
      const e2 = new DiGraph(1), n2 = t.color;
      return e2.node(0).originData = { name: "ShadelessOutput", type: "OUTPUT_MATERIAL_BL", inputs: [[n2.r, n2.g, n2.b, 1], [0, 0, 0, 0], [0, 0, 0]], outputs: [], is_active_output: true }, e2;
    }()), this.updateNodeGraph = function(e2 = false) {
      const n2 = this.nodeValue, o2 = this.nodeRGB, r2 = this.nodeTexCoordObject;
      this.nodeTextures = {}, this.nodeRGB = [], this.nodeRGBMap = {}, this.nodeValue = [], this.nodeValueMap = {}, this.nodeTexCoordObject = [], this.nodeTexCoordObjectMap = {}, this.needsBoundingBox = false, this.nodeChunks = {};
      const a2 = this.nodeGraph;
      if (function(e3) {
        let n3 = 0, o3 = 0, r3 = 0, a3 = 0, s2 = 0;
        for (let c3 = 0; c3 < e3.len(); c3++) {
          const u2 = e3.node(c3), d3 = u2.originData, h2 = d3.type;
          let f2, p2, m2, v2, x2, y2, R2, L2, P2, N, D, O, F, V, U, G, z;
          u2.attributes = [], u2.params = [], u2.inputFactors = [], u2.inputs = [], u2.outputs = [], isDef(d3.inputFactors) && (u2.inputFactors = d3.inputFactors.slice(0));
          for (let e4 = 0; e4 < d3.outputs.length; e4++) {
            const t2 = d3.outputs[e4], n4 = d3.outputTypes ? d3.outputTypes[e4] : w(t2);
            u2.outputs.push({ name: strToCamel(nodeTypeStripSuffix(h2)) + c3 + "Out" + e4, type: n4, clamp: false, normalize: false });
          }
          switch ("OUTPUT_MATERIAL_BL" != h2 && "OUTPUT_WORLD_BL" != h2 && "OUTPUT_MX" != h2 && "SHADING_ENGINE_MY" != h2 && "SKYDOME_LIGHT_AR" != h2 || u2.outputs.push({ name: "outgoingLight", type: "", clamp: false, normalize: false }), h2) {
            case "ATAN_AR":
              u2.params.push(E(d3.units));
              break;
            case "CLAMP_AR":
            case "COLOR_TO_FLOAT_AR":
            case "COLOR_TO_FLOAT_AR":
            case "FLOAT_TO_INT_AR":
            case "LENGTH_AR":
            case "MIX_SHADER_AR":
            case "RGB_TO_FLOAT_AR":
            case "RGB_TO_VECTOR_AR":
            case "RGBA_TO_FLOAT_AR":
            case "RGB_TO_VECTOR_AR":
            case "VECTOR_TO_RGB_AR":
              u2.params.push(E(d3.mode));
              break;
            case "COLOR_CONVERT_AR":
              u2.params.push(E(d3.from)), u2.params.push(E(d3.to));
              break;
            case "CHECKERBOARD_AR":
            case "PLACE_2D_TEXTURE_MY":
              f2 = d3.uvIndex ? "uv" + String(d3.uvIndex + 1) : "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2);
              break;
            case "COMPOSITE_AR":
              u2.params.push(E(d3.operation)), u2.params.push(E(d3.alphaOperation));
              break;
            case "FACING_RATIO_AR":
            case "FACING_RATIO_AR":
            case "SHADOW_MATTE_AR":
            case "NORMAL":
              u2.params.push(E("normal"));
              break;
            case "COMPARE_AR":
              u2.params.push(E(d3.test));
              break;
            case "IMAGE_AR":
              y2 = d3.texture, t.nodeTextures[nodeTexUniName(h2, n3)] = y2, u2.params.push(C(h2, n3)), n3++, u2.params.push(E(A(y2)));
              break;
            case "LAMBERT_AR":
            case "BSDF_GLASS_BL":
            case "BSDF_GLOSSY_BL":
            case "BLINN_MY":
            case "LAMBERT_MY":
            case "PHONG_MY":
            case "PHONG_E_MY":
              u2.params.push(E("geometryNormal"));
              break;
            case "MAP_TO_MTL_AR":
              u2.params.push(M(d3.opaqueEnabled));
              break;
            case "MATRIX_TRANSFORM_AR":
              u2.params.push(E(d3.transformOrder)), u2.params.push(E(d3.rotationType)), u2.params.push(E(d3.rotationUnits)), u2.params.push(E(d3.rotationOrder));
              break;
            case "NORMAL_MAP_AR":
              f2 = "tangent", p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2);
              break;
            case "SHUFFLE_AR":
            case "CHANNELS_MY":
              u2.params.push(E(d3.channelR)), u2.params.push(E(d3.channelG)), u2.params.push(E(d3.channelB)), u2.params.push(E(d3.channelA));
              break;
            case "STANDARD_SURFACE_AR":
              u2.params.push(E("geometryNormal")), u2.params.push(M(d3.thinWalled)), (d3.inputs[N_IN[h2].clearcoat] > 0 || isConnInput(e3, c3, N_IN[h2].clearcoat)) && (t.defines.USE_CLEARCOAT = ""), (d3.inputs[N_IN[h2].sheen] > 0 || isConnInput(e3, c3, N_IN[h2].sheen)) && (t.defines.USE_SHEEN = ""), u2.inputFactors.length = 0;
              break;
            case "TRIGO_AR":
              u2.params.push(E(d3.function)), u2.params.push(E(d3.units));
              break;
            case "TRIPLANAR_AR":
              u2.params.push(E(d3.coordSpace)), u2.params.push(M(d3.inputPerAxis)), u2.params.push(M(d3.flipOnOppositeDirection)), u2.params.push(b(d3.blendFactor));
              break;
            case "TRIPLANAR_UV_AR":
              u2.params.push(M(d3.flipOnOppositeDirection)), void 0 !== d3.blendFactor && u2.params.push(b(d3.blendFactor)), void 0 !== d3.projectionAxis && u2.params.push(E(d3.projectionAxis));
              break;
            case "TWO_SIDED_AR":
              u2.params.push(E("faceDirection"));
              break;
            case "USER_DATA_COLOR_AR":
              f2 = g(d3.colorLayer, ""), f2 ? (p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2)) : u2.params.push(E(B("vec4", d3.defaultColor)));
              break;
            case "UV_PROJECTION_AR":
              u2.params.push(E(d3.projectionType)), u2.params.push(E(d3.coordSpace));
              break;
            case "ATTRIBUTE_BL":
            case "VERTEX_COLOR_BL":
              f2 = g(d3.colorLayer, ""), f2 ? (p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2)) : u2.params.push(E("vec4(0.0, 0.0, 0.0, 1.0)"));
              break;
            case "BSDF_METALLIC_BL":
              u2.params.push(E("geometryNormal")), u2.params.push(E("BSDF_METALLIC_" + d3.distribution)), u2.params.push(M("PHYSICAL_CONDUCTOR" === d3.fresnelType));
              break;
            case "BSDF_PRINCIPLED_BL":
              u2.params.push(E("geometryNormal"));
              const w2 = getNodeTypeCompat(u2);
              (d3.inputs[N_IN[w2].clearcoat] > 0 || isConnInput(e3, c3, N_IN[w2].clearcoat)) && (t.defines.USE_CLEARCOAT = ""), (d3.inputs[N_IN[w2].sheen] > 0 || isConnInput(e3, c3, N_IN[w2].sheen)) && (t.defines.USE_SHEEN_BLENDER = "");
              break;
            case "BSDF_REFRACTION_BL":
              u2.params.push(E("geometryNormal")), u2.params.push(E("BSDF_REFRACTION_" + d3.distribution));
              break;
            case "BUMP_BL":
              u2.params.push(b(d3.invert));
              break;
            case "CAMERA_BL":
              u2.params.push(E("vViewPosition")), i(e3, "OUTPUT_MATERIAL_BL") > 0 || i(e3, "OUTPUT_WORLD_BL") > 0 ? u2.params.push(M(true)) : u2.params.push(M(false));
              break;
            case "CLAMP_BL":
              u2.params.push(E("RANGE" == d3.clampType));
              break;
            case "COMBINE_COLOR_BL":
              u2.params.push(E("NODE_COMB_COL_" + d3.mode));
              break;
            case "CURVE_FLOAT_BL":
              t.useFloatTex ? (m2 = new Float32Array(1024), v2 = 1) : (m2 = new Uint8Array(1024), v2 = 255);
              for (let e4 = 0; e4 < 256; e4++) {
                let t2 = v2 * (d3.curveData[e4] / 2 + 0.5);
                m2[4 * e4] = clamp(t2, 0, v2);
              }
              y2 = _(m2, 256, 1023, t.useFloatTex ? 1015 : 1009), R2 = nodeTexUniName(h2, o3), t.nodeTextures[R2] = y2, u2.params.push(C(h2, o3)), o3++;
              break;
            case "CURVE_RGB_BL":
            case "CURVE_VEC_BL":
              t.useFloatTex ? (m2 = new Float32Array(1024), v2 = 1) : (m2 = new Uint8Array(1024), v2 = 255);
              for (let e4 = 0; e4 < 256; e4++) {
                let t2, n4, o4, r4;
                P2 = d3.curveData.length / 256, P2 > 3 ? (t2 = v2 * d3.curveData[P2 * e4], n4 = v2 * d3.curveData[P2 * e4 + 1], o4 = v2 * d3.curveData[P2 * e4 + 2], r4 = v2 * d3.curveData[P2 * e4 + 3]) : (t2 = v2 * (d3.curveData[P2 * e4] / 2 + 0.5), n4 = v2 * (d3.curveData[P2 * e4 + 1] / 2 + 0.5), o4 = v2 * (d3.curveData[P2 * e4 + 2] / 2 + 0.5), r4 = v2), m2[4 * e4] = clamp(t2, 0, v2), m2[4 * e4 + 1] = clamp(n4, 0, v2), m2[4 * e4 + 2] = clamp(o4, 0, v2), m2[4 * e4 + 3] = clamp(r4, 0, v2);
              }
              y2 = _(m2, 256, 1023, t.useFloatTex ? 1015 : 1009), R2 = nodeTexUniName(h2, o3), t.nodeTextures[R2] = y2, u2.params.push(C(h2, o3)), o3++;
              break;
            case "EEVEE_SPECULAR_BL":
              u2.params.push(E("geometryNormal")), (d3.inputs[N_IN[h2].clearcoat] > 0 || isConnInput(e3, c3, N_IN[h2].clearcoat)) && (t.defines.USE_CLEARCOAT = "");
              break;
            case "FRESNEL_BL":
            case "LAYER_WEIGHT_BL":
            case "INCIDENT":
            case "POSITION":
              u2.params.push(E("vViewPosition"));
              break;
            case "GRADIENT_MX":
              u2.params.push(E(B("float", d3.color2Pos))), u2.params.push(E(B("int", d3.gradientType))), f2 = d3.uvIndex ? "uv" + String(d3.uvIndex + 1) : "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2), u2.params.push(E("vViewPosition")), u2.params.push(E("MAPPING_" + d3.mapping)), u2.params.push(E("AXIS_" + d3.axis)), u2.params.push(E(B("ivec2", [I(d3.clampToEdgeNoExtend[0]), I(d3.clampToEdgeNoExtend[1])])));
              break;
            case "GRADIENT_RAMP_MX":
              t.useFloatTex ? (m2 = new Float32Array(2048), v2 = 1) : (m2 = new Uint8Array(2048), v2 = 255);
              for (let e4 = 0; e4 < 512; e4++) {
                let t2, n4, o4, r4;
                t2 = v2 * d3.gradientData[3 * e4], n4 = v2 * d3.gradientData[3 * e4 + 1], o4 = v2 * d3.gradientData[3 * e4 + 2], r4 = 1, m2[4 * e4] = clamp(t2, 0, v2), m2[4 * e4 + 1] = clamp(n4, 0, v2), m2[4 * e4 + 2] = clamp(o4, 0, v2), m2[4 * e4 + 3] = clamp(r4, 0, v2);
              }
              y2 = _(m2, 512, 1023, t.useFloatTex ? 1015 : 1009), R2 = nodeTexUniName(h2, o3), t.nodeTextures[R2] = y2, u2.params.push(C(h2, o3)), o3++, u2.params.push(E(B("int", d3.gradientType))), f2 = d3.uvIndex ? "uv" + String(d3.uvIndex + 1) : "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2), u2.params.push(E("geometryNormal")), u2.params.push(E("vViewPosition")), ["SPHERICAL_ENVIRONMENT", "CYLINDRICAL_ENVIRONMENT", "SHRINK_WRAP_ENVIRONMENT", "SCREEN"].indexOf(d3.mapping) > -1 ? u2.params.push(E("MAPPING_EXPLICIT_MAP_CHANNEL")) : u2.params.push(E("MAPPING_" + d3.mapping)), u2.params.push(E("AXIS_" + d3.axis)), u2.params.push(E(B("ivec2", [I(d3.clampToEdgeNoExtend[0]), I(d3.clampToEdgeNoExtend[1])])));
              break;
            case "MAPPING_BL":
              u2.params.push(E("NODE_MAPPING_" + d3.vectorType));
              break;
            case "MAP_RANGE_BL":
              isDef(d3.dataType) && u2.params.push(E("NODE_MAP_RANGE_TYPE_" + d3.dataType)), u2.params.push(E("NODE_MAP_RANGE_INTERP_" + d3.interpolationType)), u2.params.push(M(d3.clamp));
              break;
            case "NEW_GEOMETRY_BL":
              u2.params.push(E("faceDirection")), u2.params.push(E("vViewPosition")), u2.params.push(E("normal")), isConnOutput(e3, c3, N_OUT.NEW_GEOMETRY_BL.tangent) && (t.needsBoundingBox = true);
              break;
            case "NORMAL_MAP_BL":
              f2 = "tangent", p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2), u2.params.push(E("vNormal"));
              break;
            case "SEPARATE_COLOR_BL":
              u2.params.push(E("NODE_SEP_COL_" + d3.mode));
              break;
            case "TANGENT_BL":
              "RADIAL" === d3.directionType ? (u2.params.push(E("TANGENT_AXIS_" + d3.axis)), u2.params.push(E("vViewPosition")), u2.params.push(E("normal")), t.needsBoundingBox = true) : "UV_MAP" === d3.directionType && (f2 = "tangent", p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2));
              break;
            case "TEX_BRICK_BL":
              u2.params.push(E(B("float", d3.offset))), u2.params.push(E(B("int", d3.offsetFrequency))), u2.params.push(E(B("float", d3.squash))), u2.params.push(E(B("int", d3.squashFrequency)));
              break;
            case "TEX_COORD_BL":
              u2.params.push(E(`nodeTexCoordObjectMatrices[${a3}]`)), u2.params.push(E("vViewPosition")), u2.params.push(E("normal")), f2 = "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2), isConnOutput(e3, c3, N_OUT.TEX_COORD_BL.generated) && (t.needsBoundingBox = true), t.nodeTexCoordObject.push(null), t.nodeTexCoordObjectMap[d3.name] = a3, a3++;
              break;
            case "TEX_ENVIRONMENT_BL":
            case "TEX_IMAGE_BL":
              if (y2 = d3.texture, t.nodeTextures[nodeTexUniName(h2, n3)] = y2, u2.params.push(C(h2, n3)), n3++, u2.params.push(E(A(y2))), "TEX_ENVIRONMENT_BL" == h2) {
                const e4 = d3.projection;
                u2.params.push(E("TEX_PROJ_" + e4));
              } else if ("TEX_IMAGE_BL" == h2) {
                let t2;
                switch (d3.alphaMode || "STRAIGHT") {
                  case "STRAIGHT":
                    t2 = isConnOutput(e3, c3, 1) ? "TEX_ALPHA_CLEAR" : "TEX_ALPHA_PREMUL";
                    break;
                  case "PREMUL":
                    t2 = isConnOutput(e3, c3, 1) ? "TEX_ALPHA_UNPREMUL" : "TEX_ALPHA_CLEAR";
                    break;
                  case "CHANNEL_PACKED":
                    t2 = "TEX_ALPHA_CLEAR";
                    break;
                  case "NONE":
                    t2 = "TEX_ALPHA_ONE";
                    break;
                  default:
                    console.error("MeshNodeMaterial: incorrect TEX_IMAGE_BL alpha mode"), t2 = "TEX_ALPHA_ONE";
                }
                u2.params.push(E(t2)), u2.params.push(E("normal"));
                const n4 = d3.projection;
                u2.params.push(E("TEX_PROJ_" + n4)), u2.params.push(b(d3.projectionBlend)), u2.params.push(M(d3.clampToEdgeNoExtend));
              }
              break;
            case "TEX_GABOR_BL":
              u2.params.push(E("TEX_GABOR_" + d3.gaborType));
              break;
            case "TEX_GRADIENT_BL":
              u2.params.push(E("TEX_GRAD_" + d3.gradientType));
              break;
            case "TEX_NOISE_BL":
              isDef(d3.noiseType) && u2.params.push(E("TEX_NOISE_" + d3.noiseType)), u2.params.push(E(B("float", d3.falloffFactor))), u2.params.push(E(B("float", d3.dispersionFactor)));
              break;
            case "TEX_SKY_BL":
              if (D = new Vector3().fromArray(d3.sunDirection).angleTo(new Vector3(0, 0, 1)), "PREETHAM" == d3.skyType) O = PreethamSkyModelUtils.getDistParams(d3.turbidity, 0).concat([0, 0, 0, 0]), F = PreethamSkyModelUtils.getDistParams(d3.turbidity, 1).concat([0, 0, 0, 0]), V = PreethamSkyModelUtils.getDistParams(d3.turbidity, 2).concat([0, 0, 0, 0]), U = PreethamSkyModelUtils.getZenithParams(d3.turbidity, D, 0), G = PreethamSkyModelUtils.getZenithParams(d3.turbidity, D, 1), z = PreethamSkyModelUtils.getZenithParams(d3.turbidity, D, 2);
              else if ("HOSEK_WILKIE" == d3.skyType) {
                const e4 = Math.max(Math.PI / 2 - D, 0);
                O = HosekWilkieSkyModelUtils.getDistParams(d3.turbidity, d3.groundAlbedo, e4, 0), F = HosekWilkieSkyModelUtils.getDistParams(d3.turbidity, d3.groundAlbedo, e4, 1), V = HosekWilkieSkyModelUtils.getDistParams(d3.turbidity, d3.groundAlbedo, e4, 2), U = HosekWilkieSkyModelUtils.getRadiance(d3.turbidity, d3.groundAlbedo, e4, 0), G = HosekWilkieSkyModelUtils.getRadiance(d3.turbidity, d3.groundAlbedo, e4, 1), z = HosekWilkieSkyModelUtils.getRadiance(d3.turbidity, d3.groundAlbedo, e4, 2);
              } else O = F = V = new Array(9).fill(0), U = G = z = 0;
              u2.params.push(E("TEX_SKY_" + d3.skyType)), u2.params.push(b([O[0], F[0], V[0]])), u2.params.push(b([O[1], F[1], V[1]])), u2.params.push(b([O[2], F[2], V[2]])), u2.params.push(b([O[3], F[3], V[3]])), u2.params.push(b([O[4], F[4], V[4]])), u2.params.push(b([O[5], F[5], V[5]])), u2.params.push(b([O[6], F[6], V[6]])), u2.params.push(b([O[7], F[7], V[7]])), u2.params.push(b([O[8], F[8], V[8]])), u2.params.push(b([U, G, z])), u2.params.push(b(d3.sunDirection));
              break;
            case "TEX_VORONOI_BL":
              u2.params.push(E("DISTANCE_" + d3.distance)), u2.params.push(E("FEATURE_" + d3.feature));
              break;
            case "TEX_WAVE_BL":
              u2.params.push(E("TEX_WAVE_TYPE_" + d3.waveType)), u2.params.push(E("TEX_WAVE_PROFILE_" + d3.waveProfile)), u2.params.push(E(`TEX_WAVE_BANDS_DIR_${d3.bandsDirection}`)), u2.params.push(E(`TEX_WAVE_RINGS_DIR_${d3.ringsDirection}`));
              break;
            case "MATH_BL":
              u2.outputs[0].clamp = d3.useClamp;
              break;
            case "MIX_BL":
              switch (u2.originData.blendType) {
                case "HUE":
                case "SATURATION":
                case "VALUE":
                case "COLOR":
                  t.defines.HSV_NODES = "";
              }
              "RGBA" == d3.dataType && (u2.outputs[0].clamp = d3.clampResult);
              break;
            case "MIX_RGB_BL":
              switch (u2.originData.blendType) {
                case "HUE":
                case "SATURATION":
                case "VALUE":
                case "COLOR":
                  t.defines.HSV_NODES = "";
              }
              u2.outputs[0].clamp = d3.useClamp;
              break;
            case "MIX_SHADER_BL":
              let k = -1;
              for (let t2 = 1; t2 < 3; t2++) {
                const n4 = findConnectedNode(e3, c3, t2);
                n4 && "BSDF_TRANSPARENT_BL" == n4.originData.type && (k = t2 - 1);
              }
              u2.params.push(E(String(k)));
              break;
            case "NORMAL_BL":
              u2.params.push(b(d3.outputs[0]));
              break;
            case "RGB_BL":
            case "RGB_MX":
              L2 = new Vector4().fromArray(d3.outputs[0]), t.nodeRGB.push(L2), t.nodeRGBMap[d3.name] = r3, u2.params.push(E("nodeRGB[" + r3 + "]")), r3++;
              break;
            case "SUB_TRANSFORM_MX":
            case "SUB_TRANSFORM_MY":
              u2.params.push(E(d3.coordSpace));
              break;
            case "UVMAP_BL":
              l2 = d3.uvLayer, f2 = t.nodeUVAliases[l2] || "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2);
              break;
            case "VALUE_BL":
            case "VALUE_MX":
            case "ANIM_CURVE_TA_MY":
            case "ANIM_CURVE_TU_MY":
            case "VALUE":
              L2 = d3.outputs[0], t.nodeValue.push(L2), t.nodeValueMap[d3.name] = s2, u2.params.push(E("nodeValue[" + s2 + "]")), s2++;
              break;
            case "VALTORGB_BL":
              N = d3.curve;
              const W = new ("STEP" == N.interpolation ? DiscreteInterpolant : LinearInterpolant)(new Float32Array(N.input), new Float32Array(N.output), 4);
              t.useFloatTex ? (m2 = new Float32Array(1024), v2 = 1) : (m2 = new Uint8Array(1024), v2 = 255);
              for (let e4 = 0; e4 < 256; e4++) {
                const t2 = W.evaluate(e4 / 255);
                m2[4 * e4] = v2 * t2[0], m2[4 * e4 + 1] = v2 * t2[1], m2[4 * e4 + 2] = v2 * t2[2], m2[4 * e4 + 3] = v2 * t2[3];
              }
              y2 = _(m2, 256, 1023, t.useFloatTex ? 1015 : 1009), "STEP" == N.interpolation && (y2.minFilter = 1003, y2.magFilter = 1003), R2 = nodeTexUniName(h2, o3), t.nodeTextures[R2] = y2, u2.params.push(C(h2, o3)), o3++;
              break;
            case "VECTOR_ROTATE_BL":
              u2.params.push(E(B("float", d3.invert ? -1 : 1)));
              break;
            case "VECT_TRANSFORM_BL":
              const Q = d3.vectorType, H = d3.convertFrom, X = d3.convertTo;
              "NORMAL" == Q && (u2.outputs[0].normalize = true);
              let Y = "";
              H == X ? Y = "VEC_TRANS_NONE" : (Y = "VEC_TRANS_" + H[0] + "_" + X[0], "VECTOR" != Q && "NORMAL" != Q || (Y += "_DIR")), u2.params.push(E(Y)), i(e3, "OUTPUT_MATERIAL_BL") > 0 || i(e3, "OUTPUT_WORLD_BL") > 0 ? u2.params.push(M(true)) : u2.params.push(M(false));
              break;
            case "BITMAP_MX":
            case "BITMAP_ENV_MX":
            case "REFLECT_REFRACT_MX":
              if (y2 = d3.texture, t.nodeTextures[nodeTexUniName(h2, n3)] = y2, u2.params.push(C(h2, n3)), n3++, "BITMAP_MX" == h2) {
                f2 = d3.uvIndex ? "uv" + String(d3.uvIndex + 1) : "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2), u2.params.push(E("MAPPING_" + d3.mapping)), u2.params.push(E("AXIS_" + d3.axis));
                const e4 = B("ivec2", [I(d3.clampToEdgeNoExtend[0]), I(d3.clampToEdgeNoExtend[1])]);
                u2.params.push(E(e4));
              } else u2.params.push(E(d3.reflectMode)), u2.params.push(b(d3.IOR));
              u2.params.push(E(A(y2))), "BITMAP_MX" != h2 && "BITMAP_ENV_MX" != h2 || (u2.params.push(M(d3.alphaAsMono)), u2.params.push(M(d3.alphaAsRGB)), u2.outputs.push({ name: h2.toLowerCase() + "_out1_n" + c3, type: "float", clamp: false, normalize: false }));
              break;
            case "BLEND_MX":
              u2.params.push(M(d3.useCurve)), u2.params.push(b(d3.curveLower)), u2.params.push(b(d3.curveUpper));
              break;
            case "BUMP_MX":
              y2 = d3.texture, t.nodeTextures[nodeTexUniName(h2, n3)] = y2, u2.params.push(C(h2, n3)), n3++, u2.params.push(E("-vViewPosition")), u2.params.push(E("normal")), f2 = d3.uvIndex ? "uv" + String(d3.uvIndex + 1) : "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2);
              break;
            case "COLOR_CORRECTION_MX":
              const j = B("ivec4", [d3.rewireR, d3.rewireG, d3.rewireB, d3.rewireA]);
              u2.params.push(E(j)), d3.gainPivotGammaLift && (u2.params.push(b(d3.gainPivotGammaLift)), u2.params.push(M(d3.enableR)), u2.params.push(M(d3.enableG)), u2.params.push(M(d3.enableB)), u2.params.push(S(d3.exposureMode)), u2.params.push(b(d3.printerLights)));
              break;
            case "COMPOSITE_LAYER_MX":
              u2.params.push(E(B("int", d3.blendMode)));
              const $ = isConnInput(e3, c3, 1) ? d3.opacity : 0;
              u2.params.push(b($));
              break;
            case "COLOR_MAP_MX":
              u2.params.push(M(d3.reverseGamma));
              break;
            case "FALLOFF_MX":
              if (u2.params.push(E("-vViewPosition")), 4 != d3.falloffType) u2.params.push(b(d3.IOR)), u2.params.push(S(d3.falloffType));
              else {
                const e4 = void 0 !== d3.extrapolateOn && d3.extrapolateOn, t2 = void 0 === d3.nearDistance ? 0 : d3.nearDistance, n4 = void 0 === d3.farDistance ? 100 : d3.farDistance;
                u2.params.push(M(e4)), u2.params.push(b(t2)), u2.params.push(b(n4));
              }
              break;
            case "MASK_MX":
              u2.params.push(M(d3.maskInverted));
              break;
            case "MATERIAL_MX":
              u2.params.push(b(d3.inputFactors[N_IN[h2].reflection])), u2.params.push(b(d3.inputFactors[N_IN[h2].refraction])), d3.inputFactors[N_IN[h2].reflection] = 1, d3.inputFactors[N_IN[h2].refraction] = 1, u2.params.push(M(d3.selfIllumColorOn));
              break;
            case "MATTE_SHADOW_MX":
              u2.params.push(E("normal")), u2.params.push(M(d3.receiveShadows)), u2.params.push(b(d3.shadowBrightness)), u2.params.push(b(d3.color));
              break;
            case "NOISE_MX":
              2 == d3.coordType ? (f2 = d3.uvIndex ? "uv" + String(d3.uvIndex + 1) : "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2)) : u2.params.push(E("vViewPosition")), u2.params.push(S(d3.noiseType)), u2.params.push(S(d3.coordType));
              break;
            case "NORMAL_BUMP_MX":
              f2 = "tangent", p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2), u2.params.push(E("normal"));
              const K = "ivec2(" + I(d3.flip[0]) + "," + I(d3.flip[1]) + ")";
              u2.params.push(E(K));
              break;
            case "OPENPBR_SURFACE_MX":
            case "OPENPBR_SURFACE_MY":
              u2.params.push(E("geometryNormal")), u2.params.push(M(d3.thinWalled)), (d3.inputs[N_IN[h2].coatWeight] > 0 || isConnInput(e3, c3, N_IN[h2].coatWeight)) && (t.defines.USE_CLEARCOAT = ""), (d3.inputs[N_IN[h2].fuzzWeight] > 0 || isConnInput(e3, c3, N_IN[h2].fuzzWeight)) && (t.defines.USE_SHEEN = "");
              break;
            case "OUTPUT_MAP_MX":
              if (u2.params.push(M(d3.invert)), u2.params.push(M(d3.clamp)), u2.params.push(M(d3.alphaFromRGB)), d3.colorMap) {
                t.useFloatTex ? (x2 = d3.colorMap, m2 = new Float32Array(1024), v2 = 1) : (x2 = clampArray(d3.colorMap.slice(), 0, 1), m2 = new Uint8Array(1024), v2 = 255), P2 = x2.length / 256;
                for (let e4 = 0; e4 < 256; e4++) m2[4 * e4] = v2 * x2[P2 * e4], 3 == P2 ? (m2[4 * e4 + 1] = v2 * x2[P2 * e4 + 1], m2[4 * e4 + 2] = v2 * x2[P2 * e4 + 2]) : (m2[4 * e4 + 1] = m2[4 * e4], m2[4 * e4 + 2] = m2[4 * e4]), m2[4 * e4 + 3] = v2;
                y2 = _(m2, 256, 1023, t.useFloatTex ? 1015 : 1009), R2 = nodeTexUniName(h2, o3), t.nodeTextures[R2] = y2, u2.params.push(C(h2, o3)), o3++;
              }
              break;
            case "PHYSICAL_MX":
              u2.params.push(E("geometryNormal")), u2.params.push(b(d3.emitLuminance));
              const q = void 0 === d3.brdfMode || d3.brdfMode, Z = void 0 === d3.brdfLow ? 0 : d3.brdfLow, J = void 0 === d3.brdfHigh ? 0 : d3.brdfHigh, ee = void 0 === d3.brdfCurve ? 0 : d3.brdfCurve;
              u2.params.push(M(!q)), u2.params.push(E(B("float", Z))), u2.params.push(E(B("float", J))), u2.params.push(E(B("float", ee))), u2.params.push(M(isDef(d3.roughnessInv) && d3.roughnessInv)), u2.params.push(M(isDef(d3.transRoughnessLock) && d3.transRoughnessLock)), u2.params.push(M(isDef(d3.transRoughnessInv) && d3.transRoughnessInv)), u2.params.push(M(isDef(d3.thinWalled) && d3.thinWalled)), (d3.inputs[N_IN[h2].clearcoat] > 0 || isConnInput(e3, c3, N_IN[h2].clearcoat)) && (t.defines.USE_CLEARCOAT = "");
              break;
            case "PHY_SUN_SKY_ENV_MX":
              const te2 = 15 * d3.haze + 2, ne = new Spherical();
              D = Math.PI / 2 - d3.sunPolarAngle;
              const oe = Math.PI - d3.sunAzimuthAngle;
              ne.phi = D, ne.theta = oe;
              const re = new Vector3().setFromSpherical(ne).toArray();
              O = PreethamSkyModelUtils.getDistParams(te2, 0), F = PreethamSkyModelUtils.getDistParams(te2, 1), V = PreethamSkyModelUtils.getDistParams(te2, 2), U = PreethamSkyModelUtils.getZenithParams(te2, D, 0), G = PreethamSkyModelUtils.getZenithParams(te2, D, 1), z = PreethamSkyModelUtils.getZenithParams(te2, D, 2), U /= 0.06, U *= 1e3, u2.params.push(b([O[0], F[0], V[0]])), u2.params.push(b([O[1], F[1], V[1]])), u2.params.push(b([O[2], F[2], V[2]])), u2.params.push(b([O[3], F[3], V[3]])), u2.params.push(b([O[4], F[4], V[4]])), u2.params.push(b([U, G, z]));
              const ie = PreethamSkyModelUtils.getSunIlluminance(re, te2), ae = [0, 0, 0];
              u2.params.push(b(re)), u2.params.push(b(ie)), u2.params.push(b(ae)), u2.params.push(b(d3.globalIntensity / MAX_LIGHT_INT_MULT)), u2.params.push(b(d3.groundColor));
              break;
            case "REFLECT_REFRACT_COLOR_MX":
              L2 = d3.outputs[0], u2.params.push(b(L2));
              break;
            case "VERTEX_COLOR_MX":
              f2 = "color", p2 = T(f2, 3), u2.attributes.push({ name: f2, type: "attribute vec3" }), u2.params.push(p2);
              break;
            case "BUMP_2D_MY":
              u2.params.push(E("vNormal")), d3.bumpInterp > 0 && (f2 = "tangent", p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2));
              break;
            case "COLOR_COMPOSITE_MY":
            case "COLOR_LOGIC_MY":
            case "COLOR_MATH_MY":
            case "CONDITION_MY":
            case "FLOAT_COMPOSITE_MY":
            case "FLOAT_LOGIC_MY":
            case "FLOAT_MATH_MY":
            case "MULTIPLY_DIVIDE_MY":
              u2.params.push(E(d3.operation));
              break;
            case "COLOR_CORRECT_MY":
              u2.params.push(M(d3.colClamp)), u2.params.push(b(d3.colClampMin)), u2.params.push(b(d3.colClampMax)), u2.params.push(M(d3.alphaClamp)), u2.params.push(b(d3.alphaClampMin)), u2.params.push(b(d3.alphaClampMax)), u2.params.push(M(d3.unpremultiplyInput)), u2.params.push(M(d3.premultiplyResult));
              break;
            case "COLOR_MASK_MY":
              u2.params.push(M(d3.maskAlphaIsLuminance));
              break;
            case "COMPOSE_MATRIX_MY":
              u2.params.push(M(d3.useEulerRotation)), u2.params.push(E(d3.inputRotateOrder));
              break;
            case "FILE_MY":
            case "ENV_SPHERE_MY":
              if (y2 = d3.texture, t.nodeTextures[nodeTexUniName(h2, n3)] = y2, u2.params.push(C(h2, n3)), n3++, u2.params.push(E(A(y2))), "ENV_SPHERE_MY" == h2) u2.params.push(E("normal"));
              else {
                const t2 = false === d3.fileHasAlpha;
                u2.params.push(M(t2 && isConnOutput(e3, c3, N_OUT.FILE_MY.alpha)));
              }
              break;
            case "RAMP_MY":
              t.useFloatTex ? (m2 = new Float32Array(2048), v2 = 1) : (m2 = new Uint8Array(2048), v2 = 255);
              for (let e4 = 0; e4 < 512; e4++) {
                const t2 = v2 * d3.rampData[3 * e4], n4 = v2 * d3.rampData[3 * e4 + 1], o4 = v2 * d3.rampData[3 * e4 + 2];
                m2[4 * e4] = clamp(t2, 0, v2), m2[4 * e4 + 1] = clamp(n4, 0, v2), m2[4 * e4 + 2] = clamp(o4, 0, v2), m2[4 * e4 + 3] = v2;
              }
              y2 = _(m2, 512, 1023, t.useFloatTex ? 1015 : 1009), R2 = nodeTexUniName(h2, o3), t.nodeTextures[R2] = y2, u2.params.push(C(h2, o3)), o3++, u2.params.push(E(B("int", d3.rampType))), u2.params.push(E(B("int", d3.wrapS))), u2.params.push(E(B("int", d3.wrapT))), t.defines.RAMP_TEX_SIZE = 512, t.definesFragOnly.add("RAMP_TEX_SIZE");
              break;
            case "SAMPLER_INFO_MY":
              u2.params.push(E("faceDirection")), f2 = "tangent", p2 = T(f2, 4), u2.attributes.push({ name: f2, type: "attribute vec4" }), u2.params.push(p2), f2 = "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2);
              break;
            case "UNIT_CONVERSION_MY":
              u2.params.push(b(d3.conversionFactor));
              break;
            case "VECTOR_PRODUCT_MY":
              u2.params.push(E(d3.operation)), u2.params.push(M(d3.normalizeOutput));
              break;
            case "OSL_NODE":
              isDef(d3.texture) && (y2 = d3.texture, t.nodeTextures[nodeTexUniName(h2, n3)] = y2, u2.params.push(C(h2, n3)), n3++);
              const se = d3.globalVariables || [];
              se.indexOf("P") > -1 && u2.params.push(E("oslGetP(vViewPosition)")), se.indexOf("I") > -1 && u2.params.push(E("oslGetI(vViewPosition)")), se.indexOf("N") > -1 && u2.params.push(E("oslGetN(normal)")), (se.indexOf("u") > -1 || se.indexOf("v") > -1) && (f2 = "uv", u2.attributes.push({ name: f2, type: "attribute vec2" }), se.indexOf("u") > -1 && u2.params.push(T(f2 + "_u", 1, f2 + ".x")), se.indexOf("v") > -1 && u2.params.push(T(f2 + "_v", 1, "1.0 - " + f2 + ".y")));
              break;
            case "RGB_ALPHA":
              L2 = new Vector4().fromArray(d3.outputs[0].concat([d3.outputs[1]])), t.nodeRGB.push(L2), t.nodeRGBMap[d3.name] = r3, u2.params.push(E("nodeRGB[" + r3 + "]")), r3++;
              break;
            case "U_FLOAT":
              f2 = "uv", p2 = T(f2, 2), u2.attributes.push({ name: f2, type: "attribute vec2" }), u2.params.push(p2);
          }
        }
        var l2;
        const c2 = {}, d2 = {};
        for (let t2 = 0; t2 < e3.len(); t2++) {
          const n4 = e3.node(t2), o4 = n4.originData, r4 = o4.type;
          for (let i2 = 0; i2 < o4.inputs.length; i2++) {
            const a4 = o4.inputs[i2], s3 = o4.inputTypes ? o4.inputTypes[i2] : w(a4), l3 = [], h2 = [];
            y(e3, t2, i2, a4, l3, h2);
            const f2 = u(r4, i2);
            if (l3.length) {
              let e4, t3;
              if (e4 = n4.inputFactors.length ? n4.inputFactors[i2] : 1, t3 = f2 ? "normal" : B(s3, a4), h2.length) {
                const e5 = l3.map(function(e6) {
                  return e6.name;
                });
                n4.inputs.push({ code: x(e5, h2, l3[0].type, s3, t3) });
              } else 1 == l3.length || console.error(`MeshNodeMaterial: wrong ${r4} node connections`), n4.inputs.push({ code: v(l3[0].name, l3[0].type, s3, t3, e4) });
            } else if (f2) n4.inputs.push({ code: "normal" });
            else if ("string" == typeof a4) n4.inputs.push({ code: a4 });
            else {
              c2[s3] = c2[s3] || [], Array.isArray(a4) ? c2[s3].push(...a4) : c2[s3].push(a4), s3 in d2 || (d2[s3] = 0);
              let e4 = d2[s3];
              n4.inputs.push({ code: `nodeInputs${strTitle(s3)}[${e4}]` }), d2[s3]++;
            }
          }
        }
        t.nodeInputs = {};
        for (const e4 in c2) t.nodeInputs[e4] = "int" == e4 || "bool" == e4 ? new Int32Array(c2[e4]) : new Float32Array(c2[e4]);
      }(a2), function(e3) {
        const n3 = [], o3 = [], r3 = [], i2 = [], a3 = new TopologicalSort(e3).order();
        t.defines.NODE_RGB_NUM = t.nodeRGB.length, t.defines.NODE_VALUE_NUM = t.nodeValue.length, t.defines.NODE_TEX_COORD_NUM = t.nodeTexCoordObject.length, t.definesFragOnly.add("NODE_RGB_NUM"), t.definesFragOnly.add("NODE_VALUE_NUM"), t.definesFragOnly.add("NODE_TEX_COORD_NUM");
        for (let o4 = 0; o4 < a3.length; o4++) {
          const i3 = e3.node(a3[o4]), s2 = i3.originData.type;
          let l2, c2;
          if (t.defines["NODE_" + s2] = "", "REFLECT_REFRACT_MX" != s2 && "BITMAP_ENV_MX" != s2 && "BUMP_BL" != s2 && "PHY_SUN_SKY_ENV_MX" != s2 && "ENV_SPHERE_MY" != s2 && "UV_PROJECTION_AR" != s2 && "TRIPLANAR_AR" != s2 && "TRIPLANAR_UV_AR" != s2 && "SUB_TRANSFORM_MX" != s2 && "SUB_TRANSFORM_MY" != s2 && t.definesFragOnly.add("NODE_" + s2), "OSL_NODE" == s2 && (t.defines.USE_OSL = ""), "OSL_NODE" != s2) {
            const e4 = "node_" + s2.toLowerCase() + "_vert";
            l2 = ShaderChunk[e4];
          } else l2 = i3.originData.vertCode;
          if (l2 && n3.indexOf(l2) < 0 && n3.push(l2), "OSL_NODE" != s2) {
            const e4 = "node_" + s2.toLowerCase() + "_frag";
            c2 = ShaderChunk[e4];
          } else c2 = i3.originData.fragCode;
          c2 && r3.indexOf(c2) < 0 && r3.push(c2);
          for (let e4 = 0; e4 < i3.attributes.length; e4++) {
            const t2 = i3.attributes[e4], o5 = t2.type + " " + t2.name + ";";
            "uv" != t2.name && n3.indexOf(o5) < 0 && n3.push(o5);
          }
          for (let e4 = 0; e4 < i3.params.length; e4++) {
            const t2 = i3.params[e4];
            if (p(t2)) {
              const e5 = t2.type + " " + t2.name + ";";
              r3.indexOf(e5) < 0 && r3.push(e5);
            } else if (m(t2)) {
              const e5 = t2.type + " " + t2.name + ";";
              n3.indexOf(e5) < 0 && n3.push(e5);
              const o5 = t2.type + " " + t2.name + ";";
              r3.indexOf(o5) < 0 && r3.push(o5);
            }
          }
        }
        for (const e4 in t.nodeInputs) {
          const n4 = t.nodeInputs[e4].length / L(e4);
          r3.push(`uniform ${e4} nodeInputs${strTitle(e4)}[${n4}];`);
        }
        isDef(t.defines.USE_OSL) && r3.unshift("#include <node_osl_frag>");
        for (let t2 = 0; t2 < a3.length; t2++) {
          const n4 = e3.node(a3[t2]), r4 = n4.originData.type;
          if ("CHECKERBOARD_AR" == r4 || "IMAGE_AR" == r4 || "TWO_SIDED_AR" == r4 || "USER_DATA_COLOR_AR" == r4 || "ATTRIBUTE_BL" == r4 || "NEW_GEOMETRY_BL" == r4 || "NORMAL_MAP_BL" == r4 || "TANGENT_BL" == r4 || "TEX_COORD_BL" == r4 || "UVMAP_BL" == r4 || "VERTEX_COLOR_BL" == r4 || "BITMAP_MX" == r4 || "NOISE_MX" == r4 || "NORMAL_BUMP_MX" == r4 || "BUMP_MX" == r4 || "VERTEX_COLOR_MX" == r4 || "GRADIENT_MX" == r4 || "GRADIENT_RAMP_MX" == r4 || "BUMP_2D_MY" == r4 || "PLACE_2D_TEXTURE_MY" == r4 || "SAMPLER_INFO_MY" == r4 || "OSL_NODE" == r4 || "U_FLOAT" == r4) for (let e4 = 0; e4 < n4.params.length; e4++) {
            const t3 = n4.params[e4];
            if (m(t3)) {
              const e5 = t3.name + "=" + t3.attrBindName + ";";
              o3.includes(e5) || (o3.push(e5), t3.name.includes("Tangent") && o3.push(["#ifdef USE_SKINNING", `    ${t3.name}.xyz = vec4(skinMatrix * vec4(${t3.name}.xyz, 0.0)).xyz;`, "#endif"].join("\n")));
            }
          }
          for (let e4 = 0; e4 < n4.outputs.length; e4++) {
            const t3 = n4.outputs[e4];
            t3.type && i2.push(t3.type + " " + t3.name + ";");
          }
          const s2 = [];
          for (let e4 = 0; e4 < n4.params.length; e4++) {
            const t3 = n4.params[e4];
            !t3.type || p(t3) || m(t3) ? s2.push(t3.name) : s2.push(B(t3.type, t3.value));
          }
          for (let e4 = 0; e4 < n4.inputs.length; e4++) {
            const t3 = n4.inputs[e4];
            s2.push(t3.code);
          }
          for (let e4 = 0; e4 < n4.outputs.length; e4++) {
            const t3 = n4.outputs[e4];
            s2.push(t3.name);
          }
          let l2;
          switch (l2 = "OSL_NODE" != r4 ? "node_" + nodeTypeStripSuffix(r4).toLowerCase() : n4.originData.shaderName, r4) {
            case "MATH_BL":
            case "VECT_MATH_BL":
              l2 += "_" + n4.originData.operation.toLowerCase();
              break;
            case "VECTOR_ROTATE_BL":
              l2 += "_" + n4.originData.rotationType.toLowerCase();
              break;
            case "MIX_BL":
              l2 += "_" + n4.originData.dataType.toLowerCase(), "RGBA" == n4.originData.dataType ? l2 += "_" + n4.originData.blendType.toLowerCase() : "VECTOR" == n4.originData.dataType && (l2 += "_" + n4.originData.factorMode.toLowerCase());
              break;
            case "MIX_RGB_BL":
              l2 += "_" + n4.originData.blendType.toLowerCase();
              break;
            case "TEX_WHITE_NOISE_BL":
              l2 += "_" + n4.originData.noise_dimension.toLowerCase();
          }
          i2.push(l2 + "(" + s2.join(",") + ");");
          for (let e4 = 0; e4 < n4.outputs.length; e4++) {
            const t3 = n4.outputs[e4], o4 = t3.name;
            if (t3.clamp) {
              const e5 = t3.type;
              i2.push(o4 + "=clamp(" + o4 + "," + e5 + "(0.0)," + e5 + "(1.0));");
            }
            t3.normalize && i2.push(o4 + "=normalize(" + o4 + ");");
          }
        }
        t.nodeChunks.node_pars_vertex = n3.join("\n"), t.nodeChunks.node_vertex = o3.join("\n"), t.nodeChunks.node_pars_fragment = r3.join("\n"), t.nodeChunks.node_fragment = i2.join("\n"), t.nodeChunksHash = hashString(JSON.stringify(t.nodeChunks));
      }(a2), e2) if (this.nodeValue.length == n2.length && this.nodeRGB.length == o2.length && this.nodeTexCoordObject.length == r2.length) {
        for (let e3 = 0; e3 < this.nodeValue.length; e3++) this.nodeValue[e3] = n2[e3];
        for (let e3 = 0; e3 < this.nodeRGB.length; e3++) this.nodeRGB[e3] = o2[e3];
        for (let e3 = 0; e3 < this.nodeTexCoordObject.length; e3++) this.nodeTexCoordObject[e3] = r2[e3];
      } else console.error("v3d.MeshNodeMaterial: Unable to preserve node variables");
      this.needsUpdate = true;
    }, function(e2) {
      for (let o2 = 0; o2 < e2.len(); o2++) {
        const i2 = e2.node(o2), a2 = i2.originData.type;
        if ("GROUP_BL" != a2) if ("REROUTE_BL" != a2) if ("OSL_OUTPUT_SELECTOR_MX" != a2) ;
        else {
          const t2 = e2.findInEdges(o2), n2 = e2.findOutEdges(o2), r2 = t2[0], i3 = r2.connections[0];
          for (let t3 = 0; t3 < n2.length; t3++) {
            const o3 = n2[t3], a3 = new Edge(r2.from(), o3.to());
            a3.connections = [];
            for (let e3 = 0; e3 < o3.connections.length; e3++) {
              const t4 = o3.connections[e3], n3 = { from: i3.from, to: t4.to };
              a3.connections.push(n3);
            }
            e2.addEdge(a3);
          }
          e2.disconnect(o2, true), o2 = -1;
        }
        else {
          e2.findInEdges(o2).length < 1 && n(e2, o2);
          const t2 = e2.findInEdges(o2), r2 = e2.findOutEdges(o2), i3 = t2[0], a3 = i3.connections[0];
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n2 = r2[t3];
            let o3 = e2.edge(i3.from(), n2.to());
            o3 || (o3 = new Edge(i3.from(), n2.to()), o3.connections = [], e2.addEdge(o3));
            for (let e3 = 0; e3 < n2.connections.length; e3++) {
              const t4 = n2.connections[e3], r3 = { from: a3.from, to: t4.to };
              o3.connections.push(r3);
            }
          }
          e2.disconnect(o2, true), o2 = -1;
        }
        else {
          const a3 = i2.originData.nodeGraph, s2 = t.additionalNodeGraphs[a3];
          if (n(e2, o2), s2.len() <= 2) {
            const t2 = e2.findInEdges(o2), n2 = e2.findOutEdges(o2), r2 = Math.min(t2.length, n2.length);
            for (let o3 = 0; o3 < r2; o3++) {
              const r3 = t2[o3], i3 = n2[o3], a4 = new Edge(r3.from(), i3.to());
              a4.connections = [];
              const s3 = Math.min(r3.connections.length, i3.connections.length);
              for (let e3 = 0; e3 < s3; e3++) {
                const t3 = r3.connections[e3], n3 = i3.connections[e3], o4 = { from: t3.from, to: n3.to };
                a4.connections.push(o4);
              }
              e2.addEdge(a4);
            }
            e2.disconnect(o2, true), o2 = -1;
            continue;
          }
          const l2 = r(e2, s2, o2);
          e2.insert(s2, l2.inputs, l2.outputs);
          const c2 = l2.removedNodes.sort(function(e3, t2) {
            return t2 - e3;
          });
          for (let t2 = 0; t2 < c2.length; t2++) e2.disconnect(c2[t2], true);
          o2 = -1;
        }
      }
    }(t.nodeGraph), function(e2) {
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const n3 = e2.node(t2), o2 = n3.originData, r2 = o2.type;
        if ("TEX_IMAGE_BL" == r2 && !isConnInput(e2, t2, 0)) {
          const n4 = { originData: { name: "UVMapGenerated", type: "UVMAP_BL", uvLayer: "", inputs: [], outputs: [[0, 0, 0]] } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, 0, t2, 0);
        }
        if (("TEX_BRICK_BL" == r2 || "TEX_CHECKER_BL" == r2 || "TEX_GABOR_BL" == r2 || "TEX_GRADIENT_BL" == r2 || "TEX_NOISE_BL" == r2 || "TEX_WAVE_BL" == r2 || "TEX_VORONOI_BL" == r2 || "TEX_SKY_BL" == r2) && !isConnInput(e2, t2, 0)) {
          const n4 = { originData: { name: "TexCoordGenerated", type: "TEX_COORD_BL", inputs: [], outputs: [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, 0, t2, 0);
        }
        if ("TEX_ENVIRONMENT_BL" == r2 && !isConnInput(e2, t2, 0)) {
          const n4 = { originData: { name: "TexCoordObject", type: "TEX_COORD_BL", inputs: [], outputs: [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, 3, t2, 0);
        }
        const i2 = getNodeTypeCompat(n3);
        if ("STANDARD_SURFACE_AR" == i2 && 25 == o2.inputs.length && (console.warn("v3d.MeshNodeMaterial: adding missing params to standard surface node, please reexport your scene"), o2.inputs.push([0, 0, 0])), i2 in DEFAULT_NORMAL_INPUT_NUM && !isConnInput(e2, t2, DEFAULT_NORMAL_INPUT_NUM[i2])) {
          const n4 = { originData: { name: "Normal", type: "NORMAL", inputs: [], outputs: [[0, 0, 0]] } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, N_OUT.NORMAL.normal, t2, DEFAULT_NORMAL_INPUT_NUM[i2]);
        }
        if (["BSDF_PRINCIPLED_BL", "BSDF_PRINCIPLED_BF43_BL", "BSDF_PRINCIPLED_BF40_BL", "EEVEE_SPECULAR_BL"].includes(i2) && !isConnInput(e2, t2, N_IN[i2].clearcoatNormal) && (o2.inputs[N_IN[i2].clearcoat] > 0 || isConnInput(e2, t2, N_IN[i2].clearcoat))) {
          const n4 = { originData: { name: "CoatNormal", type: "NORMAL", inputs: [], outputs: [[0, 0, 0]] } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, N_OUT.NORMAL.normal, t2, N_IN[i2].clearcoatNormal);
        }
        if ("EEVEE_SPECULAR_BL" != i2 || isConnInput(e2, t2, N_IN.EEVEE_SPECULAR_BL.ambientOcclusion) || (o2.inputs[N_IN.EEVEE_SPECULAR_BL.ambientOcclusion] = 1), "OSL_NODE" == i2) {
          const n4 = o2.initializers;
          for (let r3 = 0; r3 < n4.length; r3++) {
            const a2 = n4[r3];
            if (a2 && !isConnInput(e2, t2, r3)) {
              const n5 = { originData: { name: i2 + "init" + r3, type: "OSL_NODE", shaderName: o2.shaderName + "_init_" + r3, inputs: [], outputs: [o2.inputs[0]], fragCode: a2[0], globalVariables: a2[1], initializers: [] } };
              e2.addNode(n5), connectNodes(e2, e2.len() - 1, 0, t2, r3);
            }
          }
        }
        if (!("NORMAL_MAP_AR" != i2 || isConnInput(e2, t2, N_IN.NORMAL_MAP_AR.normal) && isConnInput(e2, t2, N_IN.NORMAL_MAP_AR.tangent))) {
          const n4 = { originData: { name: "SamplerInfo", type: "SAMPLER_INFO_MY", inputs: [[0, 0, 0]], outputs: [0, false, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0], [0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0]] } };
          e2.addNode(n4), isConnInput(e2, t2, N_IN.NORMAL_MAP_AR.normal) || connectNodes(e2, e2.len() - 1, N_OUT.SAMPLER_INFO_MY.normalCamera, t2, N_IN.NORMAL_MAP_AR.normal), isConnInput(e2, t2, N_IN.NORMAL_MAP_AR.tangent) || connectNodes(e2, e2.len() - 1, N_OUT.SAMPLER_INFO_MY.tangentUCamera, t2, N_IN.NORMAL_MAP_AR.tangent);
        }
        if ("IMAGE_AR" == i2 && !isConnInput(e2, t2, N_IN.IMAGE_AR.uvcoords)) {
          const n4 = { originData: { name: "place2dTexture", type: "PLACE_2D_TEXTURE_MY", inputs: [[0, 0], [1, 1], 0], outputs: [[0, 0]], uvIndex: 0 } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, N_OUT.PLACE_2D_TEXTURE_MY.uv, t2, N_IN.IMAGE_AR.uvcoords);
        }
        if ("FILE_MY" == i2 && !isConnInput(e2, t2, N_IN.FILE_MY.uvCoord)) {
          const n4 = { originData: { name: "place2dTexture", type: "PLACE_2D_TEXTURE_MY", inputs: [[0, 0], [1, 1], 0], outputs: [[0, 0]], uvIndex: 0 } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, N_OUT.PLACE_2D_TEXTURE_MY.uv, t2, N_IN.FILE_MY.uvCoord);
        }
        if ("RAMP_MY" == i2 && !isConnInput(e2, t2, N_IN.RAMP_MY.uvCoord)) {
          const n4 = { originData: { name: "place2dTexture", type: "PLACE_2D_TEXTURE_MY", inputs: [[0, 0], [1, 1], 0], outputs: [[0, 0]], uvIndex: 0 } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, N_OUT.PLACE_2D_TEXTURE_MY.uv, t2, N_IN.RAMP_MY.uvCoord);
        }
        if (isDef(o2.output) && h(e2, t2, o2), l(r2)) {
          if (!isDef(o2.inputFactors)) {
            o2.inputFactors = [];
            for (let e3 = 0; e3 < o2.inputs.length; e3++) o2.inputFactors.push(1);
          }
          o2.inputs.push([0, 0, 0]), o2.inputFactors.push(0);
        }
        if ("STANDARD_SURFACE_AR" == i2 && !isConnInput(e2, t2, N_IN[i2].clearcoatNormal) && (o2.inputs[N_IN[i2].clearcoat] > 0 || isConnInput(e2, t2, N_IN[i2].clearcoat))) {
          const n4 = { originData: { name: "CoatNormal", type: "NORMAL", inputs: [], outputs: [[0, 0, 0]] } };
          e2.addNode(n4), connectNodes(e2, e2.len() - 1, 0, t2, N_IN[i2].clearcoatNormal);
        }
        if ("MIX_BL" == i2 && o2.outputs.length > 1) {
          const n4 = [-1, -1, -1, -1, -1, -1, -1, -1], r3 = [-1, -1, -1];
          switch (o2.dataType) {
            case "RGBA":
              o2.inputs = [o2.inputs[0], o2.inputs[6], o2.inputs[7]], n4[0] = 0, n4[6] = 1, n4[7] = 2, o2.outputs = [o2.outputs[2]], r3[2] = 0;
              break;
            case "VECTOR":
              o2.inputs = [o2.inputs[0], o2.inputs[1], o2.inputs[4], o2.inputs[5]], n4[0] = 0, n4[1] = 1, n4[4] = 2, n4[5] = 3, o2.outputs = [o2.outputs[1]], r3[1] = 0;
              break;
            case "FLOAT":
              o2.inputs = [o2.inputs[0], o2.inputs[2], o2.inputs[3]], n4[0] = 0, n4[2] = 1, n4[3] = 2, o2.outputs = [o2.outputs[0]], r3[0] = 0;
          }
          const i3 = e2.findInEdges(t2);
          for (let e3 = 0; e3 < i3.length; e3++) {
            const t3 = i3[e3];
            for (let e4 = t3.connections.length - 1; e4 >= 0; e4--) {
              const o3 = t3.connections[e4];
              n4[o3.to] > -1 ? o3.to = n4[o3.to] : t3.connections.splice(e4, 1);
            }
          }
          const a2 = e2.findOutEdges(t2);
          for (let e3 = 0; e3 < a2.length; e3++) {
            const t3 = a2[e3];
            for (let e4 = t3.connections.length - 1; e4 >= 0; e4--) {
              const n5 = t3.connections[e4];
              r3[n5.from] > -1 ? n5.from = r3[n5.from] : t3.connections.splice(e4, 1);
            }
          }
        }
        if ("BUMP_2D_MY" == r2 && o2.bumpInterp > 0) {
          o2.inputs[N_IN.BUMP_2D_MY.bumpValue] = [0, 0, 0];
          const n4 = e2.findInEdges(t2);
          for (let t3 = 0; t3 < n4.length; t3++) {
            const o3 = n4[t3], r3 = e2.node(o3.from()).originData;
            for (let e3 = 0; e3 < o3.connections.length; e3++) {
              const t4 = o3.connections[e3];
              t4.to == N_IN.BUMP_2D_MY.bumpValue && "FILE_MY" == r3.type ? t4.from = N_OUT.FILE_MY.color : t4.to == N_IN.BUMP_2D_MY.bumpValue && "IMAGE_AR" == r3.type && (t4.from = N_OUT.IMAGE_AR.color);
            }
          }
        }
        if ("COLOR_CONSTANT_MY" != r2 || isConnInput(e2, t2, 0) || isConnInput(e2, t2, 1) || (o2.type = "RGB_ALPHA", o2.inputs = []), "FLOAT_CONSTANT_MY" != r2 || isConnInput(e2, t2, 0) || (o2.type = "VALUE", o2.inputs = []), "TRIPLANAR_AR" == r2) {
          const n4 = function() {
            const n5 = ["scale", "rotate", "offset"], r4 = n5.map((n6) => findAllConnectedNodes(e2, t2, N_IN.TRIPLANAR_AR[n6])), i3 = "Y_UP_RIGHT" === o2.coordSystem ? "SUB_TRANSFORM_MY" : "SUB_TRANSFORM_MX", a2 = { originData: { name: "subTransform", type: i3, inputs: n5.map((e3) => o2.inputs[N_IN.TRIPLANAR_AR[e3]]), outputs: [[0, 0, 0], [0, 0, 0]], coordSpace: o2.coordSpace } };
            e2.addNode(a2);
            const s2 = e2.len() - 1;
            return r4.forEach((t3, o3) => {
              t3.forEach((t4) => {
                const r5 = t4.nodeIdx, a3 = t4.outputIdx, l2 = t4.channelMatrix;
                connectNodes(e2, r5, a3, s2, N_IN[i3][n5[o3]], l2);
              });
            }), (t3) => {
              const n6 = e2.node(t3);
              "TRIPLANAR_AR" == n6.originData.type ? connectNodes(e2, s2, N_OUT[i3].normal, t3, N_IN.TRIPLANAR_AR.normal) : "TRIPLANAR_UV_AR" == n6.originData.type && (connectNodes(e2, s2, N_OUT[i3].vector, t3, N_IN.TRIPLANAR_UV_AR.vector), connectNodes(e2, s2, N_OUT[i3].normal, t3, N_IN.TRIPLANAR_UV_AR.normal));
            };
          }();
          o2.inputs.push([0, 0, 0]), n4(t2);
          const r3 = (t3) => {
            const r4 = { originData: { name: "triplanarUV", type: "TRIPLANAR_UV_AR", inputs: [[0, 0, 0], [0, 0, 0]], outputs: 4 == t3 ? [[0, 0], [0, 0], [0, 0]] : [[0, 0]], flipOnOppositeDirection: o2.flipOnOppositeDirection } };
            4 == t3 ? r4.originData.blendFactor = o2.blendFactor : r4.originData.projectionAxis = t3, e2.addNode(r4);
            const i3 = e2.len() - 1;
            return n4(i3), i3;
          };
          if (o2.inputPerAxis) {
            const n5 = [N_IN.TRIPLANAR_AR.inputColor, N_IN.TRIPLANAR_AR.inputColorY, N_IN.TRIPLANAR_AR.inputColorZ];
            for (let o3 = 0; o3 < 3; o3++) {
              const i3 = n5[o3], a2 = findConnectedNode(e2, t2, i3, "IMAGE_AR");
              if (!a2) {
                findConnectedNode(e2, t2, i3) && console.error("MeshNodeMaterial: TRIPLANAR_AR texture inputs accept only IMAGE_AR or color.");
                continue;
              }
              const s2 = e2.nodeIndex(a2);
              disconnectInputNode(e2, s2, N_IN.IMAGE_AR.uvcoords);
              const l2 = r3(o3);
              connectNodes(e2, l2, N_OUT.TRIPLANAR_UV_AR.uv, s2, N_IN.IMAGE_AR.uvcoords);
            }
          } else {
            const n5 = findConnectedNode(e2, t2, N_IN.TRIPLANAR_AR.inputColor, "IMAGE_AR");
            if (!n5) {
              findConnectedNode(e2, t2, N_IN.TRIPLANAR_AR.inputColor) && console.error("MeshNodeMaterial: TRIPLANAR_AR texture inputs accept only IMAGE_AR or color.");
              continue;
            }
            const i3 = e2.nodeIndex(n5);
            if (disconnectInputNode(e2, i3, N_IN.IMAGE_AR.uvcoords), disconnectInputNode(e2, t2, N_IN.TRIPLANAR_AR.inputColorY), disconnectInputNode(e2, t2, N_IN.TRIPLANAR_AR.inputColorZ), o2.blendFactor < 1e-3) {
              const t3 = r3(3);
              connectNodes(e2, t3, N_OUT.TRIPLANAR_UV_AR.uv, i3, N_IN.IMAGE_AR.uvcoords);
            } else {
              const t3 = r3(4);
              connectNodes(e2, t3, N_OUT.TRIPLANAR_UV_AR.uv, i3, N_IN.IMAGE_AR.uvcoords), n5.originData.inputs.push([0, 0], [0, 0]), connectNodes(e2, t3, N_OUT.TRIPLANAR_UV_AR.duvdx, i3, N_IN.IMAGE_AR.duvdx), connectNodes(e2, t3, N_OUT.TRIPLANAR_UV_AR.duvdy, i3, N_IN.IMAGE_AR.duvdy);
            }
          }
        }
        if ("UV_PROJECTION_AR" == r2) {
          const n4 = disconnectOutputNode(e2, t2, N_OUT.UV_PROJECTION_AR.uv), o3 = disconnectInputNode(e2, t2, N_IN.UV_PROJECTION_AR.projectionColor, "IMAGE_AR");
          if (!o3) {
            console.error("MeshNodeMaterial: UV_PROJECTION_AR.projectionColor input accepts only IMAGE_AR.");
            continue;
          }
          const r3 = o3.node;
          if (n4) {
            const i3 = e2.nodeIndex(r3);
            connectNodes(e2, i3, o3.outputIdx, e2.nodeIndex(n4.node), n4.inputIdx), disconnectInputNode(e2, i3, N_IN.IMAGE_AR.uvcoords), connectNodes(e2, t2, N_OUT.UV_PROJECTION_AR.uv, i3, N_IN.IMAGE_AR.uvcoords);
          }
        }
      }
      let n2 = 0;
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const o2 = e2.node(t2).originData, r2 = o2.type;
        "MATERIAL_MX" != r2 && "PHYSICAL_MX" != r2 && "OPENPBR_SURFACE_MX" != r2 || (s(e2, t2, o2), "MATERIAL_MX" == r2 && (n2 = o2.IOR));
      }
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const o2 = e2.node(t2).originData, r2 = o2.type;
        c(r2) && (o2.IOR = n2), c(r2) && !isDef(o2.reflectMode) && (o2.reflectMode = "MAX_ENV_COORDS_REFLECT");
      }
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const n3 = e2.node(t2).originData;
        "COMPOSITE_MX" == n3.type && (d(e2, t2, n3), e2.disconnect(t2, true));
      }
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const n3 = e2.node(t2).originData;
        "LAYERED_TEXTURE_MY" == n3.type && (f(e2, t2, n3), e2.disconnect(t2, true));
      }
      if (t.hasNode("SKYDOME_LIGHT_AR")) for (let t2 = 0; t2 < e2.len(); t2++) {
        const n3 = e2.node(t2).originData;
        if ("FILE_MY" == n3.type || "IMAGE_AR" == n3.type) {
          const o2 = { originData: { name: "envSphere", type: "ENV_SPHERE_MY", inputs: [[-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]], outputs: [0, [0, 0, 0]], texture: n3.texture } };
          e2.addNode(o2);
          const r2 = e2.findOutEdges(t2);
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n4 = r2[t3];
            for (let t4 = 0; t4 < n4.connections.length; t4++) {
              const o3 = n4.connections[t4];
              o3.from < 2 && connectNodes(e2, e2.len() - 1, o3.from, n4.to(), o3.to);
            }
          }
          e2.disconnect(t2, true), t2 = -1;
        }
      }
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const n3 = e2.node(t2).originData;
        if ("ENV_SPHERE_MY" == n3.type && 2 == n3.inputs.length) {
          const o2 = e2.findInEdges(t2);
          for (let t3 = 0; t3 < o2.length; t3++) {
            const r2 = o2[t3], i2 = e2.node(r2.from()).originData;
            "FILE_MY" != i2.type && "IMAGE_AR" != i2.type || (n3.inputs.splice(0, 1), n3.texture = i2.texture, e2.removeEdge(r2.from(), r2.to()));
          }
        }
      }
      for (let t2 = 0; t2 < e2.len(); t2++) {
        const n3 = e2.node(t2).originData;
        switch (n3.type) {
          case "BSDF_DIFFUSE_BL":
          case "BSDF_GLOSSY_BL":
          case "BSDF_TRANSLUCENT_BL":
          case "DIFFUSE_BSDF_BL":
            o(e2, t2, n3, N_IN[n3.type].color, "Color");
            break;
          case "BSDF_METALLIC_BL":
            o(e2, t2, n3, N_IN[n3.type].baseColor, "Base Color");
            break;
          case "BSDF_PRINCIPLED_BL":
            o(e2, t2, n3, N_IN.BSDF_PRINCIPLED_BL.baseColor, "Color");
            break;
          case "MATERIAL_MX":
            o(e2, t2, n3, N_IN.MATERIAL_MX.ambientColor, "Ambient Color") && (n3.inputFactors[0] = 1), o(e2, t2, n3, N_IN.MATERIAL_MX.diffuseColor, "Diffuse Color") && (n3.inputFactors[1] = 1);
            break;
          case "PHYSICAL_MX":
            o(e2, t2, n3, N_IN.PHYSICAL_MX.baseColor, "Base Color") && (n3.inputFactors[1] = 1);
            break;
          case "OPENPBR_SURFACE_MX":
            o(e2, t2, n3, N_IN.OPENPBR_SURFACE_MY.baseColor, "Base Color") && (n3.inputFactors[1] = 1);
            break;
          case "OPENPBR_SURFACE_MY":
            o(e2, t2, n3, N_IN.OPENPBR_SURFACE_MY.baseColor, "Base Color");
            break;
          case "STANDARD_SURFACE_AR":
            o(e2, t2, n3, N_IN.STANDARD_SURFACE_AR.baseColor, "Base Color");
        }
      }
    }(t.nodeGraph), cleanupGraph(t.nodeGraph), this.updateNodeGraph();
  }
  static nodeGraphFromExtGraph(e) {
    let t = e.nodes, n = e.edges;
    const o = t.slice().sort(function(e2, t2) {
      return e2.name.localeCompare(t2.name);
    }), r = [];
    for (let e2 = 0; e2 < n.length; e2++) {
      const i2 = n[e2], a = Object.assign({}, i2);
      a.fromNode = o.indexOf(t[i2.fromNode]), a.toNode = o.indexOf(t[i2.toNode]), r.push(a);
    }
    t = o, n = r;
    const i = new DiGraph(t.length);
    for (let e2 = 0; e2 < t.length; e2++) t[e2], nodeClone({ originData: t[e2] }, i.node(e2));
    for (let e2 = 0; e2 < n.length; e2++) {
      const t2 = n[e2];
      i.edge(t2.fromNode, t2.toNode) || i.addNewEdge(t2.fromNode, t2.toNode);
      const o2 = i.edge(t2.fromNode, t2.toNode);
      if (o2.connections = o2.connections || [], isDef(t2.fromChannel) || isDef(t2.toChannel)) {
        let e3 = null;
        for (let n3 = 0; n3 < o2.connections.length; n3++) {
          const r3 = o2.connections[n3];
          if (r3.from == t2.fromOutput && r3.to == t2.toInput && r3.channelMatrix) {
            e3 = r3.channelMatrix;
            break;
          }
        }
        if (!e3) {
          e3 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
          const n3 = { from: t2.fromOutput, to: t2.toInput, channelMatrix: e3 };
          o2.connections.push(n3);
        }
        const n2 = t2.fromChannel || 0, r2 = t2.toChannel || 0;
        e3[n2][r2] = 1;
      } else {
        const e3 = { from: t2.fromOutput, to: t2.toInput };
        o2.connections.push(e3);
      }
    }
    return cleanupGraph(i), i;
  }
  static nodeGraphTraverse(e, t) {
    for (let n = 0; n < e.len(); n++) {
      t(e.node(n));
    }
  }
  hasNode(e) {
    for (let t = 0; t < this.nodeGraph.len(); t++) {
      if (this.nodeGraph.node(t).originData.type == e) return true;
    }
    return false;
  }
  traverseNodes(e) {
    for (let t = 0; t < this.nodeGraph.len(); t++) {
      e(this.nodeGraph.node(t));
    }
  }
  findNodeByName(e) {
    for (let t = 0; t < this.nodeGraph.len(); t++) {
      const n = this.nodeGraph.node(t);
      if (n.originData.name === e) return n;
    }
    return null;
  }
  get color() {
    return this.getStandardProp("color");
  }
  set color(e) {
  }
  get opacity() {
    return this.getStandardProp("opacity");
  }
  set opacity(e) {
  }
  connectTexture(e, t, n) {
    let o, r, i;
    switch (this.profile) {
      case "blender":
        o = "TEX_IMAGE_BL", r = "UVMAP_BL", i = "vector";
        break;
      case "max":
        o = "BITMAP_MX";
        break;
      case "maya":
        o = "FILE_MY", r = "PLACE_2D_TEXTURE_MY", i = "uvCoord";
        break;
      default:
        return void console.error("v3d.connectTexture: Invalid material profile:", this.profile);
    }
    const a = createNode(o, e.name || "Texture", { texture: e }), s = nodeTexUniName(o, Object.keys(this.nodeTextures).length);
    this.nodeTextures[s] = e;
    const l = this.nodeGraph;
    if (l) {
      let e2 = firstNodeName(l, t);
      const s2 = N_IN[getNodeType(l.node(e2))][n], c = findConnectedNode(l, e2, s2);
      c && (l.disconnect(l.nodeIndex(c), true), e2 = firstNodeName(l, t)), l.addNode(a), connectNodes(l, l.len() - 1, N_OUT[o].color, e2, s2), r && (l.addNode(createNode(r, a.name + "UV")), connectNodes(l, l.len() - 1, N_OUT[r].uv, l.len() - 2, N_IN[o][i]));
    } else console.error("v3d.connectTexture: Unable to connect texture to empty graph");
  }
  needsLightPathDir() {
    return !!(this.hasNode("LIGHT_PATH_BL") || this.hasNode("RAY_SWITCH_AR") || "USE_OSL" in this.defines);
  }
  canUseGTAO() {
    return (this.hasNode("DIFFUSE_BSDF_BL") || this.hasNode("BSDF_DIFFUSE_BL") || this.hasNode("SUBSURFACE_SCATTERING_BL") || this.hasNode("PHYSICAL_MX") || this.hasNode("OPENPBR_SURFACE_MX") || this.hasNode("OPENPBR_SURFACE_MY") || this.hasNode("STANDARD_SURFACE_AR") || this.hasNode("BSDF_GLASS_BL") || this.hasNode("BSDF_GLOSSY_BL") || this.hasNode("BSDF_METALLIC_BL") || this.hasNode("BSDF_PRINCIPLED_BL") || this.hasNode("EEVEE_SPECULAR_BL")) && this.gtaoVisible;
  }
  worldMaterialColor() {
    const e = this.nodeGraph;
    let t = firstNodeType(e, "OUTPUT_WORLD_BL");
    if (t >= 0) {
      const n = findConnectedNode(e, t, 0);
      if (!n || "BACKGROUND_BL" != n.originData.type) return null;
      if (0 == e.findInEdges(e.nodeIndex(n)).length) return new Color().fromArray(n.originData.inputs[0]).multiplyScalar(n.originData.inputs[1]);
      if (isConnInput(e, e.nodeIndex(n), 1)) return null;
      const o = findConnectedNode(e, e.nodeIndex(n), 0);
      if (!o || ("MIX_BL" != o.originData.type || "RGBA" != o.originData.dataType) && "MIX_RGB_BL" != o.originData.type || "MIX" != o.originData.blendType) return null;
      const r = findConnectedNode(e, e.nodeIndex(o), 0);
      return r && "LIGHT_PATH_BL" == r.originData.type ? isConnInput(e, e.nodeIndex(o), 2) ? null : isConnOutput(e, e.nodeIndex(r), 0) ? new Color().fromArray(o.originData.inputs[2]) : null : null;
    }
    if (t = firstNodeType(e, "OUTPUT_MX"), t >= 0 && 0 == e.findInEdges(t).length) return new Color().fromArray(e.node(t).originData.inputs[0]);
    if (t = firstNodeType(e, "SKYDOME_LIGHT_AR"), t >= 0) {
      if (0 == e.findInEdges(t).length) {
        const n2 = e.node(t);
        return new Color().fromArray(n2.originData.inputs[0]).multiplyScalar(n2.originData.inputs[1]);
      }
      const n = findConnectedNode(e, t, 0);
      if (!n || "RAY_SWITCH_AR" != n.originData.type) return null;
      if (0 == e.findInEdges(e.nodeIndex(n)).length) return new Color().fromArray(n.originData.inputs[0]);
    }
    return null;
  }
  useAddTransparency() {
    const e = this.nodeGraph, t = firstNodeType(e, "OUTPUT_MATERIAL_BL");
    if (t >= 0) {
      const n = findConnectedNode(e, t, 0);
      if (n && "ADD_SHADER_BL" == n.originData.type) {
        const t2 = findConnectedNode(e, e.nodeIndex(n), 0), o = findConnectedNode(e, e.nodeIndex(n), 1);
        if (t2 && o && ("BSDF_TRANSPARENT_BL" == t2.originData.type || "BSDF_TRANSPARENT_BL" == o.originData.type)) return true;
      }
    }
    return false;
  }
  getMainShaderNode() {
    const e = this.nodeGraph;
    if (!e) return null;
    let t = firstNodeType(e, "OUTPUT_MATERIAL_BL");
    if (t >= 0) {
      const n = findConnectedNode(e, t, N_IN.OUTPUT_MATERIAL_BL.surface);
      if (n) {
        if (nodeOfType(n, "MIX_SHADER_BL")) {
          let t2 = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.fac, "SEPARATE_COLOR_BL"), o = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.color1, ["DIFFUSE_BSDF_BL", "BSDF_DIFFUSE_BL"]), r = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.color2, STD_SHADER_NODES_BL);
          if (t2 && o && r) return r;
          if (t2 = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.fac, "LIGHT_PATH_BL"), o = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.color1, "BSDF_TRANSPARENT_BL"), r = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.color2, "EMISSION_BL"), t2 && o && r) return r;
          if (t2 = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.fac), o = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.color1, "BSDF_TRANSPARENT_BL"), r = findConnectedNode(e, n, N_IN.MIX_SHADER_BL.color2, STD_SHADER_NODES_BL), !t2 && o && r) return r;
        } else if (nodeOfType(n, STD_SHADER_NODES_BL)) return n;
      }
    }
    if (t = firstNodeType(e, "OUTPUT_MX"), t >= 0) {
      const n = findConnectedNode(e, t, N_IN.OUTPUT_MX.color, STD_SHADER_NODES_MX);
      if (n) return n;
    }
    if (t = firstNodeType(e, "SHADING_ENGINE_MY"), t >= 0) {
      const n = findConnectedNode(e, t, N_IN.SHADING_ENGINE_MY.surface, STD_SHADER_NODES_MY);
      if (n) return n;
    }
    return null;
  }
  getInputColor(e, t) {
    const n = findConnectedNode(this.nodeGraph, e, t);
    if (!n) return new Color().fromArray(e.originData.inputs[t]);
    if (nodeOfType(n, ["RGB_BL", "RGB_MX", "RGB_ALPHA"])) {
      const e2 = this.nodeRGB[this.nodeRGBMap[n.originData.name]];
      return new Color().fromArray(e2.toArray());
    }
  }
  getInputValue(e, t) {
    const n = findConnectedNode(this.nodeGraph, e, t);
    if (n) {
      if (nodeOfType(n, ["VALUE_BL", "VALUE_MX", "VALUE"])) return this.nodeValue[this.nodeValueMap[n.originData.name]];
    } else {
      const n2 = e.originData.inputs[t];
      if ("number" == typeof n2) return n2;
      console.error(`v3d.MeshNodeMaterial: Invalid ${getNodeType(e)} input value at index ${t}`);
    }
  }
  getInputTexture(e, t) {
    const n = findConnectedNode(this.nodeGraph, e, t);
    if (n && nodeOfType(n, ["TEX_IMAGE_BL", "BITMAP_MX", "FILE_MY", "IMAGE_AR"])) return n.originData.texture;
  }
  getStandardProp(e) {
    if (!(e in STD_PROP_DEFAULTS)) return void console.error(`v3d.MeshNodeMaterial: Invalid standard property: "${e}"`);
    const t = this.getMainShaderNode();
    if (!t) return STD_PROP_DEFAULTS[e];
    const n = getNodeType(t), o = getNodeTypeCompat(t), r = this.nodeGraph;
    let i, a, s, l, c, u, d, h, f;
    switch (e) {
      case "color":
        if (i = STD_SHADER_NODES_BL.includes(n) && findConnectedNode(r, t, N_IN[o].baseColor ?? N_IN[o].color, "MIX_BL"), i && "MULTIPLY" == i.originData.blendType) {
          const e3 = findConnectedNode(r, i, N_IN.MIX_BL.fac), t2 = findConnectedNode(r, i, N_IN.MIX_BL.col1), n2 = findConnectedNode(r, i, N_IN.MIX_BL.col2);
          if (!e3 && (t2 && !n2 || !t2 && n2)) {
            const e4 = this.getInputColor(i, t2 ? N_IN.MIX_BL.col2 : N_IN.MIX_BL.col1);
            if (e4) return e4;
          }
        } else {
          let e3, r2;
          switch (n) {
            case "BSDF_PRINCIPLED_BL":
            case "EEVEE_SPECULAR_BL":
              e3 = this.getInputColor(t, N_IN[o].baseColor);
              break;
            case "PHYSICAL_MX":
            case "STANDARD_SURFACE_AR":
            case "LAMBERT_AR":
              e3 = this.getInputColor(t, N_IN[o].baseColor), e3 || (e3 = STD_PROP_DEFAULTS.color.clone()), r2 = this.getInputValue(t, N_IN[o].base), isDef(r2) && e3.multiplyScalar(r2);
              break;
            case "OPENPBR_SURFACE_MX":
            case "OPENPBR_SURFACE_MY":
              e3 = this.getInputColor(t, N_IN[o].baseColor), e3 || (e3 = STD_PROP_DEFAULTS.color.clone()), r2 = this.getInputValue(t, N_IN[o].baseWeight), isDef(r2) && e3.multiplyScalar(r2);
              break;
            default:
              e3 = this.getInputColor(t, N_IN[o].color);
          }
          if (e3) return e3;
        }
        break;
      case "map":
        if (i = STD_SHADER_NODES_BL.includes(n) && findConnectedNode(r, t, N_IN[o].baseColor ?? N_IN[o].color, "MIX_BL"), i && "MULTIPLY" == i.originData.blendType) {
          const e3 = findConnectedNode(r, i, N_IN.MIX_BL.fac), t2 = findConnectedNode(r, i, N_IN.MIX_BL.col1), n2 = findConnectedNode(r, i, N_IN.MIX_BL.col2);
          if (!e3 && (t2 && !n2 || !t2 && n2)) {
            const e4 = this.getInputTexture(i, t2 ? N_IN.MIX_BL.col1 : N_IN.MIX_BL.col2);
            if (e4) return e4;
          }
        } else if (["BSDF_PRINCIPLED_BL", "EEVEE_SPECULAR_BL", "PHYSICAL_MX", "OPENPBR_SURFACE_MX", "OPENPBR_SURFACE_MY", "STANDARD_SURFACE_AR", "LAMBERT_AR"].includes(n)) {
          const e3 = this.getInputTexture(t, N_IN[o].baseColor);
          if (e3) return e3;
        } else {
          const e3 = this.getInputTexture(t, N_IN[o].color);
          if (e3) return e3;
        }
        break;
      case "opacity":
        if (f = firstNodeType(r, "OUTPUT_MATERIAL_BL"), f >= 0) {
          const e3 = findConnectedNode(r, f, N_IN.OUTPUT_MATERIAL_BL.surface, "MIX_SHADER_BL");
          if (e3) {
            const t2 = findConnectedNode(r, e3, N_IN.MIX_SHADER_BL.fac), n2 = findConnectedNode(r, e3, N_IN.MIX_SHADER_BL.color1, "BSDF_TRANSPARENT_BL"), o2 = findConnectedNode(r, e3, N_IN.MIX_SHADER_BL.color2, STD_SHADER_NODES_BL);
            if (!t2 && n2 && o2) {
              const t3 = this.getInputValue(e3, N_IN.MIX_SHADER_BL.fac);
              if (isDef(t3)) return t3;
            }
          }
        }
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
            const e3 = this.getInputValue(t, N_IN[o].alpha);
            if (isDef(e3)) return e3;
            break;
          case "EEVEE_SPECULAR_BL":
          case "PHYSICAL_MX":
            if (s = this.getInputValue(t, N_IN[o].transparency), isDef(s)) return 1 - s;
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
            if (l = this.getInputValue(t, N_IN[o].geometryOpacity), isDef(l)) return l;
            break;
          case "LAMBERT_MY":
          case "SURFACE_SHADER_MY":
            if (s = this.getInputColor(t, N_IN[o].transparency), s) return 1 - (s.r + s.g + s.b) / 3;
            break;
          case "STANDARD_SURFACE_AR":
          case "LAMBERT_AR":
            if (l = this.getInputColor(t, N_IN[o].opacity), l) return (l.r + l.g + l.b) / 3;
        }
        break;
      case "metalness":
        if (this.getStandardProp("metalnessMap")) return 1;
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
            if (c = this.getInputValue(t, N_IN[o].metallic), isDef(c)) return c;
            break;
          case "PHYSICAL_MX":
          case "STANDARD_SURFACE_AR":
            if (c = this.getInputValue(t, N_IN[o].metalness), isDef(c)) return c;
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
            if (c = this.getInputValue(t, N_IN[o].baseMetalness), isDef(c)) return c;
            break;
          case "BSDF_DIFFUSE_BL":
          case "DIFFUSE_BSDF_BL":
          case "LAMBERT_MY":
          case "LAMBERT_AR":
          case "EMISSION_BL":
          case "SURFACE_SHADER_MY":
          case "MAP_TO_MTL_AR":
            return 0;
          case "BSDF_GLOSSY_BL":
          case "BSDF_METALLIC_BL":
            return 1;
          case "EEVEE_SPECULAR_BL":
            return 0.5;
        }
        break;
      case "metalnessMap":
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
            if (a = findConnectedNode(r, t, N_IN[o].metallic, "SEPARATE_COLOR_BL"), a && (u = this.getInputTexture(a, N_IN.SEPARATE_COLOR_BL.color), u)) return u;
            break;
          case "PHYSICAL_MX":
          case "STANDARD_SURFACE_AR":
            if (u = this.getInputTexture(t, N_IN[o].metalness), u) return u;
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
            if (u = this.getInputTexture(t, N_IN[o].baseMetalness), u) return u;
            break;
          case "BSDF_DIFFUSE_BL":
          case "BSDF_GLOSSY_BL":
          case "BSDF_METALLIC_BL":
          case "DIFFUSE_BSDF_BL":
          case "EEVEE_SPECULAR_BL":
          case "EMISSION_BL":
          case "LAMBERT_MY":
          case "LAMBERT_AR":
          case "SURFACE_SHADER_MY":
          case "MAP_TO_MTL_AR":
            return null;
        }
        break;
      case "roughness":
        if (this.getStandardProp("roughnessMap")) return 1;
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
          case "BSDF_GLOSSY_BL":
          case "BSDF_METALLIC_BL":
          case "EEVEE_SPECULAR_BL":
          case "PHYSICAL_MX":
            if (d = this.getInputValue(t, N_IN[o].roughness), isDef(d)) return d;
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
          case "STANDARD_SURFACE_AR":
            if (d = this.getInputValue(t, N_IN[o].specularRoughness), isDef(d)) return d;
            break;
          case "BSDF_DIFFUSE_BL":
          case "DIFFUSE_BSDF_BL":
          case "LAMBERT_MY":
          case "LAMBERT_AR":
            return 1;
          case "EMISSION_BL":
          case "SURFACE_SHADER_MY":
          case "MAP_TO_MTL_AR":
            return 0.9;
        }
        break;
      case "roughnessMap":
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
          case "BSDF_GLOSSY_BL":
          case "BSDF_METALLIC_BL":
          case "EEVEE_SPECULAR_BL":
            if (a = findConnectedNode(r, t, N_IN[o].roughness, "SEPARATE_COLOR_BL"), a && (h = this.getInputTexture(a, N_IN.SEPARATE_COLOR_BL.color), h)) return h;
            break;
          case "PHYSICAL_MX":
            if (h = this.getInputTexture(t, N_IN[o].roughness), h) return h;
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
          case "STANDARD_SURFACE_AR":
            if (h = this.getInputTexture(t, N_IN[o].specularRoughness), h) return h;
            break;
          case "BSDF_DIFFUSE_BL":
          case "DIFFUSE_BSDF_BL":
          case "EMISSION_BL":
          case "LAMBERT_MY":
          case "SURFACE_SHADER_MY":
          case "MAP_TO_MTL_AR":
            return null;
        }
        break;
      case "aoMap":
        if (f = firstNodeType(r, "OUTPUT_MATERIAL_BL"), f >= 0) {
          const e3 = findConnectedNode(r, f, N_IN.OUTPUT_MATERIAL_BL.surface, "MIX_SHADER_BL");
          if (e3) {
            const t2 = findConnectedNode(r, e3, N_IN.MIX_SHADER_BL.fac, "SEPARATE_COLOR_BL"), n2 = findConnectedNode(r, e3, N_IN.MIX_SHADER_BL.color1, ["DIFFUSE_BSDF_BL", "BSDF_DIFFUSE_BL"]), o2 = findConnectedNode(r, e3, N_IN.MIX_SHADER_BL.color2, STD_SHADER_NODES_BL);
            if (t2 && n2 && o2) {
              const e4 = this.getInputTexture(t2, N_IN.SEPARATE_COLOR_BL.color);
              if (e4) return e4;
            }
          }
        } else {
          let e3;
          switch (n) {
            case "PHYSICAL_MX":
            case "STANDARD_SURFACE_AR":
              if (e3 = this.getInputTexture(t, N_IN[o].base), e3) return e3;
              break;
            case "OPENPBR_SURFACE_MX":
            case "OPENPBR_SURFACE_MY":
              if (e3 = this.getInputTexture(t, N_IN[o].baseWeight), e3) return e3;
          }
        }
        break;
      case "aoMapIntensity":
        break;
      case "normalMap":
        if (STD_SHADER_NODES_BL.includes(n)) {
          const e3 = N_IN[o].normal;
          if (isDef(e3)) {
            const n2 = findConnectedNode(r, t, e3, "NORMAL_MAP_BL");
            if (n2) {
              const e4 = this.getInputTexture(n2, N_IN.NORMAL_MAP_BL.normalColor);
              if (e4) return e4;
            }
          }
        } else if (STD_SHADER_NODES_MY.includes(n)) {
          const e3 = N_IN[o].normal;
          if (isDef(e3)) {
            const n2 = findConnectedNode(r, t, e3, "BUMP_2D_MY");
            if (n2) {
              const e4 = this.getInputTexture(n2, N_IN.BUMP_2D_MY.bumpValue);
              if (e4) return e4;
            }
          }
        } else if ("PHYSICAL_MX" == n || "OPENPBR_SURFACE_MX" == n) {
          const e3 = findConnectedNode(r, t, N_IN[o].normal, "NORMAL_BUMP_MX");
          if (e3) {
            const t2 = this.getInputTexture(e3, N_IN.NORMAL_BUMP_MX.normalColor);
            if (t2) return t2;
          }
        }
        break;
      case "normalScale":
        if (STD_SHADER_NODES_BL.includes(n)) {
          const e3 = N_IN[o].normal;
          if (isDef(e3)) {
            const n2 = findConnectedNode(r, t, e3, "NORMAL_MAP_BL");
            if (n2) {
              const e4 = this.getInputValue(n2, N_IN.NORMAL_MAP_BL.strength);
              if (isDef(e4)) return new Vector2(e4, e4);
            }
          }
        } else if (STD_SHADER_NODES_MY.includes(n)) {
          const e3 = N_IN[o].normal;
          if (isDef(e3)) {
            const n2 = findConnectedNode(r, t, e3, "BUMP_2D_MY");
            if (n2) {
              const e4 = this.getInputValue(n2, N_IN.BUMP_2D_MY.bumpDepth);
              if (isDef(e4)) return new Vector2(e4, e4);
            }
          }
        } else if ("PHYSICAL_MX" == n || "OPENPBR_SURFACE_MX" == n) {
          const e3 = findConnectedNode(r, t, N_IN[o].normal, "NORMAL_BUMP_MX");
          if (e3) {
            const t2 = this.getInputValue(e3, N_IN.NORMAL_BUMP_MX.normalMult);
            if (isDef(t2)) return new Vector2(t2, t2);
          }
        }
        break;
      case "emissive":
        if (this.getStandardProp("emissiveMap")) return new Color(1, 1, 1);
        let e2;
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
            e2 = this.getInputColor(t, N_IN[o].emission);
            break;
          case "EEVEE_SPECULAR_BL":
            e2 = this.getInputColor(t, N_IN[o].emissiveColor);
            break;
          case "PHYSICAL_MX":
            e2 = this.getInputColor(t, N_IN[o].emitColor);
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
          case "STANDARD_SURFACE_AR":
            e2 = this.getInputColor(t, N_IN[o].emissionColor);
        }
        if (e2) return e2;
        break;
      case "emissiveMap":
        let p;
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
            p = this.getInputTexture(t, N_IN[o].emission);
            break;
          case "EEVEE_SPECULAR_BL":
            p = this.getInputTexture(t, N_IN[o].emissiveColor);
            break;
          case "PHYSICAL_MX":
            p = this.getInputTexture(t, N_IN[o].emitColor);
            break;
          case "OPENPBR_SURFACE_MX":
          case "OPENPBR_SURFACE_MY":
          case "STANDARD_SURFACE_AR":
            p = this.getInputTexture(t, N_IN[o].emissionColor);
        }
        if (p) return p;
        break;
      case "emissiveIntensity":
        let m;
        switch (n) {
          case "BSDF_PRINCIPLED_BL":
            m = this.getInputValue(t, N_IN[o].emissionStrength);
            break;
          case "EEVEE_SPECULAR_BL":
            m = 1;
            break;
          case "PHYSICAL_MX":
          case "STANDARD_SURFACE_AR":
            m = this.getInputValue(t, N_IN[o].emission);
            break;
          case "OPENPBR_SURFACE_MX":
            m = this.getInputValue(t, N_IN[o].emissionWeight);
            break;
          case "OPENPBR_SURFACE_MY":
            m = this.getInputValue(t, N_IN[o].emissionLuminance / 1e3);
        }
        if (isDef(m)) return m;
    }
    return STD_PROP_DEFAULTS[e];
  }
  isUnlit() {
    const e = this.getMainShaderNode();
    return !(!e || !nodeOfType(e, ["EMISSION_BL", "SURFACE_SHADER_MY", "MAP_TO_MTL_AR"]));
  }
  copy(e) {
    super.copy(e), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this.fog = e.fog, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.envMapParallaxType = e.envMapParallaxType, this.envMapParallaxMatrix.copy(e.envMapParallaxMatrix), this.envMapParallaxMatrixInv.copy(e.envMapParallaxMatrixInv), this.materialIndex = e.materialIndex, this.profile = e.profile, this.nodeTextures = Object.assign({}, e.nodeTextures), this.nodeRGB = [];
    for (let t = 0; t < e.nodeRGB.length; t++) this.nodeRGB.push(e.nodeRGB[t].clone());
    this.nodeRGBMap = Object.assign({}, e.nodeRGBMap), this.nodeTexCoordObject = e.nodeTexCoordObject.slice(), this.nodeTexCoordObjectMap = Object.assign({}, e.nodeTexCoordObjectMap), this.nodeValue = e.nodeValue.slice(), this.nodeValueMap = Object.assign({}, e.nodeValueMap), this.nodeInputs = {};
    for (const t in e.nodeInputs) this.nodeInputs[t] = e.nodeInputs[t].slice();
    this.needsBoundingBox = e.needsBoundingBox, this.useFloatTex = e.useFloatTex, this.nodeGraph = nodeGraphClone(e.nodeGraph), this.additionalNodeGraphs = {};
    for (const t in e.additionalNodeGraphs) this.additionalNodeGraphs[t] = nodeGraphClone(e.additionalNodeGraphs[t]);
    return this.nodeChunks = Object.assign({}, e.nodeChunks), this.nodeChunksHash = e.nodeChunksHash, this.nodeVCAliases = Object.assign({}, e.nodeVCAliases), this.nodeUVAliases = Object.assign({}, e.nodeUVAliases), this;
  }
};
var Cache = { enabled: false, files: {}, add: function(e, t) {
  false !== this.enabled && (this.files[e] = t);
}, get: function(e) {
  if (false !== this.enabled) return this.files[e];
}, remove: function(e) {
  delete this.files[e];
}, clear: function() {
  this.files = {};
} };
var LoadingManager = class {
  constructor(e, t, n) {
    const o = this;
    let r, i = false, a = 0, s = 0;
    const l = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e2) {
      s++, false === i && void 0 !== o.onStart && o.onStart(e2, a, s), i = true;
    }, this.itemEnd = function(e2) {
      a++, void 0 !== o.onProgress && o.onProgress(e2, a, s), a === s && (i = false, void 0 !== o.onLoad && o.onLoad());
    }, this.itemError = function(e2) {
      void 0 !== o.onError && o.onError(e2);
    }, this.resolveURL = function(e2) {
      return r ? r(e2) : e2;
    }, this.setURLModifier = function(e2) {
      return r = e2, this;
    }, this.addHandler = function(e2, t2) {
      return l.push(e2, t2), this;
    }, this.removeHandler = function(e2) {
      const t2 = l.indexOf(e2);
      return -1 !== t2 && l.splice(t2, 2), this;
    }, this.getHandler = function(e2) {
      for (let t2 = 0, n2 = l.length; t2 < n2; t2 += 2) {
        const n3 = l[t2], o2 = l[t2 + 1];
        if (n3.global && (n3.lastIndex = 0), n3.test(e2)) return o2;
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(e) {
    this.manager = void 0 !== e ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(o, r) {
      n.load(e, o, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
};
var loading = {};
var HttpError = class extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
};
var FileLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = Cache.get(e);
    if (void 0 !== r) return this.manager.itemStart(e), setTimeout(() => {
      t && t(r), this.manager.itemEnd(e);
    }, 0), r;
    if (void 0 !== loading[e]) return void loading[e].push({ onLoad: t, onProgress: n, onError: o });
    loading[e] = [], loading[e].push({ onLoad: t, onProgress: n, onError: o });
    const i = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, s = this.responseType;
    fetch(i).then((t2) => {
      if (200 === t2.status || 0 === t2.status) {
        if (0 === t2.status && console.warn("v3d.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t2.body || void 0 === t2.body.getReader) return t2;
        const n2 = loading[e], o2 = t2.body.getReader(), r2 = t2.headers.get("Content-Length") || t2.headers.get("X-File-Size"), i2 = r2 ? parseInt(r2) : 0, a2 = 0 !== i2;
        let s2 = 0;
        const l = new ReadableStream({ start(e2) {
          !function t3() {
            o2.read().then(({ done: o3, value: r3 }) => {
              if (o3) e2.close();
              else {
                s2 += r3.byteLength;
                const o4 = new ProgressEvent("progress", { lengthComputable: a2, loaded: s2, total: i2 });
                for (let e3 = 0, t4 = n2.length; e3 < t4; e3++) {
                  const t5 = n2[e3];
                  t5.onProgress && t5.onProgress(o4);
                }
                e2.enqueue(r3), t3();
              }
            });
          }();
        } });
        return new Response(l);
      }
      throw new HttpError(`fetch for "${t2.url}" responded with ${t2.status}: ${t2.statusText}`, t2);
    }).then((e2) => {
      switch (s) {
        case "arraybuffer":
          return e2.arrayBuffer();
        case "blob":
          return e2.blob();
        case "document":
          return e2.text().then((e3) => new DOMParser().parseFromString(e3, a));
        case "json":
          return e2.json();
        default:
          if (void 0 === a) return e2.text();
          {
            const t2 = /charset="?([^;"\s]*)"?/i.exec(a), n2 = t2 && t2[1] ? t2[1].toLowerCase() : void 0, o2 = new TextDecoder(n2);
            return e2.arrayBuffer().then((e3) => o2.decode(e3));
          }
      }
    }).then((t2) => {
      Cache.add(e, t2);
      const n2 = loading[e];
      delete loading[e];
      for (let e2 = 0, o2 = n2.length; e2 < o2; e2++) {
        const o3 = n2[e2];
        o3.onLoad && o3.onLoad(t2);
      }
    }).catch((t2) => {
      const n2 = loading[e];
      if (void 0 === n2) throw this.manager.itemError(e), t2;
      delete loading[e];
      for (let e2 = 0, o2 = n2.length; e2 < o2; e2++) {
        const o3 = n2[e2];
        o3.onError && o3.onError(t2);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
};
var CompressedTextureLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    const r = this, i = [], a = new CompressedTexture(), s = new FileLoader(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(r.withCredentials);
    let l = 0;
    function c(c2) {
      s.load(e[c2], function(e2) {
        const n2 = r.parse(e2, true);
        i[c2] = { width: n2.width, height: n2.height, format: n2.format, mipmaps: n2.mipmaps }, l += 1, 6 === l && (1 === n2.mipmapCount && (a.minFilter = 1006), a.image = i, a.format = n2.format, a.needsUpdate = true, t && t(a));
      }, n, o);
    }
    if (Array.isArray(e)) for (let t2 = 0, n2 = e.length; t2 < n2; ++t2) c(t2);
    else s.load(e, function(e2) {
      const n2 = r.parse(e2, true);
      if (n2.isCubemap) {
        const e3 = n2.mipmaps.length / n2.mipmapCount;
        for (let t2 = 0; t2 < e3; t2++) {
          i[t2] = { mipmaps: [] };
          for (let e4 = 0; e4 < n2.mipmapCount; e4++) i[t2].mipmaps.push(n2.mipmaps[t2 * n2.mipmapCount + e4]), i[t2].format = n2.format, i[t2].width = n2.width, i[t2].height = n2.height;
        }
        a.image = i;
      } else a.image.width = n2.width, a.image.height = n2.height, a.mipmaps = n2.mipmaps;
      1 === n2.mipmapCount && (a.minFilter = 1006), a.format = n2.format, a.needsUpdate = true, t && t(a);
    }, n, o);
    return a;
  }
};
var ImageLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, i = Cache.get(e);
    if (void 0 !== i) return r.manager.itemStart(e), setTimeout(function() {
      t && t(i), r.manager.itemEnd(e);
    }, 0), i;
    const a = createElementNS("img");
    function s() {
      c(), Cache.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function l(t2) {
      c(), o && o(t2), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function c() {
      a.removeEventListener("load", s, false), a.removeEventListener("error", l, false);
    }
    return a.addEventListener("load", s, false), a.addEventListener("error", l, false), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    const r = new CubeTexture(), i = new ImageLoader(this.manager);
    i.setCrossOrigin(this.crossOrigin), i.setPath(this.path);
    let a = 0;
    function s(n2) {
      i.load(e[n2], function(e2) {
        r.images[n2] = e2, a++, 6 === a && (r.needsUpdate = true, t && t(r));
      }, void 0, o);
    }
    for (let t2 = 0; t2 < e.length; ++t2) s(t2);
    return r;
  }
};
var DataTextureLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    const r = this, i = new DataTexture(), a = new FileLoader(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function(e2) {
      const n2 = r.parse(e2);
      n2 && (void 0 !== n2.image ? i.image = n2.image : void 0 !== n2.data && (i.image.width = n2.width, i.image.height = n2.height, i.image.data = n2.data), i.wrapS = void 0 !== n2.wrapS ? n2.wrapS : 1001, i.wrapT = void 0 !== n2.wrapT ? n2.wrapT : 1001, i.magFilter = void 0 !== n2.magFilter ? n2.magFilter : 1006, i.minFilter = void 0 !== n2.minFilter ? n2.minFilter : 1006, i.anisotropy = void 0 !== n2.anisotropy ? n2.anisotropy : 1, void 0 !== n2.encoding && (i.encoding = n2.encoding), void 0 !== n2.flipY && (i.flipY = n2.flipY), void 0 !== n2.format && (i.format = n2.format), void 0 !== n2.type && (i.type = n2.type), void 0 !== n2.mipmaps && (i.mipmaps = n2.mipmaps, i.minFilter = 1008), 1 === n2.mipmapCount && (i.minFilter = 1006), void 0 !== n2.generateMipmaps && (i.generateMipmaps = n2.generateMipmaps), i.needsUpdate = true, t && t(i, n2));
    }, n, o), i;
  }
};
var TextureLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    const r = new Texture(), i = new ImageLoader(this.manager);
    return i.setCrossOrigin(this.crossOrigin), i.setPath(this.path), i.load(e, function(e2) {
      r.image = e2, r.needsUpdate = true, void 0 !== t && t(r);
    }, n, o), r;
  }
};
var ImageBitmapLoader = class extends Loader {
  constructor(e) {
    super(e), this.isImageBitmapLoader = true, "undefined" == typeof createImageBitmap && console.warn("v3d.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("v3d.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, o) {
    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, i = Cache.get(e);
    if (void 0 !== i) return r.manager.itemStart(e), setTimeout(function() {
      t && t(i), r.manager.itemEnd(e);
    }, 0), i;
    const a = {};
    a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(e2) {
      return e2.blob();
    }).then(function(e2) {
      return createImageBitmap(e2, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(n2) {
      Cache.add(e, n2), t && t(n2), r.manager.itemEnd(e);
    }).catch(function(t2) {
      o && o(t2), r.manager.itemError(e), r.manager.itemEnd(e);
    }), r.manager.itemStart(e);
  }
};
var LoaderUtils = class {
  static decodeText(e) {
    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, o = e.length; n < o; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch (e2) {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return -1 === t ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
};
var _context;
var AudioContext = class {
  static getContext() {
    return void 0 === _context && (_context = new (window.AudioContext || window.webkitAudioContext)()), _context;
  }
  static setContext(e) {
    _context = e;
  }
};
var AudioLoader = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, n, o) {
    const r = this, i = new FileLoader(this.manager);
    i.setResponseType("arraybuffer"), i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, function(n2) {
      try {
        const e2 = n2.slice(0);
        AudioContext.getContext().decodeAudioData(e2, function(e3) {
          t(e3);
        });
      } catch (t2) {
        o ? o(t2) : console.error(t2), r.manager.itemError(e);
      }
    }, n, o);
  }
};
var Light = class extends Object3D {
  constructor(e, t = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Color(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
};
var _dir$2 = new Vector3();
var SpotLight = class extends Light {
  constructor(e, t, n = 0, o = Math.PI / 3, r = 0, i = 2) {
    super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.distance = n, this.angle = o, this.penumbra = r, this.decay = i, this.shadow = new SpotLightShadow(), this.isFreeLight = false;
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this.isFreeLight = e.isFreeLight, this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.isFreeLight && this.updateFreeLightTarget();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.isFreeLight && this.updateFreeLightTarget();
  }
  updateFreeLightTarget() {
    _dir$2.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, _dir$2), this.target.updateMatrixWorld();
  }
};
var _projScreenMatrix = new Matrix4();
var _lightPositionWorld = new Vector3();
var _lookTarget = new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, o = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(e.matrixWorld), n.position.copy(_lightPositionWorld), _lookTarget.copy(n.position), _lookTarget.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(_lookTarget), n.updateMatrixWorld(), o.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
};
var PointLight = class extends Light {
  constructor(e, t, n = 0, o = 2) {
    super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = n, this.decay = o, this.shadow = new PointLightShadow();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
};
var RectAreaLightShadow = class extends PointLightShadow {
  constructor() {
    super(), this.isRectAreaLightShadow = true;
  }
};
var RectAreaLight = class extends Light {
  constructor(e, t, n = 10, o = 10) {
    super(e, t), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = n, this.height = o, this.shadow = new RectAreaLightShadow();
  }
  get power() {
    return 2 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (2 * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this.shadow = e.shadow.clone(), this;
  }
};
var HemisphereLight = class extends Light {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
};
var SphericalHarmonics3 = class {
  constructor() {
    this.isSphericalHarmonics3 = true, this.coefficients = [];
    for (let e = 0; e < 9; e++) this.coefficients.push(new Vector3());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x, o = e.y, r = e.z, i = this.coefficients;
    return t.copy(i[0]).multiplyScalar(0.282095), t.addScaledVector(i[1], 0.488603 * o), t.addScaledVector(i[2], 0.488603 * r), t.addScaledVector(i[3], 0.488603 * n), t.addScaledVector(i[4], n * o * 1.092548), t.addScaledVector(i[5], o * r * 1.092548), t.addScaledVector(i[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(i[7], n * r * 1.092548), t.addScaledVector(i[8], 0.546274 * (n * n - o * o)), t;
  }
  getIrradianceAt(e, t) {
    const n = e.x, o = e.y, r = e.z, i = this.coefficients;
    return t.copy(i[0]).multiplyScalar(0.886227), t.addScaledVector(i[1], 1.023328 * o), t.addScaledVector(i[2], 1.023328 * r), t.addScaledVector(i[3], 1.023328 * n), t.addScaledVector(i[4], 0.858086 * n * o), t.addScaledVector(i[5], 0.858086 * o * r), t.addScaledVector(i[6], 0.743125 * r * r - 0.247708), t.addScaledVector(i[7], 0.858086 * n * r), t.addScaledVector(i[8], 0.429043 * (n * n - o * o)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return false;
    return true;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let o = 0; o < 9; o++) n[o].fromArray(e, t + 3 * o);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let o = 0; o < 9; o++) n[o].toArray(e, t + 3 * o);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x, o = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * o, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * o, t[5] = 1.092548 * o * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - o * o);
  }
};
var LightProbe = class extends Light {
  constructor(e = new SphericalHarmonics3(), t = 1) {
    super(void 0, t), this.isLightProbe = true, this.type = "LightProbe", this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(e, t, n = 1) {
    super(void 0, n), this.isHemisphereLightProbe = true, this.type = "HemisphereLightProbe";
    const o = new Color().set(e), r = new Color().set(t), i = new Vector3(o.r, o.g, o.b), a = new Vector3(r.r, r.g, r.b), s = Math.sqrt(Math.PI), l = s * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(i).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(i).sub(a).multiplyScalar(l);
  }
};
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class _CSMFrustum {
  constructor({ maxFar: e = 1e5, projectionMatrix: t = null } = {}) {
    this.vertices = { near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()], far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()] }, t && this.setFromProjectionMatrix(t, e);
  }
  setFromProjectionMatrix(e, t) {
    const n = 0 === e.elements[11];
    return inverseProjectionMatrix.copy(e).invert(), this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(e2) {
      e2.applyMatrix4(inverseProjectionMatrix);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(e2) {
      e2.applyMatrix4(inverseProjectionMatrix);
      const o = Math.abs(e2.z);
      n ? e2.z *= Math.min(t / o, 1) : e2.multiplyScalar(Math.min(t / o, 1));
    }), this.vertices;
  }
  split(e, t, n) {
    for (; e.length > t.length; ) t.push(new _CSMFrustum());
    t.length = e.length;
    for (let o = 0; o < e.length; o++) {
      const r = t[o];
      if (0 === o || n) for (let e2 = 0; e2 < 4; e2++) r.vertices.near[e2].copy(this.vertices.near[e2]);
      else for (let t2 = 0; t2 < 4; t2++) r.vertices.near[t2].lerpVectors(this.vertices.near[t2], this.vertices.far[t2], e[o - 1]);
      if (o === e.length - 1) for (let e2 = 0; e2 < 4; e2++) r.vertices.far[e2].copy(this.vertices.far[e2]);
      else for (let t2 = 0; t2 < 4; t2++) r.vertices.far[t2].lerpVectors(this.vertices.near[t2], this.vertices.far[t2], e[o]);
    }
  }
  toSpace(e, t) {
    for (let n = 0; n < 4; n++) t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(e), t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(e);
  }
};
var _vec3Tmp$7 = new Vector3();
var _vec3Tmp2$5 = new Vector3();
var _vec3Tmp3$2 = new Vector3();
var _mat4Tmp$2 = new Matrix4();
new Matrix4();
var _bbox$1 = new Box3();
var _lightSpaceFrustum = new CSMFrustum();
var _uniformArray = [];
var _logArray = [];
var DirectionalLightShadowCascade = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)), this.esmBlurRadius = 0, this.pancakeDepth = true, this.isDirectionalLightShadowCascade = true;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix, o = _vec3Tmp$7.setFromMatrixPosition(t.matrixWorld), r = _vec3Tmp2$5.setFromMatrixPosition(e.matrixWorld);
    t.position.copy(r);
    const i = _vec3Tmp3$2.setFromMatrixPosition(e.target.matrixWorld);
    t.lookAt(i), t.position.copy(o), t.updateMatrixWorld();
    const a = _mat4Tmp$2.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(a), this.pancakeDepth && (this._frustum.planes[5].constant = 1 / 0), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(a);
  }
};
var DirectionalLightShadowCSM = class extends LightShadow {
  constructor({ numCascades: e = 1, maxDistance: t = 500, fade: n = 0, lightMargin: o = 1, noLastCascadeCutOff: r = true, customSplitsCallback: i = null } = {}) {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)), this.numCascades = e, this.exponent = 0.5, this.customSplitsCallback = i, this.maxDistance = t, this.fade = n, this.lightMargin = o, this.noLastCascadeCutOff = r, this.cascadesFitToScene = false, this.mainFrustum = new CSMFrustum(), this._frustums = [], this._breaks = [], this._cascades = [], this._sceneViewProjectionMatrix = new Matrix4(), this._sceneViewCamera = null, this._needsCascadeFrustumsUpdate = true, this.createCascades(), this.isDirectionalLightShadowCSM = true;
  }
  createCascades() {
    const e = this._cascades;
    for (; e.length > this.numCascades; ) e.pop().dispose();
    for (let t = e.length; t < this.numCascades; t++) {
      const t2 = new DirectionalLightShadowCascade();
      t2.mapSize.copy(this.mapSize), t2.copy(this), e.push(t2);
    }
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      n.mapSize.copy(this.mapSize), n.copy(this);
    }
    this.updateMapSize();
  }
  initCascades(e) {
    e.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxDistance), this.mainFrustum.split(this._breaks, this._frustums, this.cascadesFitToScene);
  }
  updateShadowBounds(e) {
    const t = this._frustums;
    for (let n = 0; n < t.length; n++) {
      const o = this._cascades[n], r = this._cascades[n].camera, i = t[n], a = i.vertices.near, s = i.vertices.far, l = s[0];
      let c;
      c = l.distanceTo(s[2]) > l.distanceTo(a[2]) ? s[2] : a[2];
      let u = l.distanceTo(c);
      if (this.fade > 0) {
        const t2 = Math.min(e.far, this.maxDistance), n2 = e.near, o2 = i.vertices.far[0].z / (t2 - n2);
        u += this.fade * Math.pow(o2, 2) * (t2 - n2);
      }
      r.left = -u / 2, r.right = u / 2, r.top = u / 2, r.bottom = -u / 2, r.near = 0, r.far = u + this.lightMargin, r.updateProjectionMatrix(), o.bias = this.bias, o.normalBias = this.normalBias, o.esmBlurRadius = o.radius / ((r.right - r.left) / 2);
    }
  }
  getBreaks(e) {
    const t = e.near, n = Math.min(e.far, this.maxDistance), o = this.numCascades, r = this.exponent, i = this._breaks;
    i.length = 0, this.customSplitsCallback ? this.customSplitsCallback(o, t, n, i, r) : function(e2, t2, n2, o2, r2) {
      _uniformArray.length = 0, _logArray.length = 0, function(e3, t3, n3, o3) {
        for (let r3 = 1; r3 < e3; r3++) o3.push(t3 * (n3 / t3) ** (r3 / e3) / n3);
        o3.push(1);
      }(e2, t2, n2, _logArray), function(e3, t3, n3, o3) {
        for (let r3 = 1; r3 < e3; r3++) o3.push((t3 + (n3 - t3) * r3 / e3) / n3);
        o3.push(1);
      }(e2, t2, n2, _uniformArray);
      for (let t3 = 1; t3 < e2; t3++) r2.push(lerp(_uniformArray[t3 - 1], _logArray[t3 - 1], o2));
      r2.push(1);
    }(o, t, n, r, i);
  }
  updateCascadePositions(e) {
    const t = this._frustums;
    for (let n = 0; n < t.length; n++) {
      const o = this._cascades[n], r = this._cascades[n].camera, i = (r.right - r.left) / o.mapSize.x, a = (r.top - r.bottom) / o.mapSize.y;
      r.updateMatrixWorld(true);
      const s = _mat4Tmp$2.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld);
      t[n].toSpace(s, _lightSpaceFrustum);
      const l = _lightSpaceFrustum.vertices.near, c = _lightSpaceFrustum.vertices.far;
      _bbox$1.makeEmpty();
      for (let e2 = 0; e2 < 4; e2++) _bbox$1.expandByPoint(l[e2]), _bbox$1.expandByPoint(c[e2]);
      const u = _bbox$1.getCenter(_vec3Tmp$7);
      u.z = _bbox$1.max.z + this.lightMargin, u.x = Math.floor(u.x / i) * i, u.y = Math.floor(u.y / a) * a, u.applyMatrix4(r.matrixWorld), r.position.copy(u), r.updateMatrixWorld();
    }
  }
  update(e, t) {
    !this._needsCascadeFrustumsUpdate && this._sceneViewCamera === e && this._sceneViewProjectionMatrix.equals(e.projectionMatrix) || (this.updateFrustums(e), this.updateMatrices(t), this._sceneViewCamera = e, this._sceneViewProjectionMatrix.copy(e.projectionMatrix), this._needsCascadeFrustumsUpdate = false), this.updateCascadePositions(e);
  }
  getCascadeRange(e, t) {
    const n = this._breaks, o = n[t], r = n[t - 1] || 0;
    e.x = r, e.y = o, this.noLastCascadeCutOff && t == n.length - 1 && (e.y = 1 / 0);
  }
  updateFrustums(e) {
    this.getBreaks(e), this.initCascades(e), this.updateShadowBounds(e);
  }
  updateMatrices(e) {
    for (let t = 0; t < this._cascades.length; t++) this._cascades[t].updateMatrices(e);
  }
  updateMapSize(e) {
    e && this.mapSize.copy(e);
    const t = this.mapSize;
    for (let e2 = 0; e2 < this._cascades.length; e2++) {
      this._cascades[e2].mapSize.copy(t);
    }
    this.updateMaps();
  }
  updateMaps() {
    for (let e = 0; e < this._cascades.length; e++) {
      const t = this._cascades[e];
      t.dispose(), t.map = null, t._additionalMap2D = null, t._additionalMapCube = null;
    }
  }
  dispose() {
    for (let e = 0; e < this._cascades.length; e++) this._cascades[e].dispose();
    super.dispose();
  }
  copy(e) {
    return super.copy(e), this.numCascades = e.numCascades, this.exponent = e.exponent, this.maxDistance = e.maxDistance, this.fade = e.fade, this.lightMargin = e.lightMargin, this.noLastCascadeCutOff = e.noLastCascadeCutOff, this.createCascades(), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  setCascadesFitToScene(e) {
    this.cascadesFitToScene = e, this._needsCascadeFrustumsUpdate = true;
  }
  setExponent(e) {
    this.exponent = e, this._needsCascadeFrustumsUpdate = true;
  }
  setFade(e) {
    this.fade = e, this._needsCascadeFrustumsUpdate = true;
  }
  setMaxDistance(e) {
    this.maxDistance = e, this._needsCascadeFrustumsUpdate = true;
  }
  setNoLastCascadeCutOff(e) {
    this.noLastCascadeCutOff = e, this._needsCascadeFrustumsUpdate = true;
  }
  setNumCascades(e) {
    this.numCascades = e, this._needsCascadeFrustumsUpdate = true, this.createCascades();
  }
  setLightMargin(e) {
    this.lightMargin = e, this._needsCascadeFrustumsUpdate = true;
  }
};
var _dir$1 = new Vector3();
var DirectionalLight = class extends Light {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadowCSM(), this.isFreeLight = false;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this.isFreeLight = e.isFreeLight, this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.isFreeLight && this.updateFreeLightTarget();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.isFreeLight && this.updateFreeLightTarget();
  }
  updateFreeLightTarget() {
    _dir$1.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, _dir$1), this.target.updateMatrixWorld();
  }
};
var AmbientLight = class extends Light {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
  }
};
var AmbientLightProbe = class extends LightProbe {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = true, this.type = "AmbientLightProbe";
    const n = new Color().set(e);
    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();
var _projectionMatrix = new Matrix4();
var StereoCamera = class {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new PerspectiveCamera(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new PerspectiveCamera(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, _projectionMatrix.copy(e.projectionMatrix);
      const n = t.eyeSep / 2, o = n * t.near / t.focus, r = t.near * Math.tan(DEG2RAD * t.fov * 0.5) / t.zoom;
      let i, a;
      _eyeLeft.elements[12] = -n, _eyeRight.elements[12] = n, i = -r * t.aspect + o, a = r * t.aspect + o, _projectionMatrix.elements[0] = 2 * t.near / (a - i), _projectionMatrix.elements[8] = (a + i) / (a - i), this.cameraL.projectionMatrix.copy(_projectionMatrix), i = -r * t.aspect - o, a = r * t.aspect - o, _projectionMatrix.elements[0] = 2 * t.near / (a - i), _projectionMatrix.elements[8] = (a + i) / (a - i), this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight);
  }
};
var Clock = class {
  constructor(e = true) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
  }
  start() {
    this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
  }
  stop() {
    this.getElapsedTime(), this.running = false, this.autoStart = false;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = now();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
};
function now() {
  return ("undefined" == typeof performance ? Date : performance).now();
}
var _position$1 = new Vector3();
var _quaternion$1 = new Quaternion();
var _scale$9 = new Vector3();
var _orientation$1 = new Vector3();
var AudioListener = class extends Object3D {
  constructor() {
    super(), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$9), _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1), t.positionX) {
      const e2 = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(_position$1.x, e2), t.positionY.linearRampToValueAtTime(_position$1.y, e2), t.positionZ.linearRampToValueAtTime(_position$1.z, e2), t.forwardX.linearRampToValueAtTime(_orientation$1.x, e2), t.forwardY.linearRampToValueAtTime(_orientation$1.y, e2), t.forwardZ.linearRampToValueAtTime(_orientation$1.z, e2), t.upX.linearRampToValueAtTime(n.x, e2), t.upY.linearRampToValueAtTime(n.y, e2), t.upZ.linearRampToValueAtTime(n.z, e2);
    } else t.setPosition(_position$1.x, _position$1.y, _position$1.z), t.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, n.x, n.y, n.z);
  }
};
var Audio = class extends Object3D {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (true === this.isPlaying) return void console.warn("v3d.Audio: Audio is already playing.");
    if (false === this.hasPlaybackControl) return void console.warn("v3d.Audio: this Audio has no playback control.");
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (false !== this.hasPlaybackControl) return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
    console.warn("v3d.Audio: this Audio has no playback control.");
  }
  stop() {
    if (false !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
    console.warn("v3d.Audio: this Audio has no playback control.");
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return this._connected = true, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return this._connected = false, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), true === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (false !== this.hasPlaybackControl) return this.playbackRate = e, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    console.warn("v3d.Audio: this Audio has no playback control.");
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    return false === this.hasPlaybackControl ? (console.warn("v3d.Audio: this Audio has no playback control."), false) : this.loop;
  }
  setLoop(e) {
    if (false !== this.hasPlaybackControl) return this.loop = e, true === this.isPlaying && (this.source.loop = this.loop), this;
    console.warn("v3d.Audio: this Audio has no playback control.");
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
};
var _position = new Vector3();
var _quaternion = new Quaternion();
var _scale$8 = new Vector3();
var _orientation = new Vector3();
var PositionalAudio = class extends Audio {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  fromAudio(e) {
    return this.panner.disconnect(this.gain), this.listener = e.listener, this.context = e.context, this.gain = e.gain, this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.isPlaying = e.isPlaying, this.hasPlaybackControl = e.hasPlaybackControl, this.audio = e.audio, this.sourceType = e.sourceType, this._startedAt = e._startedAt, this._progress = e._progress, this._connected = e._connected, this.filters = e.filters.slice(0), this.panner.connect(this.gain), this;
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), true === this.hasPlaybackControl && false === this.isPlaying) return;
    this.matrixWorld.decompose(_position, _quaternion, _scale$8), _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const t = this.panner;
    if (t.positionX) {
      const e2 = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(_position.x, e2), t.positionY.linearRampToValueAtTime(_position.y, e2), t.positionZ.linearRampToValueAtTime(_position.z, e2), t.orientationX.linearRampToValueAtTime(_orientation.x, e2), t.orientationY.linearRampToValueAtTime(_orientation.y, e2), t.orientationZ.linearRampToValueAtTime(_orientation.z, e2);
    } else t.setPosition(_position.x, _position.y, _position.z), t.setOrientation(_orientation.x, _orientation.y, _orientation.z);
  }
};
var AudioAnalyser = class {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++) e += t[n];
    return e / t.length;
  }
};
var CubicInterpolant = class extends Interpolant {
  constructor(e, t, n, o) {
    super(e, t, n, o), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 };
  }
  intervalChanged_(e, t, n) {
    const o = this.parameterPositions;
    let r = e - 2, i = e + 1, a = o[r], s = o[i];
    if (void 0 === a) switch (this.getSettings_().endingStart) {
      case 2401:
        r = e, a = 2 * t - n;
        break;
      case 2402:
        r = o.length - 2, a = t + o[r] - o[r + 1];
        break;
      default:
        r = e, a = n;
    }
    if (void 0 === s) switch (this.getSettings_().endingEnd) {
      case 2401:
        i = e, s = 2 * n - t;
        break;
      case 2402:
        i = 1, s = n + o[1] - o[0];
        break;
      default:
        i = e - 1, s = t;
    }
    const l = 0.5 * (n - t), c = this.valueSize;
    this._weightPrev = l / (t - a), this._weightNext = l / (s - n), this._offsetPrev = r * c, this._offsetNext = i * c;
  }
  interpolate_(e, t, n, o) {
    const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, h = this._weightNext, f = (n - t) / (o - t), p = f * f, m = p * f, g = -d * m + 2 * d * p - d * f, _ = (1 + d) * m + (-1.5 - 2 * d) * p + (-0.5 + d) * f + 1, A = (-1 - h) * m + (1.5 + h) * p + 0.5 * f, v = h * m - h * p;
    for (let e2 = 0; e2 !== a; ++e2) r[e2] = g * i[c + e2] + _ * i[l + e2] + A * i[s + e2] + v * i[u + e2];
    return r;
  }
};
function arraySlice(e, t, n) {
  return isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n);
}
function convertArray(e, t, n) {
  return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e);
}
function isTypedArray(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function getKeyframeOrder(e) {
  const t = e.length, n = new Array(t);
  for (let e2 = 0; e2 !== t; ++e2) n[e2] = e2;
  return n.sort(function(t2, n2) {
    return e[t2] - e[n2];
  }), n;
}
function sortedArray(e, t, n) {
  const o = e.length, r = new e.constructor(o);
  for (let i = 0, a = 0; a !== o; ++i) {
    const o2 = n[i] * t;
    for (let n2 = 0; n2 !== t; ++n2) r[a++] = e[o2 + n2];
  }
  return r;
}
function flattenJSON(e, t, n, o) {
  let r = 1, i = e[0];
  for (; void 0 !== i && void 0 === i[o]; ) i = e[r++];
  if (void 0 === i) return;
  let a = i[o];
  if (void 0 !== a) if (Array.isArray(a)) do {
    a = i[o], void 0 !== a && (t.push(i.time), n.push.apply(n, a)), i = e[r++];
  } while (void 0 !== i);
  else if (void 0 !== a.toArray) do {
    a = i[o], void 0 !== a && (t.push(i.time), a.toArray(n, n.length)), i = e[r++];
  } while (void 0 !== i);
  else do {
    a = i[o], void 0 !== a && (t.push(i.time), n.push(a)), i = e[r++];
  } while (void 0 !== i);
}
function subclip(e, t, n, o, r = 30) {
  const i = e.clone();
  i.name = t;
  const a = [];
  i.tracks.forEach((e2) => {
    if (0 === e2.times.length) return;
    const t2 = [Math.max(n / r, e2.times[0]), Math.min(o / r, e2.times[e2.times.length - 1])];
    if (t2[0] > t2[1]) return;
    const i2 = e2.times.findIndex((e3) => e3 >= t2[0]), s2 = e2.times.findLastIndex((e3) => e3 <= t2[1]), l = e2.getValueSize();
    let c = [], u = isTypedArray(e2.times) ? e2.times.subarray(i2, s2 + 1) : e2.times.slice(i2, s2 + 1), d = [], h = [], f = isTypedArray(e2.values) ? e2.values.subarray(i2 * l, (s2 + 1) * l) : e2.values.slice(i2 * l, (s2 + 1) * l), p = [];
    const m = i2 > s2;
    let g, _;
    (m || t2[0] < e2.times[i2]) && (c = [t2[0]], h = e2.createInterpolant().evaluate(c[0])), t2[0] !== t2[1] && (m || t2[1] > e2.times[s2]) && (d = [t2[1]], p = e2.createInterpolant().evaluate(d[0])), isTypedArray(e2.times) ? (g = new e2.times.constructor(c.length + u.length + d.length), g.set(c), g.set(u, c.length), g.set(d, c.length + u.length)) : g = c.concat(u, d), isTypedArray(e2.values) ? (_ = new e2.values.constructor(h.length + f.length + p.length), _.set(h), _.set(f, h.length), _.set(p, h.length + f.length)) : _ = h.concat(f, p), e2.times = g, e2.values = _, a.push(e2);
  });
  const s = a.reduce((e2, t2) => Math.min(e2, t2.times[0]), 1 / 0);
  return a.forEach((e2) => e2.shift(-s)), i.tracks = a, i.resetDuration(), i;
}
function makeClipAdditive(e, t = 0, n = e, o = 30) {
  o <= 0 && (o = 30);
  const r = n.tracks.length, i = t / o;
  for (let t2 = 0; t2 < r; ++t2) {
    const o2 = n.tracks[t2], r2 = o2.ValueTypeName;
    if ("bool" === r2 || "string" === r2) continue;
    const a = e.tracks.find(function(e2) {
      return e2.name === o2.name && e2.ValueTypeName === r2;
    });
    if (void 0 === a) continue;
    let s = 0;
    const l = o2.getValueSize();
    o2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
    let c = 0;
    const u = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
    const d = o2.times.length - 1;
    let h;
    if (i <= o2.times[0]) {
      const e2 = s, t3 = l - s;
      h = arraySlice(o2.values, e2, t3);
    } else if (i >= o2.times[d]) {
      const e2 = d * l + s, t3 = e2 + l - s;
      h = arraySlice(o2.values, e2, t3);
    } else {
      const e2 = o2.createInterpolant(), t3 = s, n2 = l - s;
      e2.evaluate(i), h = arraySlice(e2.resultBuffer, t3, n2);
    }
    if ("quaternion" === r2) {
      new Quaternion().fromArray(h).normalize().conjugate().toArray(h);
    }
    const f = a.times.length;
    for (let e2 = 0; e2 < f; ++e2) {
      const t3 = e2 * u + c;
      if ("quaternion" === r2) Quaternion.multiplyQuaternionsFlat(a.values, t3, h, 0, a.values, t3);
      else {
        const e3 = u - 2 * c;
        for (let n2 = 0; n2 < e3; ++n2) a.values[t3 + n2] -= h[n2];
      }
    }
  }
  return e.blendMode = 2501, e;
}
var AnimationUtils = Object.freeze({ __proto__: null, arraySlice, convertArray, flattenJSON, getKeyframeOrder, isTypedArray, makeClipAdditive, sortedArray, subclip });
var KeyframeTrack = class {
  constructor(e, t, n, o) {
    if (void 0 === e) throw new Error("v3d.KeyframeTrack: track name is undefined");
    if (void 0 === t || 0 === t.length) throw new Error("v3d.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = convertArray(t, this.TimeBufferType), this.values = convertArray(n, this.ValueBufferType), this.setInterpolation(o || this.DefaultInterpolation);
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case 2300:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        t = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === t) {
      const t2 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (e === this.DefaultInterpolation) throw new Error(t2);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("v3d.KeyframeTrack:", t2), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (0 !== e) {
      const t = this.times;
      for (let n = 0, o = t.length; n !== o; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (1 !== e) {
      const t = this.times;
      for (let n = 0, o = t.length; n !== o; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times, o = n.length;
    let r = 0, i = o - 1;
    for (; r !== o && n[r] < e; ) ++r;
    for (; -1 !== i && n[i] > t; ) --i;
    if (++i, 0 !== r || i !== o) {
      r >= i && (i = Math.max(i, 1), r = i - 1);
      const e2 = this.getValueSize();
      this.times = arraySlice(n, r, i), this.values = arraySlice(this.values, r * e2, i * e2);
    }
    return this;
  }
  validate() {
    let e = true;
    const t = this.getValueSize();
    t - Math.floor(t) != 0 && (console.error("v3d.KeyframeTrack: Invalid value size in track.", this), e = false);
    const n = this.times, o = this.values, r = n.length;
    0 === r && (console.error("v3d.KeyframeTrack: Track is empty.", this), e = false);
    let i = null;
    for (let t2 = 0; t2 !== r; t2++) {
      const o2 = n[t2];
      if ("number" == typeof o2 && isNaN(o2)) {
        console.error("v3d.KeyframeTrack: Time is not a valid number.", this, t2, o2), e = false;
        break;
      }
      if (null !== i && i > o2) {
        console.error("v3d.KeyframeTrack: Out of order keys.", this, t2, o2, i), e = false;
        break;
      }
      i = o2;
    }
    if (void 0 !== o && isTypedArray(o)) for (let t2 = 0, n2 = o.length; t2 !== n2; ++t2) {
      const n3 = o[t2];
      if (isNaN(n3)) {
        console.error("v3d.KeyframeTrack: Value is not a valid number.", this, t2, n3), e = false;
        break;
      }
    }
    return e;
  }
  optimize() {
    const e = arraySlice(this.times), t = arraySlice(this.values), n = this.getValueSize(), o = 2302 === this.getInterpolation(), r = e.length - 1;
    let i = 1;
    for (let a = 1; a < r; ++a) {
      let r2 = false;
      const s = e[a];
      if (s !== e[a + 1] && (1 !== a || s !== e[0])) if (o) r2 = true;
      else {
        const e2 = a * n, o2 = e2 - n, i2 = e2 + n;
        for (let a2 = 0; a2 !== n; ++a2) {
          const n2 = t[e2 + a2];
          if (n2 !== t[o2 + a2] || n2 !== t[i2 + a2]) {
            r2 = true;
            break;
          }
        }
      }
      if (r2) {
        if (a !== i) {
          e[i] = e[a];
          const o2 = a * n, r3 = i * n;
          for (let e2 = 0; e2 !== n; ++e2) t[r3 + e2] = t[o2 + e2];
        }
        ++i;
      }
    }
    if (r > 0) {
      e[i] = e[r];
      for (let e2 = r * n, o2 = i * n, a = 0; a !== n; ++a) t[o2 + a] = t[e2 + a];
      ++i;
    }
    return i !== e.length ? (this.times = arraySlice(e, 0, i), this.values = arraySlice(t, 0, i * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = arraySlice(this.times, 0), t = arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = 2301;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = 2300, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(e, t, n, o) {
    super(e, t, n, o);
  }
  interpolate_(e, t, n, o) {
    const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = (n - t) / (o - t);
    let l = e * a;
    for (let e2 = l + a; l !== e2; l += 4) Quaternion.slerpFlat(r, 0, i, l - a, i, l, s);
    return r;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(e) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = 2301, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = 2300, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var PropertyMixer = class {
  constructor(e, t, n) {
    let o, r, i;
    switch (this.binding = e, this.valueSize = n, t) {
      case "quaternion":
        o = this._slerp, r = this._slerpAdditive, i = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        o = this._select, r = this._select, i = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
        break;
      default:
        o = this._lerp, r = this._lerpAdditive, i = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
    }
    this._mixBufferRegion = o, this._mixBufferRegionAdditive = r, this._setIdentity = i, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const n = this.buffer, o = this.valueSize, r = e * o + o;
    let i = this.cumulativeWeight;
    if (0 === i) {
      for (let e2 = 0; e2 !== o; ++e2) n[r + e2] = n[e2];
      i = t;
    } else {
      i += t;
      const e2 = t / i;
      this._mixBufferRegion(n, r, 0, e2, o);
    }
    this.cumulativeWeight = i;
  }
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, o = n * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, o, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, n = this.buffer, o = e * t + t, r = this.cumulativeWeight, i = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const e2 = t * this._origIndex;
      this._mixBufferRegion(n, o, e2, 1 - r, t);
    }
    i > 0 && this._mixBufferRegionAdditive(n, o, this._addIndex * t, 1, t);
    for (let e2 = t, r2 = t + t; e2 !== r2; ++e2) if (n[e2] !== n[e2 + t]) {
      a.setValue(n, o);
      break;
    }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, o = n * this._origIndex;
    e.getValue(t, o);
    for (let e2 = n, r = o; e2 !== r; ++e2) t[e2] = t[o + e2 % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = 3 * this.valueSize;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, o, r) {
    if (o >= 0.5) for (let o2 = 0; o2 !== r; ++o2) e[t + o2] = e[n + o2];
  }
  _slerp(e, t, n, o) {
    Quaternion.slerpFlat(e, t, e, t, e, n, o);
  }
  _slerpAdditive(e, t, n, o, r) {
    const i = this._workIndex * r;
    Quaternion.multiplyQuaternionsFlat(e, i, e, t, e, n), Quaternion.slerpFlat(e, t, e, t, e, i, o);
  }
  _lerp(e, t, n, o, r) {
    const i = 1 - o;
    for (let a = 0; a !== r; ++a) {
      const r2 = t + a;
      e[r2] = e[r2] * i + e[n + a] * o;
    }
  }
  _lerpAdditive(e, t, n, o, r) {
    for (let i = 0; i !== r; ++i) {
      const r2 = t + i;
      e[r2] = e[r2] + e[n + i] * o;
    }
  }
};
var _reservedRe = new RegExp("[\\[\\]\\.]", "g");
var _wordChar = "[^\\[\\]\\.]";
var _wordCharOrDot = "[^" + "\\[\\]\\.".replace("\\.", "") + "]";
/((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones", "map"];
var Composite = class {
  constructor(e, t, n) {
    const o = n || PropertyBinding.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, o);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, o = this._bindings[n];
    void 0 !== o && o.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let o = this._targetGroup.nCachedObjects_, r = n.length; o !== r; ++o) n[o].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
  }
};
var PropertyBinding = class _PropertyBinding {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || _PropertyBinding.parseTrackName(t), this.node = _PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new _PropertyBinding.Composite(e, t, n) : new _PropertyBinding(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(e) {
    const t = _trackRe.exec(e);
    if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = { nodeName: t[1], objectName: t[2], objectIndex: t[3], propertyName: t[4], propertyIndex: t[5] }, o = n.nodeName && n.nodeName.lastIndexOf(".");
    if (void 0 !== o && -1 !== o) {
      const e2 = n.nodeName.substring(o + 1);
      -1 !== _supportedObjectNames.indexOf(e2) && (n.nodeName = n.nodeName.substring(0, o), n.objectName = e2);
    }
    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (void 0 !== n) return n;
    }
    if (e.children) {
      const n = function(e2) {
        for (let o2 = 0; o2 < e2.length; o2++) {
          const r = e2[o2];
          if (r.name === t || r.uuid === t) return r;
          const i = n(r.children);
          if (i) return i;
        }
        return null;
      }, o = n(e.children);
      if (o) return o;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let o = 0, r = n.length; o !== r; ++o) e[t++] = n[o];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let o = 0, r = n.length; o !== r; ++o) n[o] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let o = 0, r = n.length; o !== r; ++o) n[o] = e[t++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let o = 0, r = n.length; o !== r; ++o) n[o] = e[t++];
    if (this.targetObject.matrixWorldNeedsUpdate = true, "morphTargetInfluences" === this.propertyName) {
      const e2 = this.targetObject.getAuxClippingMeshes();
      for (let t2 = 0; t2 < e2.length; t2++) {
        const n2 = e2[t2];
        if (n2.morphTargetInfluences) {
          const e3 = this.targetObject.morphTargetInfluences;
          for (let t3 = 0; t3 < e3.length; t3++) {
            const o = e3[t3];
            n2.morphTargetInfluences[t3] = o;
          }
        }
      }
    }
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, o = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = _PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("v3d.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    if (n) {
      let o2 = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!e.material.materials) return void console.error("v3d.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) return void console.error("v3d.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          e = e.skeleton.bones;
          for (let t2 = 0; t2 < e.length; t2++) if (e[t2].name === o2) {
            o2 = t2;
            break;
          }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!e.material.map) return void console.error("v3d.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
          e = e.material.map;
          break;
        case "constraints":
          if (void 0 === e.constraints) return void console.error("v3d.PropertyBinding: Can not bind to constraints of node undefined.", this);
          e = e.constraints, o2 = o2.replace(/"/g, "");
          for (let t2 = 0; t2 < e.length; t2++) if (e[t2].name === o2) {
            o2 = t2;
            break;
          }
          break;
        default:
          if (void 0 === e[n]) return void console.error("v3d.PropertyBinding: Can not bind to objectName of node undefined.", this);
          e = e[n];
      }
      if (void 0 !== o2) {
        if (void 0 === e[o2]) return void console.error("v3d.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
        e = e[o2];
      }
    }
    let i = e[o];
    if (void 0 === i) {
      const n2 = t.nodeName;
      return void console.error("v3d.PropertyBinding: Trying to update property for track: " + n2 + "." + o + " but it wasn't found.", e);
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.isMeshNodeMaterial || void 0 === e.needsUpdate ? void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate) : a = this.Versioning.NeedsUpdate;
    let s = this.BindingType.Direct;
    if (void 0 !== r) {
      if ("morphTargetInfluences" === o) {
        if (!e.geometry) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!e.geometry.morphAttributes) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r]), this.propertyName = o;
      } else if ("nodeValue" == o) {
        if (r = r.replace(/"/g, ""), !e.nodeValueMap) return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material", this);
        if (r = e.nodeValueMap[r], void 0 === r) return void console.error("v3d.PropertyBinding: Animated node not found ", this);
      }
      if (s = this.BindingType.ArrayElement, "nodeRGB" == o) {
        if (r = r.replace(/"/g, ""), !e.nodeRGBMap) return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material", this);
        if (r = e.nodeRGBMap[r], void 0 === r) return void console.error("v3d.PropertyBinding: Animated node not found ", this);
        s = this.BindingType.HasFromToArray, i = e.nodeRGB[r];
      }
      this.resolvedProperty = i, this.propertyIndex = r;
    } else void 0 !== i.fromArray && void 0 !== i.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = i) : Array.isArray(i) ? (s = this.BindingType.EntireArray, this.resolvedProperty = i, "morphTargetInfluences" === o && (this.propertyName = o)) : this.propertyName = o;
    this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite, PropertyBinding.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, PropertyBinding.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
var AnimationObjectGroup = class {
  constructor() {
    this.isAnimationObjectGroup = true, this.uuid = generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let t2 = 0, n = arguments.length; t2 !== n; ++t2) e[arguments[t2].uuid] = t2;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = { objects: { get total() {
      return t._objects.length;
    }, get inUse() {
      return this.total - t.nCachedObjects_;
    } }, get bindingsPerObject() {
      return t._bindings.length;
    } };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, o = this._parsedPaths, r = this._bindings, i = r.length;
    let a, s = e.length, l = this.nCachedObjects_;
    for (let c = 0, u = arguments.length; c !== u; ++c) {
      const u2 = arguments[c], d = u2.uuid;
      let h = t[d];
      if (void 0 === h) {
        h = s++, t[d] = h, e.push(u2);
        for (let e2 = 0, t2 = i; e2 !== t2; ++e2) r[e2].push(new PropertyBinding(u2, n[e2], o[e2]));
      } else if (h < l) {
        a = e[h];
        const s2 = --l, c2 = e[s2];
        t[c2.uuid] = h, e[h] = c2, t[d] = s2, e[s2] = u2;
        for (let e2 = 0, t2 = i; e2 !== t2; ++e2) {
          const t3 = r[e2], i2 = t3[s2];
          let a2 = t3[h];
          t3[h] = i2, void 0 === a2 && (a2 = new PropertyBinding(u2, n[e2], o[e2])), t3[s2] = a2;
        }
      } else e[h] !== a && console.error("v3d.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, o = n.length;
    let r = this.nCachedObjects_;
    for (let i = 0, a = arguments.length; i !== a; ++i) {
      const a2 = arguments[i], s = a2.uuid, l = t[s];
      if (void 0 !== l && l >= r) {
        const i2 = r++, c = e[i2];
        t[c.uuid] = l, e[l] = c, t[s] = i2, e[i2] = a2;
        for (let e2 = 0, t2 = o; e2 !== t2; ++e2) {
          const t3 = n[e2], o2 = t3[i2], r2 = t3[l];
          t3[l] = o2, t3[i2] = r2;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, o = n.length;
    let r = this.nCachedObjects_, i = e.length;
    for (let a = 0, s = arguments.length; a !== s; ++a) {
      const s2 = arguments[a].uuid, l = t[s2];
      if (void 0 !== l) if (delete t[s2], l < r) {
        const a2 = --r, s3 = e[a2], c = --i, u = e[c];
        t[s3.uuid] = l, e[l] = s3, t[u.uuid] = a2, e[a2] = u, e.pop();
        for (let e2 = 0, t2 = o; e2 !== t2; ++e2) {
          const t3 = n[e2], o2 = t3[a2], r2 = t3[c];
          t3[l] = o2, t3[a2] = r2, t3.pop();
        }
      } else {
        const r2 = --i, a2 = e[r2];
        r2 > 0 && (t[a2.uuid] = l), e[l] = a2, e.pop();
        for (let e2 = 0, t2 = o; e2 !== t2; ++e2) {
          const t3 = n[e2];
          t3[l] = t3[r2], t3.pop();
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let o = n[e];
    const r = this._bindings;
    if (void 0 !== o) return r[o];
    const i = this._paths, a = this._parsedPaths, s = this._objects, l = s.length, c = this.nCachedObjects_, u = new Array(l);
    o = r.length, n[e] = o, i.push(e), a.push(t), r.push(u);
    for (let n2 = c, o2 = s.length; n2 !== o2; ++n2) {
      const o3 = s[n2];
      u[n2] = new PropertyBinding(o3, e, t);
    }
    return u;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (void 0 !== n) {
      const o = this._paths, r = this._parsedPaths, i = this._bindings, a = i.length - 1, s = i[a];
      t[e[a]] = n, i[n] = s, i.pop(), r[n] = r[a], r.pop(), o[n] = o[a], o.pop();
    }
  }
};
var AnimationAction = class {
  constructor(e, t, n = null, o = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = o;
    const r = t.tracks, i = r.length, a = new Array(i), s = { endingStart: 2400, endingEnd: 2400 };
    for (let e2 = 0; e2 !== i; ++e2) {
      const t2 = r[e2].createInterpolant(null);
      a[e2] = t2, t2.settings = s;
    }
    this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._pingIsEven = true, this._startTime = null, this.time = 0, this.timeStart = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this._pingIsEven = true, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const n2 = this._clip.duration, o = e._clip.duration, r = o / n2, i = n2 / o;
      e.warp(1, r, t), this.warp(i, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const o = this._mixer, r = o.time, i = this.timeScale;
    let a = this._timeScaleInterpolant;
    null === a && (a = o._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const s = a.parameterPositions, l = a.sampleValues;
    return s[0] = r, s[1] = r + n, l[0] = e / i, l[1] = t / i, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, o) {
    if (!this.enabled) return void this._updateWeight(e);
    const r = this._startTime;
    if (null !== r) {
      const o2 = (e - r) * n;
      if (o2 < 0 || 0 === n) return;
      this._startTime = null, t = n * o2;
    }
    t *= this._updateTimeScale(e);
    const i = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const e2 = this._interpolants, t2 = this._propertyBindings;
      if (2501 === this.blendMode) for (let n2 = 0, o2 = e2.length; n2 !== o2; ++n2) e2[n2].evaluate(i), t2[n2].accumulateAdditive(a);
      else for (let n2 = 0, r2 = e2.length; n2 !== r2; ++n2) e2[n2].evaluate(i), t2[n2].accumulate(o, a);
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (null !== n) {
        const o = n.evaluate(e)[0];
        t *= o, e > n.parameterPositions[1] && (this.stopFading(), 0 === o && (this.enabled = false));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (null !== n) {
        t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = true : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _loopIsPing(e) {
    if (2202 !== this.loop) return true;
    if (-1 == e) return true;
    return !(1 & e) === this._pingIsEven;
  }
  _updateTime(e) {
    if (0 === e) return this.time;
    if (2200 !== this.loop && this.repetitions <= 0) return this.clampWhenFinished ? this.paused = true : this.enabled = false, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }), this.time;
    var t = this.timeStart, n = Math.max(t, this._clip.duration), o = n - t;
    if (2200 === this.loop) return this.time += e, -1 === this._loopCount && (this._loopCount = 0, this._setEndings(true, true, false)), (this.time < t || this.time > n) && (this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = clamp(this.time, t, n), this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 })), this.time;
    var r = 2202 === this.loop, i = this._loopIsPing(this._loopCount) ? 1 : -1;
    this.time += i * e;
    var a = this.time < t || this.time > n, s = false;
    if (-1 === this._loopCount && (s = a, this._loopCount = s ? -1 : 0, this._pingIsEven = !s, e >= 0 ? this._setEndings(true, 0 === this.repetitions, r) : this._setEndings(0 === this.repetitions, true, r)), a) {
      var l = Math.floor((this.time - t) / o);
      this._loopCount += Math.abs(l);
      var c = this.repetitions - this._loopCount;
      if (c <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = clamp(this.time, t, n), this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
      else {
        if (1 == c) {
          var u = e < 0;
          this._setEndings(u, !u, r);
        } else this._setEndings(false, false, r);
        var d = (this.time - t) % o;
        d < 0 && (d += o), this.time = r ? n - d : d + t, s || this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: l });
      }
    }
    return this.time;
  }
  _setEndings(e, t, n) {
    const o = this._interpolantSettings;
    n ? (o.endingStart = 2401, o.endingEnd = 2401) : (o.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, o.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  }
  _scheduleFading(e, t, n) {
    const o = this._mixer, r = o.time;
    let i = this._weightInterpolant;
    null === i && (i = o._lendControlInterpolant(), this._weightInterpolant = i);
    const a = i.parameterPositions, s = i.sampleValues;
    return a[0] = r, s[0] = t, a[1] = r + e, s[1] = n, this;
  }
};
var AnimationClip = class {
  constructor(e, t = -1, n, o = 2500) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = o, this.uuid = generateUUID(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, o = 1 / (e.fps || 1);
    for (let e2 = 0, r2 = n.length; e2 !== r2; ++e2) t.push(parseKeyframeTrack(n[e2]).scale(o));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static CreateFromMorphTargetSequence(e, t, n, o) {
    const r = t.length, i = [];
    for (let e2 = 0; e2 < r; e2++) {
      let a = [], s = [];
      a.push((e2 + r - 1) % r, e2, (e2 + 1) % r), s.push(0, 1, 0);
      const l = getKeyframeOrder(a);
      a = sortedArray(a, 1, l), s = sortedArray(s, 1, l), o || 0 !== a[0] || (a.push(r), s.push(s[0])), i.push(new NumberKeyframeTrack(".morphTargetInfluences[" + t[e2].name + "]", a, s).scale(1 / n));
    }
    return new this(e, -1, i);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const t2 = e;
      n = t2.geometry && t2.geometry.animations || t2.animations;
    }
    for (let e2 = 0; e2 < n.length; e2++) if (n[e2].name === t) return n[e2];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const o = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let t2 = 0, n2 = e.length; t2 < n2; t2++) {
      const n3 = e[t2], i2 = n3.name.match(r);
      if (i2 && i2.length > 1) {
        const e2 = i2[1];
        let t3 = o[e2];
        t3 || (o[e2] = t3 = []), t3.push(n3);
      }
    }
    const i = [];
    for (const e2 in o) i.push(this.CreateFromMorphTargetSequence(e2, o[e2], t, n));
    return i;
  }
  resetDuration() {
    let e = 0;
    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
      const n2 = this.tracks[t];
      e = Math.max(e, n2.times[n2.times.length - 1]);
    }
    return this.duration = e, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = true;
    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
};
function getTrackTypeForValueTypeName(e) {
  switch (e.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("v3d.KeyframeTrack: Unsupported typeName: " + e);
}
function parseKeyframeTrack(e) {
  if (void 0 === e.type) throw new Error("v3d.KeyframeTrack: track type undefined, can not parse");
  const t = getTrackTypeForValueTypeName(e.type);
  if (void 0 === e.times) {
    const t2 = [], n = [];
    flattenJSON(e.keys, t2, n, "value"), e.times = t2, e.values = n;
  }
  return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
}
var _controlInterpolantsResultBuffer = new Float32Array(1);
var AnimationMixer = class extends EventDispatcher {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, o = e._clip.tracks, r = o.length, i = e._propertyBindings, a = e._interpolants, s = n.uuid, l = this._bindingsByRootAndName;
    let c = l[s];
    void 0 === c && (c = {}, l[s] = c);
    for (let e2 = 0; e2 !== r; ++e2) {
      const r2 = o[e2], l2 = r2.name;
      let u = c[l2];
      if (void 0 !== u) ++u.referenceCount, i[e2] = u;
      else {
        if (u = i[e2], void 0 !== u) {
          null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, s, l2));
          continue;
        }
        const o2 = t && t._propertyBindings[e2].binding.parsedPath;
        u = new PropertyMixer(PropertyBinding.create(n, l2, o2), r2.ValueTypeName, r2.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, s, l2), i[e2] = u;
      }
      a[e2].resultBuffer = u.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (null === e._cacheIndex) {
        const t2 = (e._localRoot || this._root).uuid, n = e._clip.uuid, o = this._actionsByClip[n];
        this._bindAction(e, o && o.knownActions[0]), this._addInactiveAction(e, n, t2);
      }
      const t = e._propertyBindings;
      for (let e2 = 0, n = t.length; e2 !== n; ++e2) {
        const n2 = t[e2];
        0 == n2.useCount++ && (this._lendBinding(n2), n2.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let e2 = 0, n = t.length; e2 !== n; ++e2) {
        const n2 = t[e2];
        0 == --n2.useCount && (n2.restoreOriginalState(), this._takeBackBinding(n2));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = { actions: { get total() {
      return e._actions.length;
    }, get inUse() {
      return e._nActiveActions;
    } }, bindings: { get total() {
      return e._bindings.length;
    }, get inUse() {
      return e._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return e._controlInterpolants.length;
    }, get inUse() {
      return e._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return null !== t && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const o = this._actions, r = this._actionsByClip;
    let i = r[t];
    if (void 0 === i) i = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = i;
    else {
      const t2 = i.knownActions;
      e._byClipCacheIndex = t2.length, t2.push(e);
    }
    e._cacheIndex = o.length, o.push(e), i.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], o = e._cacheIndex;
    n._cacheIndex = o, t[o] = n, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, i = this._actionsByClip, a = i[r], s = a.knownActions, l = s[s.length - 1], c = e._byClipCacheIndex;
    l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null;
    delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete i[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let e2 = 0, n = t.length; e2 !== n; ++e2) {
      const n2 = t[e2];
      0 == --n2.referenceCount && this._removeInactiveBinding(n2);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, o = this._nActiveActions++, r = t[o];
    e._cacheIndex = o, t[o] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, o = --this._nActiveActions, r = t[o];
    e._cacheIndex = o, t[o] = e, r._cacheIndex = n, t[n] = r;
  }
  _addInactiveBinding(e, t, n) {
    const o = this._bindingsByRootAndName, r = this._bindings;
    let i = o[t];
    void 0 === i && (i = {}, o[t] = i), i[n] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, o = n.rootNode.uuid, r = n.path, i = this._bindingsByRootAndName, a = i[o], s = t[t.length - 1], l = e._cacheIndex;
    s._cacheIndex = l, t[l] = s, t.pop(), delete a[r], 0 === Object.keys(a).length && delete i[o];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, o = this._nActiveBindings++, r = t[o];
    e._cacheIndex = o, t[o] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, o = --this._nActiveBindings, r = t[o];
    e._cacheIndex = o, t[o] = e, r._cacheIndex = n, t[n] = r;
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return void 0 === n && (n = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, o = --this._nActiveControlInterpolants, r = t[o];
    e.__cacheIndex = o, t[o] = e, r.__cacheIndex = n, t[n] = r;
  }
  clipAction(e, t, n) {
    const o = t || this._root, r = o.uuid;
    let i = "string" == typeof e ? AnimationClip.findByName(o, e) : e;
    const a = null !== i ? i.uuid : e, s = this._actionsByClip[a];
    let l = null;
    if (void 0 === n && (n = null !== i ? i.blendMode : 2500), void 0 !== s) {
      const e2 = s.actionByRoot[r];
      if (void 0 !== e2 && e2.blendMode === n) return e2;
      l = s.knownActions[0], null === i && (i = l._clip);
    }
    if (null === i) return null;
    const c = new AnimationAction(this, i, t, n);
    return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
  }
  existingAction(e, t) {
    const n = t || this._root, o = n.uuid, r = "string" == typeof e ? AnimationClip.findByName(n, e) : e, i = r ? r.uuid : e, a = this._actionsByClip[i];
    return void 0 !== a && a.actionByRoot[o] || null;
  }
  stopAllAction() {
    const e = this._actions;
    for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, o = this.time += e, r = Math.sign(e), i = this._accuIndex ^= 1;
    for (let a2 = 0; a2 !== n; ++a2) {
      t[a2]._update(o, e, r, i);
    }
    const a = this._bindings, s = this._nActiveBindings;
    for (let e2 = 0; e2 !== s; ++e2) a[e2].apply(i);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let e2 = 0; e2 < this._actions.length; e2++) this._actions[e2].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, o = this._actionsByClip, r = o[n];
    if (void 0 !== r) {
      const e2 = r.knownActions;
      for (let n2 = 0, o2 = e2.length; n2 !== o2; ++n2) {
        const o3 = e2[n2];
        this._deactivateAction(o3);
        const r2 = o3._cacheIndex, i = t[t.length - 1];
        o3._cacheIndex = null, o3._byClipCacheIndex = null, i._cacheIndex = r2, t[r2] = i, t.pop(), this._removeInactiveBindingsForAction(o3);
      }
      delete o[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const e2 in n) {
      const o2 = n[e2].actionByRoot[t];
      void 0 !== o2 && (this._deactivateAction(o2), this._removeInactiveAction(o2));
    }
    const o = this._bindingsByRootAndName[t];
    if (void 0 !== o) for (const e2 in o) {
      const t2 = o[e2];
      t2.restoreOriginalState(), this._removeInactiveBinding(t2);
    }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
};
var Uniform = class _Uniform {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new _Uniform(void 0 === this.value.clone ? this.value : this.value.clone());
  }
};
var id = 0;
var UniformsGroup = class extends EventDispatcher {
  constructor() {
    super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", { value: id++ }), this.name = "", this.usage = 35044, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return -1 !== t && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let e2 = 0, n = t.length; e2 < n; e2++) this.uniforms.push(t[e2].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var InstancedBufferGeometry = class extends BufferGeometry {
  constructor() {
    super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
};
var InstancedInterleavedBuffer = class extends InterleavedBuffer {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
};
var GLBufferAttribute = class {
  constructor(e, t, n, o, r) {
    this.isGLBufferAttribute = true, this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = o, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    true === e && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
};
var Cylindrical = class {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$4 = new Vector2();
var Box2 = class {
  constructor(e = new Vector2(1 / 0, 1 / 0), t = new Vector2(-1 / 0, -1 / 0)) {
    this.isBox2 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = _vector$4.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return _vector$4.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
};
var _startP = new Vector3();
var _startEnd = new Vector3();
var Line3 = class {
  constructor(e = new Vector3(), t = new Vector3()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    _startP.subVectors(e, this.start), _startEnd.subVectors(this.end, this.start);
    const n = _startEnd.dot(_startEnd);
    let o = _startEnd.dot(_startP) / n;
    return t && (o = clamp(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, n) {
    const o = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(o).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$3 = new Vector3();
var SpotLightHelper = class extends Object3D {
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = false, this.color = t, this.type = "SpotLightHelper";
    const n = new BufferGeometry(), o = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let e2 = 0, t2 = 1, n2 = 32; e2 < n2; e2++, t2++) {
      const r2 = e2 / n2 * Math.PI * 2, i = t2 / n2 * Math.PI * 2;
      o.push(Math.cos(r2), Math.sin(r2), 1, Math.cos(i), Math.sin(i), 1);
    }
    n.setAttribute("position", new Float32BufferAttribute(o, 3));
    const r = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(n, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), this.parent ? (this.parent.updateWorldMatrix(true), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), _vector$3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$3), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
};
var _vector$2 = new Vector3();
var _boneMatrix = new Matrix4();
var _matrixWorldInv = new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(e) {
    const t = getBoneList(e), n = new BufferGeometry(), o = [], r = [], i = new Color(0, 0, 1), a = new Color(0, 1, 0);
    for (let e2 = 0; e2 < t.length; e2++) {
      const n2 = t[e2];
      n2.parent && n2.parent.isBone && (o.push(0, 0, 0), o.push(0, 0, 0), r.push(i.r, i.g, i.b), r.push(a.r, a.g, a.b));
    }
    n.setAttribute("position", new Float32BufferAttribute(o, 3)), n.setAttribute("color", new Float32BufferAttribute(r, 3));
    super(n, new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(e) {
    this.parent ? this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.root.matrixWorld) : this.matrix.copy(this.root.matrixWorld);
    const t = this.bones, n = this.geometry, o = n.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let e2 = 0, n2 = 0; e2 < t.length; e2++) {
      const r = t[e2];
      r.parent && r.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, r.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), o.setXYZ(n2, _vector$2.x, _vector$2.y, _vector$2.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, r.parent.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), o.setXYZ(n2 + 1, _vector$2.x, _vector$2.y, _vector$2.z), n2 += 2);
    }
    n.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
function getBoneList(e) {
  const t = [];
  true === e.isBone && t.push(e);
  for (let n = 0; n < e.children.length; n++) t.push.apply(t, getBoneList(e.children[n]));
  return t;
}
var PointLightHelper = class extends Mesh {
  constructor(e, t, n) {
    super(new SphereGeometry(t, 4, 3), new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false })), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrixAutoUpdate = false, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.parent ? (this.parent.updateWorldMatrix(true), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
};
var _vector$1 = new Vector3();
var _color1 = new Color();
var _color2 = new Color();
var HemisphereLightHelper = class extends Object3D {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n, this.type = "HemisphereLightHelper";
    const o = new OctahedronGeometry(t);
    o.rotateY(0.5 * Math.PI), this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false }), void 0 === this.color && (this.material.vertexColors = true);
    const r = o.getAttribute("position"), i = new Float32Array(3 * r.count);
    o.setAttribute("color", new BufferAttribute(i, 3)), this.add(new Mesh(o, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (void 0 !== this.color) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
      for (let e2 = 0, n = t.count; e2 < n; e2++) {
        const o = e2 < n / 2 ? _color1 : _color2;
        t.setXYZ(e2, o.r, o.g, o.b);
      }
      t.needsUpdate = true;
    }
    this.light.updateWorldMatrix(true, false), e.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
};
var GridHelper = class extends LineSegments {
  constructor(e = 10, t = 10, n = 4473924, o = 8947848) {
    n = new Color(n), o = new Color(o);
    const r = t / 2, i = e / t, a = e / 2, s = [], l = [];
    for (let e2 = 0, c2 = 0, u = -a; e2 <= t; e2++, u += i) {
      s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
      const t2 = e2 === r ? n : o;
      t2.toArray(l, c2), c2 += 3, t2.toArray(l, c2), c2 += 3, t2.toArray(l, c2), c2 += 3, t2.toArray(l, c2), c2 += 3;
    }
    const c = new BufferGeometry();
    c.setAttribute("position", new Float32BufferAttribute(s, 3)), c.setAttribute("color", new Float32BufferAttribute(l, 3));
    super(c, new LineBasicMaterial({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var PolarGridHelper = class extends LineSegments {
  constructor(e = 10, t = 16, n = 8, o = 64, r = 4473924, i = 8947848) {
    r = new Color(r), i = new Color(i);
    const a = [], s = [];
    if (t > 1) for (let n2 = 0; n2 < t; n2++) {
      const o2 = n2 / t * (2 * Math.PI), l2 = Math.sin(o2) * e, c = Math.cos(o2) * e;
      a.push(0, 0, 0), a.push(l2, 0, c);
      const u = 1 & n2 ? r : i;
      s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b);
    }
    for (let t2 = 0; t2 < n; t2++) {
      const l2 = 1 & t2 ? r : i, c = e - e / n * t2;
      for (let e2 = 0; e2 < o; e2++) {
        let t3 = e2 / o * (2 * Math.PI), n2 = Math.sin(t3) * c, r2 = Math.cos(t3) * c;
        a.push(n2, 0, r2), s.push(l2.r, l2.g, l2.b), t3 = (e2 + 1) / o * (2 * Math.PI), n2 = Math.sin(t3) * c, r2 = Math.cos(t3) * c, a.push(n2, 0, r2), s.push(l2.r, l2.g, l2.b);
      }
    }
    const l = new BufferGeometry();
    l.setAttribute("position", new Float32BufferAttribute(a, 3)), l.setAttribute("color", new Float32BufferAttribute(s, 3));
    super(l, new LineBasicMaterial({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var Box3Helper = class extends LineSegments {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), o = new BufferGeometry();
    o.setIndex(new BufferAttribute(n, 1)), o.setAttribute("position", new Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(o, new LineBasicMaterial({ color: t, toneMapped: false })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var _v1$1 = new Vector3();
var _v2$1 = new Vector3();
var _v3 = new Vector3();
var DirectionalLightHelper = class extends Object3D {
  constructor(e, t, n) {
    super(), this.light = e, this.matrixAutoUpdate = false, this.color = n, this.type = "DirectionalLightHelper", void 0 === t && (t = 1);
    let o = new BufferGeometry();
    o.setAttribute("position", new Float32BufferAttribute([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
    const r = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(o, r), this.add(this.lightPlane), o = new BufferGeometry(), o.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(o, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), this.parent ? (this.parent.updateWorldMatrix(true), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), _v1$1.setFromMatrixPosition(this.light.matrixWorld), _v2$1.setFromMatrixPosition(this.light.target.matrixWorld), _v3.subVectors(_v2$1, _v1$1), this.lightPlane.lookAt(_v2$1), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2$1), this.targetLine.scale.z = _v3.length();
  }
};
var DirectionalLightCSMHelper = class extends Object3D {
  constructor(e) {
    super(), this.csm = e, this.displayFrustum = true, this.displayPlanes = true, this.displayShadowBounds = true;
    const t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(24), o = new BufferGeometry();
    o.setIndex(new BufferAttribute(t, 1)), o.setAttribute("position", new BufferAttribute(n, 3, false));
    const r = new LineSegments(o, new LineBasicMaterial());
    this.add(r), this.frustumLines = r, this.cascadeLines = [], this.cascadePlanes = [], this.shadowLines = [];
  }
  updateVisibility() {
    const e = this.displayFrustum && this.visible, t = this.displayPlanes && this.visible, n = this.displayShadowBounds && this.visible, o = this.frustumLines, r = this.cascadeLines, i = this.cascadePlanes, a = this.shadowLines;
    for (let o2 = 0, s = r.length; o2 < s; o2++) {
      const s2 = r[o2], l = i[o2], c = a[o2];
      s2.visible = e, l.visible = e && t, c.visible = n, c.traverse((e2) => {
        e2.visible = n;
      });
    }
    o.visible = e;
  }
  update() {
    const e = this.csm, t = e._sceneViewCamera;
    if (!t || e._needsUpdate) return;
    const n = e._cascades, o = n.length, r = e.mainFrustum, i = e._frustums, a = this.frustumLines.geometry.getAttribute("position"), s = this.cascadeLines, l = this.cascadePlanes, c = this.shadowLines;
    for (this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.updateWorldMatrix(false, true); s.length > o; ) {
      this.remove(s.pop()), this.remove(l.pop());
      const e2 = c.pop();
      e2.children[0].dispose(), this.remove(e2);
    }
    for (; s.length < o; ) {
      const e2 = new Box3Helper(new Box3(), 16777215), t2 = new MeshBasicMaterial({ transparent: true, opacity: 0.1, depthWrite: false, side: 2 }), n2 = new Mesh(new PlaneGeometry(), t2), o2 = new Group(), r2 = new Box3Helper(new Box3(), 16776960);
      o2.add(r2), this.add(e2), this.add(n2), this.add(o2), s.push(e2), l.push(n2), c.push(o2);
    }
    for (let e2 = 0; e2 < o; e2++) {
      const t2 = i[e2], o2 = n[e2].camera, r2 = t2.vertices.far, a2 = s[e2], u2 = l[e2], d2 = c[e2], h = d2.children[0];
      a2.box.min.copy(r2[2]), a2.box.max.copy(r2[0]), a2.box.max.z += 1e-4, u2.position.addVectors(r2[0], r2[2]), u2.position.multiplyScalar(0.5), u2.scale.subVectors(r2[0], r2[2]), u2.scale.z = 1e-4, this.remove(d2), d2.position.copy(o2.position), d2.quaternion.copy(o2.quaternion), d2.scale.copy(o2.scale), d2.updateWorldMatrix(false, true), this.attach(d2), h.box.min.set(o2.bottom, o2.left, -o2.far), h.box.max.set(o2.top, o2.right, -o2.near);
    }
    const u = r.vertices.near, d = r.vertices.far;
    a.setXYZ(0, d[0].x, d[0].y, d[0].z), a.setXYZ(1, d[3].x, d[3].y, d[3].z), a.setXYZ(2, d[2].x, d[2].y, d[2].z), a.setXYZ(3, d[1].x, d[1].y, d[1].z), a.setXYZ(4, u[0].x, u[0].y, u[0].z), a.setXYZ(5, u[3].x, u[3].y, u[3].z), a.setXYZ(6, u[2].x, u[2].y, u[2].z), a.setXYZ(7, u[1].x, u[1].y, u[1].z), a.needsUpdate = true;
  }
  dispose() {
    const e = this.frustumLines, t = this.cascadeLines, n = this.cascadePlanes, o = this.shadowLines;
    e.geometry.dispose(), e.material.dispose();
    const r = this.csm.cascades;
    for (let e2 = 0; e2 < r; e2++) {
      const r2 = t[e2], i = n[e2], a = o[e2].children[0];
      r2.dispose(), i.geometry.dispose(), i.material.dispose(), a.dispose();
    }
  }
};
var _vector = new Vector3();
var _camera = new Camera();
var CameraHelper = class extends LineSegments {
  constructor(e) {
    const t = new BufferGeometry(), n = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false }), o = [], r = [], i = {};
    function a(e2, t2) {
      s(e2), s(t2);
    }
    function s(e2) {
      o.push(0, 0, 0), r.push(0, 0, 0), void 0 === i[e2] && (i[e2] = []), i[e2].push(o.length / 3 - 1);
    }
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), t.setAttribute("position", new Float32BufferAttribute(o, 3)), t.setAttribute("color", new Float32BufferAttribute(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = i, this.update();
    const l = new Color(16755200), c = new Color(16711680), u = new Color(43775), d = new Color(16777215), h = new Color(3355443);
    this.setColors(l, c, u, d, h);
  }
  setColors(e, t, n, o, r) {
    const i = this.geometry.getAttribute("color");
    i.setXYZ(0, e.r, e.g, e.b), i.setXYZ(1, e.r, e.g, e.b), i.setXYZ(2, e.r, e.g, e.b), i.setXYZ(3, e.r, e.g, e.b), i.setXYZ(4, e.r, e.g, e.b), i.setXYZ(5, e.r, e.g, e.b), i.setXYZ(6, e.r, e.g, e.b), i.setXYZ(7, e.r, e.g, e.b), i.setXYZ(8, e.r, e.g, e.b), i.setXYZ(9, e.r, e.g, e.b), i.setXYZ(10, e.r, e.g, e.b), i.setXYZ(11, e.r, e.g, e.b), i.setXYZ(12, e.r, e.g, e.b), i.setXYZ(13, e.r, e.g, e.b), i.setXYZ(14, e.r, e.g, e.b), i.setXYZ(15, e.r, e.g, e.b), i.setXYZ(16, e.r, e.g, e.b), i.setXYZ(17, e.r, e.g, e.b), i.setXYZ(18, e.r, e.g, e.b), i.setXYZ(19, e.r, e.g, e.b), i.setXYZ(20, e.r, e.g, e.b), i.setXYZ(21, e.r, e.g, e.b), i.setXYZ(22, e.r, e.g, e.b), i.setXYZ(23, e.r, e.g, e.b), i.setXYZ(24, t.r, t.g, t.b), i.setXYZ(25, t.r, t.g, t.b), i.setXYZ(26, t.r, t.g, t.b), i.setXYZ(27, t.r, t.g, t.b), i.setXYZ(28, t.r, t.g, t.b), i.setXYZ(29, t.r, t.g, t.b), i.setXYZ(30, t.r, t.g, t.b), i.setXYZ(31, t.r, t.g, t.b), i.setXYZ(32, n.r, n.g, n.b), i.setXYZ(33, n.r, n.g, n.b), i.setXYZ(34, n.r, n.g, n.b), i.setXYZ(35, n.r, n.g, n.b), i.setXYZ(36, n.r, n.g, n.b), i.setXYZ(37, n.r, n.g, n.b), i.setXYZ(38, o.r, o.g, o.b), i.setXYZ(39, o.r, o.g, o.b), i.setXYZ(40, r.r, r.g, r.b), i.setXYZ(41, r.r, r.g, r.b), i.setXYZ(42, r.r, r.g, r.b), i.setXYZ(43, r.r, r.g, r.b), i.setXYZ(44, r.r, r.g, r.b), i.setXYZ(45, r.r, r.g, r.b), i.setXYZ(46, r.r, r.g, r.b), i.setXYZ(47, r.r, r.g, r.b), i.setXYZ(48, r.r, r.g, r.b), i.setXYZ(49, r.r, r.g, r.b), i.needsUpdate = true;
  }
  update() {
    const e = this.geometry, t = this.pointMap;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", t, e, _camera, 0, 0, -1), setPoint("t", t, e, _camera, 0, 0, 1), setPoint("n1", t, e, _camera, -1, -1, -1), setPoint("n2", t, e, _camera, 1, -1, -1), setPoint("n3", t, e, _camera, -1, 1, -1), setPoint("n4", t, e, _camera, 1, 1, -1), setPoint("f1", t, e, _camera, -1, -1, 1), setPoint("f2", t, e, _camera, 1, -1, 1), setPoint("f3", t, e, _camera, -1, 1, 1), setPoint("f4", t, e, _camera, 1, 1, 1), setPoint("u1", t, e, _camera, 0.7, 1.1, -1), setPoint("u2", t, e, _camera, -0.7, 1.1, -1), setPoint("u3", t, e, _camera, 0, 2, -1), setPoint("cf1", t, e, _camera, -1, 0, 1), setPoint("cf2", t, e, _camera, 1, 0, 1), setPoint("cf3", t, e, _camera, 0, -1, 1), setPoint("cf4", t, e, _camera, 0, 1, 1), setPoint("cn1", t, e, _camera, -1, 0, -1), setPoint("cn2", t, e, _camera, 1, 0, -1), setPoint("cn3", t, e, _camera, 0, -1, -1), setPoint("cn4", t, e, _camera, 0, 1, -1), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
function setPoint(e, t, n, o, r, i, a) {
  _vector.set(r, i, a).unproject(o);
  const s = t[e];
  if (void 0 !== s) {
    const e2 = n.getAttribute("position");
    for (let t2 = 0, n2 = s.length; t2 < n2; t2++) e2.setXYZ(s[t2], _vector.x, _vector.y, _vector.z);
  }
}
var _box$1 = new Box3();
var BoxHelper = class extends LineSegments {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), o = new Float32Array(24), r = new BufferGeometry();
    r.setIndex(new BufferAttribute(n, 1)), r.setAttribute("position", new BufferAttribute(o, 3)), super(r, new LineBasicMaterial({ color: t, toneMapped: false })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
  }
  update(e) {
    if (void 0 !== e && console.warn("v3d.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && _box$1.setFromObject(this.object), _box$1.isEmpty()) return;
    const t = _box$1.min, n = _box$1.max, o = this.geometry.attributes.position, r = o.array;
    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, o.needsUpdate = true, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var PlaneHelper = class extends Line {
  constructor(e, t = 1, n = 16776960) {
    const o = n, r = new BufferGeometry();
    r.setAttribute("position", new Float32BufferAttribute([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new LineBasicMaterial({ color: o, toneMapped: false })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const i = new BufferGeometry();
    i.setAttribute("position", new Float32BufferAttribute([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new Mesh(i, new MeshBasicMaterial({ color: o, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
};
var _axis = new Vector3();
var _lineGeometry;
var _coneGeometry;
var ArrowHelper = class extends Object3D {
  constructor(e = new Vector3(0, 0, 1), t = new Vector3(0, 0, 0), n = 1, o = 16776960, r = 0.2 * n, i = 0.2 * r) {
    super(), this.type = "ArrowHelper", void 0 === _lineGeometry && (_lineGeometry = new BufferGeometry(), _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1), _coneGeometry.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: o, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: o, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(n, r, i);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(_axis, t);
    }
  }
  setLength(e, t = 0.2 * e, n = 0.2 * t) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
};
var AxesHelper = class extends LineSegments {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], n = new BufferGeometry();
    n.setAttribute("position", new Float32BufferAttribute(t, 3)), n.setAttribute("color", new Float32BufferAttribute([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
    super(n, new LineBasicMaterial({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const o = new Color(), r = this.geometry.attributes.color.array;
    return o.set(e), o.toArray(r, 0), o.toArray(r, 3), o.set(t), o.toArray(r, 6), o.toArray(r, 9), o.set(n), o.toArray(r, 12), o.toArray(r, 15), this.geometry.attributes.color.needsUpdate = true, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var ShapePath = class {
  constructor() {
    this.type = "ShapePath", this.color = new Color(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, o) {
    return this.currentPath.quadraticCurveTo(e, t, n, o), this;
  }
  bezierCurveTo(e, t, n, o, r, i) {
    return this.currentPath.bezierCurveTo(e, t, n, o, r, i), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(e2, t2) {
      const n2 = t2.length;
      let o2 = false;
      for (let r2 = n2 - 1, i2 = 0; i2 < n2; r2 = i2++) {
        let n3 = t2[r2], a2 = t2[i2], s2 = a2.x - n3.x, l2 = a2.y - n3.y;
        if (Math.abs(l2) > Number.EPSILON) {
          if (l2 < 0 && (n3 = t2[i2], s2 = -s2, a2 = t2[r2], l2 = -l2), e2.y < n3.y || e2.y > a2.y) continue;
          if (e2.y === n3.y) {
            if (e2.x === n3.x) return true;
          } else {
            const t3 = l2 * (e2.x - n3.x) - s2 * (e2.y - n3.y);
            if (0 === t3) return true;
            if (t3 < 0) continue;
            o2 = !o2;
          }
        } else {
          if (e2.y !== n3.y) continue;
          if (a2.x <= e2.x && e2.x <= n3.x || n3.x <= e2.x && e2.x <= a2.x) return true;
        }
      }
      return o2;
    }
    const n = ShapeUtils.isClockWise, o = this.subPaths;
    if (0 === o.length) return [];
    let r, i, a;
    const s = [];
    if (1 === o.length) return i = o[0], a = new Shape(), a.curves = i.curves, s.push(a), s;
    let l = !n(o[0].getPoints());
    l = e ? !l : l;
    const c = [], u = [];
    let d, h, f = [], p = 0;
    u[p] = void 0, f[p] = [];
    for (let t2 = 0, a2 = o.length; t2 < a2; t2++) i = o[t2], d = i.getPoints(), r = n(d), r = e ? !r : r, r ? (!l && u[p] && p++, u[p] = { s: new Shape(), p: d }, u[p].s.curves = i.curves, l && p++, f[p] = []) : f[p].push({ h: i, p: d[0] });
    if (!u[0]) return function(e2) {
      const t2 = [];
      for (let n2 = 0, o2 = e2.length; n2 < o2; n2++) {
        const o3 = e2[n2], r2 = new Shape();
        r2.curves = o3.curves, t2.push(r2);
      }
      return t2;
    }(o);
    if (u.length > 1) {
      let e2 = false, n2 = 0;
      for (let e3 = 0, t2 = u.length; e3 < t2; e3++) c[e3] = [];
      for (let o2 = 0, r2 = u.length; o2 < r2; o2++) {
        const r3 = f[o2];
        for (let i2 = 0; i2 < r3.length; i2++) {
          const a2 = r3[i2];
          let s2 = true;
          for (let r4 = 0; r4 < u.length; r4++) t(a2.p, u[r4].p) && (o2 !== r4 && n2++, s2 ? (s2 = false, c[r4].push(a2)) : e2 = true);
          s2 && c[o2].push(a2);
        }
      }
      n2 > 0 && false === e2 && (f = c);
    }
    for (let e2 = 0, t2 = u.length; e2 < t2; e2++) {
      a = u[e2].s, s.push(a), h = f[e2];
      for (let e3 = 0, t3 = h.length; e3 < t3; e3++) a.holes.push(h[e3].h);
    }
    return s;
  }
};
var _tables = _generateTables();
function _generateTables() {
  const e = new ArrayBuffer(4), t = new Float32Array(e), n = new Uint32Array(e), o = new Uint32Array(512), r = new Uint32Array(512);
  for (let e2 = 0; e2 < 256; ++e2) {
    const t2 = e2 - 127;
    t2 < -27 ? (o[e2] = 0, o[256 | e2] = 32768, r[e2] = 24, r[256 | e2] = 24) : t2 < -14 ? (o[e2] = 1024 >> -t2 - 14, o[256 | e2] = 1024 >> -t2 - 14 | 32768, r[e2] = -t2 - 1, r[256 | e2] = -t2 - 1) : t2 <= 15 ? (o[e2] = t2 + 15 << 10, o[256 | e2] = t2 + 15 << 10 | 32768, r[e2] = 13, r[256 | e2] = 13) : t2 < 128 ? (o[e2] = 31744, o[256 | e2] = 64512, r[e2] = 24, r[256 | e2] = 24) : (o[e2] = 31744, o[256 | e2] = 64512, r[e2] = 13, r[256 | e2] = 13);
  }
  const i = new Uint32Array(2048), a = new Uint32Array(64), s = new Uint32Array(64);
  for (let e2 = 1; e2 < 1024; ++e2) {
    let t2 = e2 << 13, n2 = 0;
    for (; !(8388608 & t2); ) t2 <<= 1, n2 -= 8388608;
    t2 &= -8388609, n2 += 947912704, i[e2] = t2 | n2;
  }
  for (let e2 = 1024; e2 < 2048; ++e2) i[e2] = 939524096 + (e2 - 1024 << 13);
  for (let e2 = 1; e2 < 31; ++e2) a[e2] = e2 << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let e2 = 33; e2 < 63; ++e2) a[e2] = 2147483648 + (e2 - 32 << 23);
  a[63] = 3347054592;
  for (let e2 = 1; e2 < 64; ++e2) 32 !== e2 && (s[e2] = 1024);
  return { floatView: t, uint32View: n, baseTable: o, shiftTable: r, mantissaTable: i, exponentTable: a, offsetTable: s };
}
function toHalfFloat(e) {
  Math.abs(e) > 65504 && console.warn("v3d.DataUtils.toHalfFloat(): Value out of range."), e = clamp(e, -65504, 65504), _tables.floatView[0] = e;
  const t = _tables.uint32View[0], n = t >> 23 & 511;
  return _tables.baseTable[n] + ((8388607 & t) >> _tables.shiftTable[n]);
}
function fromHalfFloat(e) {
  const t = e >> 10;
  return _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[t] + (1023 & e)] + _tables.exponentTable[t], _tables.floatView[0];
}
var DataUtils = Object.freeze({ __proto__: null, fromHalfFloat, toHalfFloat });
var AfterimagePass = class extends Pass {
  constructor(e, t, n) {
    super(), this.damp = t, this.shader = ShaderLib.afterimage, this.uniforms = UniformsUtils.clone(this.shader.uniforms), this.uniforms.damp.value = this.damp, this.textureComp = new WebGLRenderTarget(e.x, e.y, n), this.textureComp.texture.name = "AfterImage.comp", this.textureOld = new WebGLRenderTarget(e.x, e.y, n), this.textureOld.texture.name = "AfterImage.old", this.shaderMaterial = new ShaderMaterial({ uniforms: this.uniforms, vertexShader: this.shader.vertexShader, fragmentShader: this.shader.fragmentShader }), this.compFsQuad = new FullScreenQuad(this.shaderMaterial);
    const o = new MeshBasicMaterial();
    this.copyFsQuad = new FullScreenQuad(o);
  }
  dispose() {
    this.textureComp.dispose(), this.textureOld.dispose();
  }
  render(e, t, n) {
    this.uniforms.tOld.value = this.textureOld.texture, this.uniforms.tNew.value = n.texture, this.uniforms.damp.value = this.damp, e.setRenderTarget(this.textureComp), this.compFsQuad.render(e), this.copyFsQuad.material.map = this.textureComp.texture, this.renderToScreen ? (e.setRenderTarget(null), this.copyFsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(), this.copyFsQuad.render(e));
    const o = this.textureOld;
    this.textureOld = this.textureComp, this.textureComp = o;
  }
  setSize(e, t) {
    this.textureComp.setSize(e, t), this.textureOld.setSize(e, t);
  }
};
var BloomPass = class _BloomPass extends Pass {
  constructor(e, t, n, o, r) {
    super(), this.strength = void 0 !== t ? t : 1, this.radius = clamp(n), this.threshold = o, this.resolution = void 0 !== e ? new Vector2(e.x, e.y) : new Vector2(256, 256), r = r || { minFilter: 1006, magFilter: 1006, format: 1023 }, this.clearColor = new Color(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let i = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new WebGLRenderTarget(i, a, r), this.renderTargetBright.texture.name = "BloomPass.bright", this.renderTargetBright.texture.generateMipmaps = false;
    for (let e2 = 0; e2 < this.nMips; e2++) {
      const t2 = new WebGLRenderTarget(i, a, r);
      t2.texture.name = "BloomPass.h" + e2, t2.texture.generateMipmaps = false, this.renderTargetsHorizontal.push(t2);
      const n2 = new WebGLRenderTarget(i, a, r);
      n2.texture.name = "BloomPass.v" + e2, n2.texture.generateMipmaps = false, this.renderTargetsVertical.push(n2), i = Math.round(i / 2), a = Math.round(a / 2);
    }
    const s = ShaderLib.bloomLumHighPass;
    this.highPassUniforms = UniformsUtils.clone(s.uniforms), this.highPassUniforms.luminosityThreshold.value = o, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new ShaderMaterial({ type: "BloomHighPass", uniforms: this.highPassUniforms, vertexShader: s.vertexShader, fragmentShader: s.fragmentShader, defines: {} }), this.separableBlurMaterials = [];
    const l = [3, 5, 7, 9, 11];
    i = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
    for (let e2 = 0; e2 < this.nMips; e2++) this.separableBlurMaterials.push(this.getSeparableBlurMaterial(l[e2], l[e2] / 3)), this.separableBlurMaterials[e2].uniforms.texSize.value = new Vector2(i, a), i = Math.round(i / 2), a = Math.round(a / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1, this.compositeMaterial.needsUpdate = true;
    this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2], this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
    const c = ShaderLib.copy;
    this.copyUniforms = UniformsUtils.clone(c.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new ShaderMaterial({ type: "BloomCopy", defines: Object.assign({}, c.defines), uniforms: this.copyUniforms, vertexShader: c.vertexShader, fragmentShader: c.fragmentShader, blending: 5, blendEquation: 100, blendEquationAlpha: 100, blendSrc: 204, blendDst: 201, blendSrcAlpha: 200, blendDstAlpha: 201, depthTest: false, depthWrite: false, transparent: true }), this.enabled = true, this.needsSwap = false, this._oldClearColor = new Color(), this.oldClearAlpha = 1, this.basic = new MeshBasicMaterial(), this.fsQuad = new FullScreenQuad(null);
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
  }
  setSize(e, t) {
    let n = Math.round(e / 2), o = Math.round(t / 2);
    this.renderTargetBright.setSize(n, o);
    for (let e2 = 0; e2 < this.nMips; e2++) this.renderTargetsHorizontal[e2].setSize(n, o), this.renderTargetsVertical[e2].setSize(n, o), this.separableBlurMaterials[e2].uniforms.texSize.value = new Vector2(n, o), n = Math.round(n / 2), o = Math.round(o / 2);
  }
  render(e, t, n, o, r) {
    e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const i = e.autoClear;
    e.autoClear = false, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(false), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
    let a = this.renderTargetBright;
    for (let t2 = 0; t2 < this.nMips; t2++) this.fsQuad.material = this.separableBlurMaterials[t2], this.separableBlurMaterials[t2].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[t2].uniforms.direction.value = _BloomPass.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[t2]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[t2].uniforms.colorTexture.value = this.renderTargetsHorizontal[t2].texture, this.separableBlurMaterials[t2].uniforms.direction.value = _BloomPass.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[t2]), e.clear(), this.fsQuad.render(e), a = this.renderTargetsVertical[t2];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = clamp(this.radius), this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(true), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = i;
  }
  getSeparableBlurMaterial(e, t) {
    return new ShaderMaterial({ type: "BloomSeparableBlur", defines: { KERNEL_RADIUS: e, SIGMA: t }, uniforms: { colorTexture: { value: null }, texSize: { value: new Vector2(0.5, 0.5) }, direction: { value: new Vector2(0.5, 0.5) } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_bloom_separable_blur_frag });
  }
  getCompositeMaterial(e) {
    return new ShaderMaterial({ type: "BloomComposite", defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_bloom_composite_frag });
  }
};
BloomPass.BlurDirectionX = new Vector2(1, 0), BloomPass.BlurDirectionY = new Vector2(0, 1);
var BokehPass = class extends Pass {
  constructor(e, t, n) {
    super(), this.scene = e, this.camera = t;
    const o = n.width || window.innerWidth || 1, r = n.height || window.innerHeight || 1, i = new WebGLRenderTarget(o, r, { minFilter: 1006, magFilter: 1006, format: 1023 });
    this.renderTargetDepth = i.clone(), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new MeshDepthMaterial(), this.materialDepth.depthPacking = 3201, this.materialDepth.blending = 0;
    const a = ShaderLib.bokeh, s = UniformsUtils.clone(a.uniforms);
    s.tDepth.value = this.renderTargetDepth.texture, s.focus.value = isDef(n.focus) ? n.focus : 1, s.aperture.value = isDef(n.aperture) ? n.aperture : 1, s.maxblur.value = isDef(n.maxblur) ? n.maxblur : 1, s.depthLeakThreshold.value = isDef(n.depthLeakThreshold) ? n.depthLeakThreshold : 0.2, s.nearClip.value = t.near, s.farClip.value = t.far, s.aspect.value = t.aspect, Object.defineProperties(this, { focus: { get: function() {
      return this.uniforms.focus.value;
    }, set: function(e2) {
      this.uniforms.focus.value = e2;
    } }, aperture: { get: function() {
      return this.uniforms.aperture.value;
    }, set: function(e2) {
      this.uniforms.aperture.value = e2;
    } }, maxblur: { get: function() {
      return this.uniforms.maxblur.value;
    }, set: function(e2) {
      this.uniforms.maxblur.value = e2;
    } }, depthLeakThreshold: { get: function() {
      return this.uniforms.depthLeakThreshold.value;
    }, set: function(e2) {
      this.uniforms.depthLeakThreshold.value = e2;
    } } }), this.materialBokeh = new ShaderMaterial({ type: "Bokeh", defines: Object.assign({}, a.defines), uniforms: s, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader }), this.uniforms = s, this.camera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene2 = new Scene(), this.quad2 = new Mesh(new PlaneGeometry(2, 2), null), this.quad2.frustumCulled = false, this.scene2.add(this.quad2), this.oldClearColor = new Color(), this.oldClearAlpha = 1;
  }
  render(e, t, n, o, r) {
    this.quad2.material = this.materialBokeh, this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha(), e.autoClear, e.autoClear = false, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = n.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.uniforms.aspect.value = this.camera.aspect, this.renderToScreen ? (e.setRenderTarget(null), e.render(this.scene2, this.camera2)) : (e.setRenderTarget(t), e.clear(), e.render(this.scene2, this.camera2)), this.scene.overrideMaterial = null, e.setClearColor(this.oldClearColor), e.setClearAlpha(this.oldClearAlpha), e.autoClear = this.oldAutoClear;
  }
  setCamera(e) {
    this.camera = e;
  }
  setSize(e, t) {
    this.renderTargetDepth.setSize(e, t);
  }
  dispose() {
    this.renderTargetDepth.dispose();
  }
};
var ShaderPass = class extends Pass {
  constructor(e, t) {
    super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = UniformsUtils.clone(e.uniforms), this.material = new ShaderMaterial({ type: "ShaderPass", defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new FullScreenQuad(this.material);
  }
  render(e, t, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose();
  }
};
var BrightnessContrastPass = class extends ShaderPass {
  constructor() {
    super(ShaderLib.brightness_contrast), this.material.type = "Grayscale";
  }
  get brightness() {
    return this.uniforms.brightness.value;
  }
  set brightness(e) {
    this.uniforms.brightness.value = e;
  }
  get contrast() {
    return this.uniforms.contrast.value;
  }
  set contrast(e) {
    this.uniforms.contrast.value = e;
  }
};
var FXAAPass = class extends ShaderPass {
  constructor(e, t, n, o) {
    super(ShaderLib.fxaa), this.material.type = "FXAA", this.width = void 0 !== n ? n : 512, this.height = void 0 !== o ? o : 256, this.needsSwap = false;
  }
  setSize(e, t) {
    this.width = e, this.height = t, this.uniforms.resolution.value.set(1 / e, 1 / t);
  }
};
var GrayscalePass = class extends ShaderPass {
  constructor() {
    super(ShaderLib.grayscale), this.material.type = "Grayscale";
  }
};
var _renderer;
var fullscreenQuadGeometry;
var fullscreenQuadMaterial;
var fullscreenQuad;
function decompress(e, t = 1 / 0, n = null) {
  fullscreenQuadGeometry || (fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1)), fullscreenQuadMaterial || (fullscreenQuadMaterial = new ShaderMaterial({ uniforms: { blitTexture: new Uniform(e) }, vertexShader: "\n            varying vec2 vUv;\n            void main(){\n                vUv = uv;\n                gl_Position = vec4(position.xy * 1.0,0.,.999999);\n            }", fragmentShader: "\n            uniform sampler2D blitTexture;\n            varying vec2 vUv;\n\n            void main(){\n                gl_FragColor = vec4(vUv.xy, 0, 1);\n\n                #ifdef IS_SRGB\n                gl_FragColor = LinearTosRGB(texture2D(blitTexture, vUv));\n                #else\n                gl_FragColor = texture2D(blitTexture, vUv);\n                #endif\n            }" })), fullscreenQuadMaterial.uniforms.blitTexture.value = e, fullscreenQuadMaterial.defines.IS_SRGB = 3001 == e.encoding, fullscreenQuadMaterial.needsUpdate = true, fullscreenQuad || (fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial), fullscreenQuad.frustumCulled = false);
  const o = new PerspectiveCamera(), r = new Scene();
  r.add(fullscreenQuad), null === n && (n = _renderer = new WebGLRenderer({ antialias: false }));
  const i = Math.min(e.image.width, t), a = Math.min(e.image.height, t);
  n.setSize(i, a), n.clear(), n.render(r, o);
  const s = document.createElement("canvas"), l = s.getContext("2d");
  s.width = i, s.height = a, l.drawImage(n.domElement, 0, 0, i, a);
  const c = new CanvasTexture(s);
  return c.minFilter = e.minFilter, c.magFilter = e.magFilter, c.wrapS = e.wrapS, c.wrapT = e.wrapT, c.name = e.name, _renderer && (_renderer.forceContextLoss(), _renderer.dispose(), _renderer = null), c;
}
var GLTFExporter = class {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new GLTFMaterialsUnlitExtension$1(e);
    });
  }
  register(e) {
    return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, o) {
    const r = new GLTFWriter(), i = [];
    for (let e2 = 0, t2 = this.pluginCallbacks.length; e2 < t2; e2++) i.push(this.pluginCallbacks[e2](r));
    r.setPlugins(i), r.write(e, t, o).catch(n);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(o, r) {
      n.parse(e, o, r, t);
    });
  }
};
var WEBGL_CONSTANTS$1 = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123, FLOAT: 5126, UNSIGNED_INT: 5125, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 };
var V3D_TO_WEBGL = {};
V3D_TO_WEBGL[1003] = WEBGL_CONSTANTS$1.NEAREST, V3D_TO_WEBGL[1004] = WEBGL_CONSTANTS$1.NEAREST_MIPMAP_NEAREST, V3D_TO_WEBGL[1005] = WEBGL_CONSTANTS$1.NEAREST_MIPMAP_LINEAR, V3D_TO_WEBGL[1006] = WEBGL_CONSTANTS$1.LINEAR, V3D_TO_WEBGL[1007] = WEBGL_CONSTANTS$1.LINEAR_MIPMAP_NEAREST, V3D_TO_WEBGL[1008] = WEBGL_CONSTANTS$1.LINEAR_MIPMAP_LINEAR, V3D_TO_WEBGL[1001] = WEBGL_CONSTANTS$1.CLAMP_TO_EDGE, V3D_TO_WEBGL[1e3] = WEBGL_CONSTANTS$1.REPEAT, V3D_TO_WEBGL[1002] = WEBGL_CONSTANTS$1.MIRRORED_REPEAT;
var PATH_PROPERTIES$1 = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" };
function equalArray(e, t) {
  return e.length === t.length && e.every(function(e2, n) {
    return e2 === t[n];
  });
}
function stringToArrayBuffer(e) {
  return new TextEncoder().encode(e).buffer;
}
function isIdentityMatrix(e) {
  return equalArray(e.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function getMinMax(e, t, n) {
  const o = { min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY) };
  for (let r = t; r < t + n; r++) for (let t2 = 0; t2 < e.itemSize; t2++) {
    let n2;
    e.itemSize > 4 ? n2 = e.array[r * e.itemSize + t2] : (0 === t2 ? n2 = e.getX(r) : 1 === t2 ? n2 = e.getY(r) : 2 === t2 ? n2 = e.getZ(r) : 3 === t2 && (n2 = e.getW(r)), true === e.normalized && (n2 = normalize(n2, e.array))), o.min[t2] = Math.min(o.min[t2], n2), o.max[t2] = Math.max(o.max[t2], n2);
  }
  return o;
}
function getPaddedBufferSize(e) {
  return 4 * Math.ceil(e / 4);
}
function getPaddedArrayBuffer(e, t = 0) {
  const n = getPaddedBufferSize(e.byteLength);
  if (n !== e.byteLength) {
    const o = new Uint8Array(n);
    if (o.set(new Uint8Array(e)), 0 !== t) for (let r = e.byteLength; r < n; r++) o[r] = t;
    return o.buffer;
  }
  return e;
}
function getCanvas() {
  return "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function getToBlobPromise(e, t) {
  if (void 0 !== e.toBlob) return new Promise((n2) => e.toBlob(n2, t));
  let n;
  return "image/jpeg" === t ? n = 0.92 : "image/webp" === t && (n = 0.8), e.convertToBlob({ type: t, quality: n });
}
var GLTFWriter = class {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "Verge3D" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  async write(e, t, n = {}) {
    this.options = Object.assign({ binary: false, trs: false, onlyVisible: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, n), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(e), await Promise.all(this.pending);
    const o = this, r = o.buffers, i = o.json;
    n = o.options;
    const a = o.extensionsUsed, s = new Blob(r, { type: "application/octet-stream" }), l = Object.keys(a);
    if (l.length > 0 && (i.extensionsUsed = l), i.buffers && i.buffers.length > 0 && (i.buffers[0].byteLength = s.size), true === n.binary) {
      const e2 = new FileReader();
      e2.readAsArrayBuffer(s), e2.onloadend = function() {
        const n2 = getPaddedArrayBuffer(e2.result), o2 = new DataView(new ArrayBuffer(8));
        o2.setUint32(0, n2.byteLength, true), o2.setUint32(4, 5130562, true);
        const r2 = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(i)), 32), a2 = new DataView(new ArrayBuffer(8));
        a2.setUint32(0, r2.byteLength, true), a2.setUint32(4, 1313821514, true);
        const s2 = new ArrayBuffer(12), l2 = new DataView(s2);
        l2.setUint32(0, 1179937895, true), l2.setUint32(4, 2, true);
        const c = 12 + a2.byteLength + r2.byteLength + o2.byteLength + n2.byteLength;
        l2.setUint32(8, c, true);
        const u = new Blob([s2, a2, r2, o2, n2], { type: "application/octet-stream" }), d = new FileReader();
        d.readAsArrayBuffer(u), d.onloadend = function() {
          t(d.result);
        };
      };
    } else if (i.buffers && i.buffers.length > 0) {
      const e2 = new FileReader();
      e2.readAsDataURL(s), e2.onloadend = function() {
        const n2 = e2.result;
        i.buffers[0].uri = n2, t(i);
      };
    } else t(i);
  }
  serializeUserData(e, t) {
    if (0 === Object.keys(e.userData).length) return;
    const n = this.options, o = this.extensionsUsed;
    try {
      const r = JSON.parse(JSON.stringify(e.userData));
      if (n.includeCustomExtensions && r.gltfExtensions) {
        void 0 === t.extensions && (t.extensions = {});
        for (const e2 in r.gltfExtensions) t.extensions[e2] = r.gltfExtensions[e2], o[e2] = true;
        delete r.gltfExtensions;
      }
      Object.keys(r).length > 0 && (t.extras = r);
    } catch (t2) {
      console.warn("v3d.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t2.message);
    }
  }
  getUID(e, t = false) {
    if (false === this.uids.has(e)) {
      const t2 = /* @__PURE__ */ new Map();
      t2.set(true, this.uid++), t2.set(false, this.uid++), this.uids.set(e, t2);
    }
    return this.uids.get(e).get(t);
  }
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e)) return false;
    const t = new Vector3();
    for (let n = 0, o = e.count; n < o; n++) if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4) return false;
    return true;
  }
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
    const n = e.clone(), o = new Vector3();
    for (let e2 = 0, t2 = n.count; e2 < t2; e2++) o.fromBufferAttribute(n, e2), 0 === o.x && 0 === o.y && 0 === o.z ? o.setX(1) : o.normalize(), n.setXYZ(e2, o.x, o.y, o.z);
    return t.attributesNormalized.set(e, n), n;
  }
  buildMetalRoughTexture(e, t) {
    if (e === t) return e;
    function n(e2) {
      return 3001 === e2.encoding ? function(e3) {
        return e3 < 0.04045 ? 0.0773993808 * e3 : Math.pow(0.9478672986 * e3 + 0.0521327014, 2.4);
      } : function(e3) {
        return e3;
      };
    }
    console.warn("v3d.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof CompressedTexture && (e = decompress(e)), t instanceof CompressedTexture && (t = decompress(t));
    const o = e == null ? void 0 : e.image, r = t == null ? void 0 : t.image, i = Math.max((o == null ? void 0 : o.width) || 0, (r == null ? void 0 : r.width) || 0), a = Math.max((o == null ? void 0 : o.height) || 0, (r == null ? void 0 : r.height) || 0), s = getCanvas();
    s.width = i, s.height = a;
    const l = s.getContext("2d");
    l.fillStyle = "#00ffff", l.fillRect(0, 0, i, a);
    const c = l.getImageData(0, 0, i, a);
    if (o) {
      l.drawImage(o, 0, 0, i, a);
      const t2 = n(e), r2 = l.getImageData(0, 0, i, a).data;
      for (let e2 = 2; e2 < r2.length; e2 += 4) c.data[e2] = 256 * t2(r2[e2] / 256);
    }
    if (r) {
      l.drawImage(r, 0, 0, i, a);
      const e2 = n(t), o2 = l.getImageData(0, 0, i, a).data;
      for (let t2 = 1; t2 < o2.length; t2 += 4) c.data[t2] = 256 * e2(o2[t2] / 256);
    }
    l.putImageData(c, 0, 0);
    const u = (e || t).clone();
    return u.source = new Source(s), u.encoding = 3e3, u;
  }
  processBuffer(e) {
    const t = this.json, n = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), n.push(e), 0;
  }
  processBufferView(e, t, n, o, r) {
    const i = this.json;
    let a;
    i.bufferViews || (i.bufferViews = []), a = t === WEBGL_CONSTANTS$1.UNSIGNED_BYTE ? 1 : t === WEBGL_CONSTANTS$1.UNSIGNED_SHORT ? 2 : 4;
    const s = getPaddedBufferSize(o * e.itemSize * a), l = new DataView(new ArrayBuffer(s));
    let c = 0;
    for (let r2 = n; r2 < n + o; r2++) for (let n2 = 0; n2 < e.itemSize; n2++) {
      let o2;
      e.itemSize > 4 ? o2 = e.array[r2 * e.itemSize + n2] : (0 === n2 ? o2 = e.getX(r2) : 1 === n2 ? o2 = e.getY(r2) : 2 === n2 ? o2 = e.getZ(r2) : 3 === n2 && (o2 = e.getW(r2)), true === e.normalized && (o2 = normalize(o2, e.array))), t === WEBGL_CONSTANTS$1.FLOAT ? l.setFloat32(c, o2, true) : t === WEBGL_CONSTANTS$1.UNSIGNED_INT ? l.setUint32(c, o2, true) : t === WEBGL_CONSTANTS$1.UNSIGNED_SHORT ? l.setUint16(c, o2, true) : t === WEBGL_CONSTANTS$1.UNSIGNED_BYTE && l.setUint8(c, o2), c += a;
    }
    const u = { buffer: this.processBuffer(l.buffer), byteOffset: this.byteOffset, byteLength: s };
    void 0 !== r && (u.target = r), r === WEBGL_CONSTANTS$1.ARRAY_BUFFER && (u.byteStride = e.itemSize * a), this.byteOffset += s, i.bufferViews.push(u);
    return { id: i.bufferViews.length - 1, byteLength: 0 };
  }
  processBufferViewImage(e) {
    const t = this, n = t.json;
    return n.bufferViews || (n.bufferViews = []), new Promise(function(o) {
      const r = new FileReader();
      r.readAsArrayBuffer(e), r.onloadend = function() {
        const e2 = getPaddedArrayBuffer(r.result), i = { buffer: t.processBuffer(e2), byteOffset: t.byteOffset, byteLength: e2.byteLength };
        t.byteOffset += e2.byteLength, o(n.bufferViews.push(i) - 1);
      };
    });
  }
  processAccessor(e, t, n, o) {
    const r = this.json;
    let i;
    if (e.array.constructor === Float32Array) i = WEBGL_CONSTANTS$1.FLOAT;
    else if (e.array.constructor === Uint32Array) i = WEBGL_CONSTANTS$1.UNSIGNED_INT;
    else if (e.array.constructor === Uint16Array) i = WEBGL_CONSTANTS$1.UNSIGNED_SHORT;
    else {
      if (e.array.constructor !== Uint8Array) throw new Error("v3d.GLTFExporter: Unsupported bufferAttribute component type.");
      i = WEBGL_CONSTANTS$1.UNSIGNED_BYTE;
    }
    if (void 0 === n && (n = 0), void 0 === o && (o = e.count), 0 === o) return null;
    const a = getMinMax(e, n, o);
    let s;
    void 0 !== t && (s = e === t.index ? WEBGL_CONSTANTS$1.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS$1.ARRAY_BUFFER);
    const l = this.processBufferView(e, i, n, o, s), c = { bufferView: l.id, byteOffset: l.byteOffset, componentType: i, count: o, max: a.max, min: a.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[e.itemSize] };
    return true === e.normalized && (c.normalized = true), r.accessors || (r.accessors = []), r.accessors.push(c) - 1;
  }
  processImage(e, t, n, o = "image/png") {
    if (null !== e) {
      const r = this, i = r.cache, a = r.json, s = r.options, l = r.pending;
      i.images.has(e) || i.images.set(e, {});
      const c = i.images.get(e), u = o + ":flipY/" + n.toString();
      if (void 0 !== c[u]) return c[u];
      a.images || (a.images = []);
      const d = { mimeType: o }, h = getCanvas();
      h.width = Math.min(e.width, s.maxTextureSize), h.height = Math.min(e.height, s.maxTextureSize);
      const f = h.getContext("2d");
      if (true === n && (f.translate(0, h.height), f.scale(1, -1)), void 0 !== e.data) {
        1023 !== t && console.error("GLTFExporter: Only RGBAFormat is supported."), (e.width > s.maxTextureSize || e.height > s.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const n2 = new Uint8ClampedArray(e.height * e.width * 4);
        for (let t2 = 0; t2 < n2.length; t2 += 4) n2[t2 + 0] = e.data[t2 + 0], n2[t2 + 1] = e.data[t2 + 1], n2[t2 + 2] = e.data[t2 + 2], n2[t2 + 3] = e.data[t2 + 3];
        f.putImageData(new ImageData(n2, e.width, e.height), 0, 0);
      } else f.drawImage(e, 0, 0, h.width, h.height);
      true === s.binary ? l.push(getToBlobPromise(h, o).then((e2) => r.processBufferViewImage(e2)).then((e2) => {
        d.bufferView = e2;
      })) : void 0 !== h.toDataURL ? d.uri = h.toDataURL(o) : l.push(getToBlobPromise(h, o).then((e2) => new FileReader().readAsDataURL(e2)).then((e2) => {
        d.uri = e2;
      }));
      const p = a.images.push(d) - 1;
      return c[u] = p, p;
    }
    throw new Error("v3d.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const n = { magFilter: V3D_TO_WEBGL[e.magFilter], minFilter: V3D_TO_WEBGL[e.minFilter], wrapS: V3D_TO_WEBGL[e.wrapS], wrapT: V3D_TO_WEBGL[e.wrapT] };
    return t.samplers.push(n) - 1;
  }
  processTexture(e) {
    const t = this.options, n = this.cache, o = this.json;
    if (n.textures.has(e)) return n.textures.get(e);
    o.textures || (o.textures = []), e instanceof CompressedTexture && (e = decompress(e, t.maxTextureSize));
    let r = e.userData.mimeType;
    "image/webp" === r && (r = "image/png");
    const i = { sampler: this.processSampler(e), source: this.processImage(e.image, e.format, e.flipY, r) };
    e.name && (i.name = e.name), this._invokeAll(function(t2) {
      t2.writeTexture && t2.writeTexture(e, i);
    });
    const a = o.textures.push(i) - 1;
    return n.textures.set(e, a), a;
  }
  processMaterial(e) {
    const t = this.cache, n = this.json;
    if (t.materials.has(e)) return t.materials.get(e);
    if (e.isShaderMaterial) return console.warn("GLTFExporter: v3d.ShaderMaterial not supported."), null;
    n.materials || (n.materials = []);
    const o = { pbrMetallicRoughness: {} };
    true !== e.isMeshNodeMaterial && true !== e.isMeshStandardMaterial && true !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshNodeMaterial, MeshStandardMaterial, or MeshBasicMaterial for best results.");
    const r = e.color.toArray().concat([e.opacity]);
    equalArray(r, [1, 1, 1, 1]) || (o.pbrMetallicRoughness.baseColorFactor = r), e.isMeshNodeMaterial ? (o.pbrMetallicRoughness.metallicFactor = e.getStandardProp("metalness"), o.pbrMetallicRoughness.roughnessFactor = e.getStandardProp("roughness")) : e.isMeshStandardMaterial ? (o.pbrMetallicRoughness.metallicFactor = e.metalness, o.pbrMetallicRoughness.roughnessFactor = e.roughness) : (o.pbrMetallicRoughness.metallicFactor = 0.5, o.pbrMetallicRoughness.roughnessFactor = 0.5);
    const i = e.isMeshNodeMaterial ? e.getStandardProp("metalnessMap") : e.metalnessMap, a = e.isMeshNodeMaterial ? e.getStandardProp("roughnessMap") : e.roughnessMap;
    if (i || a) {
      const e2 = this.buildMetalRoughTexture(i, a), t2 = { index: this.processTexture(e2) };
      o.pbrMetallicRoughness.metallicRoughnessTexture = t2;
    }
    const s = e.isMeshNodeMaterial ? e.getStandardProp("map") : e.map;
    if (s) {
      const e2 = { index: this.processTexture(s) };
      o.pbrMetallicRoughness.baseColorTexture = e2;
    }
    let l = e.isMeshNodeMaterial ? e.getStandardProp("emissive") : e.emissive;
    if (l) {
      const t2 = e.isMeshNodeMaterial ? e.getStandardProp("emissiveIntensity") : e.emissiveIntensity;
      l = l.clone().multiplyScalar(t2);
      const n2 = Math.max(l.r, l.g, l.b);
      n2 > 1 && (l.multiplyScalar(1 / n2), console.warn("v3d.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n2 > 0 && (o.emissiveFactor = l.toArray());
      const r2 = e.isMeshNodeMaterial ? e.getStandardProp("emissiveMap") : e.emissiveMap;
      if (r2) {
        const e2 = { index: this.processTexture(r2) };
        o.emissiveTexture = e2;
      }
    }
    const c = e.isMeshNodeMaterial ? e.getStandardProp("normalMap") : e.normalMap;
    if (c) {
      const t2 = { index: this.processTexture(c) }, n2 = e.isMeshNodeMaterial ? e.getStandardProp("normalScale") : e.normalScale;
      n2 && 1 !== n2.x && (t2.scale = n2.x), o.normalTexture = t2;
    }
    const u = e.isMeshNodeMaterial ? e.getStandardProp("aoMap") : e.aoMap;
    if (u) {
      const t2 = { index: this.processTexture(u), texCoord: 1 }, n2 = e.isMeshNodeMaterial ? e.getStandardProp("aoMapIntensity") : e.aoMapIntensity;
      1 !== n2 && (t2.strength = n2), o.occlusionTexture = t2;
    }
    e.transparent ? o.alphaMode = "BLEND" : e.alphaTest > 0 && (o.alphaMode = "MASK", o.alphaCutoff = e.alphaTest), 2 === e.side && (o.doubleSided = true), "" !== e.name && (o.name = e.name), this.serializeUserData(e, o), this._invokeAll(function(t2) {
      t2.writeMaterial && t2.writeMaterial(e, o);
    });
    const d = n.materials.push(o) - 1;
    return t.materials.set(e, d), d;
  }
  processMesh(e) {
    const t = this.cache, n = this.json, o = [e.geometry.uuid];
    if (Array.isArray(e.material)) for (let t2 = 0, n2 = e.material.length; t2 < n2; t2++) o.push(e.material[t2].uuid);
    else o.push(e.material.uuid);
    const r = o.join(":");
    if (t.meshes.has(r)) return t.meshes.get(r);
    const i = e.geometry;
    let a;
    a = e.isLineSegments ? WEBGL_CONSTANTS$1.LINES : e.isLineLoop ? WEBGL_CONSTANTS$1.LINE_LOOP : e.isLine ? WEBGL_CONSTANTS$1.LINE_STRIP : e.isPoints ? WEBGL_CONSTANTS$1.POINTS : e.material.wireframe ? WEBGL_CONSTANTS$1.LINES : WEBGL_CONSTANTS$1.TRIANGLES;
    const s = {}, l = {}, c = [], u = [], d = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, h = i.getAttribute("normal");
    void 0 === h || this.isNormalizedNormalAttribute(h) || (console.warn("v3d.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), i.setAttribute("normal", this.createNormalizedNormalAttribute(h)));
    let f = null;
    for (let e2 in i.attributes) {
      if ("morph" === e2.slice(0, 5)) continue;
      const n2 = i.attributes[e2];
      e2 = d[e2] || e2.toUpperCase();
      if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e2) || (e2 = "_" + e2), t.attributes.has(this.getUID(n2))) {
        l[e2] = t.attributes.get(this.getUID(n2));
        continue;
      }
      f = null;
      const o2 = n2.array;
      "JOINTS_0" !== e2 || o2 instanceof Uint16Array || o2 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f = new BufferAttribute(new Uint16Array(o2), n2.itemSize, n2.normalized));
      const r2 = this.processAccessor(f || n2, i);
      null !== r2 && (l[e2] = r2, t.attributes.set(this.getUID(n2), r2));
    }
    if (void 0 !== h && i.setAttribute("normal", h), 0 === Object.keys(l).length) return null;
    if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
      const n2 = [], o2 = [], r2 = {};
      if (void 0 !== e.morphTargetDictionary) for (const t2 in e.morphTargetDictionary) r2[e.morphTargetDictionary[t2]] = t2;
      for (let a2 = 0; a2 < e.morphTargetInfluences.length; ++a2) {
        const s2 = {};
        let l2 = false;
        for (const e2 in i.morphAttributes) {
          if ("position" !== e2 && "normal" !== e2) {
            l2 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l2 = true);
            continue;
          }
          const n3 = i.morphAttributes[e2][a2], o3 = e2.toUpperCase(), r3 = i.attributes[e2];
          if (t.attributes.has(this.getUID(n3, true))) {
            s2[o3] = t.attributes.get(this.getUID(n3, true));
            continue;
          }
          const c2 = n3.clone();
          if (!i.morphTargetsRelative) for (let e3 = 0, t2 = n3.count; e3 < t2; e3++) for (let t3 = 0; t3 < n3.itemSize; t3++) 0 === t3 && c2.setX(e3, n3.getX(e3) - r3.getX(e3)), 1 === t3 && c2.setY(e3, n3.getY(e3) - r3.getY(e3)), 2 === t3 && c2.setZ(e3, n3.getZ(e3) - r3.getZ(e3)), 3 === t3 && c2.setW(e3, n3.getW(e3) - r3.getW(e3));
          s2[o3] = this.processAccessor(c2, i), t.attributes.set(this.getUID(r3, true), s2[o3]);
        }
        u.push(s2), n2.push(e.morphTargetInfluences[a2]), void 0 !== e.morphTargetDictionary && o2.push(r2[a2]);
      }
      s.weights = n2, o2.length > 0 && (s.extras = {}, s.extras.targetNames = o2);
    }
    const p = Array.isArray(e.material);
    if (p && 0 === i.groups.length) return null;
    const m = p ? e.material : [e.material], g = p ? i.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let e2 = 0, n2 = g.length; e2 < n2; e2++) {
      const n3 = { mode: a, attributes: l };
      if (this.serializeUserData(i, n3), u.length > 0 && (n3.targets = u), null !== i.index) {
        let o3 = this.getUID(i.index);
        void 0 === g[e2].start && void 0 === g[e2].count || (o3 += ":" + g[e2].start + ":" + g[e2].count), t.attributes.has(o3) ? n3.indices = t.attributes.get(o3) : (n3.indices = this.processAccessor(i.index, i, g[e2].start, g[e2].count), t.attributes.set(o3, n3.indices)), null === n3.indices && delete n3.indices;
      }
      const o2 = this.processMaterial(m[g[e2].materialIndex]);
      null !== o2 && (n3.material = o2), c.push(n3);
    }
    s.primitives = c, n.meshes || (n.meshes = []), this._invokeAll(function(t2) {
      t2.writeMesh && t2.writeMesh(e, s);
    });
    const _ = n.meshes.push(s) - 1;
    return t.meshes.set(r, _), _;
  }
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const n = e.isOrthographicCamera, o = { type: n ? "orthographic" : "perspective" };
    return n ? o.orthographic = { xmag: 2 * e.right, ymag: 2 * e.top, zfar: e.far <= 0 ? 1e-3 : e.far, znear: e.near < 0 ? 0 : e.near } : o.perspective = { aspectRatio: e.aspect, yfov: degToRad(e.fov), zfar: e.far <= 0 ? 1e-3 : e.far, znear: e.near < 0 ? 0 : e.near }, "" !== e.name && (o.name = e.type), t.cameras.push(o) - 1;
  }
  processAnimation(e, t) {
    const n = this.json, o = this.nodeMap;
    n.animations || (n.animations = []);
    const r = (e = GLTFExporter.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks, i = [], a = [];
    for (let e2 = 0; e2 < r.length; ++e2) {
      const n2 = r[e2], s = PropertyBinding.parseTrackName(n2.name);
      let l = PropertyBinding.findNode(t, s.nodeName);
      const c = PATH_PROPERTIES$1[s.propertyName];
      if ("bones" === s.objectName && (l = true === l.isSkinnedMesh ? l.skeleton.getBoneByName(s.objectIndex) : void 0), !l || !c) return console.warn('v3d.GLTFExporter: Could not export animation track "%s".', n2.name), null;
      const u = 1;
      let d, h = n2.values.length / n2.times.length;
      c === PATH_PROPERTIES$1.morphTargetInfluences && (h /= l.morphTargetInfluences.length), true === n2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (d = "CUBICSPLINE", h /= 3) : d = 2300 === n2.getInterpolation() ? "STEP" : "LINEAR", a.push({ input: this.processAccessor(new BufferAttribute(n2.times, u)), output: this.processAccessor(new BufferAttribute(n2.values, h)), interpolation: d }), i.push({ sampler: a.length - 1, target: { node: o.get(l), path: c } });
    }
    return n.animations.push({ name: e.name || "clip_" + n.animations.length, samplers: a, channels: i }), n.animations.length - 1;
  }
  processSkin(e) {
    const t = this.json, n = this.nodeMap, o = t.nodes[n.get(e)], r = e.skeleton;
    if (void 0 === r) return null;
    const i = e.skeleton.bones[0];
    if (void 0 === i) return null;
    const a = [], s = new Float32Array(16 * r.bones.length), l = new Matrix4();
    for (let t2 = 0; t2 < r.bones.length; ++t2) a.push(n.get(r.bones[t2])), l.copy(r.boneInverses[t2]), l.multiply(e.bindMatrix).toArray(s, 16 * t2);
    void 0 === t.skins && (t.skins = []), t.skins.push({ inverseBindMatrices: this.processAccessor(new BufferAttribute(s, 16)), joints: a, skeleton: n.get(i) });
    return o.skin = t.skins.length - 1;
  }
  processNode(e) {
    const t = this.json, n = this.options, o = this.nodeMap;
    if (e.isAuxClippingMesh) return null;
    let r = false;
    if (n.onlyVisible && !e.visible && (e.traverse(function(e2) {
      e2.visible && (r = true);
    }), !r)) return null;
    t.nodes || (t.nodes = []);
    const i = {};
    if (n.trs) {
      const t2 = e.quaternion.toArray(), n2 = e.position.toArray(), o2 = e.scale.toArray();
      equalArray(t2, [0, 0, 0, 1]) || (i.rotation = t2), equalArray(n2, [0, 0, 0]) || (i.translation = n2), equalArray(o2, [1, 1, 1]) || (i.scale = o2);
    } else e.matrixAutoUpdate && e.updateMatrix(), false === isIdentityMatrix(e.matrix) && (i.matrix = e.matrix.elements);
    if ("" !== e.name && (i.name = String(e.name)), this.serializeUserData(e, i), (e.isMesh || e.isLine || e.isPoints) && !r) {
      const t2 = this.processMesh(e);
      null !== t2 && (i.mesh = t2);
    } else e.isCamera && !r && (i.camera = this.processCamera(e));
    if (e.isSkinnedMesh && !r && this.skins.push(e), e.children.length > 0) {
      const t2 = [];
      for (let n2 = 0, o2 = e.children.length; n2 < o2; n2++) {
        const o3 = e.children[n2], r2 = this.processNode(o3);
        null !== r2 && t2.push(r2);
      }
      t2.length > 0 && (i.children = t2);
    }
    this._invokeAll(function(t2) {
      t2.writeNode && t2.writeNode(e, i);
    });
    const a = t.nodes.push(i) - 1;
    return o.set(e, a), a;
  }
  processScene(e) {
    const t = this.json, n = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const o = {};
    "" !== e.name && (o.name = e.name), t.scenes.push(o);
    const r = [];
    for (let t2 = 0, o2 = e.children.length; t2 < o2; t2++) {
      const o3 = e.children[t2];
      if (o3.visible || false === n.onlyVisible) {
        const e2 = this.processNode(o3);
        null !== e2 && r.push(e2);
      }
    }
    r.length > 0 && (o.nodes = r), this.serializeUserData(e, o);
  }
  processObjects(e) {
    const t = new Scene();
    t.name = "AuxScene";
    for (let n = 0; n < e.length; n++) t.children.push(e[n]);
    this.processScene(t);
  }
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(t2) {
      t2.beforeParse && t2.beforeParse(e);
    });
    const n = [];
    for (let t2 = 0; t2 < e.length; t2++) e[t2] instanceof Scene ? this.processScene(e[t2]) : n.push(e[t2]);
    n.length > 0 && this.processObjects(n);
    for (let e2 = 0; e2 < this.skins.length; ++e2) this.processSkin(this.skins[e2]);
    for (let n2 = 0; n2 < t.animations.length; ++n2) this.processAnimation(t.animations[n2], e[0]);
    this._invokeAll(function(t2) {
      t2.afterParse && t2.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, n = this.plugins.length; t < n; t++) e(this.plugins[t]);
  }
};
var GLTFMaterialsUnlitExtension$1 = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!(e.isMeshBasicMaterial || e.isMeshNodeMaterial && e.isUnlit())) return;
    const n = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = true, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
GLTFExporter.Utils = { insertKeyframe: function(e, t) {
  const n = 1e-3, o = e.getValueSize(), r = new e.TimeBufferType(e.times.length + 1), i = new e.ValueBufferType(e.values.length + o), a = e.createInterpolant(new e.ValueBufferType(o));
  let s;
  if (0 === e.times.length) {
    r[0] = t;
    for (let e2 = 0; e2 < o; e2++) i[e2] = 0;
    s = 0;
  } else if (t < e.times[0]) {
    if (Math.abs(e.times[0] - t) < n) return 0;
    r[0] = t, r.set(e.times, 1), i.set(a.evaluate(t), 0), i.set(e.values, o), s = 0;
  } else if (t > e.times[e.times.length - 1]) {
    if (Math.abs(e.times[e.times.length - 1] - t) < n) return e.times.length - 1;
    r[r.length - 1] = t, r.set(e.times, 0), i.set(e.values, 0), i.set(a.evaluate(t), e.values.length), s = r.length - 1;
  } else for (let l = 0; l < e.times.length; l++) {
    if (Math.abs(e.times[l] - t) < n) return l;
    if (e.times[l] < t && e.times[l + 1] > t) {
      r.set(e.times.slice(0, l + 1), 0), r[l + 1] = t, r.set(e.times.slice(l + 1), l + 2), i.set(e.values.slice(0, (l + 1) * o), 0), i.set(a.evaluate(t), (l + 1) * o), i.set(e.values.slice((l + 1) * o), (l + 2) * o), s = l + 1;
      break;
    }
  }
  return e.times = r, e.values = i, s;
}, mergeMorphTargetTracks: function(e, t) {
  const n = [], o = {}, r = e.tracks;
  for (let e2 = 0; e2 < r.length; ++e2) {
    let i = r[e2];
    const a = PropertyBinding.parseTrackName(i.name), s = PropertyBinding.findNode(t, a.nodeName);
    if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
      n.push(i);
      continue;
    }
    if (i.createInterpolant !== i.InterpolantFactoryMethodDiscrete && i.createInterpolant !== i.InterpolantFactoryMethodLinear) {
      if (i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("v3d.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
      console.warn("v3d.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), i = i.clone(), i.setInterpolation(2301);
    }
    const l = s.morphTargetInfluences.length, c = s.morphTargetDictionary[a.propertyIndex];
    if (void 0 === c) throw new Error("v3d.GLTFExporter: Morph target name not found: " + a.propertyIndex);
    let u;
    if (void 0 === o[s.uuid]) {
      u = i.clone();
      const e3 = new u.ValueBufferType(l * u.times.length);
      for (let t2 = 0; t2 < u.times.length; t2++) e3[t2 * l + c] = u.values[t2];
      u.name = (a.nodeName || "") + ".morphTargetInfluences", u.values = e3, o[s.uuid] = u, n.push(u);
      continue;
    }
    const d = i.createInterpolant(new i.ValueBufferType(1));
    u = o[s.uuid];
    for (let e3 = 0; e3 < u.times.length; e3++) u.values[e3 * l + c] = d.evaluate(u.times[e3]);
    for (let e3 = 0; e3 < i.times.length; e3++) {
      const t2 = this.insertKeyframe(u, i.times[e3]);
      u.values[t2 * l + c] = i.values[e3];
    }
  }
  return e.tracks = n, e;
} };
var MaskPass = class extends Pass {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = true, this.needsSwap = false, this.inverse = false;
  }
  render(e, t, n) {
    const o = e.getContext(), r = e.state;
    let i, a;
    r.buffers.color.setMask(false), r.buffers.depth.setMask(false), r.buffers.color.setLocked(true), r.buffers.depth.setLocked(true), this.inverse ? (i = 0, a = 1) : (i = 1, a = 0), r.buffers.stencil.setTest(true), r.buffers.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), r.buffers.stencil.setFunc(o.ALWAYS, i, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(true), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(false), r.buffers.depth.setLocked(false), r.buffers.stencil.setLocked(false), r.buffers.stencil.setFunc(o.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), r.buffers.stencil.setLocked(true);
  }
  setCamera(e) {
    this.camera = e;
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super(), this.needsSwap = false;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(false), e.state.buffers.stencil.setTest(false);
  }
};
function memcpy(e, t, n, o, r) {
  if (e = e.subarray || e.slice ? e : e.buffer, n = n.subarray || n.slice ? n : n.buffer, e = t ? e.subarray ? e.subarray(t, r && t + r) : e.slice(t, r && t + r) : e, n.set) n.set(e, o);
  else for (let t2 = 0; t2 < e.length; t2++) n[t2 + o] = e[t2];
  return n;
}
var MeshLine = class _MeshLine {
  constructor() {
    this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this.geometry = new BufferGeometry(), this.widthCallback = null;
  }
  setGeometry(e, t) {
    if (this.widthCallback = t, this.positions = [], this.counters = [], e instanceof Float32Array || e instanceof Array) for (let t2 = 0; t2 < e.length; t2 += 3) {
      const n = t2 / e.length;
      this.positions.push(e[t2], e[t2 + 1], e[t2 + 2]), this.positions.push(e[t2], e[t2 + 1], e[t2 + 2]), this.counters.push(n), this.counters.push(n);
    }
    this.process();
  }
  compareV3(e, t) {
    const n = 6 * e, o = 6 * t;
    return this.positions[n] === this.positions[o] && this.positions[n + 1] === this.positions[o + 1] && this.positions[n + 2] === this.positions[o + 2];
  }
  copyV3(e) {
    const t = 6 * e;
    return [this.positions[t], this.positions[t + 1], this.positions[t + 2]];
  }
  process() {
    const e = this.positions.length / 6;
    this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [];
    for (let t2 = 0; t2 < e; t2++) this.side.push(1), this.side.push(-1);
    let t, n;
    for (let n2 = 0; n2 < e; n2++) t = this.widthCallback ? this.widthCallback(n2 / (e - 1)) : 1, this.width.push(t), this.width.push(t);
    for (let t2 = 0; t2 < e; t2++) this.uvs.push(t2 / (e - 1), 0), this.uvs.push(t2 / (e - 1), 1);
    n = this.compareV3(0, e - 1) ? this.copyV3(e - 2) : this.copyV3(0), this.previous.push(n[0], n[1], n[2]), this.previous.push(n[0], n[1], n[2]);
    for (let t2 = 0; t2 < e - 1; t2++) n = this.copyV3(t2), this.previous.push(n[0], n[1], n[2]), this.previous.push(n[0], n[1], n[2]);
    for (let t2 = 1; t2 < e; t2++) n = this.copyV3(t2), this.next.push(n[0], n[1], n[2]), this.next.push(n[0], n[1], n[2]);
    n = this.compareV3(e - 1, 0) ? this.copyV3(1) : this.copyV3(e - 1), this.next.push(n[0], n[1], n[2]), this.next.push(n[0], n[1], n[2]);
    for (let t2 = 0; t2 < e - 1; t2++) {
      const e2 = 2 * t2;
      this.indices_array.push(e2, e2 + 1, e2 + 2), this.indices_array.push(e2 + 2, e2 + 1, e2 + 3);
    }
    this.attributes ? (this.attributes.position.copyArray(new Float32Array(this.positions)), this.attributes.position.needsUpdate = true, this.attributes.previous.copyArray(new Float32Array(this.previous)), this.attributes.previous.needsUpdate = true, this.attributes.next.copyArray(new Float32Array(this.next)), this.attributes.next.needsUpdate = true, this.attributes.side.copyArray(new Float32Array(this.side)), this.attributes.side.needsUpdate = true, this.attributes.width.copyArray(new Float32Array(this.width)), this.attributes.width.needsUpdate = true, this.attributes.uv.copyArray(new Float32Array(this.uvs)), this.attributes.uv.needsUpdate = true, this.attributes.counters.copyArray(new Float32Array(this.counters)), this.attributes.counters.needsUpdate = true, this.attributes.index.copyArray(new Uint16Array(this.indices_array)), this.attributes.index.needsUpdate = true) : this.attributes = { position: new BufferAttribute(new Float32Array(this.positions), 3), previous: new BufferAttribute(new Float32Array(this.previous), 3), next: new BufferAttribute(new Float32Array(this.next), 3), side: new BufferAttribute(new Float32Array(this.side), 1), width: new BufferAttribute(new Float32Array(this.width), 1), uv: new BufferAttribute(new Float32Array(this.uvs), 2), counters: new BufferAttribute(new Float32Array(this.counters), 1), index: new BufferAttribute(new Uint16Array(this.indices_array), 1) }, this.geometry.setAttribute("position", this.attributes.position), this.geometry.setAttribute("previous", this.attributes.previous), this.geometry.setAttribute("next", this.attributes.next), this.geometry.setAttribute("side", this.attributes.side), this.geometry.setAttribute("width", this.attributes.width), this.geometry.setAttribute("uv", this.attributes.uv), this.geometry.setAttribute("counters", this.attributes.counters), this.geometry.setIndex(this.attributes.index);
  }
  advance(e) {
    const t = this.attributes.position.array, n = this.attributes.previous.array, o = this.attributes.next.array, r = t.length;
    memcpy(t, 0, n, 0, r), memcpy(t, 6, t, 0, r - 6), t[r - 6] = e.x, t[r - 5] = e.y, t[r - 4] = e.z, t[r - 3] = e.x, t[r - 2] = e.y, t[r - 1] = e.z, memcpy(t, 6, o, 0, r - 6), o[r - 6] = e.x, o[r - 5] = e.y, o[r - 4] = e.z, o[r - 3] = e.x, o[r - 2] = e.y, o[r - 1] = e.z, this.attributes.position.needsUpdate = true, this.attributes.previous.needsUpdate = true, this.attributes.next.needsUpdate = true;
  }
  static updateAttributes(e) {
    const t = e.attributes.position.array;
    e.attributes.previous.array, e.attributes.next.array;
    const n = new _MeshLine();
    n.positions = t, n.process(), e.attributes.previous = n.attributes.previous, e.attributes.previous.needsUpdate = true, e.attributes.next = n.attributes.next, e.attributes.next.needsUpdate = true;
  }
};
var Strip = class {
  constructor(e) {
    this.headEdge = this.tailEdge = e, this.headIndex = e.index0, this.tailIndex = e.index1, this.indexCount = 2;
  }
  mergeStrip(e) {
    const t = this.headIndex, n = e.headIndex, o = this.tailIndex, r = e.tailIndex;
    t == n ? (this.headEdge.linkToEdge(e.headEdge), e.headEdge.linkToEdge(this.headEdge), this.headEdge = e.tailEdge, this.headIndex = e.tailIndex, this.indexCount += e.indexCount - 1) : t == r ? (this.headEdge.linkToEdge(e.tailEdge), e.tailEdge.linkToEdge(this.headEdge), this.headEdge = e.headEdge, this.headIndex = e.headIndex, this.indexCount += e.indexCount - 1) : o == n ? (this.tailEdge.linkToEdge(e.headEdge), e.headEdge.linkToEdge(this.tailEdge), this.tailEdge = e.tailEdge, this.tailIndex = e.tailIndex, this.indexCount += e.indexCount - 1) : o == r && (this.tailEdge.linkToEdge(e.tailEdge), e.tailEdge.linkToEdge(this.tailEdge), this.tailEdge = e.headEdge, this.tailIndex = e.headIndex, this.indexCount += e.indexCount - 1);
  }
  getIndicesFlat() {
    const e = new Float32Array(this.indexCount);
    let t = 0, n = null, o = this.headEdge, r = e[t++] = this.headIndex;
    for (; null !== o; ) {
      r = o.index0 == r ? o.index1 : o.index0, e[t++] = r;
      let i = o.edge0;
      i != n && null !== i || (i = o.edge1), i == n && (i = null), n = o, o = i;
    }
    return e;
  }
};
var StripEdge = class {
  constructor(e, t) {
    this.index0 = e, this.index1 = t, this.edge0 = null, this.edge1 = null;
  }
  linkToEdge(e) {
    null === this.edge0 ? this.edge0 = e : null === this.edge1 && (this.edge1 = e);
  }
};
function searchCompatibleStrip(e, t, n) {
  const o = e.headIndex, r = e.tailIndex;
  return t[o][0] || t[r][0] || n[o][0] || n[r][0] || null;
}
function splitIndicesIntoStrips(e) {
  const t = e.length % 2 ? e.length - 1 : e.length, n = {}, o = {};
  for (let r2 = 0; r2 < t; r2 += 2) {
    const t2 = new Strip(new StripEdge(e[r2], e[r2 + 1])), i2 = t2.headIndex, a2 = t2.tailIndex;
    n[i2] = n[i2] || [], n[a2] = n[a2] || [], o[i2] = o[i2] || [], o[a2] = o[a2] || [], n[i2].push(t2), o[a2].push(t2);
  }
  const r = new LinkMap();
  for (const e2 in n) n[e2].length && r.push(new LinkMapNode(n[e2]), e2);
  const i = [];
  let a = r.first && r.first.value[0];
  for (; a; ) {
    let e2 = a.headIndex;
    n[e2].splice(n[e2].indexOf(a), 1);
    let t2 = a.tailIndex;
    o[t2].splice(o[t2].indexOf(a), 1), 0 == n[e2].length && r.removeNodeByKey(e2);
    let s = searchCompatibleStrip(a, n, o);
    for (; null !== s; ) e2 = s.headIndex, n[e2].splice(n[e2].indexOf(s), 1), t2 = s.tailIndex, o[t2].splice(o[t2].indexOf(s), 1), 0 == n[e2].length && r.removeNodeByKey(e2), a.mergeStrip(s), s = searchCompatibleStrip(a, n, o);
    i.push(a), a = r.first && r.first.value[0];
  }
  return i;
}
var MeshLineIndexed = class {
  constructor() {
    this.geometry = new BufferGeometry();
  }
  fromBufferGeometry(e) {
    const t = e.getAttribute("position"), n = e.getIndex();
    if (void 0 === t) return;
    const o = [];
    if (null !== n) {
      splitIndicesIntoStrips(n.array).forEach(function(e2) {
        const n2 = new MeshLine(), r2 = new Float32Array(3 * e2.indexCount);
        e2.getIndicesFlat().forEach(function(e3, n3) {
          r2.set(t.array.subarray(3 * e3, 3 * e3 + 3), 3 * n3);
        }), n2.setGeometry(r2), o.push(n2);
      });
    } else {
      const e2 = new MeshLine();
      e2.setGeometry(t.array), o.push(e2);
    }
    let r = [], i = [], a = [], s = [], l = [], c = [], u = [], d = [], h = 0;
    o.forEach(function(e2) {
      r = r.concat(e2.positions), i = i.concat(e2.previous), a = a.concat(e2.next), s = s.concat(e2.side), l = l.concat(e2.width), c = c.concat(e2.uvs), u = u.concat(e2.counters);
      const t2 = e2.indices_array.map(function(e3) {
        return e3 + h;
      });
      d = d.concat(t2), h += e2.positions.length / 3;
    }), this.geometry.setAttribute("position", new BufferAttribute(new Float32Array(r), 3)), this.geometry.setAttribute("previous", new BufferAttribute(new Float32Array(i), 3)), this.geometry.setAttribute("next", new BufferAttribute(new Float32Array(a), 3)), this.geometry.setAttribute("side", new BufferAttribute(new Float32Array(s), 1)), this.geometry.setAttribute("width", new BufferAttribute(new Float32Array(l), 1)), this.geometry.setAttribute("uv", new BufferAttribute(new Float32Array(c), 2)), this.geometry.setAttribute("counters", new BufferAttribute(new Float32Array(u), 1));
    const f = arrayMax(d) > 65535 ? Uint32Array : Uint16Array;
    this.geometry.setIndex(new BufferAttribute(new f(d), 1));
  }
};
var OutlinePass = class _OutlinePass extends Pass {
  constructor(e, t, n, o) {
    super(), this.renderScene = t, this.renderCamera = n, this.selectedObjects = void 0 !== o ? o : [], this.visibleEdgeColor = new Vector4(1, 1, 1, 1), this.hiddenEdgeColor = new Vector4(0.1, 0.04, 0.02, 1), this.edgeGlow = 0, this.usePatternTexture = false, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this.renderToScreen = false, this.resolution = void 0 !== e ? new Vector2(e.x, e.y) : new Vector2(256, 256);
    const r = Math.round(this.resolution.x / this.downSampleRatio), i = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = false, this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = false, this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(r, i), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false, this.renderTargetBlurBuffer1 = new WebGLRenderTarget(r, i), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = false, this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(r / 2), Math.round(i / 2)), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = false, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(r, i), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = false, this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(r / 2), Math.round(i / 2)), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;
    this.separableBlurMaterial1 = this.getSeparableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value = new Vector2(r, i), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeparableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value = new Vector2(Math.round(r / 2), Math.round(i / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial();
    const a = ShaderLib.copy;
    this.copyUniforms = UniformsUtils.clone(a.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new ShaderMaterial({ defines: Object.assign({}, a.defines), uniforms: this.copyUniforms, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader, blending: 0, depthTest: false, depthWrite: false, transparent: true }), this.enabled = true, this.needsSwap = false, this.oldClearColor = new Color(), this.oldClearAlpha = 1, this.basic = new MeshBasicMaterial({ toneMapped: false }), this.fsQuad = new FullScreenQuad(null), this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), this.tempPulseColor1 = new Vector4(), this.tempPulseColor2 = new Vector4(), this.textureMatrix = new Matrix4(), this.visibilityState = /* @__PURE__ */ new WeakMap(), this._depthMaterial = new MeshDepthMaterial({ blending: 0, depthPacking: 3201, side: 2 }), this._maskMaterial = new MeshMaskMaterial({ side: 2 });
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose();
  }
  setSize(e, t) {
    this.renderTargetMaskBuffer.setSize(e, t);
    let n = Math.round(e / this.downSampleRatio), o = Math.round(t / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(n, o), this.renderTargetBlurBuffer1.setSize(n, o), this.renderTargetEdgeBuffer1.setSize(n, o), this.separableBlurMaterial1.uniforms.texSize.value = new Vector2(n, o), n = Math.round(n / 2), o = Math.round(o / 2), this.renderTargetBlurBuffer2.setSize(n, o), this.renderTargetEdgeBuffer2.setSize(n, o), this.separableBlurMaterial2.uniforms.texSize.value = new Vector2(n, o);
  }
  saveVisibilityState() {
    const e = this;
    e.renderScene.traverse(function(t) {
      (t.isMesh || t.isSprite || t.isPoints || t.isLine) && e.visibilityState.set(t, t.visible);
    });
  }
  restoreVisibilityState() {
    const e = this;
    e.renderScene.traverse(function(t) {
      (t.isMesh || t.isSprite || t.isPoints || t.isLine) && (t.visible = e.visibilityState.get(t));
    });
  }
  changeVisibilityOfSelectedObjects(e) {
    const t = this;
    function n(n2) {
      (n2.isMesh || n2.isSprite || n2.isPoints || n2.isLine) && t.visibilityState.get(n2) && (n2.visible = e);
    }
    for (let e2 = 0; e2 < t.selectedObjects.length; e2++) {
      const o = t.selectedObjects[e2];
      n(o);
      const r = o.children;
      for (let e3 = 0; e3 < r.length; e3++) {
        const t2 = r[e3];
        t2.isMesh && t2.isMaterialGeneratedMesh && n(t2);
      }
    }
  }
  changeVisibilityOfNonSelectedObjects(e) {
    const t = this, n = [];
    function o(e2) {
      (e2.isMesh || e2.isSprite || e2.isPoints || e2.isLine) && t.visibilityState.get(e2) && n.push(e2);
    }
    for (let e2 = 0; e2 < t.selectedObjects.length; e2++) {
      const n2 = t.selectedObjects[e2];
      o(n2);
      const r = n2.children;
      for (let e3 = 0; e3 < r.length; e3++) {
        const t2 = r[e3];
        t2.isMesh && t2.isMaterialGeneratedMesh && o(t2);
      }
    }
    t.renderScene.traverse(function(o2) {
      if ((o2.isMesh || o2.isSprite || o2.isPoints || o2.isLine) && t.visibilityState.get(o2)) {
        let t2 = false;
        for (let e2 = 0; e2 < n.length; e2++) {
          if (n[e2].id === o2.id) {
            t2 = true;
            break;
          }
        }
        t2 || (o2.visible = e);
      }
    });
  }
  updateTextureMatrix() {
    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(e, t, n, o, r) {
    if (this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), 0 === this.selectedObjects.length) return;
    e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const i = e.autoClear;
    e.autoClear = false, r && e.context.disable(e.context.STENCIL_TEST), e.setClearColor(16777215, 1);
    const a = this.renderScene.background;
    if (this.renderScene.background = null, this.renderScene.traverse(function(e2) {
      e2.isAnnotationControl && (e2._doUpdateSave = e2.doUpdate, e2.doUpdate = false);
    }), this.saveVisibilityState(), e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), this.changeVisibilityOfSelectedObjects(false), this.changeVisibilityOfNonSelectedObjects(true), this.renderScene.overrideMaterial = this._depthMaterial, e.render(this.renderScene, this.renderCamera), this.updateTextureMatrix(), e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), this.changeVisibilityOfSelectedObjects(true), this.changeVisibilityOfNonSelectedObjects(false), this.renderScene.overrideMaterial = this._maskMaterial, this.renderScene.overrideMaterial.cameraNearFar = new Vector2(this.renderCamera.near, this.renderCamera.far), this.renderScene.overrideMaterial.depthTexture = this.renderTargetDepthBuffer.texture, this.renderScene.overrideMaterial.textureMatrix = this.textureMatrix, e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.restoreVisibilityState(), this.renderScene.background = a, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), this.pulsePeriod > 0) {
      const e2 = 0.625 + 0.75 * Math.cos(0.01 * performance.now() / this.pulsePeriod) / 2;
      this.tempPulseColor1.multiplyScalar(e2), this.tempPulseColor2.multiplyScalar(e2);
    }
    this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value = new Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = _OutlinePass.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = _OutlinePass.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = _OutlinePass.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = _OutlinePass.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, r && e.context.enable(e.context.STENCIL_TEST), this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = i, this.renderScene.traverse(function(e2) {
      e2.isAnnotationControl && (e2.doUpdate = e2._doUpdateSave);
    });
  }
  getEdgeDetectionMaterial() {
    return new ShaderMaterial({ type: "OutlineEdgeDetection", defines: { HIDDEN_EDGE_ALPHA: 1 }, uniforms: { maskTexture: { value: null }, texSize: { value: new Vector2(0.5, 0.5) }, visibleEdgeColor: { value: new Vector4(1, 1, 1, 1) }, hiddenEdgeColor: { value: new Vector4(1, 1, 1, 1) } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_outline_edge_frag });
  }
  getSeparableBlurMaterial(e) {
    return new ShaderMaterial({ type: "OutlineSeparableBlur", defines: { MAX_RADIUS: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new Vector2(0.5, 0.5) }, direction: { value: new Vector2(0.5, 0.5) }, kernelRadius: { value: 1 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_outline_blur_frag });
  }
  getOverlayMaterial() {
    return new ShaderMaterial({ type: "OutlineOverlay", uniforms: { maskTexture: { value: null }, edgeTexture1: { value: null }, edgeTexture2: { value: null }, patternTexture: { value: null }, edgeStrength: { value: 1 }, edgeGlow: { value: 1 }, usePatternTexture: { value: 0 } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_outline_overlay_frag, blending: 5, blendEquation: 100, blendEquationAlpha: 100, blendSrc: 204, blendDst: 205, blendSrcAlpha: 201, blendDstAlpha: 201, depthTest: false, depthWrite: false, transparent: true });
  }
  setCamera(e) {
    this.renderCamera = e;
  }
};
OutlinePass.BlurDirectionX = new Vector2(1, 0), OutlinePass.BlurDirectionY = new Vector2(0, 1);
var RenderPass = class extends Pass {
  constructor(e, t, n, o, r) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = o, this.clearAlpha = void 0 !== r ? r : 0, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Color();
  }
  render(e, t, n) {
    const o = e.autoClear;
    let r, i;
    e.autoClear = false, void 0 !== this.overrideMaterial && (i = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), r = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = i), e.autoClear = o;
  }
  setCamera(e) {
    this.camera = e;
  }
};
var RepeatedKeyListener = class {
  constructor(e, t, n, o, r) {
    this._domElement = e, this._keyCodes = Array.isArray(t) ? t : [t], this._callback = n, this._repeats = o, this._period = r, this._timer = 0, this._counter = 0, this._keydownCb = (function(e2) {
      this._keyCodes.includes(e2.code) && (this._timer || (this._timer = window.setTimeout((function() {
        this._counter = 0, this._timer = null;
      }).bind(this), 1e3 * r)), ++this._counter >= o && (this._timer && (window.clearTimeout(this._timer), this._timer = null), this._counter = 0, this._callback()));
    }).bind(this), this._domElement.addEventListener("keydown", this._keydownCb, false);
  }
  dispose() {
    this._domElement.removeEventListener("keydown", this._keydownCb, false), this._timer && window.clearTimeout(this._timer);
  }
};
var SSAARenderPass = class extends Pass {
  constructor(e, t, n, o) {
    super(), this.scene = e, this.camera = t, this.sampleLevel = 4, this.unbiased = true, this.clearColor = void 0 !== n ? n : 0, this.clearAlpha = void 0 !== o ? o : 0, this._oldClearColor = new Color();
    const r = ShaderLib.copy;
    this.copyUniformsAccum = UniformsUtils.clone(r.uniforms), this.copyMaterialAccum = new ShaderMaterial({ type: "SSAACopyAccum", defines: Object.assign({}, r.defines), uniforms: this.copyUniformsAccum, vertexShader: r.vertexShader, fragmentShader: r.fragmentShader, premultipliedAlpha: true, transparent: true, blending: 2, depthTest: false, depthWrite: false }), this.fsQuadAccum = new FullScreenQuad(this.copyMaterialAccum), this.copyUniformsFinal = UniformsUtils.clone(r.uniforms), this.copyMaterialFinal = new ShaderMaterial({ type: "SSAACopyFinal", defines: Object.assign({}, r.defines), uniforms: this.copyUniformsFinal, vertexShader: r.vertexShader, fragmentShader: r.fragmentShader, premultipliedAlpha: false, transparent: false, blending: 0, depthTest: false, depthWrite: false }), this.fsQuadFinal = new FullScreenQuad(this.copyMaterialFinal), this.iterative = false, this.iterativeFrame = 0;
  }
  _getJitterOffsets() {
    return _JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];
  }
  _isLastIterativeFrame() {
    const e = this._getJitterOffsets();
    return this.iterativeFrame == e.length - 1;
  }
  dispose() {
    this.sampleRenderTarget && (this.sampleRenderTarget.dispose(), this.sampleRenderTarget = null, this.accumRenderTarget.dispose(), this.accumRenderTarget = null);
  }
  setSize(e, t) {
    this.sampleRenderTarget && (this.sampleRenderTarget.setSize(e, t), this.accumRenderTarget.setSize(e, t));
  }
  render(e, t, n) {
    this.sampleRenderTarget || (this.sampleRenderTarget = n.clone(), this.sampleRenderTarget.texture.name = "SSAARenderPass.sample", this.accumRenderTarget = n.clone(), this.accumRenderTarget.texture.name = "SSAARenderPass.accum");
    const o = this._getJitterOffsets(), r = e.autoClear;
    e.autoClear = false, e.getClearColor(this._oldClearColor);
    const i = e.getClearAlpha(), a = 1 / o.length;
    this.copyUniformsAccum.tDiffuse.value = this.sampleRenderTarget.texture;
    const s = n.width, l = n.height, c = this.camera.view ? this.camera.view.offsetX : 0, u = this.camera.view ? this.camera.view.offsetY : 0;
    let d, h;
    this.iterative ? (d = this.iterativeFrame, h = performance.now()) : d = 0;
    const f = o.length;
    for (let n2 = d; n2 < f; n2++) {
      this.dispatchEvent({ type: "iteration", frame: n2 });
      const r2 = o[n2];
      this.camera.setViewOffset && this.camera.setViewOffset(s, l, c + 0.0625 * r2[0], u + 0.0625 * r2[1], s, l);
      let i2 = a;
      if (this.unbiased) {
        i2 += 0.03125 * ((n2 + 0.5) / o.length - 0.5);
      }
      if (this.copyUniformsAccum.opacity.value = i2, e.setClearColor(this.clearColor, this.clearAlpha), e.setRenderTarget(this.sampleRenderTarget), e.clear(), e.render(this.scene, this.camera), this.iterative ? e.setRenderTarget(this.accumRenderTarget) : e.setRenderTarget(this.renderToScreen ? null : t), 0 === n2 && (e.setClearColor(0, 0), e.clear()), this.fsQuadAccum.render(e), this.iterativeFrame = n2, this.iterative && performance.now() - h > 4) break;
    }
    this.iterative && (this._isLastIterativeFrame() ? (this.copyUniformsFinal.tDiffuse.value = this.accumRenderTarget.texture, e.setRenderTarget(this.renderToScreen ? null : t), this.fsQuadFinal.render(e), this.iterativeFrame = 0) : this.iterativeFrame++), this.camera.setViewOffset && this.camera.setViewOffset(s, l, c, u, s, l), e.autoClear = r, e.setClearColor(this._oldClearColor, i);
  }
  isLastIterativeFrame() {
    console.error("isLastIterativeFrame() deprectated, use pass event listener instead");
  }
  setCamera(e) {
    this.camera = e;
  }
};
var _JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];
var SSRPass = class extends Pass {
  constructor(e, t, n) {
    super(), this.enabled = true, this.needsSwap = false, n = n || {}, this.objects = n.objects || [], this.steps = isDef(n.steps) || 10, this.stride = isDef(n.stride) || 30, this.binarySearchSteps = isDef(n.binarySearchSteps) || 4, this.renderTargetScale = isDef(n.renderTargetScale) || 0.5, this.thickness = isDef(n.thickness) || 0.01, this.maxDistance = isDef(n.maxDistance) || 100, this.jitter = isDef(n.jitter) || 1, this.useRefract = isDef(n.useRefract) || false, this.renderAfter = isDef(n.renderAfter) || [], this.simpleRefraction = isDef(n.simpleRefraction) || false, this.scene = e, this.camera = t, this._prevClearColor = new Color(), this._depthBuffer = new WebGLRenderTarget(256, 256, { minFilter: 1003, magFilter: 1003, format: 1023, type: 1016 }), this._depthBuffer.texture.name = "SSRPass.Depth", this._depthBuffer.texture.generateMipmaps = false, this._depthMaterial = new MeshDepthMaterial(), this._depthMaterial.depthPacking = 3202, this._backfaceDepthBuffer = this._depthBuffer.clone(), this._backfaceDepthBuffer.texture.name = "SSRPass.Depth", this._backfaceDepthMaterial = new MeshDepthMaterial(), this._backfaceDepthMaterial.depthPacking = 3202, this._backfaceDepthMaterial.side = 1, this.basic = new MeshBasicMaterial(), this.fsQuad = new FullScreenQuad(null);
  }
  _setLayer(e, t) {
    e.layers.set(t), e.isMesh && e.isMaterialGeneratedMesh && e.parent.layers.enable(t);
  }
  dispose() {
    this._depthBuffer.dispose(), this._backfaceDepthBuffer.dispose();
    for (let e = 0; e < this.objects.length; e++) {
      const t = this.objects[e], n = t.material;
      n && (this._setLayer(t, 0), delete n.defines.USE_SSR, delete n.defines.USE_SSR_REFRACT, delete n.defines.SSR_SIMPLE_REFRACT, delete n.defines.MAX_STEPS, delete n.defines.BINARY_SEARCH_ITERATIONS, n.ssrParams = null, n.needsUpdate = true);
    }
    this.objects.splice(0);
    for (let e = 0; e < this.renderAfter.length; e++) {
      const t = this.renderAfter[e];
      this._setLayer(t, 0);
    }
    this.renderAfter.splice(0);
  }
  setCamera(e) {
    this.camera = e;
  }
  setSize(e, t) {
    e *= this.renderTargetScale, t *= this.renderTargetScale, this._depthBuffer.setSize(e, t), this._backfaceDepthBuffer.setSize(e, t);
  }
  _assignMaterialParams(e, t) {
    e.ssrParams = e.ssrParams || {};
    const n = e.ssrParams;
    n.invProjectionMatrix = n.invProjectionMatrix || new Matrix4(), n.invProjectionMatrix.copy(this.camera.projectionMatrix).invert(), n.sourceBuffer = t, n.depthBuffer = this._depthBuffer, n.backfaceDepthBuffer = this._backfaceDepthBuffer, n.stride = this.stride, n.thickness = this.thickness, n.maxDistance = this.maxDistance, n.jitter = this.jitter;
  }
  render(e, t, n, o, r) {
    e.getClearColor(this._prevClearColor);
    const i = e.getClearAlpha(), a = e.autoClear;
    e.autoClear = true, e.setClearColor(0, 0);
    const s = this.scene.background;
    this.scene.background = null;
    const l = this.camera.layers.mask, c = this.camera.ignoreShadowLayers, u = this.scene.overrideMaterial;
    this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(t), e.clear(), this.fsQuad.render(e), this.useRefract || (this._depthMaterial.side = 2), this.camera.layers.enable(this.useRefract ? 3 : 5), this.useRefract && this.simpleRefraction || (this.scene.overrideMaterial = this._depthMaterial, e.setRenderTarget(this._depthBuffer), e.clear(), e.render(this.scene, this.camera)), this.useRefract || (this.scene.overrideMaterial = this._backfaceDepthMaterial, e.setRenderTarget(this._backfaceDepthBuffer), e.clear(), e.render(this.scene, this.camera)), this.scene.overrideMaterial = u, this.scene.traverse((e2) => {
      e2.isLight && (e2.userData.oldLayersMask = e2.layers.mask, e2.layers.enable(this.useRefract ? 5 : 3), this.renderAfter.length && e2.layers.enable(this.useRefract ? 6 : 4));
    });
    for (let e2 = 0; e2 < this.objects.length; e2++) {
      const n2 = this.objects[e2], o2 = n2.material;
      o2 && o2.isMeshNodeMaterial && (this._setLayer(n2, this.useRefract ? 5 : 3), isDef(o2.defines.USE_SSR) || (o2.defines.USE_SSR = "", o2.needsUpdate = true), this.useRefract && (isDef(o2.defines.USE_SSR_REFRACT) || (o2.defines.USE_SSR_REFRACT = "", o2.needsUpdate = true), this.simpleRefraction && (isDef(o2.defines.SSR_SIMPLE_REFRACT) || (o2.defines.SSR_SIMPLE_REFRACT = "", o2.needsUpdate = true))), o2.defines.MAX_STEPS !== this.steps && (o2.defines.MAX_STEPS = Math.floor(this.steps), o2.needsUpdate = true), o2.defines.BINARY_SEARCH_ITERATIONS !== this.binarySearchSteps && (o2.defines.BINARY_SEARCH_ITERATIONS = Math.floor(this.binarySearchSteps), o2.needsUpdate = true), this._assignMaterialParams(o2, t));
    }
    for (let e2 = 0; e2 < this.renderAfter.length; e2++) {
      const t2 = this.renderAfter[e2];
      this._setLayer(t2, this.useRefract ? 6 : 4);
    }
    this.camera.layers.set(this.useRefract ? 5 : 3), this.camera.ignoreShadowLayers = true, e.autoClear = false, e.setRenderTarget(n), e.render(this.scene, this.camera), this.renderAfter.length && (this.camera.layers.set(this.useRefract ? 6 : 4), e.render(this.scene, this.camera)), this.scene.background = s, this.camera.layers.mask = l, this.camera.ignoreShadowLayers = c, this.scene.traverse((e2) => {
      e2.isLight && "oldLayersMask" in e2.userData && (e2.layers.mask = e2.userData.oldLayersMask, delete e2.userData.oldLayersMask);
    }), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), e.setClearColor(this._prevClearColor, i), e.autoClear = a;
  }
};
var ToneMapPass = class extends ShaderPass {
  constructor() {
    super(ShaderLib.tonemap), this.material.type = "ToneMap";
  }
};
var durl = function(e) {
  return URL.createObjectURL(new Blob([e], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(durl(""));
} catch (e) {
  durl = function(e2) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e2);
  };
}
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(e, t) {
  for (var n = new u16(31), o = 0; o < 31; ++o) n[o] = t += 1 << e[o - 1];
  var r = new u32(n[30]);
  for (o = 1; o < 30; ++o) for (var i = n[o]; i < n[o + 1]; ++i) r[i] = i - n[o] << 5 | o;
  return [n, r];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
for (_b = freb(fdeb, 0), revfd = _b[1], rev = new u16(32768), i = 0; i < 32768; ++i) {
  x = (43690 & i) >>> 1 | (21845 & i) << 1;
  x = (61680 & (x = (52428 & x) >>> 2 | (13107 & x) << 2)) >>> 4 | (3855 & x) << 4, rev[i] = ((65280 & x) >>> 8 | (255 & x) << 8) >>> 1;
}
var x;
var _b;
var revfd;
var rev;
var i;
var hMap = function(e, t, n) {
  for (var o = e.length, r = 0, i = new u16(t); r < o; ++r) ++i[e[r] - 1];
  var a, s = new u16(t);
  for (r = 0; r < t; ++r) s[r] = s[r - 1] + i[r - 1] << 1;
  if (n) {
    a = new u16(1 << t);
    var l = 15 - t;
    for (r = 0; r < o; ++r) if (e[r]) for (var c = r << 4 | e[r], u = t - e[r], d = s[e[r] - 1]++ << u, h = d | (1 << u) - 1; d <= h; ++d) a[rev[d] >>> l] = c;
  } else for (a = new u16(o), r = 0; r < o; ++r) e[r] && (a[r] = rev[s[e[r] - 1]++] >>> 15 - e[r]);
  return a;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i) flt[i] = 8;
for (i = 144; i < 256; ++i) flt[i] = 9;
for (i = 256; i < 280; ++i) flt[i] = 7;
for (i = 280; i < 288; ++i) flt[i] = 8;
var fdt = new u8(32);
for (i = 0; i < 32; ++i) fdt[i] = 5;
var flm = hMap(flt, 9, 0);
var fdm = hMap(fdt, 5, 0);
var shft = function(e) {
  return (e / 8 | 0) + (7 & e && 1);
};
var slc = function(e, t, n) {
  (null == n || n > e.length) && (n = e.length);
  var o = new (e instanceof u16 ? u16 : e instanceof u32 ? u32 : u8)(n - t);
  return o.set(e.subarray(t, n)), o;
};
var wbits = function(e, t, n) {
  n <<= 7 & t;
  var o = t / 8 | 0;
  e[o] |= n, e[o + 1] |= n >>> 8;
};
var wbits16 = function(e, t, n) {
  n <<= 7 & t;
  var o = t / 8 | 0;
  e[o] |= n, e[o + 1] |= n >>> 8, e[o + 2] |= n >>> 16;
};
var hTree = function(e, t) {
  for (var n = [], o = 0; o < e.length; ++o) e[o] && n.push({ s: o, f: e[o] });
  var r = n.length, i = n.slice();
  if (!r) return [et, 0];
  if (1 == r) {
    var a = new u8(n[0].s + 1);
    return a[n[0].s] = 1, [a, 1];
  }
  n.sort(function(e2, t2) {
    return e2.f - t2.f;
  }), n.push({ s: -1, f: 25001 });
  var s = n[0], l = n[1], c = 0, u = 1, d = 2;
  for (n[0] = { s: -1, f: s.f + l.f, l: s, r: l }; u != r - 1; ) s = n[n[c].f < n[d].f ? c++ : d++], l = n[c != u && n[c].f < n[d].f ? c++ : d++], n[u++] = { s: -1, f: s.f + l.f, l: s, r: l };
  var h = i[0].s;
  for (o = 1; o < r; ++o) i[o].s > h && (h = i[o].s);
  var f = new u16(h + 1), p = ln(n[u - 1], f, 0);
  if (p > t) {
    o = 0;
    var m = 0, g = p - t, _ = 1 << g;
    for (i.sort(function(e2, t2) {
      return f[t2.s] - f[e2.s] || e2.f - t2.f;
    }); o < r; ++o) {
      var A = i[o].s;
      if (!(f[A] > t)) break;
      m += _ - (1 << p - f[A]), f[A] = t;
    }
    for (m >>>= g; m > 0; ) {
      var v = i[o].s;
      f[v] < t ? m -= 1 << t - f[v]++ - 1 : ++o;
    }
    for (; o >= 0 && m; --o) {
      var x = i[o].s;
      f[x] == t && (--f[x], ++m);
    }
    p = t;
  }
  return [new u8(f), p];
};
var ln = function(e, t, n) {
  return -1 == e.s ? Math.max(ln(e.l, t, n + 1), ln(e.r, t, n + 1)) : t[e.s] = n;
};
var lc = function(e) {
  for (var t = e.length; t && !e[--t]; ) ;
  for (var n = new u16(++t), o = 0, r = e[0], i = 1, a = function(e2) {
    n[o++] = e2;
  }, s = 1; s <= t; ++s) if (e[s] == r && s != t) ++i;
  else {
    if (!r && i > 2) {
      for (; i > 138; i -= 138) a(32754);
      i > 2 && (a(i > 10 ? i - 11 << 5 | 28690 : i - 3 << 5 | 12305), i = 0);
    } else if (i > 3) {
      for (a(r), --i; i > 6; i -= 6) a(8304);
      i > 2 && (a(i - 3 << 5 | 8208), i = 0);
    }
    for (; i--; ) a(r);
    i = 1, r = e[s];
  }
  return [n.subarray(0, o), t];
};
var clen = function(e, t) {
  for (var n = 0, o = 0; o < t.length; ++o) n += e[o] * t[o];
  return n;
};
var wfblk = function(e, t, n) {
  var o = n.length, r = shft(t + 2);
  e[r] = 255 & o, e[r + 1] = o >>> 8, e[r + 2] = 255 ^ e[r], e[r + 3] = 255 ^ e[r + 1];
  for (var i = 0; i < o; ++i) e[r + i + 4] = n[i];
  return 8 * (r + 4 + o);
};
var wblk = function(e, t, n, o, r, i, a, s, l, c, u) {
  wbits(t, u++, n), ++r[256];
  for (var d = hTree(r, 15), h = d[0], f = d[1], p = hTree(i, 15), m = p[0], g = p[1], _ = lc(h), A = _[0], v = _[1], x = lc(m), y = x[0], b = x[1], C = new u16(19), S = 0; S < A.length; ++S) C[31 & A[S]]++;
  for (S = 0; S < y.length; ++S) C[31 & y[S]]++;
  for (var M = hTree(C, 7), E = M[0], T = M[1], I = 19; I > 4 && !E[clim[I - 1]]; --I) ;
  var w, R, L, B, P = c + 5 << 3, N = clen(r, flt) + clen(i, fdt) + a, D = clen(r, h) + clen(i, m) + a + 14 + 3 * I + clen(C, E) + (2 * C[16] + 3 * C[17] + 7 * C[18]);
  if (P <= N && P <= D) return wfblk(t, u, e.subarray(l, l + c));
  if (wbits(t, u, 1 + (D < N)), u += 2, D < N) {
    w = hMap(h, f, 0), R = h, L = hMap(m, g, 0), B = m;
    var O = hMap(E, T, 0);
    wbits(t, u, v - 257), wbits(t, u + 5, b - 1), wbits(t, u + 10, I - 4), u += 14;
    for (S = 0; S < I; ++S) wbits(t, u + 3 * S, E[clim[S]]);
    u += 3 * I;
    for (var F = [A, y], V = 0; V < 2; ++V) {
      var U = F[V];
      for (S = 0; S < U.length; ++S) {
        var G = 31 & U[S];
        wbits(t, u, O[G]), u += E[G], G > 15 && (wbits(t, u, U[S] >>> 5 & 127), u += U[S] >>> 12);
      }
    }
  } else w = flm, R = flt, L = fdm, B = fdt;
  for (S = 0; S < s; ++S) if (o[S] > 255) {
    G = o[S] >>> 18 & 31;
    wbits16(t, u, w[G + 257]), u += R[G + 257], G > 7 && (wbits(t, u, o[S] >>> 23 & 31), u += fleb[G]);
    var z = 31 & o[S];
    wbits16(t, u, L[z]), u += B[z], z > 3 && (wbits16(t, u, o[S] >>> 5 & 8191), u += fdeb[z]);
  } else wbits16(t, u, w[o[S]]), u += R[o[S]];
  return wbits16(t, u, w[256]), u + R[256];
};
var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(e, t, n, o, r, i) {
  var a = e.length, s = new u8(o + a + 5 * (1 + Math.ceil(a / 7e3)) + r), l = s.subarray(o, s.length - r), c = 0;
  if (!t || a < 8) for (var u = 0; u <= a; u += 65535) {
    var d = u + 65535;
    d < a ? c = wfblk(l, c, e.subarray(u, d)) : (l[u] = i, c = wfblk(l, c, e.subarray(u, a)));
  }
  else {
    for (var h = deo[t - 1], f = h >>> 13, p = 8191 & h, m = (1 << n) - 1, g = new u16(32768), _ = new u16(m + 1), A = Math.ceil(n / 3), v = 2 * A, x = function(t2) {
      return (e[t2] ^ e[t2 + 1] << A ^ e[t2 + 2] << v) & m;
    }, y = new u32(25e3), b = new u16(288), C = new u16(32), S = 0, M = 0, E = (u = 0, 0), T = 0, I = 0; u < a; ++u) {
      var w = x(u), R = 32767 & u, L = _[w];
      if (g[R] = L, _[w] = R, T <= u) {
        var B = a - u;
        if ((S > 7e3 || E > 24576) && B > 423) {
          c = wblk(e, l, 0, y, b, C, M, E, I, u - I, c), E = S = M = 0, I = u;
          for (var P = 0; P < 286; ++P) b[P] = 0;
          for (P = 0; P < 30; ++P) C[P] = 0;
        }
        var N = 2, D = 0, O = p, F = R - L & 32767;
        if (B > 2 && w == x(u - F)) for (var V = Math.min(f, B) - 1, U = Math.min(32767, u), G = Math.min(258, B); F <= U && --O && R != L; ) {
          if (e[u + N] == e[u + N - F]) {
            for (var z = 0; z < G && e[u + z] == e[u + z - F]; ++z) ;
            if (z > N) {
              if (N = z, D = F, z > V) break;
              var k = Math.min(F, z - 2), W = 0;
              for (P = 0; P < k; ++P) {
                var Q = u - F + P + 32768 & 32767, H = Q - g[Q] + 32768 & 32767;
                H > W && (W = H, L = Q);
              }
            }
          }
          F += (R = L) - (L = g[R]) + 32768 & 32767;
        }
        if (D) {
          y[E++] = 268435456 | revfl[N] << 18 | revfd[D];
          var X = 31 & revfl[N], Y = 31 & revfd[D];
          M += fleb[X] + fdeb[Y], ++b[257 + X], ++C[Y], T = u + N, ++S;
        } else y[E++] = e[u], ++b[e[u]];
      }
    }
    c = wblk(e, l, i, y, b, C, M, E, I, u - I, c);
  }
  return slc(s, 0, o + shft(c) + r);
};
var crct = function() {
  for (var e = new u32(256), t = 0; t < 256; ++t) {
    for (var n = t, o = 9; --o; ) n = (1 & n && 3988292384) ^ n >>> 1;
    e[t] = n;
  }
  return e;
}();
var crc = function() {
  var e = -1;
  return { p: function(t) {
    for (var n = e, o = 0; o < t.length; ++o) n = crct[255 & n ^ t[o]] ^ n >>> 8;
    e = n;
  }, d: function() {
    return ~e;
  } };
};
var dopt = function(e, t, n, o, r) {
  return dflt(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, o, !r);
};
var mrg = function(e, t) {
  var n = {};
  for (var o in e) n[o] = e[o];
  for (var o in t) n[o] = t[o];
  return n;
};
var wbytes = function(e, t, n) {
  for (; n; ++t) e[t] = n, n >>>= 8;
};
function deflateSync(e, t) {
  return dopt(e, t || {}, 0, 0);
}
var fltn = function(e, t, n, o) {
  for (var r in e) {
    var i = e[r], a = t + r;
    i instanceof u8 ? n[a] = [i, o] : Array.isArray(i) ? n[a] = [i[0], mrg(o, i[1])] : fltn(i, a + "/", n, o);
  }
};
var te = "undefined" != typeof TextEncoder && new TextEncoder();
var td = "undefined" != typeof TextDecoder && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true }), tds = 1;
} catch (e) {
}
function strToU8(e, t) {
  if (te) return te.encode(e);
  for (var n = e.length, o = new u8(e.length + (e.length >> 1)), r = 0, i = function(e2) {
    o[r++] = e2;
  }, a = 0; a < n; ++a) {
    if (r + 5 > o.length) {
      var s = new u8(r + 8 + (n - a << 1));
      s.set(o), o = s;
    }
    var l = e.charCodeAt(a);
    l < 128 || t ? i(l) : l < 2048 ? (i(192 | l >> 6), i(128 | 63 & l)) : l > 55295 && l < 57344 ? (i(240 | (l = 65536 + (1047552 & l) | 1023 & e.charCodeAt(++a)) >> 18), i(128 | l >> 12 & 63), i(128 | l >> 6 & 63), i(128 | 63 & l)) : (i(224 | l >> 12), i(128 | l >> 6 & 63), i(128 | 63 & l));
  }
  return slc(o, 0, r);
}
var exfl = function(e) {
  var t = 0;
  if (e) for (var n in e) {
    var o = e[n].length;
    if (o > 65535) throw "extra field too long";
    t += o + 4;
  }
  return t;
};
var wzh = function(e, t, n, o, r, i, a, s) {
  var l = o.length, c = n.extra, u = s && s.length, d = exfl(c);
  wbytes(e, t, null != a ? 33639248 : 67324752), t += 4, null != a && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == i && 8), e[t++] = r && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
  var h = new Date(null == n.mtime ? Date.now() : n.mtime), f = h.getFullYear() - 1980;
  if (f < 0 || f > 119) throw "date not in range 1980-2099";
  if (wbytes(e, t, f << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != i && (wbytes(e, t, n.crc), wbytes(e, t + 4, i), wbytes(e, t + 8, n.size)), wbytes(e, t + 12, l), wbytes(e, t + 14, d), t += 16, null != a && (wbytes(e, t, u), wbytes(e, t + 6, n.attrs), wbytes(e, t + 10, a), t += 14), e.set(o, t), t += l, d) for (var p in c) {
    var m = c[p], g = m.length;
    wbytes(e, t, +p), wbytes(e, t + 2, g), e.set(m, t + 4), t += 4 + g;
  }
  return u && (e.set(s, t), t += u), t;
};
var wzf = function(e, t, n, o, r) {
  wbytes(e, t, 101010256), wbytes(e, t + 8, n), wbytes(e, t + 10, n), wbytes(e, t + 12, o), wbytes(e, t + 16, r);
};
function zipSync(e, t) {
  t || (t = {});
  var n = {}, o = [];
  fltn(e, "", n, t);
  var r = 0, i = 0;
  for (var a in n) {
    var s = n[a], l = s[0], c = s[1], u = 0 == c.level ? 0 : 8, d = (C = strToU8(a)).length, h = c.comment, f = h && strToU8(h), p = f && f.length, m = exfl(c.extra);
    if (d > 65535) throw "filename too long";
    var g = u ? deflateSync(l, c) : l, _ = g.length, A = crc();
    A.p(l), o.push(mrg(c, { size: l.length, crc: A.d(), c: g, f: C, m: f, u: d != a.length || f && h.length != p, o: r, compression: u })), r += 30 + d + m + _, i += 76 + 2 * (d + m) + (p || 0) + _;
  }
  for (var v = new u8(i + 22), x = r, y = i - r, b = 0; b < o.length; ++b) {
    var C = o[b];
    wzh(v, C.o, C, C.f, C.u, C.c.length);
    var S = 30 + C.f.length + exfl(C.extra);
    v.set(C.c, C.o + S), wzh(v, r, C, C.f, C.u, C.c.length, C.o, C.m), r += 16 + S + (C.m ? C.m.length : 0);
  }
  return wzf(v, r, o.length, y, x), v;
}
var USDZExporter = class {
  async parse(e, t = {}) {
    t = Object.assign({ ar: { anchoring: { type: "plane" }, planeAnchoring: { alignment: "horizontal" } }, quickLookCompatible: true, maxTextureSize: 1024 }, t);
    const n = {}, o = "model.usda";
    n[o] = null;
    let r = buildHeader();
    r += buildSceneStart(t);
    const i = {}, a = {};
    e.traverseVisible((e2) => {
      if (e2.isMesh) {
        const t2 = e2.geometry, o2 = e2.material;
        if (o2.isMeshNodeMaterial || o2.isMeshStandardMaterial) {
          const a2 = "geometries/Geometry_" + t2.id + ".usda";
          if (!(a2 in n)) {
            const e3 = buildMeshObject(t2);
            n[a2] = buildUSDFileAsString(e3);
          }
          o2.uuid in i || (i[o2.uuid] = o2), r += buildXform(e2, t2, o2);
        } else console.warn("v3d.USDZExporter: Unsupported material type (USDZ only supports MeshNodeMaterial and MeshStandardMaterial)", e2);
      } else e2.isCamera && (r += buildCamera(e2));
    }), r += buildSceneEnd(), r += buildMaterials(i, a, t.quickLookCompatible), n[o] = strToU8(r), r = null;
    for (const e2 in a) {
      let o2 = a[e2];
      true === o2.isCompressedTexture && (o2 = decompress(o2));
      const r2 = imageToCanvas(o2.image, o2.flipY, t.maxTextureSize), i2 = await new Promise((e3) => r2.toBlob(e3, "image/png", 1));
      n[`textures/Texture_${e2}.png`] = new Uint8Array(await i2.arrayBuffer());
    }
    let s = 0;
    for (const e2 in n) {
      const t2 = n[e2];
      s += 34 + e2.length;
      const o2 = 63 & s;
      if (4 !== o2) {
        const r2 = new Uint8Array(64 - o2);
        n[e2] = [t2, { extra: { 12345: r2 } }];
      }
      s = t2.length;
    }
    return zipSync(n, { level: 0 });
  }
};
function imageToCanvas(e, t, n) {
  if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
    const o = n / Math.max(e.width, e.height), r = document.createElement("canvas");
    r.width = e.width * Math.min(1, o), r.height = e.height * Math.min(1, o);
    const i = r.getContext("2d");
    return true === t && (i.translate(0, r.height), i.scale(1, -1)), i.drawImage(e, 0, 0, r.width, r.height), r;
  }
  throw new Error("v3d.USDZExporter: No valid image data found. Unable to process texture.");
}
var PRECISION = 7;
function buildHeader() {
  return '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Verge3D"\n    }\n    defaultPrim = "Root"\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
}
function buildSceneStart(e) {
  return `def Xform "Root"
{
    def Scope "Scenes" (
        kind = "sceneLibrary"
    )
    {
        def Xform "Scene" (
            customData = {
                bool preliminary_collidesWithEnvironment = 0
                string sceneName = "Scene"
            }
            sceneName = "Scene"
        )
        {
        token preliminary:anchoring:type = "${e.ar.anchoring.type}"
        token preliminary:planeAnchoring:alignment = "${e.ar.planeAnchoring.alignment}"

`;
}
function buildSceneEnd() {
  return "\n        }\n    }\n}\n\n";
}
function buildUSDFileAsString(e) {
  let t = buildHeader();
  return t += e, strToU8(t);
}
function buildXform(e, t, n) {
  const o = "Object_" + e.id, r = buildMatrix(e.matrixWorld);
  return e.matrixWorld.determinant() < 0 && console.warn("v3d.USDZExporter: USDZ does not support negative scales", e), `def Xform "${o}" (
    prepend references = @./geometries/Geometry_${t.id}.usda@</Geometry>
    prepend apiSchemas = ["MaterialBindingAPI"]
)
{
    matrix4d xformOp:transform = ${r}
    uniform token[] xformOpOrder = ["xformOp:transform"]

    rel material:binding = </Materials/Material_${n.id}>
}

`;
}
function buildMatrix(e) {
  const t = e.elements;
  return `(${buildMatrixRow(t, 0)}, ${buildMatrixRow(t, 4)}, ${buildMatrixRow(t, 8)}, ${buildMatrixRow(t, 12)})`;
}
function buildMatrixRow(e, t) {
  return `(${e[t + 0]}, ${e[t + 1]}, ${e[t + 2]}, ${e[t + 3]})`;
}
function buildMeshObject(e) {
  return `
def "Geometry"
{
${buildMesh(e)}
}
`;
}
function buildMesh(e) {
  const t = e.attributes, n = t.position.count;
  return `
    def Mesh "Geometry"
    {
        int[] faceVertexCounts = [${buildMeshVertexCount(e)}]
        int[] faceVertexIndices = [${buildMeshVertexIndices(e)}]
        normal3f[] normals = [${buildVector3Array(t.normal, n)}] (
            interpolation = "vertex"
        )
        point3f[] points = [${buildVector3Array(t.position, n)}]
${buildPrimvars(t)}
        uniform token subdivisionScheme = "none"
    }
`;
}
function buildMeshVertexCount(e) {
  const t = null !== e.index ? e.index.count : e.attributes.position.count;
  return Array(t / 3).fill(3).join(", ");
}
function buildMeshVertexIndices(e) {
  const t = e.index, n = [];
  if (null !== t) for (let e2 = 0; e2 < t.count; e2++) n.push(t.getX(e2));
  else {
    const t2 = e.attributes.position.count;
    for (let e2 = 0; e2 < t2; e2++) n.push(e2);
  }
  return n.join(", ");
}
function buildVector3Array(e, t) {
  if (void 0 === e) return console.warn("USDZExporter: Normals missing."), Array(t).fill("(0, 0, 0)").join(", ");
  const n = [];
  for (let t2 = 0; t2 < e.count; t2++) {
    const o = e.getX(t2), r = e.getY(t2), i = e.getZ(t2);
    n.push(`(${o.toPrecision(PRECISION)}, ${r.toPrecision(PRECISION)}, ${i.toPrecision(PRECISION)})`);
  }
  return n.join(", ");
}
function buildVector2Array(e) {
  const t = [];
  for (let n = 0; n < e.count; n++) {
    const o = e.getX(n), r = e.getY(n);
    t.push(`(${o.toPrecision(PRECISION)}, ${1 - r.toPrecision(PRECISION)})`);
  }
  return t.join(", ");
}
function buildPrimvars(e) {
  let t = "";
  for (let n2 = 0; n2 < 4; n2++) {
    const o = n2 > 0 ? n2 : "", r = e["uv" + o];
    void 0 !== r && (t += `
        texCoord2f[] primvars:st${o} = [${buildVector2Array(r)}] (
            interpolation = "vertex"
        )`);
  }
  const n = e.color;
  if (void 0 !== n) {
    t += `
    color3f[] primvars:displayColor = [${buildVector3Array(n, n.count)}] (
        interpolation = "vertex"
        )`;
  }
  return t;
}
function buildMaterials(e, t, n = false) {
  const o = [];
  for (const r in e) {
    const i = e[r];
    o.push(buildMaterial(i, t, n));
  }
  return `def "Materials"
{
${o.join("")}
}

`;
}
function buildMaterial(e, t, n = false) {
  const o = "            ", r = [], i = [];
  function a(o2, r2, i2) {
    const a2 = o2.source.id + (o2.flipY ? "_flipped" : "");
    t[a2] = o2;
    const s2 = { 1e3: "repeat", 1001: "clamp", 1002: "mirror" }, l2 = o2.repeat.clone(), c2 = o2.offset.clone(), u2 = o2.rotation, d2 = Math.sin(u2), h2 = Math.cos(u2);
    return c2.y = 1 - c2.y - l2.y, n ? (c2.x = c2.x / l2.x, c2.y = c2.y / l2.y, c2.x += d2 / l2.x, c2.y += h2 - 1) : (c2.x += d2 * l2.x, c2.y += (1 - h2) * l2.y), `
        def Shader "PrimvarReader_${r2}"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            float2 inputs:fallback = (0.0, 0.0)
            token inputs:varname = "st"
            float2 outputs:result
        }

        def Shader "Transform2d_${r2}"
        {
            uniform token info:id = "UsdTransform2d"
            token inputs:in.connect = </Materials/Material_${e.id}/PrimvarReader_${r2}.outputs:result>
            float inputs:rotation = ${(u2 * (180 / Math.PI)).toFixed(PRECISION)}
            float2 inputs:scale = ${buildVector2(l2)}
            float2 inputs:translation = ${buildVector2(c2)}
            float2 outputs:result
        }

        def Shader "Texture_${o2.id}_${r2}"
        {
            uniform token info:id = "UsdUVTexture"
            asset inputs:file = @textures/Texture_${a2}.png@
            float2 inputs:st.connect = </Materials/Material_${e.id}/Transform2d_${r2}.outputs:result>
            ${void 0 !== i2 ? "float4 inputs:scale = " + buildColor4(i2) : ""}
            token inputs:sourceColorSpace = "${3e3 === o2.encoding ? "raw" : "sRGB"}"
            token inputs:wrapS = "${s2[o2.wrapS]}"
            token inputs:wrapT = "${s2[o2.wrapT]}"
            float outputs:r
            float outputs:g
            float outputs:b
            float3 outputs:rgb
            ${e.transparent || e.alphaTest > 0 ? "float outputs:a" : ""}
        }`;
  }
  2 === e.side && console.warn("v3d.USDZExporter: USDZ does not support double sided materials", e);
  const s = e.isMeshNodeMaterial ? e.getStandardProp("map") : e.map, l = e.isMeshNodeMaterial ? e.getStandardProp("color") : e.color;
  null !== s ? (r.push(`${o}color3f inputs:diffuseColor.connect = </Materials/Material_${e.id}/Texture_${s.id}_diffuse.outputs:rgb>`), e.transparent ? r.push(`${o}float inputs:opacity.connect = </Materials/Material_${e.id}/Texture_${s.id}_diffuse.outputs:a>`) : e.alphaTest > 0 && (r.push(`${o}float inputs:opacity.connect = </Materials/Material_${e.id}/Texture_${s.id}_diffuse.outputs:a>`), r.push(`${o}float inputs:opacityThreshold = ${e.alphaTest}`)), i.push(a(s, "diffuse", l))) : r.push(`${o}color3f inputs:diffuseColor = ${buildColor(l)}`);
  const c = e.isMeshNodeMaterial ? e.getStandardProp("emissiveMap") : e.emissiveMap, u = e.isMeshNodeMaterial ? e.getStandardProp("emissiveIntensity") : e.emissiveIntensity;
  let d = e.isMeshNodeMaterial ? e.getStandardProp("emissive") : e.emissive;
  d = d.clone().multiplyScalar(u), null !== c ? (r.push(`${o}color3f inputs:emissiveColor.connect = </Materials/Material_${e.id}/Texture_${c.id}_emissive.outputs:rgb>`), i.push(a(c, "emissive"))) : d.getHex() > 0 && r.push(`${o}color3f inputs:emissiveColor = ${buildColor(d)}`);
  const h = e.isMeshNodeMaterial ? e.getStandardProp("normalMap") : e.normalMap;
  null !== h && (r.push(`${o}normal3f inputs:normal.connect = </Materials/Material_${e.id}/Texture_${h.id}_normal.outputs:rgb>`), i.push(a(h, "normal")));
  const f = e.isMeshNodeMaterial ? e.getStandardProp("aoMap") : e.aoMap;
  null !== f && (r.push(`${o}float inputs:occlusion.connect = </Materials/Material_${e.id}/Texture_${f.id}_occlusion.outputs:r>`), i.push(a(f, "occlusion")));
  const p = e.isMeshNodeMaterial ? e.getStandardProp("roughnessMap") : e.roughnessMap, m = e.isMeshNodeMaterial ? e.getStandardProp("roughness") : e.roughness;
  null !== p && 1 === m ? (r.push(`${o}float inputs:roughness.connect = </Materials/Material_${e.id}/Texture_${p.id}_roughness.outputs:g>`), i.push(a(p, "roughness"))) : r.push(`${o}float inputs:roughness = ${m}`);
  const g = e.isMeshNodeMaterial ? e.getStandardProp("metalnessMap") : e.metalnessMap, _ = e.isMeshNodeMaterial ? e.getStandardProp("metalness") : e.metalness;
  null !== g && 1 === _ ? (r.push(`${o}float inputs:metallic.connect = </Materials/Material_${e.id}/Texture_${g.id}_metallic.outputs:b>`), i.push(a(g, "metallic"))) : r.push(`${o}float inputs:metallic = ${_}`);
  const A = e.isMeshNodeMaterial ? e.getStandardProp("alphaMap") : e.alphaMap, v = e.isMeshNodeMaterial ? e.getStandardProp("opacity") : e.opacity;
  return null !== A ? (r.push(`${o}float inputs:opacity.connect = </Materials/Material_${e.id}/Texture_${A.id}_opacity.outputs:r>`), r.push(`${o}float inputs:opacityThreshold = 0.0001`), i.push(a(A, "opacity"))) : r.push(`${o}float inputs:opacity = ${v}`), e.isMeshPhysicalMaterial && (r.push(`${o}float inputs:clearcoat = ${e.clearcoat}`), r.push(`${o}float inputs:clearcoatRoughness = ${e.clearcoatRoughness}`), r.push(`${o}float inputs:ior = ${e.ior}`)), `
    def Material "Material_${e.id}"
    {
        def Shader "PreviewSurface"
        {
            uniform token info:id = "UsdPreviewSurface"
${r.join("\n")}
            int inputs:useSpecularWorkflow = 0
            token outputs:surface
        }

        token outputs:surface.connect = </Materials/Material_${e.id}/PreviewSurface.outputs:surface>

${i.join("\n")}

    }
`;
}
function buildColor(e) {
  return `(${e.r}, ${e.g}, ${e.b})`;
}
function buildColor4(e) {
  return `(${e.r}, ${e.g}, ${e.b}, 1.0)`;
}
function buildVector2(e) {
  return `(${e.x}, ${e.y})`;
}
function buildCamera(e) {
  const t = e.name ? e.name : "Camera_" + e.id, n = buildMatrix(e.matrixWorld);
  return e.matrixWorld.determinant() < 0 && console.warn("v3d.USDZExporter: USDZ does not support negative scales", e), e.isOrthographicCamera ? `def Camera "${t}"
        {
            matrix4d xformOp:transform = ${n}
            uniform token[] xformOpOrder = ["xformOp:transform"]

            float2 clippingRange = (${e.near.toPrecision(PRECISION)}, ${e.far.toPrecision(PRECISION)})
            float horizontalAperture = ${(10 * (Math.abs(e.left) + Math.abs(e.right))).toPrecision(PRECISION)}
            float verticalAperture = ${(10 * (Math.abs(e.top) + Math.abs(e.bottom))).toPrecision(PRECISION)}
            token projection = "orthographic"
        }

    ` : `def Camera "${t}"
        {
            matrix4d xformOp:transform = ${n}
            uniform token[] xformOpOrder = ["xformOp:transform"]

            float2 clippingRange = (${e.near.toPrecision(PRECISION)}, ${e.far.toPrecision(PRECISION)})
            float focalLength = ${e.getFocalLength().toPrecision(PRECISION)}
            float focusDistance = ${e.focus.toPrecision(PRECISION)}
            float horizontalAperture = ${e.getFilmWidth().toPrecision(PRECISION)}
            token projection = "perspective"
            float verticalAperture = ${e.getFilmHeight().toPrecision(PRECISION)}
        }

    `;
}
var Keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE_BREAK: 19, CAPS_LOCK: 20, ESCAPE: 27, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT_ARROW: 37, UP_ARROW: 38, RIGHT_ARROW: 39, DOWN_ARROW: 40, INSERT: 45, DELETE: 46, 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, LEFT_WINDOW_KEY: 91, RIGHT_WINDOW_KEY: 92, SELECT_KEY: 93, NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98, NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101, NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105, MULTIPLY: 106, ADD: 107, SUBTRACT: 109, DECIMAL_POINT: 110, DIVIDE: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, NUM_LOCK: 144, SCROLL_LOCK: 145, SEMI_COLON: 186, EQUAL_SIGN: 187, COMMA: 188, DASH: 189, PERIOD: 190, FORWARD_SLASH: 191, GRAVE_ACCENT: 192, OPEN_BRACKET: 219, BACK_SLASH: 220, CLOSE_BRAKET: 221, SINGLE_QUOTE: 222 };
var KeyListener = class {
  constructor(e, t = null) {
    this.isKeyDown = {};
    for (const e2 in Keys) this.isKeyDown[Keys[e2]] = false;
    if (this.onKeyDown = null, this.onKeyUp = null, this._domElement = e, this._keydownCb = (function(e2) {
      this.isKeyDown[e2.keyCode] = true, this.onKeyDown && this.onKeyDown(e2);
    }).bind(this), this._keyupCb = (function(e2) {
      this.isKeyDown[e2.keyCode] = false, this.onKeyUp && this.onKeyUp(e2);
    }).bind(this), this._mobileControlTouchStartCb = (function(e2) {
      this._keydownCb({ keyCode: Keys.W });
    }).bind(this), this._mobileControlTouchEndCb = (function(e2) {
      this._keyupCb({ keyCode: Keys.W });
    }).bind(this), this._domElement.addEventListener("keydown", this._keydownCb, false), this._domElement.addEventListener("keyup", this._keyupCb, false), t && Detector.isTouchDevice()) {
      const e2 = document.createElement("div");
      e2.className = "v3d-mobile-forward", t.appendChild(e2), e2.addEventListener("touchstart", this._mobileControlTouchStartCb), e2.addEventListener("touchend", this._mobileControlTouchEndCb), this._mobileForwardElement = e2;
    }
  }
  dispose() {
    this._domElement.removeEventListener("keydown", this._keydownCb, false), this._domElement.removeEventListener("keyup", this._keyupCb, false), this._mobileForwardElement && (this._mobileForwardElement.removeEventListener("touchstart", this._mobileControlTouchStartCb), this._mobileForwardElement.removeEventListener("touchend", this._mobileControlTouchEndCb), this._mobileForwardElement.remove());
  }
};
var _vec3Tmp$6 = new Vector3();
var _posTmp = new Vector3();
var _targetTmp$1 = new Vector3();
var TweenCameraController = class {
  constructor() {
    this.posFrom = new Vector3(), this.targetFrom = new Vector3(), this.posTo = new Vector3(), this.targetTo = new Vector3(), this.sphericalFrom = new Spherical(), this.sphericalTo = new Spherical(), this.finishCb = function() {
    }, this.movementType = 0, this.active = false, this.duration = 0, this.clock = new Clock();
  }
  setup({ posFrom: e = new Vector3(), targetFrom: t = new Vector3(), posTo: n = new Vector3(), targetTo: o = new Vector3(), finishCb: r = function() {
  }, movementType: i = 0 }) {
    if (this.posFrom.copy(e), this.targetFrom.copy(t), this.posTo.copy(n), this.targetTo.copy(o), this.finishCb = r, this.movementType = i, 1 === this.movementType) {
      _vec3Tmp$6.copy(this.posFrom).sub(this.targetFrom), this.sphericalFrom.setFromVector3(_vec3Tmp$6), _vec3Tmp$6.copy(this.posTo).sub(this.targetTo), this.sphericalTo.setFromVector3(_vec3Tmp$6);
      const e2 = angleToRange_0_2Pi(this.sphericalFrom.theta);
      let t2 = angleToRange_0_2Pi(this.sphericalTo.theta);
      const n2 = Math.abs(e2 - t2);
      n2 > Math.PI && (t2 = e2 + Math.sign(e2 - t2) * (2 * Math.PI - n2)), this.sphericalFrom.theta = e2, this.sphericalTo.theta = t2;
    }
    return this;
  }
  start(e) {
    this.active = true, this.duration = e, this.clock.start();
  }
  update(e = function(e2, t, n) {
  }) {
    let t = this.clock.getElapsedTime() / this.duration;
    if (t = smootherstep(t, 0, 1), _targetTmp$1.lerpVectors(this.targetFrom, this.targetTo, t), 0 === this.movementType) _posTmp.lerpVectors(this.posFrom, this.posTo, t);
    else if (1 === this.movementType) {
      const e2 = lerp(this.sphericalFrom.radius, this.sphericalTo.radius, t), n = lerp(this.sphericalFrom.phi, this.sphericalTo.phi, t), o = lerp(this.sphericalFrom.theta, this.sphericalTo.theta, t);
      _posTmp.setFromSphericalCoords(e2, n, o), _posTmp.add(_targetTmp$1);
    }
    e(t, _posTmp, _targetTmp$1), t >= 1 && (this.active = false, this.finishCb());
  }
};
var _targetTmp = new Vector3();
var TweenCameraZoomToController = class {
  constructor() {
    this.posFrom = new Vector3(), this.targetFrom = new Vector3(), this.posTo = new Vector3(), this.targetTo = new Vector3(), this.zoomFrom = 0, this.zoomTo = 0, this.finishCb = function() {
    }, this.active = false, this.duration = 0, this.clock = new Clock();
  }
  setup({ posFrom: e = new Vector3(), targetFrom: t = new Vector3(), posTo: n = new Vector3(), targetTo: o = new Vector3(), zoomFrom: r = 0, zoomTo: i = 0, finishCb: a = function() {
  } }) {
    return this.posFrom.copy(e), this.targetFrom.copy(t), this.posTo.copy(n), this.targetTo.copy(o), this.zoomFrom = r, this.zoomTo = i, this.finishCb = a, this;
  }
  start(e) {
    this.active = true, this.duration = e, this.clock.start();
  }
  update(e = function(e2, t, n) {
  }) {
    let t = this.clock.getElapsedTime() / this.duration;
    t = smootherstep(t, 0, 1), _targetTmp.lerpVectors(this.targetFrom, this.targetTo, t);
    let n = lerp(this.zoomFrom, this.zoomTo, t);
    e(t, _targetTmp, n), t >= 1 && (this.active = false, this.finishCb());
  }
};
var DEFAULTS$2 = { minDistance: 0, maxDistance: 1 / 0, minZoom: 0, maxZoom: 1 / 0, minPolarAngle: 0, maxPolarAngle: Math.PI, minAzimuthAngle: -1 / 0, maxAzimuthAngle: 1 / 0, autoRotate: false, autoRotateSpeed: 2, enablePan: true, panInertia: 0.05, panSpeed: 1.3, panSpeedKey: 15, screenSpacePanning: true, enableRotate: true, rotateInertia: 0.05, rotateInertiaTouch: 0.05, rotateSpeed: 1.2, rotateSpeedTouch: 0.7, enableZoom: true, enableCtrlZoom: false, zoomInertia: 0.05, zoomInertiaTouch: 0.05, zoomSpeed: 5, zoomSpeedTouch: 1, enableDamping: true, enableTurnover: false, enableKeys: true };
var Y_Up = new Vector3(0, 1, 0);
var QUAT_FLIP = new Quaternion().setFromAxisAngle(new Vector3(0, 0, 1), Math.PI);
var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };
var EPS = 1e-6;
var _vec3Tmp$5 = new Vector3();
var _vec3Tmp2$4 = new Vector3();
var _quatTmp$2 = new Quaternion();
var _quatTmp2$1 = new Quaternion();
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(e, t) {
    super(), void 0 === t && console.warn('v3d.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('v3d.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = true, this.targetObj = new Object3D(), this.minDistance = DEFAULTS$2.minDistance, this.maxDistance = DEFAULTS$2.maxDistance, this.minZoom = DEFAULTS$2.minZoom, this.maxZoom = DEFAULTS$2.maxZoom, this.minPolarAngle = DEFAULTS$2.minPolarAngle, this.maxPolarAngle = DEFAULTS$2.maxPolarAngle, this.minAzimuthAngle = DEFAULTS$2.minAzimuthAngle, this.maxAzimuthAngle = DEFAULTS$2.maxAzimuthAngle, this.enableDamping = DEFAULTS$2.enableDamping, this.enableZoom = DEFAULTS$2.enableZoom, this.enableCtrlZoom = DEFAULTS$2.enableCtrlZoom, this.zoomSpeed = DEFAULTS$2.zoomSpeed, this.zoomSpeedTouch = DEFAULTS$2.zoomSpeedTouch, this.zoomInertia = DEFAULTS$2.zoomInertia, this.zoomInertiaTouch = DEFAULTS$2.zoomInertiaTouch, this.enableRotate = DEFAULTS$2.enableRotate, this.rotateSpeed = DEFAULTS$2.rotateSpeed, this.rotateSpeedTouch = DEFAULTS$2.rotateSpeedTouch, this.rotateInertia = DEFAULTS$2.rotateInertia, this.rotateInertiaTouch = DEFAULTS$2.rotateInertiaTouch, this.enablePan = DEFAULTS$2.enablePan, this.panSpeed = DEFAULTS$2.panSpeed, this.screenSpacePanning = DEFAULTS$2.screenSpacePanning, this.panSpeedKey = DEFAULTS$2.panSpeedKey, this.panInertia = DEFAULTS$2.panInertia, this.autoRotate = DEFAULTS$2.autoRotate, this.autoRotateSpeed = DEFAULTS$2.autoRotateSpeed, this.enableTurnover = DEFAULTS$2.enableTurnover, this.enableKeys = DEFAULTS$2.enableKeys, this.mouseButtons = { ROTATE: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT }, this.target0 = this.targetObj.position.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, Object.defineProperty(this, "inTween", { get: () => I.active || w.active, set(e2) {
      I.active = e2;
    } }), this.getPolarAngle = function() {
      return r.phi;
    }, this.getAzimuthalAngle = function() {
      return r.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.targetObj.position);
    }, this.saveState = function() {
      n.targetObj.updateWorldMatrix(true, false), n.target0.setFromMatrixPosition(n.targetObj.matrixWorld), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.forceMouseUp = function() {
      G();
    }, this.reset = function() {
      n.targetObj.updateWorldMatrix(true, false);
      const e2 = _vec3Tmp$5.copy(n.target0);
      n.targetObj.worldToLocal(e2), n.targetObj.position.add(e2), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(_changeEvent), n.update(), o = STATE.NONE;
    }, this.update = function() {
      const e2 = new Vector3(), t2 = new Vector3(), d2 = new Vector3(), h2 = new Quaternion();
      let _2 = false, A2 = false;
      return function() {
        const y2 = n.object.position;
        if (n.targetObj.updateWorldMatrix(true, false), I.active) I.update(function(t3, o2, r2) {
          if (y2.copy(o2), e2.copy(r2), n.object.lookAt(e2), t3 >= 1) {
            i.set(0, 0, 0), s.set(0, 0, 0), a = 1, x.set(0, 0);
            for (let e3 in c) c[e3] = 0;
            p.set(0, 0), T.getDelta();
          }
        });
        else if (w.active) w.update(function(t3, o2, r2) {
          if (e2.copy(o2), n.object.lookAt(e2), n.object.zoom = r2, n.object.updateProjectionMatrix(), t3 >= 1) {
            i.set(0, 0, 0), s.set(0, 0, 0), a = 1, x.set(0, 0);
            for (let e3 in c) c[e3] = 0;
            p.set(0, 0), T.getDelta();
          }
        });
        else {
          e2.setFromMatrixPosition(n.targetObj.matrixWorld), t2.copy(y2).sub(e2);
          const l2 = _quatTmp$2.setFromUnitVectors(n.object.up, Y_Up), d3 = _quatTmp2$1.copy(l2).invert();
          if (t2.applyQuaternion(l2), r.setFromVector3(t2), n.autoRotate && o === STATE.NONE && L(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), r.theta += i.theta, r.phi += i.phi, n.enableTurnover) {
            _2 && (r.phi -= 2 * i.phi), A2 != _2 && o == STATE.NONE && (A2 = _2), A2 && (r.theta -= 2 * i.theta);
            const e3 = r.phi;
            (e3 <= 0 || e3 >= Math.PI) && (_2 = !_2, r.theta += Math.PI, r.phi = e3 > 0 ? 2 * Math.PI - e3 : Math.abs(e3));
          } else isFinite(n.minAzimuthAngle) && isFinite(n.maxAzimuthAngle) && (r.theta = clampAngle(r.theta, n.minAzimuthAngle, n.maxAzimuthAngle)), r.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, r.phi));
          r.makeSafe(), n.object.isPerspectiveCamera ? (r.radius *= a, r.radius = Math.max(n.minDistance, Math.min(n.maxDistance, r.radius))) : n.object.isOrthographicCamera && (n.object.zoom /= a, n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom)), n.object.updateProjectionMatrix()), e2.add(s), t2.setFromSpherical(r), t2.applyQuaternion(d3), y2.copy(e2).add(t2), n.object.lookAt(e2), _2 && (n.enableTurnover ? n.object.quaternion.multiply(QUAT_FLIP) : _2 = false), i.set(0, 0, 0), s.set(0, 0, 0), function() {
            const e3 = T.getDelta();
            let t3, o2;
            f.copy(p), p.x = n.enableDamping ? expAverageClamp(p.x, 0, e3, g, 0.1) : 0, p.y = n.enableDamping ? expAverageClamp(p.y, 0, e3, g, 0.1) : 0, f.sub(p), function() {
              const e4 = n.domElement === document ? n.domElement.body : n.domElement, t4 = e4.clientWidth, o3 = e4.clientHeight;
              if (!t4 || !o3) return;
              L(2 * Math.PI * f.x / t4 * m), r2 = 2 * Math.PI * f.y / o3 * m, i.phi -= r2;
              var r2;
            }(), v.copy(x), x.x = n.enableDamping ? expAverageClamp(x.x, 0, e3, n.panInertia, 0.1) : 0, x.y = n.enableDamping ? expAverageClamp(x.y, 0, e3, n.panInertia, 0.1) : 0, v.sub(x), v.multiplyScalar(n.panSpeed);
            for (let r2 in c) u.isKeyDown[r2] ? t3 = c[r2] = 1 : (o2 = c[r2], c[r2] = expAverageClamp(c[r2], 0, e3, n.panInertia, 0.1), t3 = o2 - c[r2]), n.enabled && n.enableKeys && n.enablePan && (t3 *= 60 * e3 * n.panSpeedKey, r2 == Keys.A || r2 == Keys.LEFT_ARROW ? v.x += t3 : r2 == Keys.D || r2 == Keys.RIGHT_ARROW ? v.x -= t3 : r2 == Keys.W || r2 == Keys.UP_ARROW ? v.y += t3 : r2 != Keys.S && r2 != Keys.DOWN_ARROW || (v.y -= t3));
            (function(e4, t4) {
              const o3 = n.domElement === document ? n.domElement.body : n.domElement, r2 = o3.clientWidth, i2 = o3.clientHeight;
              if (!r2 || !i2) return;
              if (n.object.isPerspectiveCamera) {
                n.targetObj.updateWorldMatrix(true, false);
                const o4 = _vec3Tmp$5.setFromMatrixPosition(n.targetObj.matrixWorld), r3 = n.object.position;
                let a2 = _vec3Tmp2$4.copy(r3).sub(o4).length();
                a2 *= Math.tan(n.object.fov / 2 * DEG2RAD), P(2 * e4 * a2 / i2, n.object.matrix), N(2 * t4 * a2 / i2, n.object.matrix);
              } else n.object.isOrthographicCamera ? (P(e4 * (n.object.right - n.object.left) / n.object.zoom / r2, n.object.matrix), N(t4 * (n.object.top - n.object.bottom) / n.object.zoom / i2, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = false);
            })(v.x, v.y), a = S, S = n.enableDamping ? expAverageClamp(S, 1, e3, E, 1e-3) : 1, a /= S;
          }();
        }
        return n.targetObj.position.copy(e2), !!(l || d2.distanceToSquared(n.object.position) > EPS || 8 * (1 - h2.dot(n.object.quaternion)) > EPS) && (n.dispatchEvent(_changeEvent), d2.copy(n.object.position), h2.copy(n.object.quaternion), l = false, true);
      };
    }(), this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", H), n.domElement.removeEventListener("mousedown", V), n.domElement.removeEventListener("wheel", z), n.domElement.removeEventListener("touchstart", k), n.domElement.removeEventListener("touchend", Q), n.domElement.removeEventListener("touchmove", W), document.removeEventListener("mousemove", U), document.removeEventListener("mouseup", G), document.removeEventListener("mouseleave", G), u.dispose();
    }, this.tween = /* @__PURE__ */ function() {
      const e2 = 1e-5;
      return function(t2, o2, r2, i2, a2) {
        n.targetObj.updateWorldMatrix(true, false);
        const s2 = _vec3Tmp$5.setFromMatrixPosition(n.targetObj.matrixWorld);
        n.object.parent && (t2 = _vec3Tmp2$4.copy(t2), n.object.parent.worldToLocal(t2)), t2.manhattanDistanceTo(n.object.position) < e2 && o2.manhattanDistanceTo(s2) < e2 ? void 0 !== i2 && i2() : I.setup({ posFrom: n.object.position, targetFrom: s2, posTo: t2, targetTo: o2, finishCb: i2, movementType: a2 }).start(r2);
      };
    }(), this.tweenZoomTo = function(e2, t2, o2, r2) {
      if (!n.object.isOrthographicCamera) return void console.warn("v3d.OrbitControls: .tweenZoomTo() works only for orthographic camera");
      n.targetObj.updateWorldMatrix(true, false);
      const i2 = _vec3Tmp$5.setFromMatrixPosition(n.targetObj.matrixWorld);
      w.setup({ zoomFrom: n.object.zoom, targetFrom: i2, zoomTo: t2, targetTo: e2, finishCb: r2 }).start(o2);
    };
    const n = this;
    let o = STATE.NONE;
    const r = new Spherical(), i = new Spherical();
    let a = 1;
    const s = new Vector3();
    let l = false;
    const c = {};
    c[Keys.W] = c[Keys.S] = c[Keys.A] = c[Keys.D] = c[Keys.UP_ARROW] = c[Keys.DOWN_ARROW] = c[Keys.LEFT_ARROW] = c[Keys.RIGHT_ARROW] = 0;
    const u = new KeyListener(window);
    u.onKeyDown = function(e2) {
      n.enableKeys ? e2.keyCode in c && (c[e2.keyCode] = 1) : u.isKeyDown[e2.keyCode] = false;
    };
    const d = new Vector2(), h = new Vector2(), f = new Vector2(), p = new Vector2();
    let m = 1, g = 1;
    const _ = new Vector2(), A = new Vector2(), v = new Vector2(), x = new Vector2(), y = new Vector2(), b = new Vector2(), C = new Vector2();
    let S = 1, M = 1, E = 1;
    const T = new Clock(), I = new TweenCameraController(), w = new TweenCameraZoomToController();
    function R(e2 = 1) {
      return Math.pow(0.95, M * e2);
    }
    function L(e2) {
      i.theta -= e2;
    }
    function B(e2, t2) {
      h.set(e2, t2), p.add(h).sub(d), d.copy(h);
    }
    function P(e2, t2) {
      _vec3Tmp$5.setFromMatrixColumn(t2, 0), _vec3Tmp$5.multiplyScalar(-e2), s.add(_vec3Tmp$5);
    }
    function N(e2, t2) {
      true === n.screenSpacePanning ? _vec3Tmp$5.setFromMatrixColumn(t2, 1) : (_vec3Tmp$5.setFromMatrixColumn(t2, 0), _vec3Tmp$5.crossVectors(n.object.up, _vec3Tmp$5)), _vec3Tmp$5.multiplyScalar(e2), s.add(_vec3Tmp$5);
    }
    function D(e2) {
      n.object.isPerspectiveCamera ? S /= e2 : n.object.isOrthographicCamera ? (S /= e2, l = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = false);
    }
    function O(e2) {
      n.object.isPerspectiveCamera ? S *= e2 : n.object.isOrthographicCamera ? (S *= e2, l = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = false);
    }
    function F(e2) {
      !function(e3, t2) {
        A.set(e3, t2), x.add(A).sub(_), _.copy(A);
      }(e2.clientX, e2.clientY);
    }
    function V(e2) {
      if (false !== n.enabled) {
        switch (e2.preventDefault(), e2.button) {
          case n.mouseButtons.ROTATE:
            if (false === n.enableRotate) return;
            !function(e3) {
              d.set(e3.clientX, e3.clientY);
            }(e2), o = STATE.ROTATE;
            break;
          case n.mouseButtons.ZOOM:
          case n.mouseButtons.PAN:
            if (false === n.enablePan) return;
            !function(e3) {
              _.set(e3.clientX, e3.clientY);
            }(e2), o = STATE.PAN;
        }
        o !== STATE.NONE && (document.addEventListener("mousemove", U), document.addEventListener("mouseup", G), document.addEventListener("mouseleave", G), n.dispatchEvent(_startEvent));
      }
    }
    function U(e2) {
      if (false !== n.enabled) switch (e2.preventDefault(), o) {
        case STATE.ROTATE:
          if (false === n.enableRotate) return;
          !function(e3) {
            B(e3.clientX, e3.clientY), m = n.rotateSpeed, g = n.rotateInertia;
          }(e2);
          break;
        case STATE.DOLLY:
          if (false === n.enableZoom) return;
          !function(e3) {
            b.set(e3.clientX, e3.clientY), C.subVectors(b, y), C.y > 0 ? D(R()) : C.y < 0 && O(R()), y.copy(b), n.update();
          }(e2);
          break;
        case STATE.PAN:
          if (false === n.enablePan) return;
          F(e2);
      }
    }
    function G(e2) {
      false !== n.enabled && (document.removeEventListener("mousemove", U), document.removeEventListener("mouseup", G), document.removeEventListener("mouseleave", G), n.dispatchEvent(_endEvent), o = STATE.NONE);
    }
    function z(e2) {
      false === n.enabled || false === n.enableZoom || o !== STATE.NONE && o !== STATE.ROTATE || n.enableCtrlZoom && !e2.ctrlKey || (e2.preventDefault(), e2.stopPropagation(), n.dispatchEvent(_startEvent), function(e3) {
        M = n.zoomSpeed, E = n.zoomInertia, e3.deltaY < 0 ? O(R(Math.abs(e3.deltaY) / 100)) : e3.deltaY > 0 && D(R(Math.abs(e3.deltaY) / 100)), n.update();
      }(e2), n.dispatchEvent(_endEvent));
    }
    function k(e2) {
      if (false !== n.enabled) {
        switch (e2.touches.length) {
          case 1:
            if (false === n.enableRotate) return;
            !function(e3) {
              d.set(e3.touches[0].pageX, e3.touches[0].pageY);
            }(e2), o = STATE.TOUCH_ROTATE;
            break;
          case 2:
            if (false === n.enableZoom && false === n.enablePan) return;
            !function(e3) {
              if (n.enableZoom) {
                M = n.zoomSpeedTouch, E = n.zoomInertiaTouch;
                let t2 = e3.touches[0].pageX - e3.touches[1].pageX, o2 = e3.touches[0].pageY - e3.touches[1].pageY, r2 = Math.sqrt(t2 * t2 + o2 * o2);
                y.set(0, r2);
              }
              if (n.enablePan) {
                let t2 = 0.5 * (e3.touches[0].pageX + e3.touches[1].pageX), n2 = 0.5 * (e3.touches[0].pageY + e3.touches[1].pageY);
                _.set(t2, n2);
              }
              n.update();
            }(e2), o = STATE.TOUCH_DOLLY_PAN;
            break;
          default:
            o = STATE.NONE;
        }
        o !== STATE.NONE && n.dispatchEvent(_startEvent);
      }
    }
    function W(e2) {
      if (false !== n.enabled) switch (e2.preventDefault(), e2.touches.length) {
        case 1:
          if (false === n.enableRotate) return;
          if (o !== STATE.TOUCH_ROTATE) return;
          !function(e3) {
            B(e3.touches[0].pageX, e3.touches[0].pageY), m = n.rotateSpeedTouch, g = n.rotateInertiaTouch;
          }(e2);
          break;
        case 2:
          if (false === n.enableZoom && false === n.enablePan) return;
          if (o !== STATE.TOUCH_DOLLY_PAN) return;
          !function(e3) {
            let t2 = e3.touches[0].pageX - e3.touches[1].pageX, o2 = e3.touches[0].pageY - e3.touches[1].pageY, r2 = Math.sqrt(t2 * t2 + o2 * o2);
            b.set(0, r2), C.subVectors(b, y), y.copy(b);
            let i2 = 0.5 * (e3.touches[0].pageX + e3.touches[1].pageX), a2 = 0.5 * (e3.touches[0].pageY + e3.touches[1].pageY);
            A.set(i2, a2), v.subVectors(A, _), _.copy(A), n.enableZoom && Math.abs(C.length()) > Math.abs(v.length()) && (C.y > 0 ? O(R()) : C.y < 0 && D(R())), n.enablePan && Math.abs(C.length()) < Math.abs(v.length()) && x.add(v), n.update();
          }(e2);
          break;
        default:
          o = STATE.NONE;
      }
    }
    function Q(e2) {
      false !== n.enabled && (n.dispatchEvent(_endEvent), o = STATE.NONE);
    }
    function H(e2) {
      false !== n.enabled && e2.preventDefault();
    }
    n.domElement.addEventListener("contextmenu", H), n.domElement.addEventListener("mousedown", V), n.domElement.addEventListener("wheel", z, { passive: false }), n.domElement.addEventListener("touchstart", k, { passive: true }), n.domElement.addEventListener("touchend", Q), n.domElement.addEventListener("touchmove", W, { passive: false }), this.update();
  }
};
var DEFAULTS$1 = { enableCollisions: true, gazeLevel: 1.8, enablePan: true, panInertia: 0.05, panSpeedKey: 0.15, enableRotate: true, rotateInertia: 0.05, rotateInertiaTouch: 0.05, rotateSpeed: 0.9, rotateSpeedTouch: 0.75, storyHeight: 3, enableZoom: true, enableCtrlZoom: false, zoomInertia: 0.05, zoomSpeed: 30, zoomSpeedKey: 0.2, enableDamping: true, enableKeys: true };
var _vec2Tmp = new Vector2();
var _vec3Tmp$4 = new Vector3();
var _vec3Tmp2$3 = new Vector3();
var _vec3Tmp3$1 = new Vector3();
var FirstPersonControls = class extends EventDispatcher {
  constructor(e, t) {
    super();
    __publicField(this, "_raycaster", new Raycaster(new Vector3(), new Vector3(0, -1, 0)));
    __publicField(this, "_onCollisionMesh", false);
    __publicField(this, "_lastPosition", new Vector3());
    __publicField(this, "_enableCollisions", DEFAULTS$1.enableCollisions);
    __publicField(this, "_nearestPoint", new Vector3());
    __publicField(this, "_lastIntersection", new Vector3());
    __publicField(this, "_toMeshSpaceMatrix", new Matrix4());
    __publicField(this, "_ppTarget", { point: new Vector3(), distance: 0, faceIndex: 0 });
    const n = this;
    this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = true, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.enableDamping = DEFAULTS$1.enableDamping, this.enableRotate = DEFAULTS$1.enableRotate, this.rotateSpeed = DEFAULTS$1.rotateSpeed, this.rotateSpeedTouch = DEFAULTS$1.rotateSpeedTouch, this.rotateInertia = DEFAULTS$1.rotateInertia, this.rotateInertiaTouch = DEFAULTS$1.rotateInertiaTouch, this.enableZoom = DEFAULTS$1.enableZoom, this.enableCtrlZoom = DEFAULTS$1.enableCtrlZoom, this.zoomSpeed = DEFAULTS$1.zoomSpeed, this.zoomSpeedKey = DEFAULTS$1.zoomSpeedKey, this.zoomInertia = DEFAULTS$1.zoomInertia, this.enablePan = DEFAULTS$1.enablePan, this.panSpeedKey = DEFAULTS$1.panSpeedKey, this.panInertia = DEFAULTS$1.panInertia, this.enableKeys = DEFAULTS$1.enableKeys, this.gazeLevel = DEFAULTS$1.gazeLevel, this.storyHeight = DEFAULTS$1.storyHeight, this.collisionMeshes = [], this._raycaster.params.checkVisibility = false;
    let o = false;
    Object.defineProperty(this, "enablePointerLock", { get: () => o, set(e2) {
      o !== e2 && (o = e2, H());
    } }), Object.defineProperty(this, "inTween", { get: () => T.active || I.active });
    const r = new Clock(), i = 1e-6, a = new Vector3(), s = new Vector3(), l = new Vector3(), c = new Quaternion(), u = new Vector3(), d = {};
    let h;
    d[Keys.W] = d[Keys.S] = d[Keys.A] = d[Keys.D] = d[Keys.UP_ARROW] = d[Keys.DOWN_ARROW] = d[Keys.LEFT_ARROW] = d[Keys.RIGHT_ARROW] = 0;
    let f = false;
    const p = new Spherical(), m = new Spherical(), g = new Vector2();
    let _ = 1, A = 1;
    const v = new Vector2(), x = new Vector2();
    let y = 0, b = 0, C = 1, S = 1;
    const M = new Vector2(), E = new Vector2();
    const T = new TweenCameraController(), I = new TweenCameraZoomToController(), w = { type: "change" }, R = { type: "start" }, L = { type: "end" };
    this.handleResize = function() {
      if (this.domElement === document) this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight;
      else {
        const e2 = this.domElement.getBoundingClientRect(), t2 = this.domElement.ownerDocument.documentElement;
        this.screen.left = e2.left + window.pageXOffset - t2.clientLeft, this.screen.top = e2.top + window.pageYOffset - t2.clientTop, this.screen.width = e2.width, this.screen.height = e2.height;
      }
    }, this.handleEvent = function(e2) {
      "function" == typeof this[e2.type] && this[e2.type](e2);
    };
    const B = function(e2, t2) {
      return _vec2Tmp.set((e2 - 0.5 * n.screen.width - n.screen.left) / (0.5 * n.screen.width), (n.screen.height + 2 * (n.screen.top - t2)) / n.screen.width);
    };
    function P(e2) {
      false !== n.enabled && (e2.preventDefault(), false !== n.enableRotate && (x.copy(B(e2.pageX, e2.pageY).negate()), v.copy(x), f = true, document.addEventListener("mousemove", N), document.addEventListener("mouseup", D), document.addEventListener("mouseleave", D), n.dispatchEvent(R)));
    }
    function N(e2) {
      if (false !== n.enabled && (e2.preventDefault(), f)) {
        if (false === n.enableRotate) return;
        x.copy(B(e2.pageX, e2.pageY).negate()), g.add(x).sub(v), v.copy(x), _ = n.rotateSpeed, A = n.rotateInertia;
      }
    }
    function D(e2) {
      false !== n.enabled && (e2.preventDefault(), f = false, document.removeEventListener("mousemove", N), document.removeEventListener("mouseup", D), document.removeEventListener("mouseleave", D), n.dispatchEvent(L));
    }
    function O(e2) {
      if (false !== n.enabled && false !== n.enableZoom && (!n.enableCtrlZoom || e2.ctrlKey)) {
        switch (e2.preventDefault(), e2.stopPropagation(), e2.deltaMode) {
          case 2:
            b -= 0.025 * e2.deltaY, C = n.zoomSpeed, S = n.zoomInertia;
            break;
          case 1:
            b -= 0.01 * e2.deltaY, C = n.zoomSpeed, S = n.zoomInertia;
            break;
          default:
            b -= 25e-5 * e2.deltaY, C = n.zoomSpeed, S = n.zoomInertia;
        }
        n.dispatchEvent(R), n.dispatchEvent(L);
      }
    }
    function F(e2) {
      if (false === n.enabled) return;
      const t2 = e2.targetTouches[0];
      f = true, x.copy(B(t2.pageX, t2.pageY).negate()), v.copy(x), n.dispatchEvent(R);
    }
    function V(e2) {
      if (false === n.enabled) return;
      e2.preventDefault();
      const t2 = e2.targetTouches[0];
      false !== n.enableRotate && (x.copy(B(t2.pageX, t2.pageY).negate()), g.add(x).sub(v), v.copy(x), _ = n.rotateSpeedTouch, A = n.rotateInertiaTouch);
    }
    function U(e2) {
      if (false !== n.enabled) {
        if (0 === e2.targetTouches.length) f = false;
        else {
          if (false === n.enableRotate) return;
          f = true, x.copy(B(e2.targetTouches[0].pageX, e2.targetTouches[0].pageY).negate()), v.copy(x);
        }
        n.dispatchEvent(L);
      }
    }
    function G(e2) {
      false !== n.enabled && e2.preventDefault();
    }
    function z(e2) {
      n.domElement.requestPointerLock();
    }
    function k(e2) {
      document.pointerLockElement === n.domElement ? (n.dispatchEvent(R), document.addEventListener("mousemove", Q)) : (n.dispatchEvent(L), document.removeEventListener("mousemove", Q));
    }
    function W(e2) {
      console.error("Pointer lock failed");
    }
    function Q(e2) {
      var t2, o2;
      (e2.preventDefault(), n.enabled && n.enableRotate) && (g.add((t2 = e2.movementX, o2 = e2.movementY, _vec2Tmp.set(t2, -o2).multiplyScalar(2 / n.screen.width)).negate()), _ = n.rotateSpeed, A = n.rotateInertia);
    }
    function H() {
      X(), n.domElement.addEventListener("contextmenu", G), n.enablePointerLock ? (n.domElement.addEventListener("click", z), document.addEventListener("pointerlockchange", k), document.addEventListener("pointerlockerror", W)) : n.domElement.addEventListener("mousedown", P), n.domElement.addEventListener("wheel", O, { passive: false }), n.domElement.addEventListener("touchstart", F, { passive: true }), n.domElement.addEventListener("touchend", U), n.domElement.addEventListener("touchmove", V, { passive: false }), h = new KeyListener(window, n.domElement.parentElement), h.onKeyDown = function(e2) {
        n.enableKeys ? e2.keyCode in d && (d[e2.keyCode] = 1) : h.isKeyDown[e2.keyCode] = false;
      };
    }
    function X() {
      n.domElement.removeEventListener("contextmenu", G), n.domElement.removeEventListener("click", z), document.removeEventListener("pointerlockchange", k), document.removeEventListener("pointerlockerror", W), document.removeEventListener("mousemove", Q), n.domElement.removeEventListener("mousedown", P), n.domElement.removeEventListener("wheel", O), n.domElement.removeEventListener("touchstart", F), n.domElement.removeEventListener("touchend", U), n.domElement.removeEventListener("touchmove", V), document.removeEventListener("mousemove", N), document.removeEventListener("mouseup", D), document.removeEventListener("mouseleave", D), h && h.dispose();
    }
    this.update = function() {
      T.active ? T.update(function(e3, t2, o2) {
        if (n.object.position.copy(t2), n.object.lookAt(o2), e3 >= 1) {
          m.set(0, 0, 0), g.set(0, 0), y = 0, b = 0, M.set(0, 0), E.set(0, 0);
          for (const e4 in d) d[e4] = 0;
          r.getDelta();
        }
      }) : I.active ? I.update(function(e3, t2, o2) {
        if (n.object.lookAt(t2), n.object.zoom = o2, n.object.updateProjectionMatrix(), e3 >= 1) {
          m.set(0, 0, 0), g.set(0, 0), y = 0, b = 0, M.set(0, 0), E.set(0, 0);
          for (let e4 in d) d[e4] = 0;
          r.getDelta();
        }
      }) : (n.object.matrixAutoUpdate && n.object.updateMatrix(), n.object.getLocalDirection(u), p.setFromVector3(u), p.theta += m.theta * _, p.phi += m.phi * _, p.makeSafe(), u.setFromSpherical(p), a.copy(u).add(n.object.position), n.object.lookAtLocal(a), n.object.isPerspectiveCamera ? n.object.position.addScaledVector(u, y) : n.object.isOrthographicCamera && (n.object.zoom *= 1 + 0.15 * y, n.object.updateProjectionMatrix()), s.copy(u).cross(n.object.up).setLength(-M.x), s.add(l.copy(n.object.up).setLength(M.y)), n.object.position.add(s), function() {
        const e3 = r.getDelta();
        m.set(m.radius, g.y, g.x), g.x = n.enableDamping ? expAverageClamp(g.x, 0, e3, A, 1e-3) : 0, g.y = n.enableDamping ? expAverageClamp(g.y, 0, e3, A, 1e-3) : 0, m.set(m.radius, m.phi - g.y, m.theta - g.x), M.copy(E), E.x = n.enableDamping ? expAverageClamp(E.x, 0, e3, 1, 1e-3) : 0, E.y = n.enableDamping ? expAverageClamp(E.y, 0, e3, 1, 1e-3) : 0, M.sub(E), M.multiplyScalar(1), y = b, b = n.enableDamping ? expAverageClamp(b, 0, e3, S, 1e-3) : 0, y -= b, y *= C;
        for (const t2 in d) {
          const o2 = t2 == Keys.A || t2 == Keys.LEFT_ARROW || t2 == Keys.D || t2 == Keys.RIGHT_ARROW, r2 = t2 == Keys.W || t2 == Keys.UP_ARROW || t2 == Keys.S || t2 == Keys.DOWN_ARROW, i2 = o2 ? n.panInertia : n.zoomInertia, a2 = o2 ? n.panSpeedKey : n.zoomSpeedKey, s2 = 1e-3;
          let l2;
          if (h.isKeyDown[t2]) l2 = d[t2] = 1;
          else {
            const n2 = d[t2];
            d[t2] = expAverageClamp(d[t2], 0, e3, i2, s2), l2 = n2 - d[t2];
          }
          n.enabled && n.enableKeys && (o2 && !n.enablePan || r2 && !n.enableZoom || (l2 *= 60 * e3 * a2, t2 == Keys.A || t2 == Keys.LEFT_ARROW ? M.x += l2 : t2 == Keys.D || t2 == Keys.RIGHT_ARROW ? M.x -= l2 : t2 == Keys.W || t2 == Keys.UP_ARROW ? y += l2 : t2 != Keys.S && t2 != Keys.DOWN_ARROW || (y -= l2)));
        }
      }()), this._handleCollisions();
      let e2 = false;
      this._lastPosition.distanceToSquared(n.object.position) > i && (this._lastPosition.copy(n.object.position), e2 = true), c.dot(n.object.quaternion) < 1 - i && (c.copy(n.object.quaternion), e2 = true), e2 && n.dispatchEvent(w);
    }, this.forceMouseUp = function() {
      D({ preventDefault: function() {
      } });
    }, this.dispose = X, this.releaseFromCollision = function() {
      this._onCollisionMesh = false;
    }, this.tween = function(e2, t2, o2, r2, i2) {
      n.object.parent && (e2 = _vec3Tmp$4.copy(e2), n.object.parent.worldToLocal(e2));
      const a2 = n.object.getWorldPosition(_vec3Tmp2$3), s2 = _vec3Tmp3$1.subVectors(t2, a2).length(), l2 = n.object.getWorldDirection(_vec3Tmp3$1).multiplyScalar(s2).add(a2), c2 = 1e-5;
      e2.manhattanDistanceTo(n.object.position) < c2 && t2.manhattanDistanceTo(l2) < c2 ? void 0 !== r2 && r2() : T.setup({ posFrom: n.object.position, targetFrom: l2, posTo: e2, targetTo: t2, finishCb: r2, movementType: i2 }).start(o2);
    }, this.tweenZoomTo = function(e2, t2, o2, r2) {
      if (!n.object.isOrthographicCamera) return void console.warn("v3d.FirstPersonControls: .tweenZoomTo() works only for orthographic camera");
      const i2 = n.object.getWorldPosition(_vec3Tmp$4), a2 = _vec3Tmp2$3.subVectors(e2, i2).length(), s2 = n.object.getWorldDirection(_vec3Tmp2$3).multiplyScalar(a2).add(i2);
      I.setup({ zoomFrom: n.object.zoom, targetFrom: s2, zoomTo: t2, targetTo: e2, finishCb: r2 }).start(o2);
    }, H(), this.handleResize(), this.update();
  }
  set enableCollisions(e) {
    this._enableCollisions = e, e || this.releaseFromCollision();
  }
  get enableCollisions() {
    return this._enableCollisions;
  }
  _handleCollisions() {
    if (!this._enableCollisions || 0 == this.collisionMeshes.length) return;
    this._raycaster.ray.origin.copy(this.object.position), this._raycaster.far = this.storyHeight;
    const e = this._raycaster.intersectObjects(this.collisionMeshes, false);
    if (e.length > 0) {
      const t = e[0];
      this.object.position.y = t.point.y + this.gazeLevel, this._onCollisionMesh = true;
    } else if (this._onCollisionMesh) {
      let e2 = 1 / 0;
      for (const t of this.collisionMeshes) {
        if (!t.geometry.boundsTree) {
          console.warn("v3d.FirstPersonControls: no bounding tree found on " + t.name);
          continue;
        }
        this._toMeshSpaceMatrix.copy(t.matrixWorld).invert(), this._lastIntersection.copy(this.object.position), this._lastIntersection.y -= this.gazeLevel, this._lastIntersection.applyMatrix4(this._toMeshSpaceMatrix);
        const n = this._ppTarget;
        t.geometry.boundsTree.closestPointToPoint(this._lastIntersection, n), n.distance < e2 && (this._nearestPoint.copy(n.point), this._nearestPoint.applyMatrix4(t.matrixWorld), e2 = n.distance);
      }
      isFinite(e2) ? (this.object.position.copy(this._nearestPoint), this.object.position.y += this.gazeLevel) : this.object.position.copy(this._lastPosition);
    }
  }
};
var DEFAULTS = { panInertia: 0.05, panInertiaTouch: 0.05, panSpeed: 20, panSpeedKey: 0.4, panSpeedTouch: 15, rotateInertia: 0.05, rotateInertiaTouch: 0.05, rotateSpeed: 0.9, rotateSpeedTouch: 0.75, zoomInertia: 0.05, zoomInertiaTouch: 0.05, zoomSpeed: 150, zoomSpeedKey: 0.5, zoomSpeedTouch: 20, enableDamping: true, enableRotate: true, enableZoom: true, enableCtrlZoom: false, enablePan: true, enableKeys: true, minAzimuthAngle: -1 / 0, maxAzimuthAngle: 1 / 0, minPolarAngle: 0, maxPolarAngle: Math.PI };
var FlyingControls = class extends EventDispatcher {
  constructor(e, t) {
    super();
    var n = this, o = -1, r = 0, i = 1, a = 2, s = 3, l = 4;
    this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = true, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.enableDamping = DEFAULTS.enableDamping, this.enableRotate = DEFAULTS.enableRotate, this.rotateSpeed = DEFAULTS.rotateSpeed, this.rotateSpeedTouch = DEFAULTS.rotateSpeedTouch, this.rotateInertia = DEFAULTS.rotateInertia, this.rotateInertiaTouch = DEFAULTS.rotateInertiaTouch, this.enableZoom = DEFAULTS.enableZoom, this.enableCtrlZoom = DEFAULTS.enableCtrlZoom, this.zoomSpeed = DEFAULTS.zoomSpeed, this.zoomSpeedKey = DEFAULTS.zoomSpeedKey, this.zoomSpeedTouch = DEFAULTS.zoomSpeedTouch, this.zoomInertia = DEFAULTS.zoomInertia, this.zoomInertiaTouch = DEFAULTS.zoomInertiaTouch, this.enablePan = DEFAULTS.enablePan, this.panSpeed = DEFAULTS.panSpeed, this.panSpeedKey = DEFAULTS.panSpeedKey, this.panSpeedTouch = DEFAULTS.panSpeedTouch, this.panInertia = DEFAULTS.panInertia, this.panInertiaTouch = DEFAULTS.panInertiaTouch, this.enableKeys = DEFAULTS.enableKeys, this.minAzimuthAngle = DEFAULTS.minAzimuthAngle, this.maxAzimuthAngle = DEFAULTS.maxAzimuthAngle, this.minPolarAngle = DEFAULTS.minPolarAngle, this.maxPolarAngle = DEFAULTS.maxPolarAngle, this.mouseButtons = { ROTATE: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT }, Object.defineProperty(this, "inTween", { get: () => G.active || z.active });
    var c = new Clock(), u = 1e-6, d = new Vector3(), h = new Vector3(), f = new Vector3(), p = new Vector2(), m = new Vector3(), g = new Quaternion(), _ = o, A = new Vector3(), v = {};
    v[Keys.W] = v[Keys.S] = v[Keys.A] = v[Keys.D] = v[Keys.UP_ARROW] = v[Keys.DOWN_ARROW] = v[Keys.LEFT_ARROW] = v[Keys.RIGHT_ARROW] = 0;
    var x = new KeyListener(window);
    x.onKeyDown = function(e2) {
      n.enableKeys ? e2.keyCode in v && (v[e2.keyCode] = 1) : x.isKeyDown[e2.keyCode] = false;
    };
    var y = new Spherical(), b = new Spherical(), C = new Vector2(), S = 1, M = 1, E = new Vector2(), T = new Vector2(), I = 0, w = 0, R = 1, L = 1, B = 0, P = 0, N = new Vector2(), D = new Vector2(), O = 1, F = 1, V = new Vector2(), U = new Vector2(), G = new TweenCameraController();
    const z = new TweenCameraZoomToController();
    var k = { type: "change" }, W = { type: "start" }, Q = { type: "end" };
    this.handleResize = function() {
      if (this.domElement === document) this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight;
      else {
        var e2 = this.domElement.getBoundingClientRect(), t2 = this.domElement.ownerDocument.documentElement;
        this.screen.left = e2.left + window.pageXOffset - t2.clientLeft, this.screen.top = e2.top + window.pageYOffset - t2.clientTop, this.screen.width = e2.width, this.screen.height = e2.height;
      }
    }, this.handleEvent = function(e2) {
      "function" == typeof this[e2.type] && this[e2.type](e2);
    };
    var H, X, Y, j, $ = (H = new Vector2(), function(e2, t2) {
      return H.set((e2 - n.screen.left) / n.screen.width, (t2 - n.screen.top) / n.screen.height), H;
    }), K = function() {
      var e2 = new Vector2();
      return function(t2, o2) {
        return e2.set((t2 - 0.5 * n.screen.width - n.screen.left) / (0.5 * n.screen.width), (n.screen.height + 2 * (n.screen.top - o2)) / n.screen.width), e2;
      };
    }();
    function q(e2) {
      if (false !== n.enabled) {
        switch (e2.preventDefault(), e2.button) {
          case n.mouseButtons.ROTATE:
            if (false === n.enableRotate) return;
            T.copy(K(e2.pageX, e2.pageY).negate()), E.copy(T), _ = r;
            break;
          case n.mouseButtons.ZOOM:
          case n.mouseButtons.PAN:
            if (false === n.enablePan) return;
            V.copy($(e2.pageX, e2.pageY)), U.copy(V), _ = e2.button == n.mouseButtons.PAN ? a : i;
        }
        document.addEventListener("mousemove", Z), document.addEventListener("mouseup", J), document.addEventListener("mouseleave", J), n.dispatchEvent(W);
      }
    }
    function Z(e2) {
      if (false !== n.enabled) {
        if (e2.preventDefault(), _ === r) {
          if (false === n.enableRotate) return;
          T.copy(K(e2.pageX, e2.pageY).negate()), C.add(T).sub(E), E.copy(T), S = n.rotateSpeed, M = n.rotateInertia;
        } else if (_ === a || _ === i) {
          if (false === n.enablePan) return;
          U.copy($(e2.pageX, e2.pageY)), D.add(U).sub(V), V.copy(U), O = n.panSpeed, F = n.panInertia;
        }
      }
    }
    function J(e2) {
      false !== n.enabled && (e2.preventDefault(), _ = o, document.removeEventListener("mousemove", Z), document.removeEventListener("mouseup", J), document.removeEventListener("mouseleave", J), n.dispatchEvent(Q));
    }
    function ee(e2) {
      if (false !== n.enabled && false !== n.enableZoom && (!n.enableCtrlZoom || e2.ctrlKey)) {
        switch (e2.preventDefault(), e2.stopPropagation(), e2.deltaMode) {
          case 2:
            w -= 0.025 * e2.deltaY, R = n.zoomSpeed, L = n.zoomInertia;
            break;
          case 1:
            w -= 0.01 * e2.deltaY, R = n.zoomSpeed, L = n.zoomInertia;
            break;
          default:
            w -= 25e-5 * e2.deltaY, R = n.zoomSpeed, L = n.zoomInertia;
        }
        n.dispatchEvent(W), n.dispatchEvent(Q);
      }
    }
    function te2(e2) {
      if (false !== n.enabled) {
        var t2 = e2.touches[0], o2 = e2.touches[1];
        if (1 === e2.touches.length) {
          if (false === n.enableRotate) return;
          _ = s, T.copy(K(t2.pageX, t2.pageY).negate()), E.copy(T);
        } else {
          if (false === n.enableZoom && false === n.enablePan) return;
          if (_ = l, n.enableZoom) {
            var r2 = $(t2.pageX - o2.pageX, t2.pageY - o2.pageY);
            B = P = r2.length();
          }
          if (n.enablePan) {
            var i2 = $((t2.pageX + o2.pageX) / 2, (t2.pageY + o2.pageY) / 2);
            V.copy(i2), U.copy(V);
          }
        }
        n.dispatchEvent(W);
      }
    }
    function ne(e2) {
      if (false !== n.enabled) {
        e2.preventDefault();
        var t2 = e2.touches[0], o2 = e2.touches[1];
        if (1 === e2.touches.length) {
          if (false === n.enableRotate) return;
          T.copy(K(t2.pageX, t2.pageY).negate()), C.add(T).sub(E), E.copy(T), S = n.rotateSpeedTouch, M = n.rotateInertiaTouch;
        } else {
          if (false === n.enableZoom && false === n.enablePan) return;
          var r2 = $(t2.pageX - o2.pageX, t2.pageY - o2.pageY), i2 = (P = r2.length()) - B;
          B = P;
          var a2 = $((t2.pageX + o2.pageX) / 2, (t2.pageY + o2.pageY) / 2);
          U.copy(a2);
          var s2 = p.subVectors(U, V), l2 = s2.length();
          V.copy(U), n.enableZoom && Math.abs(i2) > Math.abs(l2) && (w += i2, R = n.zoomSpeedTouch, L = n.zoomInertiaTouch), n.enablePan && Math.abs(i2) <= Math.abs(l2) && (D.add(s2), O = n.panSpeedTouch, F = n.panInertiaTouch);
        }
      }
    }
    function oe(e2) {
      if (false !== n.enabled) {
        switch (e2.touches.length) {
          case 0:
            _ = o;
            break;
          case 1:
            if (false === n.enableRotate) return;
            _ = s, T.copy(K(e2.touches[0].pageX, e2.touches[0].pageY).negate()), E.copy(T);
        }
        n.dispatchEvent(Q);
      }
    }
    function re(e2) {
      false !== n.enabled && e2.preventDefault();
    }
    this.update = (new Vector3(), function() {
      G.active ? G.update(function(e3, t2, o2) {
        if (n.object.position.copy(t2), n.object.lookAt(o2), e3 >= 1) {
          for (var r2 in b.set(0, 0, 0), C.set(0, 0), I = 0, w = 0, N.set(0, 0), D.set(0, 0), v) v[r2] = 0;
          c.getDelta();
        }
      }) : z.active ? z.update(function(e3, t2, o2) {
        if (n.object.lookAt(t2), n.object.zoom = o2, n.object.updateProjectionMatrix(), e3 >= 1) {
          b.set(0, 0, 0), C.set(0, 0), I = 0, w = 0, N.set(0, 0), D.set(0, 0);
          for (let e4 in v) v[e4] = 0;
          c.getDelta();
        }
      }) : (n.object.getLocalDirection(A), y.setFromVector3(A), y.theta += b.theta * S, y.phi += b.phi * S, y.theta = Math.max(n.minAzimuthAngle, Math.min(n.maxAzimuthAngle, y.theta)), y.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, y.phi)), y.makeSafe(), A.setFromSpherical(y), d.copy(A).add(n.object.position), n.object.lookAtLocal(d), n.object.isPerspectiveCamera ? n.object.position.addScaledVector(A, I) : n.object.isOrthographicCamera && (n.object.zoom *= 1 + 0.15 * I, n.object.updateProjectionMatrix()), h.copy(A).cross(n.object.up).setLength(-N.x), h.add(f.copy(n.object.up).setLength(N.y)), n.object.position.add(h), function() {
        var e3 = c.getDelta();
        for (var t2 in b.set(b.radius, C.y, C.x), C.x = n.enableDamping ? expAverageClamp(C.x, 0, e3, M, 1e-3) : 0, C.y = n.enableDamping ? expAverageClamp(C.y, 0, e3, M, 1e-3) : 0, b.set(b.radius, b.phi - C.y, b.theta - C.x), N.copy(D), D.x = n.enableDamping ? expAverageClamp(D.x, 0, e3, F, 1e-3) : 0, D.y = n.enableDamping ? expAverageClamp(D.y, 0, e3, F, 1e-3) : 0, N.sub(D), N.multiplyScalar(O), I = w, w = n.enableDamping ? expAverageClamp(w, 0, e3, L, 1e-3) : 0, I -= w, I *= R, v) {
          var o2 = t2 == Keys.A || t2 == Keys.LEFT_ARROW || t2 == Keys.D || t2 == Keys.RIGHT_ARROW, r2 = t2 == Keys.W || t2 == Keys.UP_ARROW || t2 == Keys.S || t2 == Keys.DOWN_ARROW, i2 = o2 ? n.panInertia : n.zoomInertia, a2 = o2 ? n.panSpeedKey : n.zoomSpeedKey;
          if (x.isKeyDown[t2]) var s2 = v[t2] = 1;
          else {
            var l2 = v[t2];
            v[t2] = expAverageClamp(v[t2], 0, e3, i2, 1e-3), s2 = l2 - v[t2];
          }
          n.enabled && n.enableKeys && (o2 && !n.enablePan || r2 && !n.enableZoom || (s2 *= 60 * e3 * a2, t2 == Keys.A || t2 == Keys.LEFT_ARROW ? N.x += s2 : t2 == Keys.D || t2 == Keys.RIGHT_ARROW ? N.x -= s2 : t2 == Keys.W || t2 == Keys.UP_ARROW ? I += s2 : t2 != Keys.S && t2 != Keys.DOWN_ARROW || (I -= s2)));
        }
      }());
      var e2 = false;
      m.distanceToSquared(n.object.position) > u && (m.copy(n.object.position), e2 = true), g.dot(n.object.quaternion) < 1 - u && (g.copy(n.object.quaternion), e2 = true), e2 && n.dispatchEvent(k);
    }), this.forceMouseUp = function() {
      J({ preventDefault: function() {
      } });
    }, this.dispose = function() {
      this.domElement.removeEventListener("contextmenu", re), this.domElement.removeEventListener("mousedown", q), this.domElement.removeEventListener("wheel", ee), this.domElement.removeEventListener("touchstart", te2), this.domElement.removeEventListener("touchend", oe), this.domElement.removeEventListener("touchmove", ne), document.removeEventListener("mousemove", Z), document.removeEventListener("mouseup", J), document.removeEventListener("mouseleave", J), x.dispose();
    }, this.tween = (X = new Vector3(), Y = new Vector3(), j = new Vector3(), function(e2, t2, o2, r2, i2) {
      n.object.parent && (e2 = X.copy(e2), n.object.parent.worldToLocal(e2));
      var a2 = n.object.getWorldPosition(Y), s2 = j.subVectors(t2, a2).length(), l2 = n.object.getWorldDirection(j).multiplyScalar(s2).add(a2), c2 = 1e-5;
      e2.manhattanDistanceTo(n.object.position) < c2 && t2.manhattanDistanceTo(l2) < c2 ? void 0 !== r2 && r2() : G.setup({ posFrom: n.object.position, targetFrom: l2, posTo: e2, targetTo: t2, finishCb: r2, movementType: i2 }).start(o2);
    }), this.tweenZoomTo = function() {
      const e2 = new Vector3(), t2 = new Vector3();
      return function(o2, r2, i2, a2) {
        if (!n.object.isOrthographicCamera) return void console.warn("v3d.FlyingControls: .tweenZoomTo() works only for orthographic camera");
        const s2 = n.object.getWorldPosition(e2);
        let l2 = t2.subVectors(o2, s2).length();
        const c2 = n.object.getWorldDirection(t2).multiplyScalar(l2).add(s2);
        z.setup({ zoomFrom: n.object.zoom, targetFrom: c2, zoomTo: r2, targetTo: o2, finishCb: a2 }).start(i2);
      };
    }(), this.domElement.addEventListener("contextmenu", re), this.domElement.addEventListener("mousedown", q), this.domElement.addEventListener("wheel", ee, { passive: false }), this.domElement.addEventListener("touchstart", te2, { passive: true }), this.domElement.addEventListener("touchend", oe), this.domElement.addEventListener("touchmove", ne, { passive: false }), this.handleResize(), this.update();
  }
};
var CONTROLS_DEFAULT_PROPS = { ORBIT: DEFAULTS$2, FIRST_PERSON: DEFAULTS$1, FLYING: DEFAULTS };
var ControlSettings = class {
  constructor(e = "ORBIT", t = true, n = 1, o = 1) {
    this.type = e, this.enablePan = t, this.enableZoom = true, this.enableCtrlZoom = false, this.enableKeys = true, this.rotateSpeed = n, this.moveSpeed = o, this.orbitMinDistance = DEFAULTS$2.minDistance, this.orbitMaxDistance = DEFAULTS$2.maxDistance, this.orbitMinZoom = DEFAULTS$2.minZoom, this.orbitMaxZoom = DEFAULTS$2.maxZoom, this.orbitMinPolarAngle = DEFAULTS$2.minPolarAngle, this.orbitMaxPolarAngle = DEFAULTS$2.maxPolarAngle, this.orbitMinAzimuthAngle = DEFAULTS$2.minAzimuthAngle, this.orbitMaxAzimuthAngle = DEFAULTS$2.maxAzimuthAngle, this.orbitEnableTurnover = DEFAULTS$2.enableTurnover, this.orbitTarget = new Object3D(), this.enableCollisions = DEFAULTS$1.enableCollisions, this.collisionMaterial = null, this.gazeLevel = DEFAULTS$1.gazeLevel, this.storyHeight = DEFAULTS$1.storyHeight, this.enablePointerLock = false;
  }
  copy(e) {
    return this.type = e.type, this.enablePan = e.enablePan, this.enableZoom = e.enableZoom, this.enableCtrlZoom = e.enableCtrlZoom, this.enableKeys = e.enableKeys, this.rotateSpeed = e.rotateSpeed, this.moveSpeed = e.moveSpeed, this.orbitMinDistance = e.orbitMinDistance, this.orbitMaxDistance = e.orbitMaxDistance, this.orbitMinZoom = e.orbitMinZoom, this.orbitMaxZoom = e.orbitMaxZoom, this.orbitMinPolarAngle = e.orbitMinPolarAngle, this.orbitMaxPolarAngle = e.orbitMaxPolarAngle, this.orbitMinAzimuthAngle = e.orbitMinAzimuthAngle, this.orbitMaxAzimuthAngle = e.orbitMaxAzimuthAngle, this.orbitEnableTurnover = e.orbitEnableTurnover, this.orbitTarget = e.orbitTarget, this.enableCollisions = e.enableCollisions, this.collisionMaterial = e.collisionMaterial, this.gazeLevel = e.gazeLevel, this.storyHeight = e.storyHeight, this.enablePointerLock = e.enablePointerLock, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  assignToControls(e, t) {
    const n = CONTROLS_DEFAULT_PROPS[this.type];
    switch (this.type) {
      case "ORBIT":
        e.targetObj = this.orbitTarget, e.minDistance = this.orbitMinDistance, e.maxDistance = this.orbitMaxDistance, e.minZoom = this.orbitMinZoom, e.maxZoom = this.orbitMaxZoom, e.minPolarAngle = this.orbitMinPolarAngle, e.maxPolarAngle = this.orbitMaxPolarAngle, e.minAzimuthAngle = this.orbitMinAzimuthAngle, e.maxAzimuthAngle = this.orbitMaxAzimuthAngle, e.enableTurnover = this.orbitEnableTurnover;
        break;
      case "FLYING":
        e.panSpeedTouch = n.panSpeedTouch * this.moveSpeed, e.zoomSpeedKey = n.zoomSpeedKey * this.moveSpeed;
        break;
      case "FIRST_PERSON":
        e.enableCollisions = this.enableCollisions, e.gazeLevel = this.gazeLevel, e.storyHeight = this.storyHeight, e.zoomSpeedKey = n.zoomSpeedKey * this.moveSpeed, e.enablePointerLock = this.enablePointerLock;
        const o = this;
        e.collisionMeshes = [], t.traverse(function(t2) {
          const n2 = t2.material;
          n2 && o.collisionMaterial && n2.name == o.collisionMaterial.name && e.collisionMeshes.push(t2);
        });
        break;
      default:
        return void console.error("ControlSettings: unsupported control type");
    }
    e.enablePan = this.enablePan, e.enableZoom = this.enableZoom, e.enableCtrlZoom = this.enableCtrlZoom, e.enableKeys = this.enableKeys, e.rotateSpeed = n.rotateSpeed * this.rotateSpeed, e.rotateSpeedTouch = n.rotateSpeedTouch * this.rotateSpeed, e.panSpeed = n.panSpeed * this.moveSpeed, e.panSpeedKey = n.panSpeedKey * this.moveSpeed, e.zoomSpeed = n.zoomSpeed * this.moveSpeed, e.zoomSpeedTouch = n.zoomSpeedTouch * this.moveSpeed;
  }
};
function computeTangents() {
  throw new Error("BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.");
}
function computeMikkTSpaceTangents(e, t, n = true) {
  if (!t || !t.isReady) throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
  if (!e.hasAttribute("position") || !e.hasAttribute("normal") || !e.hasAttribute("uv")) throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
  function o(e2) {
    if (e2.normalized || e2.isInterleavedBufferAttribute) {
      const t2 = new Float32Array(e2.getCount() * e2.itemSize);
      for (let n2 = 0, o2 = 0; n2 < e2.getCount(); n2++) t2[o2++] = e2.getX(n2), t2[o2++] = e2.getY(n2), e2.itemSize > 2 && (t2[o2++] = e2.getZ(n2));
      return t2;
    }
    return e2.array instanceof Float32Array ? e2.array : new Float32Array(e2.array);
  }
  const r = e.index ? e.toNonIndexed() : e, i = t.generateTangents(o(r.attributes.position), o(r.attributes.normal), o(r.attributes.uv));
  if (n) for (let e2 = 3; e2 < i.length; e2 += 4) i[e2] *= -1;
  return r.setAttribute("tangent", new BufferAttribute(i, 4)), e !== r && e.copy(r), e;
}
function mergeBufferGeometries(e, t = false) {
  const n = null !== e[0].index, o = new Set(Object.keys(e[0].attributes)), r = new Set(Object.keys(e[0].morphAttributes)), i = {}, a = {}, s = e[0].morphTargetsRelative, l = new BufferGeometry();
  let c = 0;
  for (let u = 0; u < e.length; ++u) {
    const d = e[u];
    let h = 0;
    if (n !== (null !== d.index)) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + u + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const e2 in d.attributes) {
      if (!o.has(e2)) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + u + '. All geometries must have compatible attributes; make sure "' + e2 + '" attribute exists among all geometries, or in none of them.'), null;
      void 0 === i[e2] && (i[e2] = []), i[e2].push(d.attributes[e2]), h++;
    }
    if (h !== o.size) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + u + ". Make sure all geometries have the same number of attributes."), null;
    if (s !== d.morphTargetsRelative) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + u + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const e2 in d.morphAttributes) {
      if (!r.has(e2)) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + u + ".  .morphAttributes must be consistent throughout all geometries."), null;
      void 0 === a[e2] && (a[e2] = []), a[e2].push(d.morphAttributes[e2]);
    }
    if (t) {
      let e2;
      if (n) e2 = d.index.count;
      else {
        if (void 0 === d.attributes.position) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + u + ". The geometry must have either an index or a position attribute"), null;
        e2 = d.attributes.position.count;
      }
      l.addGroup(c, e2, u), c += e2;
    }
  }
  if (n) {
    let t2 = 0;
    const n2 = [];
    for (let o2 = 0; o2 < e.length; ++o2) {
      const r2 = e[o2].index;
      for (let e2 = 0; e2 < r2.count; ++e2) n2.push(r2.getX(e2) + t2);
      t2 += e[o2].attributes.position.count;
    }
    l.setIndex(n2);
  }
  for (const e2 in i) {
    const t2 = mergeBufferAttributes(i[e2]);
    if (!t2) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + e2 + " attribute."), null;
    l.setAttribute(e2, t2);
  }
  for (const e2 in a) {
    const t2 = a[e2][0].length;
    if (0 === t2) break;
    l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[e2] = [];
    for (let n2 = 0; n2 < t2; ++n2) {
      const t3 = [];
      for (let o3 = 0; o3 < a[e2].length; ++o3) t3.push(a[e2][o3][n2]);
      const o2 = mergeBufferAttributes(t3);
      if (!o2) return console.error("v3d.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + e2 + " morphAttribute."), null;
      l.morphAttributes[e2].push(o2);
    }
  }
  return l;
}
function mergeBufferAttributes(e) {
  let t, n, o, r = 0;
  for (let i2 = 0; i2 < e.length; ++i2) {
    const a2 = e[i2];
    if (a2.isInterleavedBufferAttribute) return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null;
    if (void 0 === t && (t = a2.array.constructor), t !== a2.array.constructor) return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (void 0 === n && (n = a2.itemSize), n !== a2.itemSize) return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (void 0 === o && (o = a2.normalized), o !== a2.normalized) return console.error("v3d.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    r += a2.array.length;
  }
  const i = new t(r);
  let a = 0;
  for (let t2 = 0; t2 < e.length; ++t2) i.set(e[t2].array, a), a += e[t2].array.length;
  return new BufferAttribute(i, n, o);
}
function deepCloneAttribute(e) {
  return e.isInstancedInterleavedBufferAttribute || e.isInterleavedBufferAttribute ? deinterleaveAttribute(e) : e.isInstancedBufferAttribute ? new InstancedBufferAttribute().copy(e) : new BufferAttribute().copy(e);
}
function interleaveAttributes(e) {
  let t, n = 0, o = 0;
  for (let r2 = 0, i2 = e.length; r2 < i2; ++r2) {
    const i3 = e[r2];
    if (void 0 === t && (t = i3.array.constructor), t !== i3.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null;
    n += i3.array.length, o += i3.itemSize;
  }
  const r = new InterleavedBuffer(new t(n), o);
  let i = 0;
  const a = [], s = ["getX", "getY", "getZ", "getW"], l = ["setX", "setY", "setZ", "setW"];
  for (let t2 = 0, n2 = e.length; t2 < n2; t2++) {
    const n3 = e[t2], o2 = n3.itemSize, c = n3.count, u = new InterleavedBufferAttribute(r, o2, i, n3.normalized);
    a.push(u), i += o2;
    for (let e2 = 0; e2 < c; e2++) for (let t3 = 0; t3 < o2; t3++) u[l[t3]](e2, n3[s[t3]](e2));
  }
  return a;
}
function deinterleaveAttribute(e) {
  const t = e.data.array.constructor, n = e.count, o = e.itemSize, r = e.normalized, i = new t(n * o);
  let a;
  a = e.isInstancedInterleavedBufferAttribute ? new InstancedBufferAttribute(i, o, r, e.meshPerAttribute) : new BufferAttribute(i, o, r);
  for (let t2 = 0; t2 < n; t2++) a.setX(t2, e.getX(t2)), o >= 2 && a.setY(t2, e.getY(t2)), o >= 3 && a.setZ(t2, e.getZ(t2)), o >= 4 && a.setW(t2, e.getW(t2));
  return a;
}
function deinterleaveGeometry(e) {
  const t = e.attributes, n = e.morphTargets, o = /* @__PURE__ */ new Map();
  for (const e2 in t) {
    const n2 = t[e2];
    n2.isInterleavedBufferAttribute && (o.has(n2) || o.set(n2, deinterleaveAttribute(n2)), t[e2] = o.get(n2));
  }
  for (const e2 in n) {
    const t2 = n[e2];
    t2.isInterleavedBufferAttribute && (o.has(t2) || o.set(t2, deinterleaveAttribute(t2)), n[e2] = o.get(t2));
  }
}
function estimateBytesUsed(e) {
  let t = 0;
  for (const n2 in e.attributes) {
    const o = e.getAttribute(n2);
    t += o.count * o.itemSize * o.array.BYTES_PER_ELEMENT;
  }
  const n = e.getIndex();
  return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, t;
}
function mergeVertices(e, t = 1e-4) {
  t = Math.max(t, Number.EPSILON);
  const n = {}, o = e.getIndex(), r = e.getAttribute("position"), i = o ? o.count : r.count;
  let a = 0;
  const s = Object.keys(e.attributes), l = {}, c = {}, u = [], d = ["getX", "getY", "getZ", "getW"], h = ["setX", "setY", "setZ", "setW"];
  for (let t2 = 0, n2 = s.length; t2 < n2; t2++) {
    const n3 = s[t2], o2 = e.attributes[n3];
    l[n3] = new BufferAttribute(new o2.array.constructor(o2.count * o2.itemSize), o2.itemSize, o2.normalized);
    const r2 = e.morphAttributes[n3];
    r2 && (c[n3] = new BufferAttribute(new r2.array.constructor(r2.count * r2.itemSize), r2.itemSize, r2.normalized));
  }
  const f = Math.log10(1 / t), p = Math.pow(10, f);
  for (let t2 = 0; t2 < i; t2++) {
    const r2 = o ? o.getX(t2) : t2;
    let i2 = "";
    for (let t3 = 0, n2 = s.length; t3 < n2; t3++) {
      const n3 = s[t3], o2 = e.getAttribute(n3), a2 = o2.itemSize;
      for (let e2 = 0; e2 < a2; e2++) i2 += ~~(o2[d[e2]](r2) * p) + ",";
    }
    if (i2 in n) u.push(n[i2]);
    else {
      for (let t3 = 0, n2 = s.length; t3 < n2; t3++) {
        const n3 = s[t3], o2 = e.getAttribute(n3), i3 = e.morphAttributes[n3], u2 = o2.itemSize, f2 = l[n3], p2 = c[n3];
        for (let e2 = 0; e2 < u2; e2++) {
          const t4 = d[e2], n4 = h[e2];
          if (f2[n4](a, o2[t4](r2)), i3) for (let e3 = 0, o3 = i3.length; e3 < o3; e3++) p2[e3][n4](a, i3[e3][t4](r2));
        }
      }
      n[i2] = a, u.push(a), a++;
    }
  }
  const m = e.clone();
  for (const t2 in e.attributes) {
    const e2 = l[t2];
    if (m.setAttribute(t2, new BufferAttribute(e2.array.slice(0, a * e2.itemSize), e2.itemSize, e2.normalized)), t2 in c) for (let e3 = 0; e3 < c[t2].length; e3++) {
      const n2 = c[t2][e3];
      m.morphAttributes[t2][e3] = new BufferAttribute(n2.array.slice(0, a * n2.itemSize), n2.itemSize, n2.normalized);
    }
  }
  return m.setIndex(u), m;
}
function toTrianglesDrawMode$1(e, t) {
  if (0 === t) return console.warn("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
  if (2 === t || 1 === t) {
    let n = e.getIndex();
    if (null === n) {
      const t2 = [], o2 = e.getAttribute("position");
      if (void 0 === o2) return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
      for (let e2 = 0; e2 < o2.count; e2++) t2.push(e2);
      e.setIndex(t2), n = e.getIndex();
    }
    const o = n.count - 2, r = [];
    if (2 === t) for (let e2 = 1; e2 <= o; e2++) r.push(n.getX(0)), r.push(n.getX(e2)), r.push(n.getX(e2 + 1));
    else for (let e2 = 0; e2 < o; e2++) e2 % 2 == 0 ? (r.push(n.getX(e2)), r.push(n.getX(e2 + 1)), r.push(n.getX(e2 + 2))) : (r.push(n.getX(e2 + 2)), r.push(n.getX(e2 + 1)), r.push(n.getX(e2)));
    r.length / 3 !== o && console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = e.clone();
    return i.setIndex(r), i.clearGroups(), i;
  }
  return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e;
}
function computeMorphedAttributes(e) {
  if (true !== e.geometry.isBufferGeometry) return console.error("v3d.BufferGeometryUtils: Geometry is not of type BufferGeometry."), null;
  const t = new Vector3(), n = new Vector3(), o = new Vector3(), r = new Vector3(), i = new Vector3(), a = new Vector3(), s = new Vector3(), l = new Vector3(), c = new Vector3();
  function u(e2, u2, d2, h2, f2, p2, m2, g2) {
    t.fromBufferAttribute(u2, f2), n.fromBufferAttribute(u2, p2), o.fromBufferAttribute(u2, m2);
    const _2 = e2.morphTargetInfluences;
    if (d2 && _2) {
      s.set(0, 0, 0), l.set(0, 0, 0), c.set(0, 0, 0);
      for (let e3 = 0, u3 = d2.length; e3 < u3; e3++) {
        const u4 = _2[e3], g3 = d2[e3];
        0 !== u4 && (r.fromBufferAttribute(g3, f2), i.fromBufferAttribute(g3, p2), a.fromBufferAttribute(g3, m2), h2 ? (s.addScaledVector(r, u4), l.addScaledVector(i, u4), c.addScaledVector(a, u4)) : (s.addScaledVector(r.sub(t), u4), l.addScaledVector(i.sub(n), u4), c.addScaledVector(a.sub(o), u4)));
      }
      t.add(s), n.add(l), o.add(c);
    }
    e2.isSkinnedMesh && (e2.boneTransform(f2, t), e2.boneTransform(p2, n), e2.boneTransform(m2, o)), g2[3 * f2 + 0] = t.x, g2[3 * f2 + 1] = t.y, g2[3 * f2 + 2] = t.z, g2[3 * p2 + 0] = n.x, g2[3 * p2 + 1] = n.y, g2[3 * p2 + 2] = n.z, g2[3 * m2 + 0] = o.x, g2[3 * m2 + 1] = o.y, g2[3 * m2 + 2] = o.z;
  }
  const d = e.geometry, h = e.material;
  let f, p, m;
  const g = d.index, _ = d.attributes.position, A = d.morphAttributes.position, v = d.morphTargetsRelative, x = d.attributes.normal, y = d.morphAttributes.position, b = d.groups, C = d.drawRange;
  let S, M, E, T, I, w, R;
  const L = new Float32Array(_.count * _.itemSize), B = new Float32Array(x.count * x.itemSize);
  if (null !== g) if (Array.isArray(h)) for (S = 0, E = b.length; S < E; S++) for (I = b[S], w = Math.max(I.start, C.start), R = Math.min(I.start + I.count, C.start + C.count), M = w, T = R; M < T; M += 3) f = g.getX(M), p = g.getX(M + 1), m = g.getX(M + 2), u(e, _, A, v, f, p, m, L), u(e, x, y, v, f, p, m, B);
  else for (w = Math.max(0, C.start), R = Math.min(g.count, C.start + C.count), S = w, E = R; S < E; S += 3) f = g.getX(S), p = g.getX(S + 1), m = g.getX(S + 2), u(e, _, A, v, f, p, m, L), u(e, x, y, v, f, p, m, B);
  else if (Array.isArray(h)) for (S = 0, E = b.length; S < E; S++) for (I = b[S], w = Math.max(I.start, C.start), R = Math.min(I.start + I.count, C.start + C.count), M = w, T = R; M < T; M += 3) f = M, p = M + 1, m = M + 2, u(e, _, A, v, f, p, m, L), u(e, x, y, v, f, p, m, B);
  else for (w = Math.max(0, C.start), R = Math.min(_.count, C.start + C.count), S = w, E = R; S < E; S += 3) f = S, p = S + 1, m = S + 2, u(e, _, A, v, f, p, m, L), u(e, x, y, v, f, p, m, B);
  return { positionAttribute: _, normalAttribute: x, morphedPositionAttribute: new Float32BufferAttribute(L, 3), morphedNormalAttribute: new Float32BufferAttribute(B, 3) };
}
function mergeGroups(e) {
  if (0 === e.groups.length) return console.warn("v3d.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), e;
  let t = e.groups;
  if (t = t.sort((e2, t2) => e2.materialIndex !== t2.materialIndex ? e2.materialIndex - t2.materialIndex : e2.start - t2.start), null === e.getIndex()) {
    const t2 = e.getAttribute("position"), n2 = [];
    for (let e2 = 0; e2 < t2.count; e2 += 3) n2.push(e2, e2 + 1, e2 + 2);
    e.setIndex(n2);
  }
  const n = e.getIndex(), o = [];
  for (let e2 = 0; e2 < t.length; e2++) {
    const r2 = t[e2], i2 = r2.start, a = i2 + r2.count;
    for (let e3 = i2; e3 < a; e3++) o.push(n.getX(e3));
  }
  e.dispose(), e.setIndex(o);
  let r = 0;
  for (let e2 = 0; e2 < t.length; e2++) {
    const n2 = t[e2];
    n2.start = r, r += n2.count;
  }
  let i = t[0];
  e.groups = [i];
  for (let n2 = 1; n2 < t.length; n2++) {
    const o2 = t[n2];
    i.materialIndex === o2.materialIndex ? i.count += o2.count : (i = o2, e.groups.push(i));
  }
  return e;
}
function toCreasedNormals(e, t = Math.PI / 3) {
  const n = Math.cos(t), o = 100 * (1 + 1e-10), r = [new Vector3(), new Vector3(), new Vector3()], i = new Vector3(), a = new Vector3(), s = new Vector3(), l = new Vector3();
  function c(e2) {
    return `${~~(e2.x * o)},${~~(e2.y * o)},${~~(e2.z * o)}`;
  }
  const u = e.toNonIndexed(), d = u.attributes.position, h = {};
  for (let e2 = 0, t2 = d.count / 3; e2 < t2; e2++) {
    const t3 = 3 * e2, n2 = r[0].fromBufferAttribute(d, t3 + 0), o2 = r[1].fromBufferAttribute(d, t3 + 1), s2 = r[2].fromBufferAttribute(d, t3 + 2);
    i.subVectors(s2, o2), a.subVectors(n2, o2);
    const l2 = new Vector3().crossVectors(i, a).normalize();
    for (let e3 = 0; e3 < 3; e3++) {
      const t4 = c(r[e3]);
      t4 in h || (h[t4] = []), h[t4].push(l2);
    }
  }
  const f = new Float32Array(3 * d.count), p = new BufferAttribute(f, 3, false);
  for (let e2 = 0, t2 = d.count / 3; e2 < t2; e2++) {
    const t3 = 3 * e2, o2 = r[0].fromBufferAttribute(d, t3 + 0), u2 = r[1].fromBufferAttribute(d, t3 + 1), f2 = r[2].fromBufferAttribute(d, t3 + 2);
    i.subVectors(f2, u2), a.subVectors(o2, u2), s.crossVectors(i, a).normalize();
    for (let e3 = 0; e3 < 3; e3++) {
      const o3 = h[c(r[e3])];
      l.set(0, 0, 0);
      for (let e4 = 0, t4 = o3.length; e4 < t4; e4++) {
        const t5 = o3[e4];
        s.dot(t5) > n && l.add(t5);
      }
      l.normalize(), p.setXYZ(t3 + e3, l.x, l.y, l.z);
    }
  }
  return u.setAttribute("normal", p), u;
}
function batchMeshes(e, t) {
  const n = {};
  for (let t2 = 0; t2 < e.length; t2++) {
    const o = e[t2], r = o.geometry, i = o.material;
    let a = [];
    a.push(i.name), a.push(o.visible), a.push(o.disableChildRendering), a.push(o.castShadow), a.push(o.receiveShadow), a.push(o.renderOrder), a = a.concat(o.groupNames);
    const s = Object.keys(r.attributes);
    a = a.concat(s);
    const l = Object.keys(r.morphAttributes);
    a = a.concat(l), a = a.join(), n[a] = n[a] || [], -1 == n[a].indexOf(o) && n[a].push(o);
  }
  for (let e2 in n) {
    const o = n[e2];
    if (o.length < 2) continue;
    const r = [];
    let i = true;
    for (let e3 = 0; e3 < o.length; e3++) {
      const t2 = o[e3], n2 = t2.geometry;
      t2.updateWorldMatrix(true, false), r.push(n2.clone().applyMatrix4(t2.matrixWorld)), n2.boundsTree || (i = false);
    }
    const a = o[0], s = a.material, l = `${s.name}_x${o.length}_batch`, c = this.mergeBufferGeometries(r);
    if (c) {
      const e3 = new Mesh(c, s);
      e3.name = l, e3.visible = a.visible, e3.disableChildRendering = a.disableChildRendering, e3.castShadow = a.castShadow, e3.receiveShadow = a.receiveShadow, e3.renderOrder = a.renderOrder, e3.groupNames = a.groupNames;
      for (let e4 = 0; e4 < o.length; e4++) {
        const t2 = o[e4];
        t2.parent.remove(t2);
      }
      i && c.computeBoundsTree({ verbose: false }), console.log("Adding batch object:", l), t.add(e3);
    } else console.warn("Failed to create batch object:", l);
  }
}
var BufferGeometryUtils = Object.freeze({ __proto__: null, batchMeshes, computeMikkTSpaceTangents, computeMorphedAttributes, computeTangents, deepCloneAttribute, deinterleaveAttribute, deinterleaveGeometry, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeGroups, mergeVertices, toCreasedNormals, toTrianglesDrawMode: toTrianglesDrawMode$1 });
var STD_TEX_PROPERTY_NAMES = ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "envMap", "lightMap", "map", "metalnessMap", "normalMap", "roughnessMap", "specularMap"];
function replaceTexture(e, t, n) {
  switch (e.type) {
    case "MeshNodeMaterial":
      e.traverseNodes((e2) => {
        e2.originData.texture === t && (e2.originData.texture = n);
      });
      for (const o in e.nodeTextures) e.nodeTextures[o] === t && (e.nodeTextures[o] = n);
      break;
    case "MeshStandardMaterial":
      STD_TEX_PROPERTY_NAMES.forEach((o) => {
        e[o] === t && (e[o] = n);
      });
      break;
    default:
      return void console.error("replaceTexture: Unsupported material type " + e.type);
  }
  n.encoding = t.encoding, n.wrapS = t.wrapS, n.wrapT = t.wrapT;
}
function disposeTextures(e) {
  if (STD_TEX_PROPERTY_NAMES.forEach(function(t) {
    e[t] && e[t].isTexture && e[t].dispose();
  }), "MeshNodeMaterial" == e.type) for (const t in e.nodeTextures) e.nodeTextures[t] && e.nodeTextures[t].dispose();
}
function createEnvironmentMaterial(e, t, n) {
  const o = new DiGraph(), r = {};
  if (o.addNode(createNode("LIGHT_PATH_BL", "Light Path")), o.addNode(createNode("TEX_ENVIRONMENT_BL", "Lighting Texture", { texture: t })), r[nodeTexUniName("TEX_ENVIRONMENT_BL", 0)] = t, n instanceof Color) {
    const e2 = n.toArray([0, 0, 0, 1]);
    o.addNode(createNode("RGB_BL", "Background Color", { outputs: [e2] }));
  } else o.addNode(createNode("TEX_ENVIRONMENT_BL", "Background  Texture", { texture: n })), r[nodeTexUniName("TEX_ENVIRONMENT_BL", 1)] = n;
  return o.addNode(createNode("MIX_BL", "Mix")), connectNodes(o, 0, N_OUT.LIGHT_PATH_BL.isCameraRay, 3, N_IN.MIX_BL.fac), connectNodes(o, 1, N_OUT.TEX_ENVIRONMENT_BL.color, 3, N_IN.MIX_BL.col1), connectNodes(o, 2, N_OUT[getNodeType(o.node(2))].color, 3, N_IN.MIX_BL.col2), o.addNode(createNode("BACKGROUND_BL", "Background")), connectNodes(o, 3, N_OUT.MIX_BL.col, 4, N_IN.BACKGROUND_BL.color), o.addNode(createNode("OUTPUT_WORLD_BL", "Output")), connectNodes(o, 4, N_OUT.BACKGROUND_BL.color, 5, N_IN.OUTPUT_WORLD_BL.surface), new MeshNodeMaterial({ name: e, nodeGraph: o, nodeTextures: r });
}
function createDiffuseMaterial(e, t, n, o = "blender") {
  let r = new DiGraph();
  switch (o) {
    case "blender":
      if (n < 1) {
        r.addNode(createNode("BSDF_TRANSPARENT_BL", "Transparent"));
        const e3 = createNode("DIFFUSE_BSDF_BL", "Diffuse");
        t.toArray(e3.originData.inputs[N_IN.DIFFUSE_BSDF_BL.color]), r.addNode(e3);
        const o2 = createNode("MIX_SHADER_BL", "Mix");
        o2.originData.inputs[N_IN.MIX_SHADER_BL.fac] = n, r.addNode(o2), connectNodes(r, 0, N_OUT.BSDF_TRANSPARENT_BL.color, 2, N_IN.MIX_SHADER_BL.color1), connectNodes(r, 1, N_OUT.DIFFUSE_BSDF_BL.color, 2, N_IN.MIX_SHADER_BL.color2);
      } else {
        const e3 = createNode("DIFFUSE_BSDF_BL", "Diffuse");
        t.toArray(e3.originData.inputs[N_IN.DIFFUSE_BSDF_BL.color]), r.addNode(e3);
      }
      r.addNode(createNode("OUTPUT_MATERIAL_BL", "Output")), connectNodes(r, r.len() - 2, N_OUT[getNodeType(r.node(r.len() - 2))].color, r.len() - 1, N_IN.OUTPUT_MATERIAL_BL.surface);
      break;
    case "max":
      const e2 = createNode("LAMBERT_AR", "Diffuse");
      e2.originData.inputs[N_IN.LAMBERT_AR.base] = 1, t.toArray(e2.originData.inputs[N_IN.LAMBERT_AR.baseColor]), e2.originData.inputs[N_IN.LAMBERT_AR.opacity][0] = n, e2.originData.inputs[N_IN.LAMBERT_AR.opacity][1] = n, e2.originData.inputs[N_IN.LAMBERT_AR.opacity][2] = n, r.addNode(e2), r.addNode(createNode("OUTPUT_MX", "Output")), connectNodes(r, 0, N_OUT.LAMBERT_AR.color, 1, N_IN.OUTPUT_MX.color);
      break;
    case "maya":
      const i = createNode("LAMBERT_MY", "Diffuse");
      t.toArray(i.originData.inputs[N_IN.LAMBERT_MY.color]), i.originData.inputs[N_IN.LAMBERT_MY.diffuse] = 1, i.originData.inputs[N_IN.LAMBERT_MY.transparency][0] = 1 - n, i.originData.inputs[N_IN.LAMBERT_MY.transparency][1] = 1 - n, i.originData.inputs[N_IN.LAMBERT_MY.transparency][2] = 1 - n, r.addNode(i), r.addNode(createNode("SHADING_ENGINE_MY", "Output")), connectNodes(r, 0, N_OUT.LAMBERT_MY.color, 1, N_IN.SHADING_ENGINE_MY.surface);
      break;
    default:
      console.error("createDiffuseMaterial: Incorrect material profile - " + o), r = null;
  }
  return new MeshNodeMaterial({ name: e, nodeGraph: r, profile: o });
}
function createStandardPBRMaterial(e = "blender", t = {}) {
  let n = new DiGraph(), o = t.color ?? "white", r = t.emissive ?? "black";
  const i = t.opacity ?? 1, a = t.metalness ?? 0, s = t.roughness ?? 1, l = t.emissiveIntensity ?? 1;
  let c, u;
  switch (o instanceof Color || (o = new Color(o)), r instanceof Color || (r = new Color(r)), e) {
    case "blender":
      c = createNode("RGB_BL", "color"), o.toArray(c.originData.outputs[N_OUT.RGB_BL.color]), n.addNode(c), u = createNode("RGB_BL", "emissive"), r.toArray(u.originData.outputs[N_OUT.RGB_BL.color]), n.addNode(u), n.addNode(createNode("VALUE_BL", "opacity", { outputs: [i] })), n.addNode(createNode("VALUE_BL", "metalness", { outputs: [a] })), n.addNode(createNode("VALUE_BL", "roughness", { outputs: [s] })), n.addNode(createNode("VALUE_BL", "emissiveIntensity", { outputs: [l] })), n.addNode(createNode("BSDF_PRINCIPLED_BL", "Shader")), connectNodes(n, 0, N_OUT.RGB_BL.color, 6, N_IN.BSDF_PRINCIPLED_BL.baseColor), connectNodes(n, 1, N_OUT.RGB_BL.color, 6, N_IN.BSDF_PRINCIPLED_BL.emission), connectNodes(n, 2, N_OUT.VALUE_BL.value, 6, N_IN.BSDF_PRINCIPLED_BL.alpha), connectNodes(n, 3, N_OUT.VALUE_BL.value, 6, N_IN.BSDF_PRINCIPLED_BL.metallic), connectNodes(n, 4, N_OUT.VALUE_BL.value, 6, N_IN.BSDF_PRINCIPLED_BL.roughness), connectNodes(n, 5, N_OUT.VALUE_BL.value, 6, N_IN.BSDF_PRINCIPLED_BL.emissionStrength), n.addNode(createNode("OUTPUT_MATERIAL_BL", "Output")), connectNodes(n, 6, N_OUT.BSDF_PRINCIPLED_BL.color, 7, N_IN.OUTPUT_MATERIAL_BL.surface);
      break;
    case "max":
      c = createNode("RGB_MX", "color"), o.toArray(c.originData.outputs[N_OUT.RGB_MX.color]), n.addNode(c), u = createNode("RGB_MX", "emissive"), r.toArray(u.originData.outputs[N_OUT.RGB_BL.color]), n.addNode(u), n.addNode(createNode("VALUE_MX", "opacity", { outputs: [i] })), n.addNode(createNode("VALUE_MX", "metalness", { outputs: [a] })), n.addNode(createNode("VALUE_MX", "roughness", { outputs: [s] })), n.addNode(createNode("VALUE_MX", "emissiveIntensity", { outputs: [l] })), n.addNode(createNode("PHYSICAL_MX", "Shader")), connectNodes(n, 0, N_OUT.RGB_MX.color, 6, N_IN.PHYSICAL_MX.baseColor), connectNodes(n, 1, N_OUT.RGB_MX.color, 6, N_IN.PHYSICAL_MX.emitColor), connectNodes(n, 2, N_OUT.VALUE_BL.value, 6, N_IN.PHYSICAL_MX.opacity), connectNodes(n, 3, N_OUT.VALUE_MX.value, 6, N_IN.PHYSICAL_MX.metalness), connectNodes(n, 4, N_OUT.VALUE_MX.value, 6, N_IN.PHYSICAL_MX.roughness), connectNodes(n, 5, N_OUT.VALUE_MX.value, 6, N_IN.PHYSICAL_MX.emission), n.addNode(createNode("OUTPUT_MX", "Output")), connectNodes(n, 6, N_OUT.PHYSICAL_MX.color, 7, N_IN.OUTPUT_MX.color);
      break;
    case "maya":
      c = createNode("COLOR_CONSTANT_MY", "color"), o.toArray(c.originData.inputs[N_IN.COLOR_CONSTANT_MY.color]), o.toArray(c.originData.outputs[N_IN.COLOR_CONSTANT_MY.color]), n.addNode(c), u = createNode("COLOR_CONSTANT_MY", "emissive"), r.toArray(u.originData.inputs[N_IN.COLOR_CONSTANT_MY.color]), r.toArray(u.originData.outputs[N_IN.COLOR_CONSTANT_MY.color]), n.addNode(u), n.addNode(createNode("FLOAT_CONSTANT_MY", "opacity", { outputs: [i] })), n.addNode(createNode("FLOAT_CONSTANT_MY", "metalness", { outputs: [a] })), n.addNode(createNode("FLOAT_CONSTANT_MY", "roughness", { outputs: [s] })), n.addNode(createNode("FLOAT_CONSTANT_MY", "emissiveIntensity", { outputs: [l] })), n.addNode(createNode("STANDARD_SURFACE_AR", "Shader")), connectNodes(n, 0, N_OUT.COLOR_CONSTANT_MY.color, 6, N_IN.STANDARD_SURFACE_AR.baseColor), connectNodes(n, 1, N_OUT.COLOR_CONSTANT_MY.color, 6, N_IN.STANDARD_SURFACE_AR.emissionColor), connectNodes(n, 2, N_OUT.FLOAT_CONSTANT_MY.value, 6, N_IN.STANDARD_SURFACE_AR.opacity), connectNodes(n, 3, N_OUT.FLOAT_CONSTANT_MY.value, 6, N_IN.STANDARD_SURFACE_AR.metalness), connectNodes(n, 4, N_OUT.FLOAT_CONSTANT_MY.value, 6, N_IN.STANDARD_SURFACE_AR.specularRoughness), connectNodes(n, 5, N_OUT.FLOAT_CONSTANT_MY.value, 6, N_IN.STANDARD_SURFACE_AR.emission), n.addNode(createNode("SHADING_ENGINE_MY", "Output")), connectNodes(n, 6, N_OUT.STANDARD_SURFACE_AR.color, 7, N_IN.SHADING_ENGINE_MY.surface);
      break;
    default:
      console.error("createStandardPBRMaterial: Incorrect material profile - " + e), n = null;
  }
  return new MeshNodeMaterial({ name: name ?? "", nodeGraph: n, profile: e });
}
var MaterialUtils = Object.freeze({ __proto__: null, createDiffuseMaterial, createEnvironmentMaterial, createStandardPBRMaterial, disposeTextures, replaceTexture });
var _color = new Color();
var _matrix = new Matrix4();
function createMeshesFromInstancedMesh(e) {
  const t = new Group(), n = e.count, o = e.geometry, r = e.material;
  for (let i = 0; i < n; i++) {
    const n2 = new Mesh(o, r);
    e.getMatrixAt(i, n2.matrix), n2.matrix.decompose(n2.position, n2.quaternion, n2.scale), t.add(n2);
  }
  return t.copy(e), t.updateWorldMatrix(false, true), t;
}
function createMeshesFromMultiMaterialMesh(e) {
  if (false === Array.isArray(e.material)) return console.warn("v3d.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials."), e;
  const t = new Group();
  t.copy(e);
  const n = mergeGroups(e.geometry), o = n.index, r = n.groups, i = Object.keys(n.attributes);
  for (let a = 0; a < r.length; a++) {
    const s = r[a], l = s.start, c = l + s.count, u = new BufferGeometry(), d = e.material[s.materialIndex];
    for (let e2 = 0; e2 < i.length; e2++) {
      const t2 = i[e2], r2 = n.attributes[t2], a2 = r2.itemSize, d2 = s.count * a2, h2 = new (0, r2.array.constructor)(d2), f = new BufferAttribute(h2, a2);
      for (let e3 = l, t3 = 0; e3 < c; e3++, t3++) {
        const n2 = o.getX(e3);
        a2 >= 1 && f.setX(t3, r2.getX(n2)), a2 >= 2 && f.setY(t3, r2.getY(n2)), a2 >= 3 && f.setZ(t3, r2.getZ(n2)), a2 >= 4 && f.setW(t3, r2.getW(n2));
      }
      u.setAttribute(t2, f);
    }
    const h = new Mesh(u, d);
    t.add(h);
  }
  return t;
}
function createMultiMaterialObject(e, t) {
  const n = new Group();
  for (let o = 0, r = t.length; o < r; o++) n.add(new Mesh(e, t[o]));
  return n;
}
function reduceVertices(e, t, n) {
  let o = n;
  const r = new Vector3();
  return e.updateWorldMatrix(true, true), e.traverseVisible((e2) => {
    const { geometry: n2 } = e2;
    if (void 0 !== n2) {
      const { position: i } = n2.attributes;
      if (void 0 !== i) for (let n3 = 0, a = i.count; n3 < a; n3++) e2.isMesh ? e2.getVertexPosition(n3, r) : r.fromBufferAttribute(i, n3), e2.isSkinnedMesh || r.applyMatrix4(e2.matrixWorld), o = t(o, r);
    }
  }), o;
}
function sortInstancedMesh(e, t) {
  const n = deepCloneAttribute(e.instanceMatrix), o = e.instanceColor ? deepCloneAttribute(e.instanceColor) : null, r = /* @__PURE__ */ new Map();
  for (const t2 in e.geometry.attributes) {
    const n2 = e.geometry.attributes[t2];
    n2.isInstancedBufferAttribute && r.set(n2, deepCloneAttribute(n2));
  }
  const i = [];
  for (let t2 = 0; t2 < e.count; t2++) i.push(t2);
  i.sort(t);
  for (let t2 = 0; t2 < i.length; t2++) {
    const a = i[t2];
    _matrix.fromArray(n.array, a * e.instanceMatrix.itemSize), _matrix.toArray(e.instanceMatrix.array, t2 * e.instanceMatrix.itemSize), e.instanceColor && (_color.fromArray(o.array, a * e.instanceColor.itemSize), _color.toArray(e.instanceColor.array, t2 * e.instanceColor.itemSize));
    for (const n2 in e.geometry.attributes) {
      const o2 = e.geometry.attributes[n2];
      if (o2.isInstancedBufferAttribute) {
        const e2 = r.get(o2);
        o2.setX(t2, e2.getX(a)), o2.itemSize > 1 && o2.setY(t2, e2.getY(a)), o2.itemSize > 2 && o2.setZ(t2, e2.getZ(a)), o2.itemSize > 3 && o2.setW(t2, e2.getW(a));
      }
    }
  }
}
function getMaterialByName(e, t) {
  if (checkUUID(t)) return getMaterialByUUID(e, t);
  const n = this.getMaterialsByName(e, t);
  return n.length ? n[0] : null;
}
function getMaterialsByName(e, t) {
  if (checkUUID(t)) {
    const n2 = getMaterialByUUID(e, t);
    return n2 ? [n2] : [];
  }
  const n = [];
  if (null !== e.scene) {
    e.scene.traverse(function(e2) {
      e2.material && e2.material.name === t && -1 === n.indexOf(e2.material) && n.push(e2.material);
    });
    const o = e.scene.worldMaterial;
    null !== o && o.name === t && -1 === n.indexOf(o) && n.push(o);
  }
  return n;
}
function getMaterialByUUID(e, t) {
  let n = null;
  if (null !== e.scene) {
    e.scene.traverse((e2) => {
      e2.material && e2.material.uuid === t && (n = e2.material);
    });
    const o = e.scene.worldMaterial;
    null !== o && o.uuid === t && (n = o);
  }
  return n;
}
function getAllMaterials(e) {
  const t = [];
  if (null !== e.scene) {
    e.scene.traverse((e2) => {
      e2.material && !t.includes(e2.material) && t.push(e2.material);
    });
    const n = e.scene.worldMaterial;
    null === n || t.includes(n) || t.push(n);
  }
  return t;
}
function getAnimationActionByName(e, t) {
  for (let n = 0; n < e.actions.length; n++) {
    const o = e.actions[n];
    if (o.getClip().name == t) return o;
  }
  return null;
}
function checkActionIsUsed(e, t) {
  return Boolean(t._propertyBindings.find(function(t2) {
    const n = t2.binding.node;
    return n && n.findRoot() === e;
  }));
}
function calcSceneBox(e) {
  const t = new Box3();
  return t.expandByObject(e), t;
}
function createDefaultCamera(e, t) {
  const n = new Vector3(), o = 2 * e.getSize(n).length(), r = new PerspectiveCamera(45, t, o / 1e4, o);
  return r.position.copy(e.max).multiplyScalar(2), r.lookAt(e.getCenter(n)), r;
}
function assignDefaultControls(e, t) {
  const n = new Object3D();
  t.getCenter(n.position), e.controlSettings = new ControlSettings(), e.controlSettings.orbitMinDistance = e.near, e.controlSettings.orbitMaxDistance = e.far, e.controlSettings.orbitTarget = n;
}
var SceneUtils = Object.freeze({ __proto__: null, assignDefaultControls, calcSceneBox, checkActionIsUsed, createDefaultCamera, createEnvironmentMaterial, createMeshesFromInstancedMesh, createMeshesFromMultiMaterialMesh, createMultiMaterialObject, getAllMaterials, getAnimationActionByName, getMaterialByName, getMaterialByUUID, getMaterialsByName, reduceVertices, sortInstancedMesh });
var WM_TEXT = "MADE WITH VERGE3D TRIAL";
var PP_PASSES = { Afterimage: AfterimagePass, Bloom: BloomPass, Bokeh: BokehPass, "Brightness/Contrast": BrightnessContrastPass, FXAA: FXAAPass, Grayscale: GrayscalePass, Mask: MaskPass, Outline: OutlinePass, Render: RenderPass, SSAA: SSAARenderPass, SSR: SSRPass, ToneMapping: ToneMapPass, "Copy/Other": ShaderPass };
var TEX_FORMAT_STRINGS = { [RGBAFormat]: "RGBA", [DepthFormat]: "DEPTH", [RGBA_BPTC_Format]: "RGBA_BPTC", [RGBA_ASTC_4x4_Format]: "RGBA_ASTC_4x4", [RGB_S3TC_DXT1_Format]: "RGB_S3TC_DXT1", [RGBA_S3TC_DXT5_Format]: "RGBA_S3TC_DXT5", [RGB_PVRTC_4BPPV1_Format]: "RGB_PVRTC_4BPPV1", [RGBA_PVRTC_4BPPV1_Format]: "RGBA_PVRTC_4BPPV1", [RGB_ETC1_Format]: "RGB_ETC1", [RGB_ETC2_Format]: "RGB_ETC2", [RGBA_ETC2_EAC_Format]: "RGB_ETC2_EAC" };
var AppUtils = class _AppUtils {
  static getPageParams(e) {
    let t = (e = e || window).location.href.toString();
    const n = {};
    if (-1 == t.indexOf("?")) return n;
    const o = t.split("#")[0].split("?")[1].split("&");
    for (let e2 = 0; e2 < o.length; e2++) {
      const t2 = o[e2].split("="), r = decodeURIComponent(t2[0]);
      1 == t2.length ? n[r] = "" : n[r] = decodeURIComponent(t2[1]);
    }
    return n;
  }
  static updatePageParam(e, t, n) {
    let o, r, i = null, a = "", s = e.split("?"), l = s[0], c = s[1], u = "";
    if (c) {
      o = c.split("#"), r = o[0], i = o[1], i && (c = r), s = c.split("&");
      for (let e2 = 0; e2 < s.length; e2++) s[e2].split("=")[0] != t && (a += u + s[e2], u = "&");
    } else o = l.split("#"), r = o[0], i = o[1], r && (l = r);
    i && (n += "#" + i);
    return l + "?" + a + (u + "" + t + "=" + n);
  }
  static loadScript(e, t, n, o) {
    function r(e2) {
      a.removeEventListener("load", r, false), a.removeEventListener("error", i, false), t.removeChild(a), n(e2);
    }
    function i(e2) {
      a.removeEventListener("load", r, false), a.removeEventListener("error", i, false), t.removeChild(a), o(e2);
    }
    const a = document.createElement("script");
    a.addEventListener("load", r, false), a.addEventListener("error", i, false), t.appendChild(a), a.src = e;
  }
  static drawWatermark(e) {
    setTimeout(function() {
      "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "4.9.2", v3dl: V3DL } }));
    }, 0);
    const t = e.container;
    if (3483952072 != hashString(V3DL)) return;
    const n = ["color: #fff;", "opacity: 0.5;", "font-size: 18px;", "font-family: sans-serif;", "text-align: center;", "text-decoration: none;", "position: absolute;", "bottom: 1%;", "right: 1%;", "user-select: none;", "z-index: 9999;", "text-shadow: 1px 1px #000;"].join("\n"), o = document.createElement("div");
    o.innerHTML = `<a href="https://www.soft8soft.com/verge3d-trial/" target="_blank" style="${n}">${WM_TEXT}</a>`, t.appendChild(o), setTimeout(function() {
      t.contains(o) && 890310108 == hashString(o.textContent) || e.dispose();
    }, 1e3);
  }
  static isXML(e) {
    return null !== e.match(/.*\.xml$/);
  }
  static isJS(e) {
    return null !== e.match(/.*\.js$/);
  }
  static addToAppList(e) {
    const t = getGlobalScope();
    t.v3d && (t.v3d.apps = t.v3d.apps || [], -1 == t.v3d.apps.indexOf(e) && t.v3d.apps.push(e));
  }
  static removeFromAppList(e) {
    const t = getGlobalScope();
    if (t.v3d && t.v3d.apps) {
      const n = t.v3d.apps.indexOf(e);
      n > -1 && t.v3d.apps.splice(n, 1);
    }
  }
  static printPerformanceInfo(e, t) {
    t = t || 1;
    const n = e.renderer.info;
    n.reset();
    const o = e.frame;
    for (let e2 = 0; e2 < n.programs.length; e2++) n.programs[e2].profile.calcRenderTime = true;
    let r;
    function i(e2, t2) {
      r == e2 && (e2 += " "), r = e2, t2 ? console.log("%c" + e2, "color:red") : console.log(e2);
    }
    setTimeout(function() {
      if (i("--- Verge3D Performance Profile (" + t + "s) ---"), !e.scene) return void i("Scene not loaded");
      const r2 = e.frame - o, a = Math.round(e._loadingTime);
      i(`Scene Loading Time: ${a}ms`, a > 1e4);
      const s = -1 != e._loadSceneURL.indexOf(".xz", e._loadSceneURL.length - 3);
      i("Asset Compression: " + (s ? "yes" : "no"), 0 == s);
      const l = Math.round(n.numShaderCompiles);
      i(`Shader Compilations: ${l}`, l > 100);
      const c = r2 / t;
      i("FPS: " + c, c < 30);
      const u = Math.round(n.render.calls / r2);
      i("Render Calls: " + u, u > 1e3);
      const d = Math.round(n.render.triangles / r2);
      i("Triangles Rendered: " + d, d > 1e6), i("Geometry Buffers: " + n.memory.geometries, n.memory.geometries > 200), i("HDR Rendering: " + (e.useHDR ? "yes" : "no")), i("Order-Independent Transparency: " + (e.renderer.useOIT ? "yes" : "no"));
      const h = e.renderer.getDrawingBufferSize(new Vector2());
      i("Viewport Resolution: " + h.x + "x" + h.y), i(`Pixel Ratio: ${e.renderer.getPixelRatio()} (current) / ${window.devicePixelRatio} (device)`);
      let f = "N/A";
      switch (e._envIBLMode) {
        case 0:
          f = "PMREM", f += ` ${e._pmremMaxTileSize} px`;
          break;
        case 1:
          f = "Light Probe", f += ` ${e._pmremMaxTileSize} px`;
      }
      i(`Image-Based Lighting: ${f}`);
      let p = 0, m = 0, g = 0, _ = 0, A = 0, v = 0;
      e.scene.traverse(function(e2) {
        e2.isLight && (p++, e2.castShadow && e2.shadow && (_++, A = e2.shadow.mapSize.width, v = e2.shadow.mapSize.height)), e2.isCubeReflectionProbe && m++, e2.isPlaneReflectionProbe && g++;
      }), i("Lights: " + p, p > 10), i(`Reflection Probes: ${m} (cube) / ${g} (plane) `, m > 3 || g > 1);
      const x = [];
      if (e.postprocessing) {
        e.postprocessing.gtaoGenerator && x.push("GTAO");
        e.postprocessing.composer.passes.forEach(function(e2) {
          for (let t2 in PP_PASSES) if (e2 instanceof PP_PASSES[t2]) return void x.push(t2);
          x.push("Undefined");
        });
      }
      i(`Post-Processing: ${x.length ? x.join(",") : "N/A"}`);
      let y = "N/A";
      if (_ && e.renderer.shadowMap && e.renderer.shadowMap.enabled) {
        switch (e.renderer.shadowMap.type) {
          case 0:
            y = "Basic";
            break;
          case 1:
            y = "Bilinear";
            break;
          case 2:
            y = "PCF";
            break;
          case 3:
            y = "ESM";
            break;
          default:
            y = "Unknown";
        }
        y += ` ${A}x${v}x${_}`;
      }
      i("Shadow Map: " + y, _ > 4 || A > 2048 || v > 2048);
      const b = n.programs.slice(0);
      i("Materials and Shaders: " + b.length, b > 100), b.sort(function(e2, t2) {
        return t2.profile.renderTime - e2.profile.renderTime;
      });
      let C = 0;
      for (let e2 = 0; e2 < b.length; e2++) {
        const t2 = b[e2];
        t2.profile.calcRenderTime = false;
        const n2 = t2.profile.materials, o2 = t2.profile.renderTime / r2;
        let a2;
        a2 = o2 >= 0.1 ? String(Math.round(10 * o2) / 10) + "ms" : o2 > 0 && o2 < 0.1 ? String(Math.round(1e3 * o2) / 1e3) + "ms" : "N/R", i("    " + (0 == n2.size ? "System Material" : Array.from(n2).join(",")) + " - " + t2.name + " - " + a2, o2 > 16), C += o2, t2.profile.renderTime = 0;
      }
      i("Total Render Time: " + String(Math.round(10 * C) / 10) + "ms", C > 16), i("Textures & Render Buffers: " + n.memory.textures, n.memory.textures > 100);
      const S = Array.from(n.memory.textureSpecs.values());
      S.sort(function(e2, t2) {
        return e2.type < t2.type ? 1 : e2.type > t2.type ? -1 : e2.width != t2.width ? t2.width - e2.width : t2.height - e2.height;
      });
      for (let e2 = 0; e2 < S.length; e2++) {
        const t2 = S[e2], n2 = "Texture" == t2.type ? "- " + TEX_FORMAT_STRINGS[t2.format] : "", o2 = t2.isCube ? "x6" : "";
        i(`    ${t2.name || "N/A"} - ${t2.type} - ${t2.width}x${t2.height}${o2} ${n2}`, t2.width >= 4096 || t2.height >= 4096);
      }
      if (n.render.customCounter) {
        const e2 = n.render.customCounter / r2;
        i(`Custom Counter: ${Math.round(10 * e2) / 10} iter/frame`);
      }
    }, 1e3 * t);
  }
  static printMaterialsStats(e) {
    const t = getAllMaterials(e).filter((e2) => "MeshNodeMaterial" == e2.type), n = /* @__PURE__ */ new Map();
    t.forEach((e2) => {
      e2.traverseNodes((e3) => {
        const t2 = e3.originData.type;
        n.has(t2) || n.set(t2, 0), n.set(t2, n.get(t2) + 1);
      });
    });
    const o = Array.from(n);
    o.sort((e2, t2) => t2[1] - e2[1]), console.log("Total Node Materials:", t.length);
    const r = e.renderer.info.programs.filter((e2) => "MeshNodeMaterial" == e2.name);
    console.log("Total Node Shaders:", r.length), console.log("Node Stats:"), o.forEach((e2) => {
      console.log(`    ${e2[0]} - ${e2[1]}`);
    });
  }
  static registerServiceKeys(e) {
    _AppUtils.unregisterServiceKeys(e), e._serviceKeyListeners = e._serviceKeyListeners || [];
    const t = e._serviceKeyListeners;
    t.push(new RepeatedKeyListener(window, "KeyP", function() {
      _AppUtils.printPerformanceInfo(e, 1);
    }, 3, 1)), t.push(new RepeatedKeyListener(window, "KeyF", function() {
      e.stats ? e.hideFPS() : e.showFPS();
    }, 3, 1)), t.push(new RepeatedKeyListener(window, "KeyH", function() {
      e.enableRender ? e.disableRendering() : e.enableRendering();
    }, 3, 1)), t.push(new RepeatedKeyListener(window, ["Backquote", "IntlBackslash"], () => {
      let t2;
      _AppUtils.showServiceKeysHelp(e), e.controls && (t2 = e.controls.enableKeys, e.controls.enableKeys = false);
      const n = (o) => {
        switch (o.code) {
          case "KeyW":
            e.hasDebugMode("wireframes") ? e.disableDebugMode("wireframes") : e.enableDebugMode("wireframes");
            break;
          case "KeyL":
            e.hasDebugMode("lights") ? e.disableDebugMode("lights") : e.enableDebugMode("lights");
            break;
          case "KeyS":
            e.hasDebugMode("skeletons") ? e.disableDebugMode("skeletons") : e.enableDebugMode("skeletons");
            break;
          case "KeyP":
            _AppUtils.printPerformanceInfo(e, 1);
            break;
          case "KeyF":
            e.stats ? e.hideFPS() : e.showFPS();
            break;
          case "KeyH":
            e.enableRender ? e.disableRendering() : e.enableRendering();
            break;
          case "KeyN":
            e.hasDebugMode("normals") ? e.disableDebugMode("normals") : e.enableDebugMode("normals");
        }
        window.removeEventListener("keydown", n), _AppUtils.hideServiceKeysHelp(e), e.controls && (e.controls.enableKeys = t2);
      };
      window.addEventListener("keydown", n);
    }, 3, 1));
  }
  static unregisterServiceKeys(e) {
    Array.isArray(e._serviceKeyListeners) && (e._serviceKeyListeners.forEach((e2) => e2.dispose()), e._serviceKeyListeners.length = 0);
  }
  static showServiceKeysHelp(e) {
    const t = e.container, n = ["color: #fff;", "font-size: 14px;", "font-family: monospace;", "text-decoration: none;", "position: absolute;", `top: ${e.stats ? 60 : 10}px;`, "left: 10px;", "user-select: none;", "z-index: 9999;", "text-shadow: 1px 1px #000;"].join("\n"), o = document.createElement("div");
    o.id = "v3d-debug-info-help", o.style = n, o.innerHTML = "Service Tools:<br>[F] FPS counter<br>[P] performance profile<br>[H] halt/resume render<br>[W] wireframes<br>[L] lights<br>[S] skeletons<br>[N] normals", t.appendChild(o);
  }
  static hideServiceKeysHelp(e) {
    e.container.querySelector("#v3d-debug-info-help").remove();
  }
};
var Compat = { prepareRenderer: function(e) {
  Detector.getGPUVendor(e), Detector.getGPUModel(e);
  const t = Detector.checkAndroid();
  e.compatSettings.gtaoDisableBkgFix = t;
} };
function CubeCopy(e) {
  this.sourceTexture = e, this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), this.shader = new ShaderMaterial({ type: "CubeCopy", uniforms: { faceIdx: { value: 0 }, cubemap: { value: null } }, vertexShader: "\n        uniform int faceIdx;\n\n        varying vec3 vCubeDirection;\n\n        vec3 uvToCubeDirection(vec2 uv, int face) {\n            vec3 dir;\n            uv = 2.0 * uv - 1.0;\n\n            if (face == 0) {\n                dir = vec3(1.0, -uv.y, -uv.x);\n            } else if (face == 1) {\n                dir = vec3(-1.0, -uv.y, uv.x);\n            } else if (face == 2) {\n                dir = vec3(uv.x, 1.0, uv.y);\n            } else if (face == 3) {\n                dir = vec3(uv.x, -1.0, -uv.y);\n            } else if (face == 4) {\n                dir = vec3(uv.x, -uv.y, 1.0);\n            } else if (face == 5) {\n                dir = vec3(-uv.x, -uv.y, -1.0);\n            }\n            return dir;\n        }\n\n        void main() {\n            vCubeDirection = uvToCubeDirection(uv, faceIdx);\n            gl_Position = vec4(position, 1.0);\n        }\n        ", fragmentShader: "\n        uniform samplerCube cubemap;\n\n        varying vec3 vCubeDirection;\n\n        void main() {\n            gl_FragColor = textureCube(cubemap, vCubeDirection);\n\n            #include <tonemapping_fragment>\n\n            gl_FragColor = linearToOutputTexel(gl_FragColor);\n        }\n        " }), this.shader.map = e, this.shader.uniforms.cubemap.value = e, this.planeMesh = new Mesh(new PlaneGeometry(2, 2), this.shader), this.scene = new Scene(), this.scene.add(this.camera), this.scene.add(this.planeMesh);
}
function _useHalfFloatCubemaps(e) {
  return !!Detector.checkHalfFloatTex(e, true) && (!/Firefox/.test(navigator.userAgent) || !/Android/.test(navigator.userAgent));
}
function renderSceneToCubemap(e, t, n, { camPos: o = new Vector3(), clipStart: r = 0.1, clipEnd: i = 100 } = {}) {
  _useHalfFloatCubemaps(t) || (console.warn("v3d.RenderUtils: disabling half float cubemaps"), n.texture.type = 1009);
  const a = new CubeCamera(r, i, n);
  a.position.copy(o);
  let s = e.worldMaterial;
  if (null !== s && s.isMeshNodeMaterial) {
    const o2 = new Mesh(new BoxGeometry(1, 1, 1), s);
    o2.material.side = 1, o2.material.defines.WORLD_NODES = 1, new CubeCamera(0.1, 10, n).update(t, o2), o2.geometry.disposeBoundsTree && o2.geometry.disposeBoundsTree(), o2.geometry.dispose();
    const r2 = e.background;
    e.background = null;
    const i2 = t.autoClearColor;
    t.autoClearColor = false, a.update(t, e), t.autoClearColor = i2, e.background = r2;
  } else a.update(t, e);
  return a.renderTarget;
}
function renderWorldNodeMatToCubemap(e, t, n, o) {
  t.isMeshNodeMaterial || console.error("v3d.RenderUtils.renderWorldNodeMatToCubemap(): material is not an instance of MeshNodeMaterial.");
  const r = new Scene();
  r.worldMaterial = t;
  const i = new WebGLCubeRenderTarget(n, o);
  return i.texture.name = "WorldNodesCubemap", renderSceneToCubemap(r, e, i);
}
function assignAllLayersMask(e) {
  const t = e.layers.mask;
  return e.layers.set(0), e.isArrayCamera && (e.layers.enable(1), e.layers.enable(2)), e.layers.enable(3), e.layers.enable(4), e.layers.enable(5), e.layers.enable(6), e.layers.enable(7), t;
}
CubeCopy.prototype = { constructor: CubeCopy, render: function(e, t, n = 1) {
  var o = e.toneMapping, r = e.toneMappingExposure, i = e.getRenderTarget();
  e.toneMapping = 1, e.toneMappingExposure = n;
  for (var a = 0; a < 6; a++) e.setRenderTarget(t, a), this.shader.uniforms.faceIdx.value = a, e.render(this.scene, this.camera);
  e.toneMapping = o, e.toneMappingExposure = r, e.setRenderTarget(i);
}, dispose: function() {
  this.planeMesh.geometry.dispose(), this.planeMesh.material.dispose();
} };
var RenderUtils = Object.freeze({ __proto__: null, assignAllLayersMask, renderSceneToCubemap, renderWorldNodeMatToCubemap });
var _box = new Box3();
var _sphere = new Sphere();
var _matrix4 = new Matrix4();
var _vector3 = new Vector3();
var _vector3_2 = new Vector3();
var CubeReflectionProbe = class extends Object3D {
  constructor(e = 256) {
    super(), this.isCubeReflectionProbe = true, this.type = "CubeReflectionProbe", this.influenceType = 1, this.influenceDistance = 1, this.parallaxType = 1, this.parallaxDistance = 1, this.probeClipStart = 0.1, this.probeClipEnd = 100, this.probeIntensity = 1, this.visibilityGroup = null, this.visibilityGroupInv = false, this.influenceGroup = null, this.influenceGroupInv = false, this._renderTargetCube = new WebGLCubeRenderTarget(e, { encoding: 3001, format: 1023, generateMipmaps: true, minFilter: 1008, type: 1016 }), this._renderTargetCube.texture.name = "CubeReflectionProbe.ini", this._exposureRenderTargetCube = this._renderTargetCube.clone(), this._renderTargetCube.texture.name = "CubeReflectionProbe.exp", this.renderTarget = null, this.matrixWorldInverse = new Matrix4();
  }
  setSize(e) {
    this._renderTargetCube.setSize(e, e), this._exposureRenderTargetCube.setSize(e, e);
  }
  setEncoding(e) {
    this._renderTargetCube.texture.encoding = e, this._exposureRenderTargetCube.texture.encoding = e;
  }
  intersectsMesh(e) {
    let t = false;
    const n = e.geometry, o = n.boundsTree, r = _matrix4;
    switch (r.copy(e.matrixWorld).invert(), r.multiply(this.matrixWorld), this.influenceType) {
      case 0:
        t = true;
        break;
      case 1:
        _sphere.center.setScalar(0), _sphere.radius = this.influenceDistance, _sphere.applyMatrix4(r), o ? t = o.intersectsSphere(_sphere) : (null === n.boundingBox && n.computeBoundingBox(), t = n.boundingBox.intersectsSphere(_sphere));
        break;
      case 2:
        const e2 = _vector3.setScalar(0), i = _vector3_2.setScalar(2 * this.influenceDistance);
        _box.setFromCenterAndSize(e2, i), o ? t = o.intersectsBox(_box, r) : (_box.applyMatrix4(r), null === n.boundingBox && n.computeBoundingBox(), t = n.boundingBox.intersectsBox(_box));
    }
    return t;
  }
  update(e, t) {
    const n = {};
    e.traverse((e2) => {
      !e2.isCubeReflectionProbe && this._isVisible(e2) || (n[e2.id] = e2.layers.mask, e2.layers.disableAll());
    });
    const o = e.worldMaterial, r = null !== o && o.isMeshNodeMaterial && o.needsLightPathDir();
    let i;
    r && (i = o.defines.LIGHT_PATH_IS_CAM_RAY, o.defines.LIGHT_PATH_IS_CAM_RAY = 0), renderSceneToCubemap(e, t, this._renderTargetCube, { camPos: this.position, clipStart: this.probeClipStart, clipEnd: this.probeClipEnd }), this._exposureRenderTargetCube.texture.type = this._renderTargetCube.texture.type;
    const a = new CubeCopy(this._renderTargetCube.texture);
    a.render(t, this._exposureRenderTargetCube, this.probeIntensity), a.dispose(), this.renderTarget = this.onUpdate(this._exposureRenderTargetCube), r && (o.defines.LIGHT_PATH_IS_CAM_RAY = i), e.traverse((e2) => {
      !e2.isCubeReflectionProbe && this._isVisible(e2) || (e2.layers.mask = n[e2.id]);
    });
  }
  onUpdate(e) {
    return e;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return super.copy(e), this.influenceType = e.influenceType, this.influenceDistance = e.influenceDistance, this.parallaxType = e.parallaxType, this.parallaxDistance = e.parallaxDistance, this.probeClipStart = e.probeClipStart, this.probeClipEnd = e.probeClipEnd, this.probeIntensity = e.probeIntensity, this.visibilityGroup = e.visibilityGroup, this.visibilityGroupInv = e.visibilityGroupInv, this.influenceGroup = e.influenceGroup, this.influenceGroupInv = e.influenceGroupInv, this.setSize(e._renderTargetCube.width), this.matrixWorldInverse.copy(e.matrixWorldInverse), this;
  }
  dispose() {
    null !== this._renderTargetCube && this._renderTargetCube.dispose(), null !== this._exposureRenderTargetCube && this._exposureRenderTargetCube.dispose(), null !== this.renderTarget && (this.renderTarget.dispose(), this.renderTarget = null), this.dispatchEvent({ type: "dispose" });
  }
  _isVisible(e) {
    if (null === this.visibilityGroup) return true;
    if (!e.isMesh) return true;
    return -1 !== e.groupNames.indexOf(this.visibilityGroup) ^ this.visibilityGroupInv;
  }
};
var EffectComposer = class {
  constructor(e, t) {
    if (this.renderer = e, void 0 === t) {
      const n = e.getSize(new Vector2());
      this._pixelRatio = e.getPixelRatio(), this._width = n.width, this._height = n.height, (t = new WebGLRenderTarget(Math.floor(this._width * this._pixelRatio), Math.floor(this._height * this._pixelRatio))).texture.name = "EffectComposer.rt1";
    } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new ShaderPass(ShaderLib.copy), this.clock = new Clock();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(Math.floor(this._width * this._pixelRatio), Math.floor(this._height * this._pixelRatio));
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(Math.floor(this._width * this._pixelRatio), Math.floor(this._height * this._pixelRatio));
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    -1 !== t && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return false;
    return true;
  }
  render(e) {
    void 0 === e && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let n = false;
    for (let t2 = 0, o = this.passes.length; t2 < o; t2++) {
      const o2 = this.passes[t2];
      if (false !== o2.enabled) {
        if (o2.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t2), o2.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o2.needsSwap) {
          if (n) {
            const t3 = this.renderer.getContext(), n2 = this.renderer.state.buffers.stencil;
            n2.setFunc(t3.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), n2.setFunc(t3.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        o2 instanceof MaskPass ? n = true : o2 instanceof ClearMaskPass && (n = false);
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (void 0 === e) {
      const t = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(Math.floor(this._width * this._pixelRatio), Math.floor(this._height * this._pixelRatio));
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this._width = e, this._height = t;
    const n = Math.floor(this._width * this._pixelRatio), o = Math.floor(this._height * this._pixelRatio);
    this.renderTarget1.setSize(n, o), this.renderTarget2.setSize(n, o);
    for (let e2 = 0; e2 < this.passes.length; e2++) this.passes[e2].setSize(n, o);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
  getActiveSSAAPass() {
    return this.passes[0] instanceof SSAARenderPass ? this.passes[0] : null;
  }
  insertPassAfter(e, t) {
    let n = 0;
    for (let e2 = 0; e2 < this.passes.length; e2++) t.indexOf(this.passes[e2]) > -1 && (n = e2 + 1);
    this.insertPass(e, n);
  }
  enableAllPasses() {
    for (let e = 0; e < this.passes.length; e++) this.passes[e].enabled = true;
  }
  disableAllPasses() {
    for (let e = 0; e < this.passes.length; e++) this.passes[e].enabled = false;
  }
  setStencil(e) {
    this.renderTarget1.stencilBuffer = e, this.renderTarget1.dispose(), this.renderTarget2.stencilBuffer = e, this.renderTarget2.dispose();
  }
};
var Module = (() => {
  var e = import.meta.url;
  return function(t) {
    t = void 0 !== (t = t || {}) ? t : {};
    var n, o, r = Object.assign;
    t.ready = new Promise(function(e2, t2) {
      n = e2, o = t2;
    });
    var i, a, s, l, c, u, d = r({}, t), h = "object" == typeof window, f = "function" == typeof importScripts, p = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, m = "";
    p ? (m = f ? require_path().dirname(m) + "/" : __dirname + "/", u = () => {
      c || (l = require_fs(), c = require_path());
    }, i = function(e2, t2) {
      var n2 = X(e2);
      return n2 ? t2 ? n2 : n2.toString() : (u(), e2 = c.normalize(e2), l.readFileSync(e2, t2 ? null : "utf8"));
    }, s = (e2) => {
      var t2 = i(e2, true);
      return t2.buffer || (t2 = new Uint8Array(t2)), t2;
    }, a = (e2, t2, n2) => {
      var o2 = X(e2);
      o2 && t2(o2), u(), e2 = c.normalize(e2), l.readFile(e2, function(e3, o3) {
        e3 ? n2(e3) : t2(o3.buffer);
      });
    }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(e2) {
      if (!(e2 instanceof Z)) throw e2;
    }), process.on("unhandledRejection", function(e2) {
      throw e2;
    }), t.inspect = function() {
      return "[Emscripten Module object]";
    }) : (h || f) && (f ? m = self.location.href : "undefined" != typeof document && document.currentScript && (m = document.currentScript.src), e && (m = e), m = 0 !== m.indexOf("blob:") ? m.substr(0, m.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", i = (e2) => {
      try {
        var t2 = new XMLHttpRequest();
        return t2.open("GET", e2, false), t2.send(null), t2.responseText;
      } catch (t3) {
        var n2 = X(e2);
        if (n2) return function(e3) {
          for (var t4 = [], n3 = 0; n3 < e3.length; n3++) {
            var o2 = e3[n3];
            o2 > 255 && (o2 &= 255), t4.push(String.fromCharCode(o2));
          }
          return t4.join("");
        }(n2);
        throw t3;
      }
    }, f && (s = (e2) => {
      try {
        var t2 = new XMLHttpRequest();
        return t2.open("GET", e2, false), t2.responseType = "arraybuffer", t2.send(null), new Uint8Array(t2.response);
      } catch (t3) {
        var n2 = X(e2);
        if (n2) return n2;
        throw t3;
      }
    }), a = (e2, t2, n2) => {
      var o2 = new XMLHttpRequest();
      o2.open("GET", e2, true), o2.responseType = "arraybuffer", o2.onload = () => {
        if (200 == o2.status || 0 == o2.status && o2.response) t2(o2.response);
        else {
          var r2 = X(e2);
          r2 ? t2(r2.buffer) : n2();
        }
      }, o2.onerror = n2, o2.send(null);
    }), t.print || console.log.bind(console);
    var g, _, A = t.printErr || console.warn.bind(console);
    r(t, d), d = null, t.arguments && t.arguments, t.thisProgram && t.thisProgram, t.quit && t.quit, t.wasmBinary && (g = t.wasmBinary), t.noExitRuntime, "object" != typeof WebAssembly && N("no native wasm support detected");
    var v = false;
    function x(e2) {
      return t["_" + e2];
    }
    function y(e2, t2, n2, o2, r2) {
      var i2 = { string: function(e3) {
        var t3 = 0;
        if (null != e3 && 0 !== e3) {
          var n3 = 1 + (e3.length << 2);
          (function(e4, t4, n4) {
            (function(e5, t5, n5, o3) {
              if (!(o3 > 0)) return 0;
              for (var r3 = n5, i3 = n5 + o3 - 1, a3 = 0; a3 < e5.length; ++a3) {
                var s3 = e5.charCodeAt(a3);
                if (s3 >= 55296 && s3 <= 57343) s3 = 65536 + ((1023 & s3) << 10) | 1023 & e5.charCodeAt(++a3);
                if (s3 <= 127) {
                  if (n5 >= i3) break;
                  t5[n5++] = s3;
                } else if (s3 <= 2047) {
                  if (n5 + 1 >= i3) break;
                  t5[n5++] = 192 | s3 >> 6, t5[n5++] = 128 | 63 & s3;
                } else if (s3 <= 65535) {
                  if (n5 + 2 >= i3) break;
                  t5[n5++] = 224 | s3 >> 12, t5[n5++] = 128 | s3 >> 6 & 63, t5[n5++] = 128 | 63 & s3;
                } else {
                  if (n5 + 3 >= i3) break;
                  t5[n5++] = 240 | s3 >> 18, t5[n5++] = 128 | s3 >> 12 & 63, t5[n5++] = 128 | s3 >> 6 & 63, t5[n5++] = 128 | 63 & s3;
                }
              }
              t5[n5] = 0;
            })(e4, S, t4, n4);
          })(e3, t3 = q(n3), n3);
        }
        return t3;
      }, array: function(e3) {
        var t3 = q(e3.length);
        return function(e4, t4) {
          C.set(e4, t4);
        }(e3, t3), t3;
      } };
      function a2(e3) {
        return "string" === t2 ? (n3 = e3) ? function(e4, t3, n4) {
          for (var o4 = t3 + n4, r3 = t3; e4[r3] && !(r3 >= o4); ) ++r3;
          if (r3 - t3 > 16 && e4.subarray && E) return E.decode(e4.subarray(t3, r3));
          for (var i3 = ""; t3 < r3; ) {
            var a3 = e4[t3++];
            if (128 & a3) {
              var s3 = 63 & e4[t3++];
              if (192 != (224 & a3)) {
                var l3 = 63 & e4[t3++];
                if ((a3 = 224 == (240 & a3) ? (15 & a3) << 12 | s3 << 6 | l3 : (7 & a3) << 18 | s3 << 12 | l3 << 6 | 63 & e4[t3++]) < 65536) i3 += String.fromCharCode(a3);
                else {
                  var c3 = a3 - 65536;
                  i3 += String.fromCharCode(55296 | c3 >> 10, 56320 | 1023 & c3);
                }
              } else i3 += String.fromCharCode((31 & a3) << 6 | s3);
            } else i3 += String.fromCharCode(a3);
          }
          return i3;
        }(S, n3, o3) : "" : "boolean" === t2 ? Boolean(e3) : e3;
        var n3, o3;
      }
      var s2 = x(e2), l2 = [], c2 = 0;
      if (o2) for (var u2 = 0; u2 < o2.length; u2++) {
        var d2 = i2[n2[u2]];
        d2 ? (0 === c2 && (c2 = $()), l2[u2] = d2(o2[u2])) : l2[u2] = o2[u2];
      }
      var h2 = s2.apply(null, l2);
      return h2 = function(e3) {
        return 0 !== c2 && K(c2), a2(e3);
      }(h2);
    }
    var b, C, S, M, E = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
    function T(e2, t2) {
      return e2 % t2 > 0 && (e2 += t2 - e2 % t2), e2;
    }
    function I(e2) {
      b = e2, t.HEAP8 = C = new Int8Array(e2), t.HEAP16 = new Int16Array(e2), t.HEAP32 = new Int32Array(e2), t.HEAPU8 = S = new Uint8Array(e2), t.HEAPU16 = new Uint16Array(e2), t.HEAPU32 = new Uint32Array(e2), t.HEAPF32 = new Float32Array(e2), t.HEAPF64 = new Float64Array(e2);
    }
    t.INITIAL_MEMORY;
    var w = [], R = [], L = [];
    var B = 0, P = null;
    function N(e2) {
      t.onAbort && t.onAbort(e2), A(e2 = "Aborted(" + e2 + ")"), v = true, e2 += ". Build with -s ASSERTIONS=1 for more info.";
      var n2 = new WebAssembly.RuntimeError(e2);
      throw o(n2), n2;
    }
    t.preloadedImages = {}, t.preloadedAudios = {};
    var D, O, F = "data:application/octet-stream;base64,";
    function V(e2) {
      return e2.startsWith(F);
    }
    function U(e2) {
      return e2.startsWith("file://");
    }
    function G(e2) {
      try {
        if (e2 == D && g) return new Uint8Array(g);
        var t2 = X(e2);
        if (t2) return t2;
        if (s) return s(e2);
        throw "both async and sync fetching of the wasm failed";
      } catch (e3) {
        N(e3);
      }
    }
    function z(e2) {
      for (; e2.length > 0; ) {
        var n2 = e2.shift();
        if ("function" != typeof n2) {
          var o2 = n2.func;
          "number" == typeof o2 ? void 0 === n2.arg ? W(o2)() : W(o2)(n2.arg) : o2(void 0 === n2.arg ? null : n2.arg);
        } else n2(t);
      }
    }
    V(D = "data:application/octet-stream;base64,AGFzbQEAAAABIwdgAX8AYAABf2ABfwF/YAN/f38Bf2ADf39/AGACf38AYAAAAg0CAWEBYQACAWEBYgADAxoZBAMCAAIFBgQCAAQDAQEBAQIAAQEBAAAAAAQFAXABAQEFBwEBgAKAgAIGCQF/AUHQpIADCwdBEAFjAgABZAAIAWUAEQFmABABZwAPAWgADgFpABoBagAZAWsAGAFsABcBbQAWAW4AFQFvAQABcAAUAXEAEwFyABIKl6QBGf0DAQJ/IAJBgARPBEAgACABIAIQARoPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgBBwABJDQAgAiAAQUBqIgRLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAETQ0ACwsgACACTQ0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgAEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCwujAQEBfyACQX9zIQICQCABRQ0AIAFBAXEEfyAALQAAIAJB/wFxc0ECdEGwCGooAgAgAkEIdnMhAiAAQQFqIQAgAUEBawUgAQshAyABQQFGDQADQCAALQABIAAtAAAgAkH/AXFzQQJ0QbAIaigCACACQQh2cyIBQf8BcXNBAnRBsAhqKAIAIAFBCHZzIQIgAEECaiEAIANBAmsiAw0ACwsgAkF/cwtRAQJ/QaAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBoAggADYCACABDwtB1KDAAEEwNgIAQX8L8QwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQeigwAAoAgBJDQEgACABaiEAIANB7KDAACgCAEcEQCABQf8BTQRAIAMoAggiAiABQQN2IgRBA3RBgKHAAGpGGiACIAMoAgwiAUYEQEHYoMAAQdigwAAoAgBBfiAEd3E2AgAMAwsgAiABNgIMIAEgAjYCCAwCCyADKAIYIQYCQCADIAMoAgwiAUcEQCADKAIIIgIgATYCDCABIAI2AggMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEBDAELA0AgAiEHIAQiAUEUaiICKAIAIgQNACABQRBqIQIgASgCECIEDQALIAdBADYCAAsgBkUNAQJAIAMgAygCHCICQQJ0QYijwABqIgQoAgBGBEAgBCABNgIAIAENAUHcoMAAQdygwAAoAgBBfiACd3E2AgAMAwsgBkEQQRQgBigCECADRhtqIAE2AgAgAUUNAgsgASAGNgIYIAMoAhAiAgRAIAEgAjYCECACIAE2AhgLIAMoAhQiAkUNASABIAI2AhQgAiABNgIYDAELIAUoAgQiAUEDcUEDRw0AQeCgwAAgADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVB8KDAACgCAEYEQEHwoMAAIAM2AgBB5KDAAEHkoMAAKAIAIABqIgA2AgAgAyAAQQFyNgIEIANB7KDAACgCAEcNA0HgoMAAQQA2AgBB7KDAAEEANgIADwsgBUHsoMAAKAIARgRAQeygwAAgAzYCAEHgoMAAQeCgwAAoAgAgAGoiADYCACADIABBAXI2AgQgACADaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIIIgIgAUEDdiIEQQN0QYChwABqRhogAiAFKAIMIgFGBEBB2KDAAEHYoMAAKAIAQX4gBHdxNgIADAILIAIgATYCDCABIAI2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgFHBEAgBSgCCCICQeigwAAoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEGIo8AAaiIEKAIARgRAIAQgATYCACABDQFB3KDAAEHcoMAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQeygwAAoAgBHDQFB4KDAACAANgIADwsgBSABQX5xNgIEIAMgAEEBcjYCBCAAIANqIAA2AgALIABB/wFNBEAgAEEDdiIBQQN0QYChwABqIQACf0HYoMAAKAIAIgJBASABdCIBcUUEQEHYoMAAIAEgAnI2AgAgAAwBCyAAKAIICyECIAAgAzYCCCACIAM2AgwgAyAANgIMIAMgAjYCCA8LQR8hAiADQgA3AhAgAEH///8HTQRAIABBCHYiASABQYD+P2pBEHZBCHEiAXQiAiACQYDgH2pBEHZBBHEiAnQiBCAEQYCAD2pBEHZBAnEiBHRBD3YgASACciAEcmsiAUEBdCAAIAFBFWp2QQFxckEcaiECCyADIAI2AhwgAkECdEGIo8AAaiEBAkACQAJAQdygwAAoAgAiBEEBIAJ0IgdxRQRAQdygwAAgBCAHcjYCACABIAM2AgAgAyABNgIYDAELIABBAEEZIAJBAXZrIAJBH0YbdCECIAEoAgAhAQNAIAEiBCgCBEF4cSAARg0CIAJBHXYhASACQQF0IQIgBCABQQRxaiIHQRBqKAIAIgENAAsgByADNgIQIAMgBDYCGAsgAyADNgIMIAMgAzYCCAwBCyAEKAIIIgAgAzYCDCAEIAM2AgggA0EANgIYIAMgBDYCDCADIAA2AggLQfigwABB+KDAACgCAEEBayIAQX8gABs2AgALC5IvAQt/IwBBEGsiCyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQdigwAAoAgAiBkEQIABBC2pBeHEgAEELSRsiB0EDdiICdiIBQQNxBEAgAUF/c0EBcSACaiIDQQN0IgFBiKHAAGooAgAiBEEIaiEAAkAgBCgCCCICIAFBgKHAAGoiAUYEQEHYoMAAIAZBfiADd3E2AgAMAQsgAiABNgIMIAEgAjYCCAsgBCADQQN0IgFBA3I2AgQgASAEaiIBIAEoAgRBAXI2AgQMDAsgB0HgoMAAKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBiKHAAGooAgAiBCgCCCIBIABBgKHAAGoiAEYEQEHYoMAAIAZBfiADd3EiBjYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAHQQNyNgIEIAQgB2oiAiADQQN0IgEgB2siA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGAocAAaiEFQeygwAAoAgAhBAJ/IAZBASABdCIBcUUEQEHYoMAAIAEgBnI2AgAgBQwBCyAFKAIICyEBIAUgBDYCCCABIAQ2AgwgBCAFNgIMIAQgATYCCAtB7KDAACACNgIAQeCgwAAgAzYCAAwMC0HcoMAAKAIAIglFDQEgCUEAIAlrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QYijwABqKAIAIgEoAgRBeHEgB2shAyABIQIDQAJAIAIoAhAiAEUEQCACKAIUIgBFDQELIAAoAgRBeHEgB2siAiADIAIgA0kiAhshAyAAIAEgAhshASAAIQIMAQsLIAEoAhghCCABIAEoAgwiBEcEQCABKAIIIgBB6KDAACgCAEkaIAAgBDYCDCAEIAA2AggMCwsgAUEUaiICKAIAIgBFBEAgASgCECIARQ0DIAFBEGohAgsDQCACIQUgACIEQRRqIgIoAgAiAA0AIARBEGohAiAEKAIQIgANAAsgBUEANgIADAoLQX8hByAAQb9/Sw0AIABBC2oiAEF4cSEHQdygwAAoAgAiCUUNAEEAIAdrIQMCQAJAAkACf0EAIAdBgAJJDQAaQR8gB0H///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgByAAQRVqdkEBcXJBHGoLIgZBAnRBiKPAAGooAgAiAkUEQEEAIQAMAQtBACEAIAdBAEEZIAZBAXZrIAZBH0YbdCEBA0ACQCACKAIEQXhxIAdrIgUgA08NACACIQQgBSIDDQBBACEDIAIhAAwDCyAAIAIoAhQiBSAFIAIgAUEddkEEcWooAhAiAkYbIAAgBRshACABQQF0IQEgAg0ACwsgACAEckUEQEEAIQRBAiAGdCIAQQAgAGtyIAlxIgBFDQMgAEEAIABrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QYijwABqKAIAIQALIABFDQELA0AgACgCBEF4cSAHayIBIANJIQIgASADIAIbIQMgACAEIAIbIQQgACgCECIBBH8gAQUgACgCFAsiAA0ACwsgBEUNACADQeCgwAAoAgAgB2tPDQAgBCgCGCEGIAQgBCgCDCIBRwRAIAQoAggiAEHooMAAKAIASRogACABNgIMIAEgADYCCAwJCyAEQRRqIgIoAgAiAEUEQCAEKAIQIgBFDQMgBEEQaiECCwNAIAIhBSAAIgFBFGoiAigCACIADQAgAUEQaiECIAEoAhAiAA0ACyAFQQA2AgAMCAsgB0HgoMAAKAIAIgJNBEBB7KDAACgCACEDAkAgAiAHayIBQRBPBEBB4KDAACABNgIAQeygwAAgAyAHaiIANgIAIAAgAUEBcjYCBCACIANqIAE2AgAgAyAHQQNyNgIEDAELQeygwABBADYCAEHgoMAAQQA2AgAgAyACQQNyNgIEIAIgA2oiACAAKAIEQQFyNgIECyADQQhqIQAMCgsgB0HkoMAAKAIAIghJBEBB5KDAACAIIAdrIgE2AgBB8KDAAEHwoMAAKAIAIgIgB2oiADYCACAAIAFBAXI2AgQgAiAHQQNyNgIEIAJBCGohAAwKC0EAIQAgB0EvaiIJAn9BsKTAACgCAARAQbikwAAoAgAMAQtBvKTAAEJ/NwIAQbSkwABCgKCAgICABDcCAEGwpMAAIAtBDGpBcHFB2KrVqgVzNgIAQcSkwABBADYCAEGUpMAAQQA2AgBBgCALIgFqIgZBACABayIFcSICIAdNDQlBkKTAACgCACIEBEBBiKTAACgCACIDIAJqIgEgA00NCiABIARLDQoLQZSkwAAtAABBBHENBAJAAkBB8KDAACgCACIDBEBBmKTAACEAA0AgAyAAKAIAIgFPBEAgASAAKAIEaiADSw0DCyAAKAIIIgANAAsLQQAQBCIBQX9GDQUgAiEGQbSkwAAoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEGCyAGIAdNDQUgBkH+////B0sNBUGQpMAAKAIAIgQEQEGIpMAAKAIAIgMgBmoiACADTQ0GIAAgBEsNBgsgBhAEIgAgAUcNAQwHCyAGIAhrIAVxIgZB/v///wdLDQQgBhAEIgEgACgCACAAKAIEakYNAyABIQALAkAgAEF/Rg0AIAdBMGogBk0NAEG4pMAAKAIAIgEgCSAGa2pBACABa3EiAUH+////B0sEQCAAIQEMBwsgARAEQX9HBEAgASAGaiEGIAAhAQwHC0EAIAZrEAQaDAQLIAAiAUF/Rw0FDAMLQQAhBAwHC0EAIQEMBQsgAUF/Rw0CC0GUpMAAQZSkwAAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAEIQFBABAEIQAgAUF/Rg0BIABBf0YNASAAIAFNDQEgACABayIGIAdBKGpNDQELQYikwABBiKTAACgCACAGaiIANgIAQYykwAAoAgAgAEkEQEGMpMAAIAA2AgALAkACQAJAQfCgwAAoAgAiBQRAQZikwAAhAANAIAEgACgCACIDIAAoAgQiAmpGDQIgACgCCCIADQALDAILQeigwAAoAgAiAEEAIAAgAU0bRQRAQeigwAAgATYCAAtBACEAQZykwAAgBjYCAEGYpMAAIAE2AgBB+KDAAEF/NgIAQfygwABBsKTAACgCADYCAEGkpMAAQQA2AgADQCAAQQN0IgNBiKHAAGogA0GAocAAaiICNgIAIANBjKHAAGogAjYCACAAQQFqIgBBIEcNAAtB5KDAACAGQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBB8KDAACAAIAFqIgA2AgAgACACQQFyNgIEIAEgA2pBKDYCBEH0oMAAQcCkwAAoAgA2AgAMAgsgAC0ADEEIcQ0AIAMgBUsNACABIAVNDQAgACACIAZqNgIEQfCgwAAgBUF4IAVrQQdxQQAgBUEIakEHcRsiAGoiAjYCAEHkoMAAQeSgwAAoAgAgBmoiASAAayIANgIAIAIgAEEBcjYCBCABIAVqQSg2AgRB9KDAAEHApMAAKAIANgIADAELQeigwAAoAgAgAUsEQEHooMAAIAE2AgALIAEgBmohAkGYpMAAIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQZikwAAhAANAIAUgACgCACICTwRAIAIgACgCBGoiBCAFSw0DCyAAKAIIIQAMAAsACyAAIAE2AgAgACAAKAIEIAZqNgIEIAFBeCABa0EHcUEAIAFBCGpBB3EbaiIJIAdBA3I2AgQgAkF4IAJrQQdxQQAgAkEIakEHcRtqIgYgByAJaiIIayECIAUgBkYEQEHwoMAAIAg2AgBB5KDAAEHkoMAAKAIAIAJqIgA2AgAgCCAAQQFyNgIEDAMLIAZB7KDAACgCAEYEQEHsoMAAIAg2AgBB4KDAAEHgoMAAKAIAIAJqIgA2AgAgCCAAQQFyNgIEIAAgCGogADYCAAwDCyAGKAIEIgBBA3FBAUYEQCAAQXhxIQUCQCAAQf8BTQRAIAYoAggiAyAAQQN2IgBBA3RBgKHAAGpGGiADIAYoAgwiAUYEQEHYoMAAQdigwAAoAgBBfiAAd3E2AgAMAgsgAyABNgIMIAEgAzYCCAwBCyAGKAIYIQcCQCAGIAYoAgwiAUcEQCAGKAIIIgAgATYCDCABIAA2AggMAQsCQCAGQRRqIgAoAgAiAw0AIAZBEGoiACgCACIDDQBBACEBDAELA0AgACEEIAMiAUEUaiIAKAIAIgMNACABQRBqIQAgASgCECIDDQALIARBADYCAAsgB0UNAAJAIAYgBigCHCIDQQJ0QYijwABqIgAoAgBGBEAgACABNgIAIAENAUHcoMAAQdygwAAoAgBBfiADd3E2AgAMAgsgB0EQQRQgBygCECAGRhtqIAE2AgAgAUUNAQsgASAHNgIYIAYoAhAiAARAIAEgADYCECAAIAE2AhgLIAYoAhQiAEUNACABIAA2AhQgACABNgIYCyAFIAZqIQYgAiAFaiECCyAGIAYoAgRBfnE2AgQgCCACQQFyNgIEIAIgCGogAjYCACACQf8BTQRAIAJBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAg2AgggACAINgIMIAggAjYCDCAIIAA2AggMAwtBHyEAIAJB////B00EQCACQQh2IgAgAEGA/j9qQRB2QQhxIgN0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgA3IgAHJrIgBBAXQgAiAAQRVqdkEBcXJBHGohAAsgCCAANgIcIAhCADcCECAAQQJ0QYijwABqIQQCQEHcoMAAKAIAIgNBASAAdCIBcUUEQEHcoMAAIAEgA3I2AgAgBCAINgIAIAggBDYCGAwBCyACQQBBGSAAQQF2ayAAQR9GG3QhACAEKAIAIQEDQCABIgMoAgRBeHEgAkYNAyAAQR12IQEgAEEBdCEAIAMgAUEEcWoiBCgCECIBDQALIAQgCDYCECAIIAM2AhgLIAggCDYCDCAIIAg2AggMAgtB5KDAACAGQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBB8KDAACAAIAFqIgA2AgAgACACQQFyNgIEIAEgA2pBKDYCBEH0oMAAQcCkwAAoAgA2AgAgBSAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAVBEGpJGyICQRs2AgQgAkGgpMAAKQIANwIQIAJBmKTAACkCADcCCEGgpMAAIAJBCGo2AgBBnKTAACAGNgIAQZikwAAgATYCAEGkpMAAQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAVGDQMgAiACKAIEQX5xNgIEIAUgAiAFayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAU2AgggACAFNgIMIAUgAjYCDCAFIAA2AggMBAtBHyEAIAVCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAUgADYCHCAAQQJ0QYijwABqIQMCQEHcoMAAKAIAIgJBASAAdCIBcUUEQEHcoMAAIAEgAnI2AgAgAyAFNgIAIAUgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBTYCECAFIAI2AhgLIAUgBTYCDCAFIAU2AggMAwsgAygCCCIAIAg2AgwgAyAINgIIIAhBADYCGCAIIAM2AgwgCCAANgIICyAJQQhqIQAMBQsgAigCCCIAIAU2AgwgAiAFNgIIIAVBADYCGCAFIAI2AgwgBSAANgIIC0HkoMAAKAIAIgAgB00NAEHkoMAAIAAgB2siATYCAEHwoMAAQfCgwAAoAgAiAiAHaiIANgIAIAAgAUEBcjYCBCACIAdBA3I2AgQgAkEIaiEADAMLQdSgwABBMDYCAEEAIQAMAgsCQCAGRQ0AAkAgBCgCHCICQQJ0QYijwABqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQdygwAAgCUF+IAJ3cSIJNgIADAILIAZBEEEUIAYoAhAgBEYbaiABNgIAIAFFDQELIAEgBjYCGCAEKAIQIgAEQCABIAA2AhAgACABNgIYCyAEKAIUIgBFDQAgASAANgIUIAAgATYCGAsCQCADQQ9NBEAgBCADIAdqIgBBA3I2AgQgACAEaiIAIAAoAgRBAXI2AgQMAQsgBCAHQQNyNgIEIAQgB2oiBSADQQFyNgIEIAMgBWogAzYCACADQf8BTQRAIANBA3YiAEEDdEGAocAAaiECAn9B2KDAACgCACIBQQEgAHQiAHFFBEBB2KDAACAAIAFyNgIAIAIMAQsgAigCCAshACACIAU2AgggACAFNgIMIAUgAjYCDCAFIAA2AggMAQtBHyEAIANB////B00EQCADQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgAyAAQRVqdkEBcXJBHGohAAsgBSAANgIcIAVCADcCECAAQQJ0QYijwABqIQECQAJAIAlBASAAdCICcUUEQEHcoMAAIAIgCXI2AgAgASAFNgIADAELIANBAEEZIABBAXZrIABBH0YbdCEAIAEoAgAhBwNAIAciASgCBEF4cSADRg0CIABBHXYhAiAAQQF0IQAgASACQQRxaiICKAIQIgcNAAsgAiAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIARBCGohAAwBCwJAIAhFDQACQCABKAIcIgJBAnRBiKPAAGoiACgCACABRgRAIAAgBDYCACAEDQFB3KDAACAJQX4gAndxNgIADAILIAhBEEEUIAgoAhAgAUYbaiAENgIAIARFDQELIAQgCDYCGCABKAIQIgAEQCAEIAA2AhAgACAENgIYCyABKAIUIgBFDQAgBCAANgIUIAAgBDYCGAsCQCADQQ9NBEAgASADIAdqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQsgASAHQQNyNgIEIAEgB2oiAiADQQFyNgIEIAIgA2ogAzYCACAKBEAgCkEDdiIAQQN0QYChwABqIQVB7KDAACgCACEEAn9BASAAdCIAIAZxRQRAQdigwAAgACAGcjYCACAFDAELIAUoAggLIQAgBSAENgIIIAAgBDYCDCAEIAU2AgwgBCAANgIIC0HsoMAAIAI2AgBB4KDAACADNgIACyABQQhqIQALIAtBEGokACAAC9YCAQF/AkAgAUUNACAAQQA6AAAgACABaiICQQFrQQA6AAAgAUEDSQ0AIABBADoAAiAAQQA6AAEgAkEDa0EAOgAAIAJBAmtBADoAACABQQdJDQAgAEEAOgADIAJBBGtBADoAACABQQlJDQAgAEEAIABrQQNxIgJqIgBBADYCACAAIAEgAmtBfHEiAmoiAUEEa0EANgIAIAJBCUkNACAAQQA2AgggAEEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgAkEZSQ0AIABBADYCGCAAQQA2AhQgAEEANgIQIABBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAiAAQQRxQRhyIgJrIgFBIEkNACAAIAJqIQADQCAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAgAEEgaiEAIAFBIGsiAUEfSw0ACwsLAwABC7AEAQd/AkAgACgCACIGQYCAgAhPBEAgACgCBCEEDAELIAAgBkEIdCIGNgIAIAAgACgCECIDQQFqNgIQIAAgAyAAKAIMai0AACAAKAIEQQh0ciIENgIECwJ/IAEvAQAiBSAGQQt2bCIDIARLBEAgASAFQYAQIAVrQQV2ajsBACABIAJBBHRqQQRqIQhBAiEFQQgMAQsgACAEIANrIgQ2AgQgASAFIAVBBXZrOwEAIAYgA2siBkH///8HTQRAIAAgBkEIdCIGNgIAIAAgACgCECIDQQFqNgIQIAAgAyAAKAIMai0AACAEQQh0ciIENgIECyABLwECIgUgBkELdmwiAyAESwRAIAEgBUGAECAFa0EFdmo7AQIgASACQQR0akGEAmohCEEKIQVBCAwBCyAAIAQgA2siBDYCBCABIAUgBUEFdms7AQIgAUGEBGohCCAGIANrIQNBEiEFQYACCyEGIAAgBTYCaEEBIQEDQCAIIAFBAXQiAWohCQJAIANB////B0sEQCADIQIMAQsgACADQQh0IgI2AgAgACAAKAIQIgNBAWo2AhAgACADIAAoAgxqLQAAIARBCHRyIgQ2AgQLAkAgCS8BACIHIAJBC3ZsIgMgBE0EQCAAIAQgA2siBDYCBCAAIAIgA2siAzYCACAJIAcgB0EFdms7AQAgAUEBciEBDAELIAAgAzYCACAJIAdBgBAgB2tBBXZqOwEACyABIAZJDQALIAAgASAGayAFajYCaAvIHwEQfwJAIAAoAigiASAAKAIgIglNDQAgACgCaCICRQ0AIAAoAlQiAyAAKAIkTw0AIAAoAjAgA00NACAAIAIgASAJayIBIAIgASACSRsiBms2AmggCSADQX9zaiEEIAMgCU8EQCAAKAIsIARqIQQLIAAoAhgiAyAEai0AACEBIAAgCUEBajYCICADIAlqIAE6AAACQCAGQQFrIgdFDQAgB0EBcQRAIAAoAhgiAkEAIARBAWoiASABIAAoAixGGyIEai0AACEDIAAgACgCICIBQQFqNgIgIAEgAmogAzoAACAGQQJrIQcLIAZBAkYNAANAIAAoAhgiAkEAIARBAWoiASABIAAoAixGGyIGai0AACEDIAAgACgCICIBQQFqNgIgIAEgAmogAzoAACAAKAIYIgJBACAGQQFqIgEgASAAKAIsRhsiBGotAAAhAyAAIAAoAiAiAUEBajYCICABIAJqIAM6AAAgB0ECayIHDQALCyAAKAIgIgkgACgCJE0NACAAIAk2AiQLAkACQCAJIAAoAihPDQAgAEHcDWohDiAAQeAVaiEPIABB1ABqIRADQCAAKAIQIgMgACgCFEsNASAAIAAoAmQiCkEFdGogACgCdCAJcSIIQQF0aiIMIQYCQCAAKAIAIgVBgICACE8EQCAAKAIEIQQMAQsgACAFQQh0IgU2AgAgACADQQFqIgE2AhAgACAAKAIMIANqLQAAIAAoAgRBCHRyIgQ2AgQgASEDCwJAIAYvAXgiASAFQQt2bCICIARLBEAgACACNgIAIAYgAUGAECABa0EFdmo7AXggCUEBayEFIAlFBEAgACgCLCAFaiEFCyAAKAJwIAlxIAAoAmwiAXQgACgCJCIGBH8gACgCGCAFai0AAAVBAAtBCCABa3ZqIQ1BASEFAkAgCkEGTQRAA0AgBUEBdCIFIAAgDUGADGxqakHkHWohBgJAIAJB////B0sEQCACIQEMAQsgACACQQh0IgE2AgAgACADQQFqIgI2AhAgACAAKAIMIANqLQAAIARBCHRyIgQ2AgQgAiEDCwJAIAYvAQAiCCABQQt2bCICIARNBEAgACAEIAJrIgQ2AgQgACABIAJrIgI2AgAgBiAIIAhBBXZrOwEAIAVBAXIhBQwBCyAAIAI2AgAgBiAIQYAQIAhrQQV2ajsBAAsgBUGAAkkNAAwCCwALIAkgACgCVCIBQX9zaiEFIAEgCU8EQCAAKAIsIAVqIQULIAYEfyAAKAIYIAVqLQAABUEACyEGQQEhBUGAAiEHA0AgACANQYAMbGogBkEBdCIGIAdxIgwgB2ogBWpBAXRqQeQdaiELAkAgAkH///8HSwRAIAIhCAwBCyAAIAJBCHQiCDYCACAAIANBAWoiATYCECAAIAAoAgwgA2otAAAgBEEIdHIiBDYCBCABIQMLIAsCfyAEIAsvAQAiASAIQQt2bCICTyIKRQRAIAAgAjYCACABQYAQIAFrQQV2agwBCyAAIAQgAmsiBDYCBCAAIAggAmsiAjYCAEEAIQcgASABQQV2aws7AQAgByAMcyEHIAVBAXQgCnIiBUGAAkkNAAsLIAAgCUEBajYCICAAKAIYIAlqIAU6AAAgACgCICIJIAAoAiRLBEAgACAJNgIkC0EAIQIgACAAKAJkIgFBBE8EfyABQQlNBEAgACABQQNrNgJkDAMLIAFBBmsFQQALNgJkDAELIAAgBCACayIENgIEIAAgBSACayICNgIAIAYgASABQQV2azsBeCAAIApBAXRqIgshBgJAIAJB////B0sEQCADIQEMAQsgACACQQh0IgI2AgAgACADQQFqIgE2AhAgACAAKAIMIANqLQAAIARBCHRyIgQ2AgQLAkAgBi8B+AMiCiACQQt2bCIDIARNBEAgACAEIANrIgQ2AgQgACACIANrIgI2AgAgBiAKIApBBXZrOwH4AwJAIAJB////B0sEQCABIQYMAQsgACACQQh0IgI2AgAgACABQQFqIgY2AhAgACAAKAIMIAFqLQAAIARBCHRyIgQ2AgQLAkAgCy8BkAQiASACQQt2bCIFIARLBEAgCyABQYAQIAFrQQV2ajsBkAQgBUH///8HTQRAIAAgBUEIdCIFNgIAIAAgBkEBajYCECAAIAAoAgwgBmotAAAgBEEIdHIiBDYCBAsgDC8B2AQiAyAFQQt2bCIBIARNBEAgACAEIAFrNgIEIAAgBSABazYCACAMIAMgA0EFdms7AdgEDAILIAAgATYCACAMIANBgBAgA2tBBXZqOwHYBCAAQQE2AmggAEEJQQsgACgCZEEHSRs2AmQMAwsgACAEIAVrIgQ2AgQgCyABIAFBBXZrOwGQBAJAIAIgBWsiAkH///8HSwRAIAYhAQwBCyAAIAJBCHQiAjYCACAAIAZBAWoiATYCECAAIAAoAgwgBmotAAAgBEEIdHIiBDYCBAsCQCALLwGoBCIGIAJBC3ZsIgMgBEsEQCAAIAM2AgAgCyAGQYAQIAZrQQV2ajsBqAQgACgCWCECDAELIAAgBCADayIENgIEIAsgBiAGQQV2azsBqAQgAiADayICQf///wdNBEAgACACQQh0IgI2AgAgACABQQFqNgIQIAAgACgCDCABai0AACAEQQh0ciIENgIECwJAIAsvAcAEIgMgAkELdmwiASAESwRAIAAgATYCACALIANBgBAgA2tBBXZqOwHABCAAKAJcIQIMAQsgACAEIAFrNgIEIAAgAiABazYCACALIAMgA0EFdms7AcAEIAAoAmAhAiAAIAAoAlw2AmALIAAgACgCWDYCXAsgACAAKAJUNgJYIAAgAjYCVAsgAEEIQQsgACgCZEEHSRs2AmQgACAPIAgQCQwBCyAAIAM2AgAgBiAKQYAQIAprQQV2ajsB+AMgACAAKAJcNgJgIAAgACkCVDcCWCAAQQdBCiAAKAJkQQdJGzYCZCAAIA4gCBAJIAAoAmgiAUECa0EDIAFBBkkbIQMgACgCACECQQEhBANAIARBAXQiBCAAIANBB3RqaiEGAkAgAkGAgIAITwRAIAAoAgQhBQwBCyAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgACgCBEEIdHIiBTYCBAsCQCAGLwHYByIIIAJBC3ZsIgEgBU0EQCAAIAUgAWsiBTYCBCAAIAIgAWsiAjYCACAGIAggCEEFdms7AdgHIARBAXIhBAwBCyAAIAE2AgAgBiAIQYAQIAhrQQV2ajsB2AcgASECCyAEQcAASQ0ACyAEQUBqIgNBA00EQCAAIAM2AlQMAQsgACAEQQFxQQJyIgc2AlQgA0EBdiEBIANBDU0EQCAAIAcgAUEBayIKdCIINgJUQQEhByAQIAhBAXRqQQAgBGtBAXRqQYIMaiEGQQAhCwNAIAYgB0EBdCIHaiEMAkAgAkH///8HSwRAIAIhAQwBCyAAIAJBCHQiATYCACAAIAAoAhAiA0EBajYCECAAIAMgACgCDGotAAAgBUEIdHIiBTYCBAsCQCAMLwEAIgMgAUELdmwiAiAFTQRAIAAgBSACayIFNgIEIAAgASACayICNgIAIAwgAyADQQV2azsBACAAQQEgC3QgCGoiCDYCVCAHQQFyIQcMAQsgACACNgIAIAwgA0GAECADa0EFdmo7AQALIAtBAWoiCyAKRw0ACwwBCyABQQVrIQQDQAJAIAJB////B0sEQCACIQMMAQsgACACQQh0IgM2AgAgACAAKAIQIgFBAWo2AhAgASAAKAIMai0AACAFQQh0ciEFCyAAIANBAXYiAjYCACAAIAUgAmsiBkEfdSIBIAdBAXRqQQFqIgc2AlQgACABIAJxIAZqIgU2AgQgBEEBayIEDQALIAAgB0EEdCIHNgJUIANB////D00EQCAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsgAAJ/IAAvAb4NIgEgAkELdmwiBCAFTQRAIAAgBSAEayIFNgIEIAAgB0EBciIHNgJUIAAgASABQQV2azsBvg0gAiAEayEEQQMMAQsgACABQYAQIAFrQQV2ajsBvg1BAgtBAXQiA2pBvA1qIQYgBEH///8HTQRAIAAgBEEIdCIENgIAIAAgACgCECIBQQFqNgIQIAAgASAAKAIMai0AACAFQQh0ciIFNgIECwJAIAYvAQAiASAEQQt2bCICIAVNBEAgACAFIAJrIgU2AgQgBiABIAFBBXZrOwEAIAAgB0ECaiIHNgJUIAQgAmshAiADQQFyIQMMAQsgBiABQYAQIAFrQQV2ajsBAAsgACADQQF0IgNqQbwNaiEGIAJB////B00EQCAAIAJBCHQiAjYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsCQCAGLwEAIgEgAkELdmwiBCAFTQRAIAAgBSAEayIFNgIEIAYgASABQQV2azsBACAAIAdBBGoiBzYCVCACIARrIQQgA0EBciEDDAELIAYgAUGAECABa0EFdmo7AQALIARB////B00EQCAAIARBCHQiBDYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgBUEIdHIiBTYCBAsgACADQQF0akG8DWoiAS8BACICIARBC3ZsIgMgBU0EQCAAIAUgA2s2AgQgACAEIANrNgIAIAEgAiACQQV2azsBACAAIAdBCGo2AlQMAQsgACADNgIAIAEgAkGAECACa0EFdmo7AQALQQAhAiAAKAJUIgYgACgCJE8NAyAAKAIwIAZNDQMgACAAKAJoIgMgACgCKCAAKAIgIgprIgEgAyABIANJGyIIazYCaCAKIAZBf3NqIQIgBiAKTwRAIAAoAiwgAmohAgsgACgCGCIDIAJqLQAAIQEgACAKQQFqNgIgIAMgCmogAToAAAJAIAhBAWsiBUUNACAFQQFxBEAgACgCGCIGQQAgAkEBaiIBIAEgACgCLEYbIgJqLQAAIQMgACAAKAIgIgFBAWo2AiAgASAGaiADOgAAIAhBAmshBQsgCEECRg0AA0AgACgCGCIGQQAgAkEBaiIBIAEgACgCLEYbIgJqLQAAIQMgACAAKAIgIgFBAWo2AiAgASAGaiADOgAAIAAoAhgiBkEAIAJBAWoiASABIAAoAixGGyICai0AACEDIAAgACgCICIBQQFqNgIgIAEgBmogAzoAACAFQQJrIgUNAAsLIAAoAiAiCSAAKAIkTQ0AIAAgCTYCJAsgCSAAKAIoSQ0ACwtBASECIAAoAgAiAUH///8HSw0AIAAgAUEIdDYCACAAIAAoAhAiAUEBajYCECAAIAEgACgCDGotAAAgACgCBEEIdHI2AgQLIAILJgEBfyAABEAgACgCsAkiASgCPARAIAEoAhgQBQsgARAFIAAQBQsLMgEBfyAAIAApA4ABIAIgACgCECICayIDrXw3A4ABIAAgASACaiADIAAoAhgQA603AxgLgQEBAn8CQAJAIAJBBE8EQCAAIAFyQQNxDQEDQCAAKAIAIAEoAgBHDQIgAUEEaiEBIABBBGohACACQQRrIgJBA0sNAAsLIAJFDQELA0AgAC0AACIDIAEtAAAiBEYEQCABQQFqIQEgAEEBaiEAIAJBAWsiAg0BDAILCyADIARrDwtBAAsJAEG8oCAoAgALCQBBsKAgKAIAC9QzAhR/An4CQAJAAkACQAJAAkACQAJAAn8Cf0HQoMAAKAIAIgEoAiQEQCABKAIADAELIAFBADoAKCABQgA3AwAgAUIANwMYIAFByABqQeQAEAcgAUEMNgKsAUEACyEAQcCgICgCACENIAFBtKAgKAIAIg42AhAgAUHgAGohDyABQbYBaiEQIAFBsAFqIREgAUGoAWohCANAAkACQAJAAkACQAJAAkACQAJAAkAgCAJ/AkACQAJAIAAOCgECAAoLDAQFBgcOC0GwoCAoAgAhAyABKAKsASECQbSgICgCACEAQbigICgCACEGIAEoAqgBDAILIAggASgCqAEiAGpBCGpBtKAgKAIAIgJBsKAgKAIAakG4oCAoAgAgAmsiAiABKAKsASAAayIAIAAgAksbIgAQAkG0oCBBtKAgKAIAIABqNgIAQQAhAyABQQAgASgCqAEgAGoiACAAIAEoAqwBIgJGGzYCqAEgACACRw0LIAFBATYCACARQYAIQQYQDQRAQQUhAwwMCyAQQQJBABADIAEoALgBRwRAQQchAwwMC0EGIQMgEC0AAA0LIAEgAS0AtwEiADYCICAAQQ9LDQtBAiEDIABBBEsNC0EBIAB0QRNxRQ0LC0G0oCAoAgAiAEG4oCAoAgAiBkYEQEEAIQMMCwtBsKAgKAIAIgMgAGotAAAiAkUEQEG0oCAgAEEBajYCACABIAA2AhBBBiEAIAFBBjYCAAwMCyABQQA2AqgBIAFBAjYCACABIAJBAnRBBGoiAjYCrAEgASACNgJAQQALIgVqQQhqIAAgA2ogBiAAayIAIAIgBWsiAiAAIAJJGyIAEAJBtKAgIABBtKAgKAIAajYCAEEAIQMgAUEAIAEoAqgBIABqIgAgACABKAKsASICRhs2AqgBIAAgAkcNCSABIABBBGsiADYCrAEgESAAQQAQAyABIAEoAqwBIgVqKACwAUcEQEEHIQMMCgsgAUECNgKoASABLACxASIEQT9xBEBBBiEDDAoLQQIhAEJ/IRVCfyEUIARBwABxRQ0FIAEoAgQiAkUEQCABQgA3AwgLIAVBAiAFQQJLGyEGA0AgACAGRgRAQQchAwwLCyAAIAhqLQAIIQMgASAAQQFqIgA2AqgBIAEgASkDCCADQf8Aca0gAq2GhCIUNwMIIANBgAFxRQRAAkAgAw0AIAJFDQBBByEDDAwLIAFBADYCBAwHC0EHIQMgASACQQdqIgI2AgQgAkE/Rw0ACwwJCwJ/IAFBkAFqIQYDQEG4oCAoAgAhAkGwoCAoAgAhBCABKAIEIgVFBEAgAUIANwMIC0G0oCAoAgAiACACIAAgAksbIQICQANAAkAgACACRgRAQQAhAyACIQAMAQsgACAEai0AACEDQbSgICAAQQFqIgA2AgAgASABKQMIIANB/wBxrSAFrYaEIhQ3AwggA0GAAXFFBEAgAw0DIAVFDQNBByEDDAELQQchAyABIAVBB2oiBTYCBCAFQT9HDQELCyABIAEpA4ABIAAgASgCECIAayICrXw3A4ABIAEgACAEaiACIAEoAhgQA603AxggAwwCCyABQQA2AgQCQAJAAkACQAJAIAEoAngOAwACAQMLIAEgFDcDiAFBByABKQNYIBRSDQUaIAFBATYCeAwDCyABIAEpA5gBIBR8NwOYASABIAZBGCABKAKgARADNgKgASABQQE2AnggASABKQOIAUIBfSIUNwOIAQwCCyABQQI2AnggASABKQOQASAUfDcDkAELIAEpA4gBIRQLIBRCAFINAAtBAQsiA0EBRw0IIAFBBzYCAAsCQCABKQOAASIUQbSgICgCACIAIAEoAhAiBGutfEIDg1ANAEGwoCAoAgAhBkG4oCAoAgAgAEYEQCAAIQIMBAtBtKAgIABBAWoiAjYCAEEHIQMgACAGai0AAA0IAkAgFCACIARrrXxCA4NQDQBBsKAgKAIAIQYgAkG4oCAoAgBGDQRBtKAgIABBAmoiBTYCACACIAZqLQAADQkgFCAFIARrrXxCA4NQBEAgBSEADAILQbCgICgCACEGQbigICgCACAFRgRAIAUhAgwFC0G0oCAgAEEDaiICNgIAIAUgBmotAAANCSAUIAIgBGutfEIDg1ANAEG4oCAoAgAgAkYEQEGwoCAoAgAhBgwFC0G0oCAgAEEEajYCAAwJCyACIQALIAFBsKAgKAIAIAAQDEEHIQMgDyABQZABakEYEA0NByABQQg2AgALAn9BtKAgKAIAIQBBuKAgKAIAIQUDQEEAIAAgBUYNARogASkDGCEUIAEoAgQhA0G0oCAgAEEBaiICNgIAQQdBsKAgKAIAIABqLQAAIBQgA62Ip0H/AXFHDQEaIAEgA0EIaiIDNgIEIAIhACADQSBJDQALIAFBADYCBCABQgA3AxhBAQsiA0EBRw0GIAFBCTYCACABQQw2AqwBC0EAIQMgASABKAKoASIAakGwAWpBtKAgKAIAIgJBsKAgKAIAakG4oCAoAgAgAmsiAiABKAKsASAAayIAIAAgAksbIgAQAkG0oCBBtKAgKAIAIABqNgIAIAFBACABKAKoASAAaiIAIAAgASgCrAFGIgAbNgKoASAARQ0FQQchAAJAIAEvALoBQdm0AUcNACABQbQBakEGQQAQAyABKACwAUcNACABNQC0ASABKQOAAUICiFINACABLQC4AQ0AQQFBByABKAIgIAEtALkBRhshAAsgACEDDAULIAEgBiACEAxBACEDDAQLIAEgFDcDMCAEQQBIBEAgASgCBCICRQRAIAFCADcDCAsgACAFIAAgBUsbIQQDQCAAIARGBEBBByEDDAYLIAAgCGotAAghAyABIABBAWoiADYCqAEgASABKQMIIANB/wBxrSACrYaEIhU3AwgCQCADQYABcUUEQCADDQEgAkUNAUEHIQMMBwtBByEDIAEgAkEHaiICNgIEIAJBP0cNAQwGCwsgAUEANgIECyABIBU3AzggBSAAa0ECSQRAQQchAwwECyABIABBAWoiAjYCqAEgACAIai0ACEEhRwRAQQYhAwwECyABIABBAmoiBDYCqAEgAiAIai0ACEEBRwRAQQYhAwwEC0EHIQMgBCAFRg0DIAEgAEEDajYCqAEgASgCsAkhAEEGIQICQCAEIAhqLQAIIgNBJ0sNACAAIANBAXFBAnIgA0EBdkELanQiBTYCMAJ/AkAgACgCPCIDRQ0AQQQhAiAFIAAoAjRLDQIgACAFNgIsIANBAkcNACAFIABBOGoiAygCAE0NACAAKAIYEAUgACAAKAIwEAYiAjYCGCACDQBBAwwBCyAAQQA2AkAgAEEBOgBQIABBADYCaCAAQeTdAWohA0EACyECIANBADYCAAsgAiIDDQMgASgCqAEiACABKAKsASICIAAgAksbIQMCQANAIAAgA0YNASABIABBAWoiAjYCqAEgACAIaiEFIAIhACAFLQAIRQ0AC0EGIQMMBAsgAUEANgKoASABQgA3A1AgAUIANwNIIAFBAzYCAAsgAUG0oCAoAgA2AhAgAUHAoCAoAgA2AhQCfyABKAKwCSIEQejdAWohBSAEQfgAaiEKIARB5N0BaiELA38gBCgCQCEDAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQbSgICgCACIAQbigICgCACICTwRAIANBB0YNAUEADBELIAMOCQECAwQFBgcACQ8LIAQoAkwhAwwHC0EBIQZBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIgBFDQggAEEBRyAAQd8BTXFFBEAgBEGAAjsBUCAEKAI8RQRAIARBwKAgKAIAIgJBvKAgKAIAajYCGCAEQcSgICgCACACazYCLAsgBEIANwIcIARCADcCJAwLCyAELQBQRQ0KQQcMDgtBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIQAgBEECNgJAIAQgBCgCSCAAQQh0ajYCSAwMC0G0oCAgAEEBajYCAEGwoCAoAgAgAGotAAAhACAEQQM2AkAgBCAAIAQoAkhqQQFqNgJIDAsLQbSgICAAQQFqNgIAQbCgICgCACAAai0AACEAIARBBDYCQCAEIABBCHQ2AkwMCgtBtKAgIABBAWo2AgBBsKAgKAIAIABqLQAAIQAgBCAEKAJENgJAIAQgACAEKAJMakEBajYCTAwJC0G0oCAgAEEBajYCAEEHIQZBsKAgKAIAIABqLQAAIgBB4AFLDQNBACEDIARBfyAAQS1JBH9BAAUgAEEtayIAIABB/wFxQS1uIgJBLWxrIQAgAkEBagt0QX9zNgJ0IABB/wFxQQlPBEAgAEEJayIAIABB/wFxQQluIgJBCWxrIQAgAkEBaiEDCyAEIAM2AnAgBCAAQf8BcSIANgJsIAAgA2pBBEsNAyAEQX8gA3RBf3M2AnBBACEAIARBADYCZCAEQgA3AlwgBEIANwJUA0AgCiAAQQF0IgJqQYAIOwEAIAogAkECcmpBgAg7AQAgAEECaiIAQbbuAEcNAAsgBEEGNgJAIARBBTYCCCAEQv////8PNwIAC0EHIAQoAkwiBkEFSQ0IGiAEKAIIIgMEQEG0oCAoAgAhAEG4oCAoAgAhBwNAQQAgACAHRg0KGiAEKAIEIQxBtKAgIABBAWoiAjYCAEGwoCAoAgAgAGotAAAhACAEIANBAWsiAzYCCCAEIAAgDEEIdHI2AgQgAiEAIAMNAAsLIARBBzYCQCAEIAZBBWsiAzYCTAsgBCAEKAIgIgBBxKAgKAIAQcCgICgCAGsiAiAEKAJIIgYgAiAGSRsiAmogBCgCLCIGIAYgAGsgAksbNgIoQbigICgCACIGQbSgICgCACICayEAAkACQCAEKALk3QEiB0UEQCADDQFBACEDCyAHIAtqQQRqQbCgICgCACACaiAAIAMgB2siAkEqIAdrIgMgAiADSRsiAiAAIAJJGyIAEAICfyAAIAQoAuTdASIDaiICIAQoAkxGBEAgAyALaiAAakEEakE/IAJrEAcgBCgC5N0BIABqDAELIAJBFE0EQCAEIAI2AuTdAUG0oCBBtKAgKAIAIABqNgIADAMLIAJBFWsLIQIgBEEANgIQIAQgBTYCDCAEIAI2AhRBByEGIAQQCkUNAyAEKAIQIgcgACAEKALk3QEiAmpLDQMgBCAEKAJMIAdrIgM2AkwgAiAHSwRAIAQgAiAHayIANgLk3QECQCAFIgIgByALakEEaiIDRg0AIAMgACACaiIHa0EAIABBAXRrTQRAIAIgAyAAEAIMAQsgAiADc0EDcSEGAkACQCACIANJBEAgBg0CIAJBA3FFDQEDQCAARQ0EIAIgAy0AADoAACADQQFqIQMgAEEBayEAIAJBAWoiAkEDcQ0ACwwBCwJAIAYNACAHQQNxBEADQCAARQ0FIAIgAEEBayIAaiIGIAAgA2otAAA6AAAgBkEDcQ0ACwsgAEEDTQ0AA0AgAiAAQQRrIgBqIAAgA2ooAgA2AgAgAEEDSw0ACwsgAEUNAgNAIAIgAEEBayIAaiAAIANqLQAAOgAAIAANAAsMAgsgAEEDTQ0AA0AgAiADKAIANgIAIANBBGohAyACQQRqIQIgAEEEayIAQQNLDQALCyAARQ0AA0AgAiADLQAAOgAAIAJBAWohAiADQQFqIQMgAEEBayIADQALCwwCC0G0oCBBtKAgKAIAIAcgAmtqIgI2AgAgBEEANgLk3QFBuKAgKAIAIgYgAmshAAsgAEEVTwRAQbCgICgCACEHIAQgAjYCECAEIAc2AgwgBCAGQRVrIAIgA2ogACADQRVqSRs2AhRBByEGIAQQCkUNAyAEKAJMIgAgBCgCECICQbSgICgCAGsiA0kNAyAEIAAgA2siAzYCTEG0oCAgAjYCAEG4oCAoAgAgAmsiAEEUSw0BCyAFQbCgICgCACACaiADIAAgACADSxsiABACIAQgADYC5N0BQbSgIEG0oCAoAgAgAGo2AgALIAQoAiAiAiAEKAIcIgNrIQAgBCAEKAI8BH8gBCgCLCACRgRAIARBADYCIAtBvKAgKAIAQcCgICgCAGogBCgCGCADaiAAEAIgBCgCIAUgAgs2AhxBwKAgQcCgICgCACAAaiICNgIAIAQgBCgCSCAAayIANgJIIABFBEBBByEGIAQoAkwNAiAEKAJoDQIgBCgCBA0CIARBADYCQAwFC0EAIQYgAkHEoCAoAgBGDQFBtKAgKAIAQbigICgCAEcNBiAEKALk3QEgBCgCTE8NBgwBCyAEKAJMIgNFDQFBACEGIAAgAk8NAANAQcSgICgCACIHQcCgICgCACIMTQ0BIAQgAyADIAQoAiwgBCgCICISayITIAIgAGsiAiAHIAxrIgcgAiAHSRsiAiACIBNLGyICIAIgA0sbIgJrNgJMIBIgBCgCGGpBsKAgKAIAIABqIAIQAiAEIAQoAiAgAmoiADYCICAAIAQoAiRLBEAgBCAANgIkCyAEIAQoAjwEfyAEKAIsIABGBEAgBEEANgIgC0G8oCAoAgBBwKAgKAIAakGwoCAoAgBBtKAgKAIAaiACEAIgBCgCIAUgAAs2AhxBwKAgQcCgICgCACACajYCAEG0oCBBtKAgKAIAIAJqIgA2AgAgBCgCTCIDRQ0CQbigICgCACICIABLDQALCyAGDAULIARBADYCQAwDCyAAQRh0QRh1QQBODQEgBEEBNgJAIAQgAEEQdEGAgPwAcTYCSCAAQcABTwRAIARBBTYCRCAEQQA6AFEMAwtBByAELQBRDQMaIARBBjYCRCAAQaABSQ0CIARCADcCVEEAIQAgBEEANgJkIARCADcCXANAIAogAEEBdCICakGACDsBACAKIAJBAnJqQYAIOwEAIABBAmoiAEG27gBHDQALCyAEQQU2AgggBEL/////DzcCAAwBCyAAQQJLBH9BBwUgBEKDgICAgAE3AkAMAQsLCyEDIAEgASkDSEG0oCAoAgAgASgCEGutfCIUNwNIIAEgASkDUEHAoCAoAgAgASgCFCICayIArXwiFTcDUCABKQMwIBRUBEBBByEDDAMLIAEpAzggFVQEQEEHIQMMAwsCQCABAn4CQAJAIAEoAiBBAWsOBAADAwEDC0G8oCAoAgAgAmogACABKAIYEAOtDAELQbygICgCACACaiEFIAEpAxhCf4UhFAJAIABFDQAgAEEBcQR/IAUxAAAgFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUhFCAFQQFqIQUgAEEBawUgAAshAiAAQQFGDQADQCAFMQABIAUxAAAgFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUiFEL/AYOFp0EDdEGwEGopAwAgFEIIiIUhFCAFQQJqIQUgAkECayICDQALCyAUQn+FCzcDGAsgA0EBRw0CAkAgASkDMCIUQn9RDQAgFCABKQNIUQ0AQQchAwwDCyABKQNQIRUCQCABKQM4IhRCf1EEQCAVIRQMAQtBByEDIBQgFVINAwsgASABKQNoIBR8NwNoIAEgASgCIEGQCGoxAAAgASkDYCABKQNIIAE1AkB8fHw3A2AgASAPQRggASgCcBADNgJwIAFBBDYCACABIAEpA1hCAXw3A1gLAkAgASkDSCIUQgODUA0AQQAhA0G0oCAoAgAiAEG4oCAoAgAiAkYNAkG0oCAgAEEBaiIFNgIAQbCgICgCACAAai0AAARAQQchAwwDCyABIBRCAXwiFTcDSCAVQgODUA0AIAIgBUYNAkG0oCAgAEECaiIENgIAQbCgICgCACAFai0AAARAQQchAwwDCyABIBRCAnwiFTcDSCAVQgODUA0AIAIgBEYNAkG0oCAgAEEDaiIFNgIAQbCgICgCACAEai0AAARAQQchAwwDCyABIBRCA3wiFTcDSCAVQgODUA0AIAIgBUYNAkG0oCAgAEEEajYCAEEHIQNBsKAgKAIAIAVqLQAADQIgASAUQgR8NwNICyABQQU2AgALAkACQAJAAkACQCABKAIgIgBBAWsOBAACAgECC0G0oCAoAgAhAEG4oCAoAgAhBQNAIAAgBUYEQEEAIQMMBgsgASkDGCEUIAEoAgQhA0G0oCAgAEEBaiICNgIAQbCgICgCACAAai0AACAUIAOtiKdB/wFxRwRAQQchAwwGCyABIANBCGoiAzYCBCACIQAgA0EgSQ0ACyABQgA3AxgMAgtBtKAgKAIAIQBBuKAgKAIAIQUDQCAAIAVGBEBBACEDDAULIAEpAxghFCABKAIEIQNBtKAgIABBAWoiAjYCAEGwoCAoAgAgAGotAAAgFCADrYinQf8BcUcEQEEHIQMMBQsgASADQQhqIgM2AgQgAiEAIANBwABJDQALIAFCADcDGAwBCyABKAIEIgIgAEGQCGotAAAiBU8NAEEAIQNBtKAgKAIAIgBBuKAgKAIAIgRGDQIDQAJAIABBAWohACACQQFqIgIgBUYNACAAIARHDQEMAwsLQbSgICAANgIACyABQQA2AgRBASEAIAFBATYCAAwCC0G0oCAgBDYCACABIAI2AgRBASEAIAIgBUkNACABQQE2AgAMAQsLAkAgASgCJEUEQAJAAkAgAw4CAAMBC0EHQQhBtKAgKAIAQbigICgCAEYbIQMLQcCgICANNgIAQbSgICAONgIAIAMMAgsCQCADDQAgDkG0oCAoAgBHDQAgDUHAoCAoAgBHDQAgAS0AKCEAIAFBAToAKCAAQQN0DAILIAFBADoAKAsgAwsOCQcGBwABAgMEBAULQQEhCQwFC0ECIQkMBAtBBCEJDAMLQQUhCQwCC0EGIQkMAQtBByEJC0HQoMAAKAIAEAsLIAkL9wQCA38DfkHAoCBCgICAgICAgAQ3AgBBvKAgQdCgIDYCAEG0oCBCADcCAEGwoCBBsCA2AgADQCAAQQJ0QbAIakEAQQBBAEEAIABBAXYiAUEBcWtBoIbi7X5xQQAgAEEBcWtBoIbi7X5xIAFzQQF2IgFzQQF2IgJBAXFrQaCG4u1+cUEAIAFBAXFrQaCG4u1+cSACc0EBdiIBc0EBdiICQQFxa0GghuLtfnFBACABQQFxa0GghuLtfnEgAnNBAXYiAXNBAXYiAkEBcWtBoIbi7X5xQQAgAUEBcWtBoIbi7X5xIAJzQQF2czYCACAAQQFqIgBBgAJHDQALA0AgBadBA3RBsBBqQgBCAEIAQgAgBUIBiCIDQgGDfULCnpy83fKVtkmDQgAgBUIBg31Cwp6cvN3ylbZJgyADhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiCIDhUIBiCIEQgGDfULCnpy83fKVtkmDQgAgA0IBg31Cwp6cvN3ylbZJgyAEhUIBiIU3AwAgBUIBfCIFQoACUg0AC0HQoMAAAn9BuAkQBiIABEAgAEECNgIkIABBqN4BEAYiAQR/IAFBgICABDYCNCABQQI2AjwgAUEANgIYIAFBADYCOCABBUEACyIBNgKwCSABBEAgAEEAOgAoIABCADcDACAAQgA3AxggAEHIAGpB5AAQByAAQQw2AqwBIAAMAgsgABAFC0EACyIANgIAIAAEf0EABUEAEAtBAQsLEAAjACAAa0FwcSIAJAAgAAsGACAAJAALBAAjAAsRAEG0oCAoAgBBuKAgKAIARgsJAEHAoCAoAgALFwBBxKAgIABBgIAgIABBgIAgSRs2AgALCwBBwKAgIAA2AgALFwBBuKAgIABBgIAgIABBgIAgSRs2AgALCwBBtKAgIAA2AgALCyoDAEGACAsF/Td6WFoAQZEICw8EBAQICAgQEBAgICBAQEAAQaAICwNQEmA=") || (O = D, D = t.locateFile ? t.locateFile(O, m) : m + O);
    var k = [];
    function W(e2) {
      var t2 = k[e2];
      return t2 || (e2 >= k.length && (k.length = e2 + 1), k[e2] = t2 = M.get(e2)), t2;
    }
    function Q(e2) {
      try {
        return _.grow(e2 - b.byteLength + 65535 >>> 16), I(_.buffer), 1;
      } catch (e3) {
      }
    }
    var H = "function" == typeof atob ? atob : function(e2) {
      var t2, n2, o2, r2, i2, a2, s2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", l2 = "", c2 = 0;
      e2 = e2.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      do {
        t2 = s2.indexOf(e2.charAt(c2++)) << 2 | (r2 = s2.indexOf(e2.charAt(c2++))) >> 4, n2 = (15 & r2) << 4 | (i2 = s2.indexOf(e2.charAt(c2++))) >> 2, o2 = (3 & i2) << 6 | (a2 = s2.indexOf(e2.charAt(c2++))), l2 += String.fromCharCode(t2), 64 !== i2 && (l2 += String.fromCharCode(n2)), 64 !== a2 && (l2 += String.fromCharCode(o2));
      } while (c2 < e2.length);
      return l2;
    };
    function X(e2) {
      if (V(e2)) return function(e3) {
        if ("boolean" == typeof p && p) {
          var t2 = Buffer.from(e3, "base64");
          return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
        }
        try {
          for (var n2 = H(e3), o2 = new Uint8Array(n2.length), r2 = 0; r2 < n2.length; ++r2) o2[r2] = n2.charCodeAt(r2);
          return o2;
        } catch (e4) {
          throw new Error("Converting base64 string to bytes failed.");
        }
      }(e2.slice(F.length));
    }
    var Y = { b: function(e2, t2, n2) {
      S.copyWithin(e2, t2, t2 + n2);
    }, a: function(e2) {
      var t2 = S.length, n2 = 2147483648;
      if ((e2 >>>= 0) > n2) return false;
      for (var o2 = 1; o2 <= 4; o2 *= 2) {
        var r2 = t2 * (1 + 0.2 / o2);
        if (r2 = Math.min(r2, e2 + 100663296), Q(Math.min(n2, T(Math.max(e2, r2), 65536)))) return true;
      }
      return false;
    } };
    !function() {
      var e2 = { a: Y };
      function n2(e3, n3) {
        var o2, r3 = e3.exports;
        t.asm = r3, I((_ = t.asm.c).buffer), M = t.asm.o, o2 = t.asm.d, R.unshift(o2), function() {
          if (B--, t.monitorRunDependencies && t.monitorRunDependencies(B), 0 == B && P) {
            var e4 = P;
            P = null, e4();
          }
        }();
      }
      function r2(e3) {
        n2(e3.instance);
      }
      function i2(t2) {
        return function() {
          if (!g && (h || f)) {
            if ("function" == typeof fetch && !U(D)) return fetch(D, { credentials: "same-origin" }).then(function(e3) {
              if (!e3.ok) throw "failed to load wasm binary file at '" + D + "'";
              return e3.arrayBuffer();
            }).catch(function() {
              return G(D);
            });
            if (a) return new Promise(function(e3, t3) {
              a(D, function(t4) {
                e3(new Uint8Array(t4));
              }, t3);
            });
          }
          return Promise.resolve().then(function() {
            return G(D);
          });
        }().then(function(t3) {
          return WebAssembly.instantiate(t3, e2);
        }).then(function(e3) {
          return e3;
        }).then(t2, function(e3) {
          A("failed to asynchronously prepare wasm: " + e3), N(e3);
        });
      }
      if (B++, t.monitorRunDependencies && t.monitorRunDependencies(B), t.instantiateWasm) try {
        return t.instantiateWasm(e2, n2);
      } catch (e3) {
        return A("Module.instantiateWasm callback failed with error: " + e3), false;
      }
      (g || "function" != typeof WebAssembly.instantiateStreaming || V(D) || U(D) || "function" != typeof fetch ? i2(r2) : fetch(D, { credentials: "same-origin" }).then(function(t2) {
        return WebAssembly.instantiateStreaming(t2, e2).then(r2, function(e3) {
          return A("wasm streaming compile failed: " + e3), A("falling back to ArrayBuffer instantiation"), i2(r2);
        });
      })).catch(o);
    }(), t.___wasm_call_ctors = function() {
      return (t.___wasm_call_ctors = t.asm.d).apply(null, arguments);
    }, t._init_decompressor = function() {
      return (t._init_decompressor = t.asm.e).apply(null, arguments);
    }, t._decompress = function() {
      return (t._decompress = t.asm.f).apply(null, arguments);
    }, t._get_in_buffer_ptr = function() {
      return (t._get_in_buffer_ptr = t.asm.g).apply(null, arguments);
    }, t._get_out_buffer_ptr = function() {
      return (t._get_out_buffer_ptr = t.asm.h).apply(null, arguments);
    }, t._in_buffer_set_pos = function() {
      return (t._in_buffer_set_pos = t.asm.i).apply(null, arguments);
    }, t._in_buffer_set_size = function() {
      return (t._in_buffer_set_size = t.asm.j).apply(null, arguments);
    }, t._out_buffer_set_pos = function() {
      return (t._out_buffer_set_pos = t.asm.k).apply(null, arguments);
    }, t._out_buffer_set_size = function() {
      return (t._out_buffer_set_size = t.asm.l).apply(null, arguments);
    }, t._get_curr_output_length = function() {
      return (t._get_curr_output_length = t.asm.m).apply(null, arguments);
    }, t._is_input_end_reached = function() {
      return (t._is_input_end_reached = t.asm.n).apply(null, arguments);
    };
    var j, $ = t.stackSave = function() {
      return ($ = t.stackSave = t.asm.p).apply(null, arguments);
    }, K = t.stackRestore = function() {
      return (K = t.stackRestore = t.asm.q).apply(null, arguments);
    }, q = t.stackAlloc = function() {
      return (q = t.stackAlloc = t.asm.r).apply(null, arguments);
    };
    function Z(e2) {
      this.name = "ExitStatus", this.message = "Program terminated with exit(" + e2 + ")", this.status = e2;
    }
    function J(e2) {
      function o2() {
        j || (j = true, t.calledRun = true, v || (z(R), n(t), t.onRuntimeInitialized && t.onRuntimeInitialized(), function() {
          if (t.postRun) for ("function" == typeof t.postRun && (t.postRun = [t.postRun]); t.postRun.length; ) e3 = t.postRun.shift(), L.unshift(e3);
          var e3;
          z(L);
        }()));
      }
      B > 0 || (!function() {
        if (t.preRun) for ("function" == typeof t.preRun && (t.preRun = [t.preRun]); t.preRun.length; ) e3 = t.preRun.shift(), w.unshift(e3);
        var e3;
        z(w);
      }(), B > 0 || (t.setStatus ? (t.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          t.setStatus("");
        }, 1), o2();
      }, 1)) : o2()));
    }
    if (t.cwrap = function(e2, t2, n2, o2) {
      var r2 = (n2 = n2 || []).every(function(e3) {
        return "number" === e3;
      });
      return "string" !== t2 && r2 && !o2 ? x(e2) : function() {
        return y(e2, t2, n2, arguments);
      };
    }, P = function e2() {
      j || J(), j || (P = e2);
    }, t.run = J, t.preInit) for ("function" == typeof t.preInit && (t.preInit = [t.preInit]); t.preInit.length > 0; ) t.preInit.pop()();
    return J(), t.ready;
  };
})();
var ERR_CODES = ["", "Memory allocation failed", "Memory usage limit reached", "Unsupported check; not verifying file integrity", "Not an .xz file", "Unsupported options in the .xz headers", "File is corrupt", "Unknown decompression bug"];
var XZLoader = class {
  constructor(e) {
    this.manager = void 0 !== e ? e : DefaultLoadingManager, this.crossOrigin = "Anonymous", this.xz = null;
  }
  init() {
    return this.xz ? Promise.resolve() : Module().then((e) => {
      this._emInitDecompressor = e.cwrap("init_decompressor", "number"), this._emDecompress = e.cwrap("decompress", "number"), this._emGetInBufferPtr = e.cwrap("get_in_buffer_ptr", "number"), this._emGetOutBufferPtr = e.cwrap("get_out_buffer_ptr", "number"), this._emInBufferSetPos = e.cwrap("in_buffer_set_pos", null, ["number"]), this._emInBufferSetSize = e.cwrap("in_buffer_set_size", null, ["number"]), this._emOutBufferSetPos = e.cwrap("out_buffer_set_pos", null, ["number"]), this._emOutBufferSetSize = e.cwrap("out_buffer_set_size", null, ["number"]), this._emGetCurrOutputLength = e.cwrap("get_curr_output_length", "number"), this._emIsInputEndReached = e.cwrap("is_input_end_reached", "number"), this.xz = e;
    });
  }
  load(e, t, n, o) {
    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
    const r = this, i = Cache.get(e);
    if (void 0 !== i) return r.manager.itemStart(e), setTimeout(function() {
      t && t(i), r.manager.itemEnd(e);
    }, 0), i;
    const a = this.init(), s = new XMLHttpRequest();
    return s.open("GET", e, true), s.addEventListener("load", function(i2) {
      const s2 = i2.target.response;
      200 === this.status || 0 === this.status ? (0 === this.status && console.warn("v3d.XZLoader: HTTP Status 0 received."), a.then(() => {
        r.decompressArrayBuffer(s2, function(n2) {
          setTimeout(function() {
            t && t(n2), r.manager.itemEnd(e), Cache.add(e, n2);
          }, 1);
        }, function(e2) {
          if (n) {
            n((2 + 1 * e2) / 3);
          }
        }, function(t2) {
          o && o(t2), r.manager.itemEnd(e), r.manager.itemError(e);
        });
      })) : (o && o(i2), r.manager.itemEnd(e), r.manager.itemError(e));
    }, false), n && s.addEventListener("progress", function(e2) {
      let t2;
      t2 = e2.lengthComputable ? e2.loaded / e2.total : 1;
      n(2 * t2 / 3);
    }, false), s.addEventListener("error", function(t2) {
      o && o(t2), r.manager.itemEnd(e), r.manager.itemError(e);
    }, false), s.responseType = "arraybuffer", s.send(null), r.manager.itemStart(e), s;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  decompressArrayBuffer(e, t, n, o) {
    const r = this;
    function i(e2) {
      const t2 = r._emGetInBufferPtr();
      r.xz.HEAPU8.set(e2, t2), r._emInBufferSetPos(0), r._emInBufferSetSize(e2.length), a();
    }
    function a() {
      r._emOutBufferSetPos(0);
    }
    const s = r._emInitDecompressor();
    if (0 != s) return console.error("XZLoader._emInitDecompressor: error code " + s + " (" + ERR_CODES[s] + ")"), void (o && o(s));
    const l = new Uint8Array(e), c = l.length, u = [];
    let d = 0, h = Math.min(524288, c), f = 0;
    i(l.subarray(d, h)), function e2() {
      const s2 = r._emDecompress();
      if (s2) console.error("XZLoader._emDecompress: error code " + s2 + " (" + ERR_CODES[s2] + ")"), o && o(s2);
      else {
        const o2 = r._emGetCurrOutputLength();
        if (u.push(function(e3) {
          const t2 = r._emGetOutBufferPtr();
          return new Uint8Array(r.xz.HEAPU8.subarray(t2, t2 + e3));
        }(o2)), a(), r._emIsInputEndReached() && (d = h, h = Math.min(h + 524288, c), i(l.subarray(d, h))), n && n(d / c), d == h) {
          const e3 = u.reduce(function(e4, t2, n3, o4) {
            return e4 + t2.length;
          }, 0), n2 = new Uint8Array(e3);
          let o3 = 0;
          u.forEach(function(e4) {
            n2.set(e4, o3), o3 += e4.length;
          }), t && t(n2.buffer);
        } else f++, f % 2 == 0 ? setTimeout(e2, 1) : e2();
      }
    }();
  }
};
var TTFLoader = class extends Loader {
  constructor(e) {
    super(e), this.reversed = false;
  }
  load(e, t, n, o) {
    const r = this, i = new FileLoader(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.load(e, function(e2) {
      t(r.parse(e2));
    }, n, o);
  }
  parse(e) {
    function t(e2) {
      var t2, n = [];
      e2.forEach(function(e3) {
        "m" === e3.type.toLowerCase() ? (t2 = [e3], n.push(t2)) : "z" !== e3.type.toLowerCase() && t2.push(e3);
      });
      var o = [];
      return n.forEach(function(e3) {
        var t3 = { type: "m", x: e3[e3.length - 1].x, y: e3[e3.length - 1].y };
        o.push(t3);
        for (var n2 = e3.length - 1; n2 > 0; n2--) {
          var r = e3[n2];
          t3 = { type: r.type };
          void 0 !== r.x2 && void 0 !== r.y2 ? (t3.x1 = r.x2, t3.y1 = r.y2, t3.x2 = r.x1, t3.y2 = r.y1) : void 0 !== r.x1 && void 0 !== r.y1 && (t3.x1 = r.x1, t3.y1 = r.y1), t3.x = e3[n2 - 1].x, t3.y = e3[n2 - 1].y, o.push(t3);
        }
      }), o;
    }
    return "undefined" == typeof opentype ? (console.warn("v3d.TTFLoader: The loader requires opentype.js. Make sure it's included before using the loader."), null) : function(e2, n) {
      for (var o = Math.round, r = {}, i = 1e3 / (e2.unitsPerEm || 2048), a = e2.encoding.cmap.glyphIndexMap, s = Object.keys(a), l = 0; l < s.length; l++) {
        var c = s[l], u = e2.glyphs.glyphs[a[c]];
        if (void 0 !== c) {
          var d = { ha: o(u.advanceWidth * i), x_min: o(u.xMin * i), x_max: o(u.xMax * i), o: "" };
          n && (u.path.commands = t(u.path.commands)), u.path.commands.forEach(function(e3) {
            "c" === e3.type.toLowerCase() && (e3.type = "b"), d.o += e3.type.toLowerCase() + " ", void 0 !== e3.x && void 0 !== e3.y && (d.o += o(e3.x * i) + " " + o(e3.y * i) + " "), void 0 !== e3.x1 && void 0 !== e3.y1 && (d.o += o(e3.x1 * i) + " " + o(e3.y1 * i) + " "), void 0 !== e3.x2 && void 0 !== e3.y2 && (d.o += o(e3.x2 * i) + " " + o(e3.y2 * i) + " ");
          }), r[String.fromCodePoint(u.unicode)] = d;
        }
      }
      return { glyphs: r, familyName: e2.getEnglishName("fullName"), ascender: o(e2.tables.os2.sTypoAscender * i), descender: o(e2.tables.os2.sTypoDescender * i), lineGap: e2.tables.os2.sTypoLineGap * i, underlinePosition: e2.tables.post.underlinePosition, underlineThickness: e2.tables.post.underlineThickness, boundingBox: { xMin: e2.tables.head.xMin * i, xMax: e2.tables.head.xMax * i, yMin: e2.tables.head.yMin * i, yMax: e2.tables.head.yMax * i }, resolution: 1e3, original_font_information: e2.tables.name };
    }(opentype.parse(e), this.reversed);
  }
};
var RGBELoader = class extends DataTextureLoader {
  constructor(e) {
    super(e), this.type = 1016, Detector.isSafariWithUint16Bug() && (console.warn("Safari 11/12 detected. Applying workaround for half-float texture bug"), this.type = 1015);
  }
  parse(e) {
    const t = function(e2, t2) {
      switch (e2) {
        case 1:
          console.error("v3d.RGBELoader Read Error: " + (t2 || ""));
          break;
        case 2:
          console.error("v3d.RGBELoader Write Error: " + (t2 || ""));
          break;
        case 3:
          console.error("v3d.RGBELoader Bad File Format: " + (t2 || ""));
          break;
        default:
          console.error("v3d.RGBELoader: Error: " + (t2 || ""));
      }
      return -1;
    }, n = function(e2, t2, n2) {
      t2 = t2 || 1024;
      let o2 = e2.pos, r2 = -1, i2 = 0, a2 = "", s = String.fromCharCode.apply(null, new Uint16Array(e2.subarray(o2, o2 + 128)));
      for (; 0 > (r2 = s.indexOf("\n")) && i2 < t2 && o2 < e2.byteLength; ) a2 += s, i2 += s.length, o2 += 128, s += String.fromCharCode.apply(null, new Uint16Array(e2.subarray(o2, o2 + 128)));
      return -1 < r2 && (e2.pos += i2 + r2 + 1, a2 + s.slice(0, r2));
    }, o = function(e2, t2, n2, o2) {
      const r2 = e2[t2 + 3], i2 = Math.pow(2, r2 - 128) / 255;
      n2[o2 + 0] = e2[t2 + 0] * i2, n2[o2 + 1] = e2[t2 + 1] * i2, n2[o2 + 2] = e2[t2 + 2] * i2, n2[o2 + 3] = 1;
    }, r = function(e2, t2, n2, o2) {
      const r2 = e2[t2 + 3], i2 = Math.pow(2, r2 - 128) / 255;
      n2[o2 + 0] = toHalfFloat(Math.min(e2[t2 + 0] * i2, 65504)), n2[o2 + 1] = toHalfFloat(Math.min(e2[t2 + 1] * i2, 65504)), n2[o2 + 2] = toHalfFloat(Math.min(e2[t2 + 2] * i2, 65504)), n2[o2 + 3] = toHalfFloat(1);
    }, i = new Uint8Array(e);
    i.pos = 0;
    const a = function(e2) {
      const o2 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, r2 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, i2 = /^\s*FORMAT=(\S+)\s*$/, a2 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, s = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
      let l, c;
      if (e2.pos >= e2.byteLength || !(l = n(e2))) return t(1, "no header found");
      if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");
      for (s.valid |= 1, s.programtype = c[1], s.string += l + "\n"; l = n(e2), false !== l; ) if (s.string += l + "\n", "#" !== l.charAt(0)) {
        if ((c = l.match(o2)) && (s.gamma = parseFloat(c[1])), (c = l.match(r2)) && (s.exposure = parseFloat(c[1])), (c = l.match(i2)) && (s.valid |= 2, s.format = c[1]), (c = l.match(a2)) && (s.valid |= 4, s.height = parseInt(c[1], 10), s.width = parseInt(c[2], 10)), 2 & s.valid && 4 & s.valid) break;
      } else s.comments += l + "\n";
      return 2 & s.valid ? 4 & s.valid ? s : t(3, "missing image size specifier") : t(3, "missing format specifier");
    }(i);
    if (-1 !== a) {
      const e2 = a.width, n2 = a.height, s = function(e3, n3, o2) {
        const r2 = n3;
        if (r2 < 8 || r2 > 32767 || 2 !== e3[0] || 2 !== e3[1] || 128 & e3[2]) return new Uint8Array(e3);
        if (r2 !== (e3[2] << 8 | e3[3])) return t(3, "wrong scanline width");
        const i2 = new Uint8Array(4 * n3 * o2);
        if (!i2.length) return t(4, "unable to allocate buffer space");
        let a2 = 0, s2 = 0;
        const l = 4 * r2, c = new Uint8Array(4), u = new Uint8Array(l);
        let d = o2;
        for (; d > 0 && s2 < e3.byteLength; ) {
          if (s2 + 4 > e3.byteLength) return t(1);
          if (c[0] = e3[s2++], c[1] = e3[s2++], c[2] = e3[s2++], c[3] = e3[s2++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != r2) return t(3, "bad rgbe scanline format");
          let n4, o3 = 0;
          for (; o3 < l && s2 < e3.byteLength; ) {
            n4 = e3[s2++];
            const r3 = n4 > 128;
            if (r3 && (n4 -= 128), 0 === n4 || o3 + n4 > l) return t(3, "bad scanline data");
            if (r3) {
              const t2 = e3[s2++];
              for (let e4 = 0; e4 < n4; e4++) u[o3++] = t2;
            } else u.set(e3.subarray(s2, s2 + n4), o3), o3 += n4, s2 += n4;
          }
          const h = r2;
          for (let e4 = 0; e4 < h; e4++) {
            let t2 = 0;
            i2[a2] = u[e4 + t2], t2 += r2, i2[a2 + 1] = u[e4 + t2], t2 += r2, i2[a2 + 2] = u[e4 + t2], t2 += r2, i2[a2 + 3] = u[e4 + t2], a2 += 4;
          }
          d--;
        }
        return i2;
      }(i.subarray(i.pos), e2, n2);
      if (-1 !== s) {
        let t2, i2, l;
        switch (this.type) {
          case 1015:
            l = s.length / 4;
            const e3 = new Float32Array(4 * l);
            for (let t3 = 0; t3 < l; t3++) o(s, 4 * t3, e3, 4 * t3);
            t2 = e3, i2 = 1015;
            break;
          case 1016:
            l = s.length / 4;
            const n3 = new Uint16Array(4 * l);
            for (let e4 = 0; e4 < l; e4++) r(s, 4 * e4, n3, 4 * e4);
            t2 = n3, i2 = 1016;
            break;
          default:
            console.error("v3d.RGBELoader: unsupported type: ", this.type);
        }
        return { width: e2, height: n2, data: t2, header: a.string, gamma: a.gamma, exposure: a.exposure, type: i2 };
      }
    }
    return null;
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, o) {
    return super.load(e, function(e2, n2) {
      switch (e2.type) {
        case 1015:
        case 1016:
          e2.encoding = 3e3, e2.minFilter = 1006, e2.magFilter = 1006, e2.generateMipmaps = false, e2.flipY = true;
      }
      t && t(e2, n2);
    }, n, o);
  }
};
var _box3Tmp = new Box3();
var _mat4Tmp$1 = new Matrix4();
var _vec3Tmp$3 = new Vector3();
var _vec3Tmp2$2 = new Vector3();
var _vec4Tmp = new Vector4();
var _frustum = new Frustum();
var _objLayersMasks = /* @__PURE__ */ new Map();
var PlaneReflectionProbe = class extends Object3D {
  constructor() {
    super(), this.isPlaneReflectionProbe = true, this.type = "PlaneReflectionProbe", this.influenceDistance = 1, this.falloff = 0.5, this.probeClipStart = 0.1, this.planeSize = new Vector2(1, 1), this.qualityFactor = 0.75, this.visibilityGroup = null, this.visibilityGroupInv = false, this.boundingBox = new Box3(), this.normal = new Vector3(), this.textureMatrix = new Matrix4(), this.virtualCamera = new PerspectiveCamera(), this.reflectorWorldPosition = new Vector3(), this.cameraWorldPosition = new Vector3(), this.rotationMatrix = new Matrix4(), this.view = new Vector3(), this.lookAtPosition = new Vector3(0, 0, -1), this.reflectorPlane = new Plane(), this.clipPlane = new Vector4(), this.target = new Vector3();
    const e = { minFilter: 1006, magFilter: 1006, format: 1023, encoding: 3001 };
    this.renderTarget = new WebGLRenderTarget(1024, 1024, e), this.renderTarget.texture.name = "PlaneReflectionProbe", this.matrixWorldInverse = new Matrix4();
  }
  _calcLocalBounding() {
    const e = _vec3Tmp$3.setScalar(0), t = _vec3Tmp2$2.set(2 * this.planeSize.x, 2 * this.influenceDistance / this.scale.y, 2 * this.planeSize.y);
    this.boundingBox.setFromCenterAndSize(e, t);
  }
  _isOutOfFrustum(e) {
    const t = _mat4Tmp$1.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(t);
    const n = _box3Tmp.copy(this.boundingBox).applyMatrix4(this.matrixWorld);
    return !_frustum.intersectsBox(n);
  }
  _traverseDisableOther(e) {
    !e.isPlaneReflectionProbe && this._isVisible(e) || (_objLayersMasks.set(e, e.layers.mask), e.layers.disableAll());
    const t = e.children;
    for (let e2 = 0; e2 < t.length; e2++) this._traverseDisableOther(t[e2]);
  }
  makeMultisampleRenderTarget(e) {
    this.renderTarget.samples = e;
  }
  setSize(e, t) {
    this.renderTarget.setSize(this.qualityFactor * e, this.qualityFactor * t);
  }
  setEncoding(e) {
    this.renderTarget.texture.encoding = e;
  }
  intersectsMesh(e) {
    let t = false;
    const n = e.geometry, o = _mat4Tmp$1;
    o.copy(e.matrixWorld).invert(), o.multiply(this.matrixWorld);
    const r = this.boundingBox, i = _box3Tmp.copy(r).applyMatrix4(o);
    return null === n.boundingBox && n.computeBoundingBox(), t = n.boundingBox.intersectsBox(i), t && n.boundsTree && (t = n.boundsTree.intersectsBox(r, o)), t;
  }
  update(e, t, n) {
    if (this._calcLocalBounding(), this._isOutOfFrustum(t)) return;
    const o = this.reflectorWorldPosition;
    o.setFromMatrixPosition(this.matrixWorld);
    const r = this.cameraWorldPosition;
    r.setFromMatrixPosition(t.matrixWorld);
    const i = this.rotationMatrix;
    i.extractRotation(this.matrixWorld);
    const a = this.normal;
    a.set(0, 1, 0), a.applyMatrix4(i);
    const s = this.view;
    if (s.subVectors(o, r), s.dot(a) > 0) return;
    this._traverseDisableOther(e), s.reflect(a).negate(), s.add(o), i.extractRotation(t.matrixWorld);
    const l = this.lookAtPosition;
    l.set(0, 0, -1), l.applyMatrix4(i), l.add(r);
    const c = this.target;
    c.subVectors(o, l), c.reflect(a).negate(), c.add(o);
    const u = this.virtualCamera;
    u.position.copy(s), u.up.set(0, 1, 0), u.up.applyMatrix4(i), u.up.reflect(a), u.lookAt(c), u.far = t.far, u.updateMatrixWorld();
    const d = u.projectionMatrix;
    d.copy(t.projectionMatrix);
    const h = this.textureMatrix;
    h.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), h.multiply(d), h.multiply(u.matrixWorldInverse);
    const f = this.reflectorPlane;
    f.setFromNormalAndCoplanarPoint(a, o), f.applyMatrix4(u.matrixWorldInverse);
    const p = this.clipPlane;
    p.set(f.normal.x, f.normal.y, f.normal.z, f.constant), _vec4Tmp.x = (Math.sign(p.x) + d.elements[8]) / d.elements[0], _vec4Tmp.y = (Math.sign(p.y) + d.elements[9]) / d.elements[5], _vec4Tmp.z = -1, _vec4Tmp.w = (1 + d.elements[10]) / d.elements[14], p.multiplyScalar(2 / p.dot(_vec4Tmp)), d.elements[2] = p.x, d.elements[6] = p.y, d.elements[10] = p.z + 1 - this.probeClipStart, d.elements[14] = p.w;
    const m = n.getRenderTarget(), g = n.xr.enabled, _ = n.shadowMap.autoUpdate, A = n.useOIT;
    n.xr.enabled = false, n.shadowMap.autoUpdate = false, n.useOIT = false, n.setRenderTarget(this.renderTarget), n.state.buffers.depth.setMask(true), false === n.autoClear && n.clear(), n.render(e, u), n.xr.enabled = g, n.shadowMap.autoUpdate = _, n.useOIT = A, n.setRenderTarget(m);
    const v = t.viewport;
    void 0 !== v && n.state.viewport(v), _objLayersMasks.forEach((e2, t2) => {
      t2.layers.mask = e2;
    }), _objLayersMasks.clear();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return super.copy(e), this.influenceDistance = e.influenceDistance, this.probeClipStart = e.probeClipStart, this.visibilityGroup = e.visibilityGroup, this.visibilityGroupInv = e.visibilityGroupInv, this;
  }
  dispose() {
    null !== this.renderTarget && (this.renderTarget.dispose(), this.renderTarget = null), this.dispatchEvent({ type: "dispose" });
  }
  _isVisible(e) {
    if (null === this.visibilityGroup) return true;
    if (!e.isMesh) return true;
    return -1 !== e.groupNames.indexOf(this.visibilityGroup) ^ this.visibilityGroupInv;
  }
};
var RectAreaLightUniformsLib = class {
  static init(e, t) {
    void 0 !== e && void 0 !== t || console.error("RectAreaLightUniformsLib: Missing LTC data (required in Verge3D)");
    const n = new Float32Array(e), o = new Float32Array(t);
    UniformsLib.LTC_FLOAT_1 = new DataTexture(n, 64, 64, 1023, 1015, 300, 1001, 1001, 1006, 1003, 1), UniformsLib.LTC_FLOAT_2 = new DataTexture(o, 64, 64, 1023, 1015, 300, 1001, 1001, 1006, 1003, 1), UniformsLib.LTC_FLOAT_1.name = "RectArea.ltc1", UniformsLib.LTC_FLOAT_2.name = "RectArea.ltc2", UniformsLib.LTC_FLOAT_1.needsUpdate = true, UniformsLib.LTC_FLOAT_2.needsUpdate = true;
    const r = new Uint16Array(e.length);
    e.forEach(function(e2, t2) {
      r[t2] = toHalfFloat(e2);
    });
    const i = new Uint16Array(t.length);
    t.forEach(function(e2, t2) {
      i[t2] = toHalfFloat(e2);
    }), UniformsLib.LTC_HALF_1 = new DataTexture(r, 64, 64, 1023, 1016, 300, 1001, 1001, 1006, 1003, 1), UniformsLib.LTC_HALF_2 = new DataTexture(i, 64, 64, 1023, 1016, 300, 1001, 1001, 1006, 1003, 1), UniformsLib.LTC_HALF_1.needsUpdate = true, UniformsLib.LTC_HALF_2.needsUpdate = true;
  }
};
var Font = class {
  constructor(e) {
    this.isFont = true, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100, n = "left", o = "topBaseline", r = -1, i = false) {
    const a = [], s = createPaths(e, t, this.data, n, o, r, i);
    for (let e2 = 0, t2 = s.length; e2 < t2; e2++) Array.prototype.push.apply(a, s[e2].toShapes());
    return a;
  }
};
function createPaths(e, t, n, o, r, i, a) {
  const s = String(e).split("\n"), l = [];
  for (let e2 = 0; e2 < s.length; e2++) {
    let t2 = s[e2];
    l[e2] = Array.from(t2);
  }
  let c = t / n.resolution;
  a && (c *= (n.ascender - n.descender) / (n.boundingBox.yMax - n.boundingBox.yMin)), n.lineGap = n.lineGap || 0, -1 === i ? i = (n.ascender - n.descender + n.lineGap) * c : i *= t;
  const u = [];
  let d = 0, h = 0;
  const f = l.length, p = i * f, m = i - i * Math.abs(n.descender) / n.ascender;
  switch (r) {
    case "topBaseline":
    default:
      h = 0;
      break;
    case "top":
      h = -m;
      break;
    case "center":
      h = f > 1 ? 0.5 * p - m : -n.ascender / 2 * c;
      break;
    case "bottom":
      h = p - i - n.descender * c;
      break;
    case "bottomBaseline":
      h = p - i;
  }
  for (let e2 = 0; e2 < l.length; e2++) {
    const t2 = l[e2];
    switch (o) {
      case "left":
      default:
        d = 0;
        break;
      case "center":
        d = -calcLineWidth(t2, c, n) / 2;
        break;
      case "right":
        d = -calcLineWidth(t2, c, n);
    }
    for (let e3 = 0; e3 < t2.length; e3++) {
      const o2 = createPath(t2[e3], c, d, h, n);
      d += o2.offsetX, u.push(o2.path);
    }
    h -= i;
  }
  return u;
}
function createPath(e, t, n, o, r) {
  const i = r.glyphs[e] || r.glyphs["?"];
  if (!i) return void console.error('v3d.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".");
  const a = new ShapePath();
  let s, l, c, u, d, h, f, p;
  if (i.o) {
    const e2 = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let r2 = 0, i2 = e2.length; r2 < i2; ) {
      switch (e2[r2++]) {
        case "m":
          s = e2[r2++] * t + n, l = e2[r2++] * t + o, a.moveTo(s, l);
          break;
        case "l":
          s = e2[r2++] * t + n, l = e2[r2++] * t + o, a.lineTo(s, l);
          break;
        case "q":
          c = e2[r2++] * t + n, u = e2[r2++] * t + o, d = e2[r2++] * t + n, h = e2[r2++] * t + o, a.quadraticCurveTo(d, h, c, u);
          break;
        case "b":
          c = e2[r2++] * t + n, u = e2[r2++] * t + o, d = e2[r2++] * t + n, h = e2[r2++] * t + o, f = e2[r2++] * t + n, p = e2[r2++] * t + o, a.bezierCurveTo(d, h, f, p, c, u);
      }
    }
  }
  return { offsetX: i.ha * t, path: a };
}
function calcLineWidth(e, t, n) {
  let o = 0;
  for (var r = 0; r < e.length; r++) {
    const i = e[r];
    o += (n.glyphs[i] || n.glyphs["?"]).ha * t;
  }
  return o;
}
var _tmpWorldPos = new Vector3();
var _tmpNormal = new Vector3();
var ClippingPlaneObject = class extends Object3D {
  constructor() {
    super(), this.isClippingPlaneObject = true, this.type = "ClippingPlaneObject", this.plane = new Plane(), this.clippingGroup = null, this.clipShadows = false, this.negated = false, this.clipIntersection = false, this.crossSection = false, this.crossSectionColor = new Color(16711680), this.crossSectionOpacity = 1, this.crossSectionRenderSide = 0, this.crossSectionSize = 100, this._crossMatProfile = "blender";
  }
  updatePlane() {
    this.updateWorldMatrix(true, false), this.getWorldPosition(_tmpWorldPos);
    const e = this.matrixWorld.elements;
    _tmpNormal.set(e[4], e[5], e[6]).normalize(), this.plane.setFromNormalAndCoplanarPoint(_tmpNormal, _tmpWorldPos), this.negated && this.plane.negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.updatePlane();
  }
  needsClippingPlane(e) {
    return e.isMesh && (e.groupNames.indexOf(this.clippingGroup) >= 0 || null === this.clippingGroup) && !e.isAuxClippingMesh;
  }
  assignToObject(e, t = 0) {
    const n = this.plane, o = e.material, r = e.geometry;
    if (o.clippingPlanes = o.clippingPlanes || [], -1 == o.clippingPlanes.indexOf(n) && o.clippingPlanes.push(n), o.clipShadows = this.clipShadows, o.clipIntersection = this.clipIntersection, this.crossSection) {
      this.cleanupAuxMeshes(e);
      const i = new MeshBasicMaterial();
      i.depthWrite = false, i.depthTest = false, i.colorWrite = false, i.stencilWrite = true, i.stencilFunc = 519, i.clipShadows = this.clipShadows, i.clipIntersection = this.clipIntersection;
      const a = !!e.isSkinnedMesh, s = e.morphTargetInfluences, l = isDef(s) && s.length > 0, c = i.clone();
      let u;
      c.name = "ClipCrossSectionStencilBack", c.side = 1, c.clippingPlanes = [n], c.stencilFail = 34055, c.stencilZFail = 34055, c.stencilZPass = 34055, a ? (u = new SkinnedMesh(r, c), u.skeleton = e.skeleton) : u = new Mesh(r, c), u.renderOrder = t, u.name = "ClipCrossSectionStencilBack", u.isAuxClippingMesh = true, l && (u.morphTargetInfluences = s.slice(), u.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), e.add(u);
      const d = i.clone();
      let h;
      d.name = "ClipCrossSectionStencilFront", d.side = 0, d.clippingPlanes = [n], d.stencilFail = 34056, d.stencilZFail = 34056, d.stencilZPass = 34056, a ? (h = new SkinnedMesh(r, d), h.skeleton = e.skeleton) : h = new Mesh(r, d), h.renderOrder = t + 0.1, h.name = "ClipCrossSectionStencilFront", h.isAuxClippingMesh = true, l && (h.morphTargetInfluences = s.slice(), h.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), e.add(h), o.isMeshNodeMaterial && (this._crossMatProfile = o.profile);
    }
  }
  createCrossSectionPlane(e, t) {
    this.cleanupAuxMeshes();
    const n = new createDiffuseMaterial("ClipCrossSectionColor", this.crossSectionColor, this.crossSectionOpacity, this._crossMatProfile);
    n.clippingPlanes = e.filter((e2) => e2 !== this.plane), n.clipShadows = this.clipShadows, n.clipIntersection = this.clipIntersection, n.stencilWrite = true, n.stencilRef = 0, n.stencilFunc = 517, n.stencilFail = 7681, n.stencilZFail = 7681, n.stencilZPass = 7681, n.side = this.crossSectionRenderSide, this.crossSectionOpacity < 1 && (n.transparent = true, n.premultipliedAlpha = true, n.blending = 5, n.blendEquation = 100, n.blendSrc = 201, n.blendDst = 205);
    const o = new PlaneGeometry(this.crossSectionSize, this.crossSectionSize);
    this.negated ? o.rotateX(-Math.PI / 2) : o.rotateX(Math.PI / 2);
    const r = new Mesh(o, n);
    r.name = "ClipCrossSectionColor", r.isAuxClippingMesh = true, r.renderOrder = t, r.onAfterRender = function(e2) {
      e2.clearStencil();
    }, this.add(r);
  }
  cleanupAuxMeshes(e = null) {
    if (e) for (let t = e.children.length - 1; t >= 0; t--) {
      const n = e.children[t];
      n.isAuxClippingMesh && n.material.clippingPlanes[0] == this.plane && (n.geometry.dispose(), n.material.dispose(), e.remove(n));
    }
    else for (let e2 = this.children.length - 1; e2 >= 0; e2--) {
      const t = this.children[e2];
      t.isAuxClippingMesh && (t.geometry.dispose(), t.material.dispose(), this.remove(t));
    }
  }
  copy(e) {
    return super.copy(e), this.plane = e.plane, this.clippingGroup = e.clippingGroup, this.clipShadows = e.clipShadows, this.negated = e.negated, this.clipIntersection = e.clipIntersection, this.crossSection = e.crossSection, this.crossSectionColor.copy(e.crossSectionColor), this.crossSectionOpacity = e.crossSectionOpacity, this.crossSectionRenderSide = e.crossSectionRenderSide, this.crossSectionSize = e.crossSectionSize, this._crossMatProfile = e._crossMatProfile, this;
  }
};
var Constraint = class {
  constuctor() {
    this.isConstraint = true, this.name = "", this.type = "Constraint", this.mute = false;
  }
  _updateObjMatrixWorld(e) {
    e.matrixAutoUpdate && e.matrix.compose(e.position, e.quaternion, e.scale), null == e.parent ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(e.parent.matrixWorld, e.matrix);
  }
  update(e) {
    this.mute;
  }
  copy(e) {
    return this.name = e.name, this.mute = e.mute, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var TargetConstraint = class extends Constraint {
  constructor(e) {
    super(), this.isTargetConstraint = true, this.type = "TargetConstraint", this.target = e;
  }
  copy(e) {
    return super.copy(e), this.target = e.target, this;
  }
  clone() {
    return new this.constructor(this.target).copy(this);
  }
};
var _mat = new Matrix4();
var QUAT_90_MX$7 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var ChildOfConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isChildOfConstraint = true, this.type = "ChildOfConstraint", this.offsetMatrix = new Matrix4(), this.fixCameraLightRotation = false;
  }
  copy(e) {
    return super.copy(e), this.offsetMatrix.copy(e.offsetMatrix), this.fixCameraLightRotation = e.fixCameraLightRotation, this;
  }
  update(e) {
    super.update(e), this.mute || (_mat.multiplyMatrices(this.target.matrixWorld, this.offsetMatrix), _mat.decompose(e.position, e.quaternion, e.scale), this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$7));
  }
};
var _pos$8 = new Vector3();
var _quat$7 = new Quaternion();
var _scale$7 = new Vector3();
var CopyLocationConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isCopyLocationConstraint = true, this.type = "CopyLocationConstraint", this.useX = true, this.useY = true, this.useZ = true, this.invertX = false, this.invertY = false, this.invertZ = false, this.useOffset = false, this.influence = 1, this._firstIteration = true, this._objPosInit = new Vector3(), this._offset = new Vector3();
  }
  copy(e) {
    return super.copy(e), this.useX = e.useX, this.useY = e.useY, this.useZ = e.useZ, this.invertX = e.invertX, this.invertY = e.invertY, this.invertZ = e.invertZ, this.useOffset = e.useOffset, this.influence = e.influence, this._firstIteration = false, this;
  }
  update(e) {
    super.update(e), this.mute || (this.target.matrixWorld.decompose(_pos$8, _quat$7, _scale$7), this._firstIteration && (this._updateObjMatrixWorld(e), e.getWorldPositionNU(this._objPosInit), this._offset.subVectors(_pos$8, this._objPosInit), this._firstIteration = false), this.useX ? (this.invertX && (_pos$8.x = -_pos$8.x), this.useOffset && (_pos$8.x -= this._offset.x)) : _pos$8.x = this._objPosInit.x, this.useY ? (this.invertY && (_pos$8.y = -_pos$8.y), this.useOffset && (_pos$8.y -= this._offset.y)) : _pos$8.y = this._objPosInit.y, this.useZ ? (this.invertZ && (_pos$8.z = -_pos$8.z), this.useOffset && (_pos$8.z -= this._offset.z)) : _pos$8.z = this._objPosInit.z, e.position.lerpVectors(this._objPosInit, _pos$8, this.influence), e.parent && e.parent.worldToLocal(e.position));
  }
};
var QUAT_90_MX$6 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var _pos$7 = new Vector3();
var _quat$6 = new Quaternion();
var _scale$6 = new Vector3();
var CopyRotationConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isCopyRotationConstraint = true, this.type = "CopyRotationConstraint", this.useX = true, this.useY = true, this.useZ = true, this.invertX = false, this.invertY = false, this.invertZ = false, this.mixMode = "REPLACE", this.influence = 1, this.fixCameraLightRotation = false, this._firstIteration = true, this._objQuatInit = new Quaternion();
  }
  copy(e) {
    return super.copy(e), this.useX = e.useX, this.useY = e.useY, this.useZ = e.useZ, this.invertX = e.invertX, this.invertY = e.invertY, this.invertZ = e.invertZ, this.mixMode = e.mixMode, this.influence = e.influence, this.fixCameraLightRotation = e.fixCameraLightRotation, this._firstIteration = false, this;
  }
  update(e) {
    super.update(e), this.mute || (this.target.matrixWorld.decompose(_pos$7, _quat$6, _scale$6), this._firstIteration && (this._updateObjMatrixWorld(e), e.matrixWorld.decompose(_pos$7, this._objQuatInit, _scale$6), this._firstIteration = false), e.quaternion.copy(this._objQuatInit), (this.useX || this.useY || this.useZ) && ("REPLACE" == this.mixMode || "ADD" == this.mixMode || ("BEFORE" == this.mixMode ? _quat$6.multiply(e.quaternion) : "AFTER" == this.mixMode ? _quat$6.premultiply(e.quaternion) : this.mixMode), e.quaternion.slerp(_quat$6, this.influence)), e.parent && (e.parent.matrixWorld.decompose(_pos$7, _quat$6, _scale$6), e.quaternion.premultiply(_quat$6.invert())), this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$6));
  }
};
var _pos$6 = new Vector3();
var _quat$5 = new Quaternion();
var _scale$5 = new Vector3();
var CopyScaleConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isCopyScaleConstraint = true, this.type = "CopyScaleConstraint", this.useX = true, this.useY = true, this.useZ = true, this.power = 1, this.useMakeUniform = false, this.useOffset = false, this.useAdd = false, this.influence = 1, this._objInitScale = new Vector3(), this._volumeScaleFactor = new Vector3(), this._firstIteration = true;
  }
  copy(e) {
    return super.copy(e), this.useX = e.useX, this.useY = e.useY, this.useZ = e.useZ, this.power = e.power, this.useMakeUniform = e.useMakeUniform, this.useOffset = e.useOffset, this.useAdd = e.useAdd, this.influence = e.influence, this._firstIteration = false, this;
  }
  update(e) {
    if (super.update(e), !this.mute) {
      if (this.target.matrixWorld.decompose(_pos$6, _quat$5, _scale$5), this._firstIteration && (this._updateObjMatrixWorld(e), e.matrixWorld.decompose(_pos$6, _quat$5, this._objInitScale), this._volumeScaleFactor.set(Math.pow(_scale$5.x - this._objInitScale.x, 3), Math.pow(_scale$5.y - this._objInitScale.y, 3), Math.pow(_scale$5.z - this._objInitScale.z, 3)), this._firstIteration = false), this.useMakeUniform) {
        let e2 = 1;
        this.useX && (e2 *= _scale$5.x), this.useY && (e2 *= _scale$5.y), this.useZ && (e2 *= _scale$5.z), e2 = Math.pow(Math.cbrt(e2), this.power), _scale$5.set(e2, e2, e2), this.useOffset && (this.useAdd ? (_scale$5.add(this._objInitScale), _scale$5.addScalar(-1)) : _scale$5.multiply(this._objInitScale));
      } else _scale$5.set(this.useX ? Math.pow(_scale$5.x, this.power) : this._objInitScale.x, this.useY ? Math.pow(_scale$5.y, this.power) : this._objInitScale.y, this.useZ ? Math.pow(_scale$5.z, this.power) : this._objInitScale.z), this.useOffset && (this.useAdd ? _scale$5.set(this.useX ? _scale$5.x + this._objInitScale.x - 1 : _scale$5.x, this.useY ? _scale$5.y + this._objInitScale.y - 1 : _scale$5.y, this.useZ ? _scale$5.z + this._objInitScale.z - 1 : _scale$5.z) : _scale$5.set(this.useX ? _scale$5.x * this._objInitScale.x : _scale$5.x, this.useY ? _scale$5.y * this._objInitScale.y : _scale$5.y, this.useZ ? _scale$5.z * this._objInitScale.z : _scale$5.z));
      e.scale.copy(this._objInitScale), e.scale.lerp(_scale$5, this.influence);
    }
  }
};
var QUAT_90_MX$5 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var _matrixWorld = new Matrix4();
var _pos$5 = new Vector3();
var _quat$4 = new Quaternion();
var _scale$4 = new Vector3();
var CopyTransformsConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isCopyTransformsConstraint = true, this.type = "CopyTransformsConstraint", this.mixMode = "REPLACE", this.influence = 1, this.fixCameraLightRotation = false, this._firstIteration = true, this._objMatrixWorldInit = new Matrix4();
  }
  copy(e) {
    return super.copy(e), this.mixMode = e.mixMode, this.influence = e.influence, this.fixCameraLightRotation = e.fixCameraLightRotation, this._firstIteration = true, this;
  }
  update(e) {
    super.update(e), this.mute || (this._firstIteration && (this._updateObjMatrixWorld(e), this._objMatrixWorldInit.copy(e.matrixWorld), this._firstIteration = false), _matrixWorld.copy(this.target.matrixWorld), "REPLACE" == this.mixMode || ("BEFORE" == this.mixMode ? _matrixWorld.multiply(this._objMatrixWorldInit) : "AFTER" == this.mixMode && _matrixWorld.premultiply(this._objMatrixWorldInit)), _matrixWorld.decompose(_pos$5, _quat$4, _scale$4), this._objMatrixWorldInit.decompose(e.position, e.quaternion, e.scale), e.position.lerp(_pos$5, this.influence), e.quaternion.slerp(_quat$4, this.influence), e.scale.lerp(_scale$4, this.influence), this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$5));
  }
};
var QUAT_90_MX$4 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var _pos$4 = new Vector3();
var _quat$3 = new Quaternion();
var _scale$3 = new Vector3();
var _objWorldPos$1 = new Vector3();
var _targetVec = new Vector3();
var _objVec = new Vector3();
var _rotAxis = new Vector3();
var TRACK_DIR_NUMS = { X: 0, Y: 1, Z: 2, "-X": 3, "-Y": 4, "-Z": 5 };
var TRACK_DIR_VECS$1 = { 0: new Vector3(1, 0, 0), 1: new Vector3(0, 1, 0), 2: new Vector3(0, 0, 1), 3: new Vector3(-1, 0, 0), 4: new Vector3(0, -1, 0), 5: new Vector3(0, 0, -1) };
var DampedTrackConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isDampedTrackConstraint = true, this.type = "DampedTrackConstraint", this.trackAxis = "X", this.influence = 1, this.fixCameraLightRotation = false, this._firstIteration = true;
  }
  copy(e) {
    return super.copy(e), this.trackAxis = e.trackAxis, this.influence = e.influence, this.fixCameraLightRotation = e.fixCameraLightRotation, this._firstIteration = false, this;
  }
  update(e) {
    if (super.update(e), !this.mute && (this.target.matrixWorld.decompose(_pos$4, _quat$3, _scale$3), this._firstIteration && (this._updateObjMatrixWorld(e), this._firstIteration = false), e.matrixWorld.decompose(_objWorldPos$1, _quat$3, _scale$3), _targetVec.subVectors(_pos$4, _objWorldPos$1), 0 != _targetVec.length())) {
      let t;
      if (_targetVec.normalize(), _objVec.copy(TRACK_DIR_VECS$1[TRACK_DIR_NUMS[this.trackAxis]]), _objVec.applyQuaternion(_quat$3), 0 == _objVec.length() && _objVec.copy(TRACK_DIR_VECS$1[TRACK_DIR_NUMS[this.trackAxis]]), _objVec.normalize(), _rotAxis.crossVectors(_objVec, _targetVec), t = _objVec.angleTo(_targetVec), _rotAxis.length() < Number.EPSILON) {
        if (Math.abs(t) < Math.PI - 0.01) return;
        if (t = Math.PI, _targetVec.copy(TRACK_DIR_VECS$1[(TRACK_DIR_NUMS[this.trackAxis] + 2) % 6]), _targetVec.applyQuaternion(_quat$3), _rotAxis.crossVectors(_objVec, _targetVec), 0 == _rotAxis.length()) return;
      }
      _rotAxis.normalize(), e.quaternion.premultiply(_quat$3.setFromAxisAngle(_rotAxis, t)), e.parent && (e.parent.matrixWorld.decompose(_pos$4, _quat$3, _scale$3), e.quaternion.premultiply(_quat$3.invert())), this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$4);
    }
  }
};
var TRACK_DIR_VECS = { X: new Vector3(1, 0, 0), Y: new Vector3(0, 1, 0), Z: new Vector3(0, 0, 1), "-X": new Vector3(-1, 0, 0), "-Y": new Vector3(0, -1, 0), "-Z": new Vector3(0, 0, -1) };
var _normalVec = new Vector3();
var _closestPlanePoint = new Vector3();
var _pos$3 = new Vector3();
var _tpos = new Vector3();
var FloorConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isFloorConstraint = true, this.type = "FloorConstraint", this.floorLocation = "Y", this.offset = 0, this.useRotation = false;
  }
  copy(e) {
    return super.copy(e), this.floorLocation = e.floorLocation, this.offset = e.offset, this.useRotation = e.useRotation, this;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    const t = e.position;
    _tpos.copy(this.target.position);
    const n = this.target.scale, o = this.offset;
    if (this.useRotation) {
      let e2;
      switch (_normalVec.copy(TRACK_DIR_VECS[this.floorLocation]), _normalVec.applyQuaternion(this.target.quaternion), this.floorLocation) {
        case "X":
          _tpos.x += o * n.x, _pos$3.subVectors(t, _tpos), e2 = _normalVec.dot(_pos$3), _normalVec.multiplyScalar(e2), _closestPlanePoint.subVectors(_pos$3, _normalVec).add(_tpos), _closestPlanePoint.x > t.x ? t.copy(_closestPlanePoint) : t.x = Math.max(t.x, _tpos.x);
          break;
        case "Y":
          _tpos.y += o * n.y, _pos$3.subVectors(t, _tpos), e2 = _normalVec.dot(_pos$3), _normalVec.multiplyScalar(e2), _closestPlanePoint.subVectors(_pos$3, _normalVec).add(_tpos), _closestPlanePoint.y > t.y ? t.copy(_closestPlanePoint) : t.y = Math.max(t.y, _tpos.y);
          break;
        case "Z":
          _tpos.z += o * n.z, _pos$3.subVectors(t, _tpos), e2 = _normalVec.dot(_pos$3), _normalVec.multiplyScalar(e2), _closestPlanePoint.subVectors(_pos$3, _normalVec).add(_tpos), _closestPlanePoint.z > t.z ? t.copy(_closestPlanePoint) : t.z = Math.max(t.z, _tpos.z);
          break;
        case "-X":
          _tpos.x += o * n.x, _pos$3.subVectors(t, _tpos), e2 = _normalVec.dot(_pos$3), _normalVec.multiplyScalar(e2), _closestPlanePoint.subVectors(_pos$3, _normalVec).add(_tpos), _closestPlanePoint.x < t.x ? t.copy(_closestPlanePoint) : t.x = Math.min(t.x, _tpos.x);
          break;
        case "-Y":
          _tpos.y += o * n.y, _pos$3.subVectors(t, _tpos), e2 = _normalVec.dot(_pos$3), _normalVec.multiplyScalar(e2), _closestPlanePoint.subVectors(_pos$3, _normalVec).add(_tpos), _closestPlanePoint.y < t.y ? t.copy(_closestPlanePoint) : t.y = Math.min(t.y, _tpos.y);
          break;
        case "-Z":
          _tpos.z += o * n.z, _pos$3.subVectors(t, _tpos), e2 = _normalVec.dot(_pos$3), _normalVec.multiplyScalar(e2), _closestPlanePoint.subVectors(_pos$3, _normalVec).add(_tpos), _closestPlanePoint.z < t.z ? t.copy(_closestPlanePoint) : t.z = Math.min(t.z, _tpos.z);
      }
    } else switch (this.floorLocation) {
      case "X":
        t.x = Math.max(t.x, _tpos.x + o);
        break;
      case "Y":
        t.y = Math.max(t.y, _tpos.y + o);
        break;
      case "Z":
        t.z = Math.max(t.z, _tpos.z + o);
        break;
      case "-X":
        t.x = Math.min(t.x, _tpos.x + o);
        break;
      case "-Y":
        t.y = Math.min(t.y, _tpos.y + o);
        break;
      case "-Z":
        t.z = Math.min(t.z, _tpos.z + o);
    }
  }
};
var _pos$2 = new Vector3();
var _quat$2 = new Quaternion();
var _scale$2 = new Vector3();
var _vec3 = new Vector3();
var LimitDistanceConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isLimitDistanceConstraint = true, this.type = "LimitDistanceConstraint", this.distance = 0, this.limitMode = "LIMITDIST_ONSURFACE", this.useTransformLimit = false, this.influence = 1, this._objPosInit = new Vector3(), this._distInit = 0, this._sfac = 1, this._clampSurf = 0;
  }
  copy(e) {
    return super.copy(e), this.distance = e.distance, this.limitMode = e.limitMode, this.useTransformLimit = e.useTransformLimit, this.influence = e.influence, this;
  }
  update(e) {
    super.update(e), this.mute || (this._sfac = 1, this._clampSurf = 0, this.target.matrixWorld.decompose(_pos$2, _quat$2, _scale$2), this._updateObjMatrixWorld(e), e.getWorldPositionNU(this._objPosInit), _vec3.subVectors(this._objPosInit, _pos$2), this._distInit = _vec3.length(), "LIMITDIST_INSIDE" == this.limitMode ? this._distInit >= this.distance && (this._clampSurf = 1, 0 != this._distInit && (this._sfac = this.distance / this._distInit)) : "LIMITDIST_OUTSIDE" == this.limitMode ? this._distInit <= this.distance && (this._clampSurf = 1, 0 != this._distInit && (this._sfac = this.distance / this._distInit)) : "LIMITDIST_ONSURFACE" == this.limitMode && this._distInit - this.distance != 0 && (this._clampSurf = 1, 0 != this._distInit && (this._sfac = this.distance / this._distInit)), this._clampSurf && (e.position.lerpVectors(this._objPosInit, _pos$2, (1 - this._sfac) * this.influence), e.parent && e.parent.worldToLocal(e.position)));
  }
};
var objPosWorld = new Vector3();
var objPosTarget = new Vector3();
var objPosLocal = new Vector3();
var mat4Tmp = new Matrix4();
var LimitLocationConstraint = class extends TargetConstraint {
  constructor(e = null) {
    super(e), this.isLimitLocationConstraint = true, this.type = "LimitLocationConstraint", this.space = 2, this.min = new Vector3().setScalar(-1 / 0), this.max = new Vector3().setScalar(1 / 0);
  }
  copy(e) {
    return super.copy(e), this.min.copy(e.min), this.max.copy(e.max), this.space = e.space, this;
  }
  update(e) {
    if (super.update(e), !this.mute) switch (this.space) {
      case 0:
        this._updateObjMatrixWorld(e), objPosWorld.setFromMatrixPosition(e.matrixWorld), objPosWorld.clamp(this.min, this.max), objPosLocal.copy(objPosWorld), null !== e.parent && objPosLocal.applyMatrix4(mat4Tmp.copy(e.parent.matrixWorld).invert()), e.position.copy(objPosLocal);
        break;
      case 1:
        null !== this.target && (this._updateObjMatrixWorld(e), this._updateObjMatrixWorld(this.target), objPosWorld.setFromMatrixPosition(e.matrixWorld), objPosTarget.copy(objPosWorld), objPosTarget.applyMatrix4(mat4Tmp.copy(this.target.matrixWorld).invert()), objPosTarget.clamp(this.min, this.max), objPosWorld.copy(objPosTarget), objPosWorld.applyMatrix4(this.target.matrixWorld), objPosLocal.copy(objPosWorld), null !== e.parent && objPosLocal.applyMatrix4(mat4Tmp.copy(e.parent.matrixWorld).invert()), e.position.copy(objPosLocal));
        break;
      default:
        e.position.clamp(this.min, this.max);
    }
  }
};
var _euler = new Euler();
var LimitRotationConstraint = class extends Constraint {
  constructor() {
    super(), this.isLimitRotationConstraint = true, this.type = "LimitRotationConstraint", this.axis = "Y", this.min = 0, this.max = 2 * Math.PI;
  }
  copy(e) {
    return super.copy(e), this.axis = e.axis, this.min = e.min, this.max = e.max, this;
  }
  update(e) {
    super.update(e), this.mute || ("X" == this.axis ? (_euler.setFromQuaternion(e.quaternion, "XYZ"), _euler.x = this._clampAngle(_euler.x, this.min, this.max)) : "Y" == this.axis ? (_euler.setFromQuaternion(e.quaternion, "YZX"), _euler.y = this._clampAngle(_euler.y, this.min, this.max)) : "Z" == this.axis && (_euler.setFromQuaternion(e.quaternion, "ZXY"), _euler.z = this._clampAngle(_euler.z, this.min, this.max)), e.quaternion.setFromEuler(_euler));
  }
  _clampAngle(e, t, n) {
    return Math.abs(n - t) < 2 * Math.PI && (e = clampAngle(e, t, n)), e;
  }
};
var LimitScaleConstraint = class extends Constraint {
  constructor() {
    super(), this.isLimitScaleConstraint = true, this.type = "LimitScaleConstraint", this.min = new Vector3().setScalar(-1 / 0), this.max = new Vector3().setScalar(1 / 0);
  }
  copy(e) {
    return super.copy(e), this.min.copy(e.min), this.max.copy(e.max), this;
  }
  update(e) {
    super.update(e), this.mute || e.scale.clamp(this.min, this.max);
  }
};
var QUAT_90_MX$3 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var _objWorldPos = new Vector3();
var _targetWorldPos = new Vector3();
var _trackDir = new Vector3();
var _lockDir = new Vector3();
var _projDir = new Vector3();
var _plane = new Plane();
var _vec = new Vector3();
var _tmpVec$2 = new Vector3();
var _tmpQuat$2 = new Quaternion();
var LockedTrackConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isLockedTrackConstraint = true, this.type = "LockedTrackConstraint", this.trackAxis = "X", this.lockAxis = "Y", this.fixCameraLightRotation = false;
  }
  copy(e) {
    return super.copy(e), this.trackAxis = e.trackAxis, this.lockAxis = e.lockAxis, this.fixCameraLightRotation = e.fixCameraLightRotation, this;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    if (_trackDir.set("X" == this.trackAxis ? 1 : "-X" == this.trackAxis ? -1 : 0, "Y" == this.trackAxis ? 1 : "-Y" == this.trackAxis ? -1 : 0, "Z" == this.trackAxis ? 1 : "-Z" == this.trackAxis ? -1 : 0), _lockDir.set("X" == this.lockAxis ? 1 : 0, "Y" == this.lockAxis ? 1 : 0, "Z" == this.lockAxis ? 1 : 0), 1 == Math.abs(_trackDir.dot(_lockDir))) return;
    _objWorldPos.setFromMatrixPosition(e.matrixWorld), _targetWorldPos.setFromMatrixPosition(this.target.matrixWorld), _plane.setFromNormalAndCoplanarPoint(_lockDir, _objWorldPos), _plane.projectPoint(_targetWorldPos, _projDir).sub(_objWorldPos);
    const t = _vec.crossVectors(_trackDir, _projDir).dot(_lockDir) > 0 ? 1 : -1;
    e.setRotationFromAxisAngle(_plane.normal, t * _trackDir.angleTo(_projDir)), e.parent && (e.parent.matrixWorld.decompose(_tmpVec$2, _tmpQuat$2, _tmpVec$2), e.quaternion.premultiply(_tmpQuat$2.invert())), this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$3);
  }
};
var UP_WORLD$1 = new Vector3(0, 1, 0);
var QUAT_90_MX$2 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var plane = new Plane();
var objWorldPos = new Vector3();
var targetWorldPos = new Vector3();
var targetDir = new Vector3();
var upProjected = new Vector3();
var lastAxis = new Vector3();
var rotMat = new Matrix4();
var tmpVec = new Vector3();
var tmpQuat = new Quaternion();
var TrackToConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isTrackToConstraint = true, this.type = "TrackToConstraint", this.trackAxis = "X", this.upAxis = "Y", this.fixCameraLightRotation = false;
  }
  copy(e) {
    return super.copy(e), this.trackAxis = e.trackAxis, this.upAxis = e.upAxis, this.fixCameraLightRotation = e.fixCameraLightRotation, this;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    const t = this.trackAxis[this.trackAxis.length - 1], n = this.upAxis[this.upAxis.length - 1], o = "-" == this.trackAxis[0], r = "-" == this.upAxis[0];
    if (t == n) return;
    objWorldPos.setFromMatrixPosition(e.matrixWorld), targetWorldPos.setFromMatrixPosition(this.target.matrixWorld), targetDir.subVectors(targetWorldPos, objWorldPos), targetDir.lengthSq() ? targetDir.normalize() : targetDir.set(0, -1, 0), plane.set(targetDir, 0), 1 != Math.abs(targetDir.dot(UP_WORLD$1)) ? plane.projectPoint(UP_WORLD$1, upProjected).normalize() : upProjected.set(0, 0, -1), o && targetDir.negate(), r && upProjected.negate();
    let i = "X" == t ? targetDir : "X" == n ? upProjected : null, a = "Y" == t ? targetDir : "Y" == n ? upProjected : null, s = "Z" == t ? targetDir : "Z" == n ? upProjected : null;
    i ? a ? s || (s = lastAxis.crossVectors(i, a)) : a = lastAxis.crossVectors(s, i) : i = lastAxis.crossVectors(a, s), rotMat.makeBasis(i, a, s), e.setRotationFromMatrix(rotMat), e.parent && (e.parent.matrixWorld.decompose(tmpVec, tmpQuat, tmpVec), e.quaternion.premultiply(tmpQuat.invert())), this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$2);
  }
};
var FixOrthoZoomConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isFixOrthoZoomConstraint = true, this._orthoZoom = 1;
  }
  copy(e) {
    super.copy(e), this._orthoZoom = e._orthoZoom;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    const t = this.target;
    if (e.parent !== t || !t.isOrthographicCamera) return void console.error("FixOrthoZoom: object should be a direct child of the orthographic camera");
    const n = this._orthoZoom / t.zoom;
    e.position.multiplyScalar(n), e.scale.multiplyScalar(n), this._orthoZoom = t.zoom;
  }
};
var _vec3Tmp$2 = new Vector3();
var _vec3Tmp2$1 = new Vector3();
var _quatTmp$1 = new Quaternion();
var _bbox = new Box3();
var _bsphere = new Sphere();
var CanvasFitConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isCanvasFitConstraint = true, this.type = "CanvasFitConstraint", this.edgeH = "NONE", this.edgeV = "NONE", this.offset = 0, this.fitShape = "BOX", this.xr = null;
  }
  copy(e) {
    return super.copy(e), this.edgeH = e.edgeH, this.edgeV = e.edgeV, this.offset = e.offset, this.fitShape = e.fitShape, this.xr = e.xr, this;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    if (e.parent !== this.target) return void console.error(`CanvasFitConstraint: object ${e.name} should be a direct child of the camera`);
    let t, n, o, r;
    t = this.xr && this.xr.enabled && this.xr.isPresenting ? this.xr.getCamera() : this.target;
    const i = "LEFT" == this.edgeH ? -1 : "RIGHT" == this.edgeH ? 1 : 0, a = "BOTTOM" == this.edgeV ? -1 : "TOP" == this.edgeV ? 1 : 0;
    t.isPerspectiveCamera && (o = degToRad(t.fov / 2), n = Math.atan(t.aspect * Math.tan(o)), "LEFT" == this.edgeH && (n *= i), "BOTTOM" == this.edgeV && (o *= a), r = Math.abs(e.position.z)), e.geometry;
    let s = 0, l = 0, c = 0, u = 0;
    if (e.matrix.compose(e.position, e.quaternion, e.scale), "BOX" == this.fitShape) if (_bbox.makeEmpty(), e.resolveMultiMaterial().forEach(function(e2) {
      e2.geometry && (null == e2.geometry.boundingBox && e2.geometry.computeBoundingBox(), _bbox.union(e2.geometry.boundingBox));
    }), _bbox.isEmpty()) s = -i * this.offset, l = -a * this.offset;
    else {
      _bbox.applyMatrix4(e.matrix);
      const t2 = _bbox.getCenter(_vec3Tmp$2).sub(e.position), n2 = _bbox.getSize(_vec3Tmp2$1).addScalar(2 * this.offset);
      s = -(0.5 * n2.x * i + t2.x), l = -(0.5 * n2.y * a + t2.y), c = n2.x, u = n2.y;
    }
    else if ("SPHERE" == this.fitShape) if (_bsphere.makeEmpty(), e.resolveMultiMaterial().forEach(function(e2) {
      e2.geometry && (null === e2.geometry.boundingSphere && e2.geometry.computeBoundingSphere(), _bsphere.isEmpty() ? _bsphere.copy(e2.geometry.boundingSphere) : _bsphere.union(e2.geometry.boundingSphere));
    }), _bsphere.isEmpty()) s = -i * this.offset, l = -a * this.offset;
    else {
      _bsphere.applyMatrix4(e.matrix), _bsphere.radius += this.offset;
      const r2 = _vec3Tmp$2.copy(_bsphere.center).sub(e.position);
      s = -(_bsphere.radius * i + r2.x), l = -(_bsphere.radius * a + r2.y), t.isPerspectiveCamera && (s /= Math.cos(n), l /= Math.cos(o)), c = 2 * _bsphere.radius, u = 2 * _bsphere.radius;
    }
    else s = -i * this.offset, l = -a * this.offset;
    "STRETCH" == this.edgeH ? (e.position.x = s, 0 !== c && (e.scale.applyQuaternion(_quatTmp$1.copy(e.quaternion)), t.isPerspectiveCamera ? e.scale.x *= 2 * r * Math.tan(n) / c : e.scale.x *= (t.right - t.left) / t.zoom / c, e.scale.applyQuaternion(_quatTmp$1.copy(e.quaternion).invert()))) : "NONE" !== this.edgeH && (t.isPerspectiveCamera ? e.position.x = r * Math.tan(n) + s : e.position.x = (i < 0 ? t.left : t.right) / t.zoom + s), "STRETCH" == this.edgeV ? (e.position.y = l, 0 !== u && (e.scale.applyQuaternion(_quatTmp$1.copy(e.quaternion)), t.isPerspectiveCamera ? e.scale.y *= 2 * r * Math.tan(o) / u : e.scale.y *= (t.top - t.bottom) / t.zoom / u, e.scale.applyQuaternion(_quatTmp$1.copy(e.quaternion).invert()))) : "NONE" !== this.edgeV && (t.isPerspectiveCamera ? e.position.y = r * Math.tan(o) + l : e.position.y = (a < 0 ? t.bottom : t.top) / t.zoom + l);
  }
};
var CanvasBreakpointsConstraint = class extends Constraint {
  constructor() {
    super(), this.isCanvasBreakpointsConstraint = true, this.type = "CanvasBreakpointsConstraint", this.minWidth = 0, this.maxWidth = 1 / 0, this.minHeight = 0, this.maxHeight = 1 / 0, this.orientation = "ALL", this.appInstance = null;
  }
  copy(e) {
    return super.copy(e), this.minWidth = e.minWidth, this.maxWidth = e.maxWidth, this.minHeight = e.minHeight, this.maxHeight = e.maxHeight, this.orientation = e.orientation, this.appInstance = e.appInstance, this;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    if (!this.appInstance) return;
    const t = this.appInstance.getWidth(), n = this.appInstance.getHeight();
    let o;
    switch (this.orientation) {
      case "ALL":
        o = true;
        break;
      case "LANDSCAPE":
        o = t / n >= 1;
        break;
      case "PORTRAIT":
        o = t / n < 1;
    }
    if (this.appInstance.getCamera() !== e || t >= this.minWidth && t <= this.maxWidth && n >= this.minHeight && n <= this.maxHeight && o) t >= this.minWidth && t <= this.maxWidth && n >= this.minHeight && n <= this.maxHeight && o ? e.traverse((e2) => {
      e2.internVisible = true;
    }) : e.traverse((e2) => {
      e2.internVisible = false;
    });
    else {
      let o2 = this.findAlternativeCamera(e, this.appInstance.scene, t, n);
      o2 && this.appInstance.setCamera(o2);
    }
  }
  findAlternativeCamera(e, t, n, o) {
    let r, i, a = false;
    return e && t.traverse(function(t2) {
      if (!a && t2.isCamera && t2 != e) for (let e2 = 0; e2 < t2.constraints.length; e2++) {
        let s = t2.constraints[e2];
        if (s.isCanvasBreakpointsConstraint) {
          switch (s.orientation) {
            case "ALL":
              r = true;
              break;
            case "LANDSCAPE":
              r = n / o >= 1;
              break;
            case "PORTRAIT":
              r = n / o < 1;
          }
          n >= s.minWidth && n <= s.maxWidth && o >= s.minHeight && o <= s.maxHeight && r && (i ? (console.error("CanvasBreakpointsConstraint: two or more alternative cameras"), a = true) : i = t2);
        }
      }
    }), i;
  }
};
var isNdarray = function(e) {
  return !!e && (!!e.dtype && new RegExp("function View[0-9]+d(:?" + e.dtype + ")+").test(String(e.constructor)));
};
var isNdarrayLike = function(e) {
  return !!e && (void 0 !== e.data && Array.isArray(e.shape) && void 0 !== e.offset && void 0 !== e.stride);
};
function isArrayLike(e) {
  return Array.isArray(e) || ArrayBuffer.isView(e);
}
function inferType(e) {
  if (e) {
    if (isNdarray(e) || isNdarrayLike(e)) return "generic" === e.dtype ? inferType.GENERIC_NDARRAY : inferType.NDARRAY;
    if (isArrayLike(e)) return inferType.ARRAY_OF_ARRAYS;
    throw new Error("Unhandled data type. Got type: " + typeof e);
  }
}
function capitalize(e) {
  return e[0].toUpperCase() + e.slice(1);
}
inferType.ARRAY_OF_ARRAYS = "Arr", inferType.NDARRAY = "Nd", inferType.GENERIC_NDARRAY = "GenNd", inferType.PACKED = "PackArr";
var computeCacheKey = function(e, t, n, o, r, i) {
  var a, s = [], l = false;
  for (a = 0; a < e.splineDimension; a++) {
    var c = isArrayLike(e.knots) && isArrayLike(e.knots[a]);
    c && (l = true), s.push("Deg" + e.degree[a] + (c ? "" : "Uniform") + capitalize(e.boundary[a]));
  }
  var u = [[l ? "NU" : "", e.weights ? "RBS" : "BS"].join("") + e.dimension + "D", s.join("_")];
  return o && u.push(o + "Pts"), r && u.push(r + "Wts"), i && u.push(i + "Kts"), t && u.push("debug"), n && u.push("chk"), u.join("_");
};
var createVariable = function(e, t) {
  return function(t2, n) {
    void 0 === t2 || Array.isArray(t2) || (t2 = [t2]);
    for (var o = [], r = 0; r < t2.length; r++) o.push(createVariable.sum(t2[r]));
    if (n) for (t2 = 0; t2 < o.length; t2++) void 0 !== n[t2] && (o[t2] = "(" + o[t2] + " + " + n[t2] + ") % " + n[t2]);
    return e + o.join("_");
  };
};
function wrapAccessor(e) {
  return function(t, n) {
    void 0 === t || Array.isArray(t) || (t = [t]);
    for (var o = [], r = 0; r < t.length; r++) o.push(createVariable.sum(t[r]));
    if (n) for (t = 0; t < o.length; t++) void 0 !== n[t] && (o[t] = "(" + o[t] + " + " + n[t] + ") % " + n[t]);
    return e(o);
  };
}
function createAccessor(e, t) {
  var n;
  if (t) switch (inferType(t)) {
    case inferType.ARRAY_OF_ARRAYS:
      return wrapAccessor(function(t2) {
        return e + "[" + t2.join("][") + "]";
      });
    case inferType.GENERIC_NDARRAY:
      return wrapAccessor(function(t2) {
        return e + ".get(" + t2.join(",") + ")";
      });
    case inferType.NDARRAY:
      return wrapAccessor(function(t2) {
        var o = [e + "Offset"];
        for (n = 0; n < t2.length; n++) o.push(e + "Stride" + n + " * (" + t2[n] + ")");
        return e + "[" + o.join(" + ") + "]";
      });
    case inferType.PACKED:
    default:
      return;
  }
}
createVariable.sum = function(e) {
  return 0 === (e = (e = Array.isArray(e) ? e : [e]).filter(function(e2) {
    return void 0 !== e2 && 0 !== e2;
  })).length && e.push(0), e.join(" + ");
};
var createAccessors = function(e) {
  var t, n = {};
  return (t = createAccessor("x", e.points)) && (n.point = t), (t = createAccessor("w", e.weights)) && (n.weight = t), (t = createAccessor("k", e.knots)) && (n.knot = t), n;
};
var args = [];
var tmp = [];
var numericalDerivative = function(e, t, n) {
  if (1 !== t) throw new Error("Numerical derivative not implemented for order n = " + t + ".");
  var o, r = void 0 === arguments[this.splineDimension + 3] ? 1e-4 : arguments[this.splineDimension + 3];
  for (args.length = this.splineDimension, o = 0; o < this.splineDimension; o++) args[o + 1] = arguments[o + 3];
  var i, a, s, l = this.domain, c = l[n][0], u = l[n][1], d = args[n + 1], h = (u - c) * r;
  for ("closed" === this.boundary[n] ? (i = c + (d - c - h + (s = u - c)) % s, a = c + (d - c + h + s) % s, h *= 2) : (i = Math.min(u, Math.max(c, d - h)), h = (a = Math.min(u, Math.max(c, d + h))) - i), args[n + 1] = i, args[0] = tmp, this.evaluate.apply(null, args), args[n + 1] = a, args[0] = e, this.evaluate.apply(null, args), o = 0; o < this.dimension; o++) e[o] = (e[o] - tmp[o]) / h;
  return e;
};
var ndloop = function(e, t) {
  for (var n = 1, o = 0, r = []; o < e.length; o++) n *= Array.isArray(e[o]) ? e[o][1] - e[o][0] : e[o], r[o] = Array.isArray(e[o]) ? e[o][0] : 0;
  for (var i = 0; i < n; i++) for (t(r.slice()), o = e.length - 1; o >= 0; o--) {
    if (r[o] !== (Array.isArray(e[o]) ? e[o][1] : e[o]) - 1) {
      r[o]++;
      break;
    }
    r[o] = Array.isArray(e[o]) ? e[o][0] : 0;
  }
};
var accessorPreamble = function(e, t, n, o) {
  var r, i = [];
  switch (inferType(o)) {
    case inferType.NDARRAY:
      for (i.push("  const " + t + " = " + n + ".data;"), i.push("  const " + t + "Offset = " + n + ".offset;"), r = 0; r < o.dimension; r++) i.push("  const " + t + "Stride" + r + " = " + n + ".stride[" + r + "];");
      break;
    case inferType.ARRAY_OF_ARRAYS:
      i.push("  const " + t + " = " + n + ";");
  }
  return i.join("\n");
};
var sizeGetter = function(e, t, n) {
  if (e) {
    if (isNdarrayLike(e)) return t + ".shape[" + n + "]";
    for (var o = t, r = 0; r < n; r++) o += "[0]";
    return o + ".length";
  }
  return "this.size[" + n + "]";
};
var evaluatorCache = {};
var codeCache = {};
var createEvaluator = function(e, t, n, o, r, i, a) {
  var s, l, c, u, d, h, f = t.splineDimension, p = t.points, m = t.degree, g = t.weights, _ = void 0 !== g, A = t.knots, v = t.dimension, x = t.boundary;
  if (null != a) {
    Array.isArray(a) || (a = [a]);
    var y = 0;
    for (s = 0; s < f; s++) void 0 === a[s] && (a[s] = 0), y += a[s];
    if (_ && y > 1) throw new Error("Analytical derivative not implemented for rational b-splines with order n = " + y + ".");
  }
  i && (e = "Basis" + e), a && (e = "Der" + a.join("_") + "_" + e);
  var b = evaluatorCache[e];
  if (o) var C = "function" == typeof o ? o : console.log;
  if (b) return o && C(codeCache[e]), b.bind(t);
  var S = [], M = "evaluate" + e, E = n.point;
  i && (E = function(e2, t2) {
    for (var n2 = [], o2 = 0; o2 < e2.length; o2++) {
      for (var r2 = e2[o2], i2 = [], a2 = 0; a2 < r2.length; a2++) 0 !== r2[a2] && i2.push(r2[a2]);
      r2 = i2.join(" + "), t2[o2] && (r2 = "(" + r2 + " + " + t2[o2] + ") % " + t2[o2]), n2.push(r2 + " === " + B(o2));
    }
    return "((" + n2.join(" && ") + ") ? 1 : 0)";
  });
  var T = n.weight, I = n.knot, w = createVariable("k"), R = createVariable("x"), L = createVariable("w"), B = createVariable("i"), P = createVariable("t"), N = o ? "domain" : "d", D = createVariable(o ? "size" : "s"), O = createVariable(o ? "knotIndex" : "j"), F = true;
  for (d = 0; d < f; d++) isArrayLike(A) && isArrayLike(A[d]) && (F = false);
  function V(e2) {
    S.push("  " + (e2 || ""));
  }
  function U(e2) {
    o && V(e2);
  }
  if (i) var G = [];
  var z = [];
  for (s = 0; s < f; s++) i && G.push(B([s])), z.push(P([s]));
  for (S.push("function " + M + " (" + (i ? "" : "out, ") + z.join(", ") + (i ? ", " + G.join(", ") : "") + ") {"), V("let h, m, a, b;"), r && (V("const " + N + " = this.domain;"), V("for (let i = 0; i < this.splineDimension; i++) {"), V("  a = arguments[i + 1];"), V("  if (a < " + N + "[i][0] || a > " + N + "[i][1] || a === undefined || isNaN(a)) {"), V("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + N + "[i][0]+', '+" + N + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"), V("  }"), V("}")), d = 0; d < f; d++) V("let " + D(d) + " = " + sizeGetter(p, "this.points", d) + ";");
  function k(e2, t2, n2) {
    return "(" + e2 + ") ? (" + t2 + ") : (" + n2 + ")";
  }
  S.push(accessorPreamble(0, "x", "this.points", p)), _ && S.push(accessorPreamble(0, "w", "this.weights", g)), F || S.push(accessorPreamble(0, "k", "this.knots", A));
  var W = [];
  for (d = 0; d < f; d++) switch (inferType(A)) {
    case inferType.NDARRAY:
      W[d] = true;
      break;
    case inferType.ARRAY_OF_ARRAYS:
      W[d] = isArrayLike(A[d]);
  }
  for (d = 0; d < f; d++) if (W[d]) for (U("\n  // Bisect to locate the knot interval in dimension " + d + "\n"), V("let " + O(d) + " = 0;"), V("h = " + D(d) + ";"), V("while(h > " + O(d) + " + 1) {"), V("  m = 0.5 * (h + " + O(d) + ") | 0;"), V("  if (" + I([d, "m"]) + " > " + P(d) + ") h = m;"), V("  else " + O(d) + " = m;"), V("}"), U("\n  // Fetch knots for dimension " + d + "\n"), s = 1 - m[d]; s <= m[d]; s++) "closed" === x[d] ? V(s < 0 ? "let " + w([d, s + m[d] - 1]) + " = " + k(O(d) + " < " + -s, I([d, 0]) + " + " + I([d, [D(d), O(d), s]]) + " - " + I([d, [D(d)]]), I([d, [O(d), s]])) + ";" : s > 0 ? "let " + w([d, s + m[d] - 1]) + " = " + k(O(d) + " + " + s + " > " + D(d), I([d, D(d)]) + " + " + I([d, s + " + " + O(d) + " - " + D(d)]) + " - " + I([d, 0]), I([d, [O(d), s]])) + ";" : "let " + w([d, s + m[d] - 1]) + " = " + I([d, [O(d), s]]) + ";") : V("let " + w([d, s + m[d] - 1]) + " = " + I([d, [O(d), s]]) + ";");
  else {
    for (U("\n  // Directly compute knot interval for dimension " + d + "\n"), "closed" === x[d] ? V(O(d) + " = (" + P(d) + " | 0) % " + D(d) + ";") : (V(O(d) + " = (" + P(d) + " | 0);"), V("if (" + O(d) + " < " + m[d] + ") " + O(d) + " = " + m[d] + ";"), V("if (" + O(d) + " > " + D(d) + " - 1) " + O(d) + " = " + D(d) + " - 1;")), U("\n  // Compute and clamp knots for dimension " + d + "\n"), s = 1 - m[d]; s <= m[d]; s++) V("let " + (h = w([d, s + m[d] - 1])) + " = " + O(d) + " + " + s + ";");
    if ("clamped" === x[d]) for (s = 1 - m[d]; s <= m[d]; s++) h = w([d, s + m[d] - 1]), s < 0 && V("if (" + h + " < " + m[d] + ") " + h + " = " + m[d] + ";"), s > 0 && V("if (" + h + " > " + D(d) + ") " + h + " = " + D(d) + ";");
    "closed" === x[d] && (U("\n  // Wrap the B-Spline parameter for closed boundary"), V(P(d) + " %= " + D(d) + ";"));
  }
  for (d = 0, c = []; d < f; d++) c[d] = m[d] + 1;
  for (_ && (U("\n  // Fetch weights\n"), ndloop(c, function(e2) {
    for (var t2 = [], n2 = [], o2 = 0; o2 < f; o2++) t2[o2] = [O(o2), e2[o2] - m[o2]], "closed" === x[o2] && e2[o2] - m[o2] < 0 && (n2[o2] = D(o2));
    V("let " + L(e2) + " = " + T(t2, n2) + ";");
  })), o && V(_ ? "\n  // Fetch points and project into homogeneous (weighted) coordinates\n" : "\n  // Fetch points\n"), ndloop(c, function(e2) {
    for (var t2 = [], n2 = [], o2 = 0; o2 < f; o2++) t2[o2] = [O(o2), e2[o2] - m[o2]], "closed" === x[o2] && e2[o2] - m[o2] < 0 && (n2[o2] = D(o2));
    if (i) V(_ ? "let " + R(e2) + " = " + E(t2, n2) + " * " + L(e2) + ";" : "let " + R(e2) + " = " + E(t2, n2) + ";");
    else for (o2 = 0; o2 < v; o2++) {
      var r2 = e2.concat(o2);
      t2[f] = o2, V(_ ? "let " + R(r2) + " = " + E(t2, n2) + " * " + L(e2) + ";" : "let " + R(r2) + " = " + E(t2, n2) + ";");
    }
  }), U("\n"), U("// Perform De Boor's algorithm"), d = c.length - 1; d >= 0; d--) for (c[d] = [m[d], m[d] + 1], s = 0; s < m[d]; s++) for (U("\n  // Degree " + m[d] + " evaluation in dimension " + d + ", step " + (s + 1) + "\n"), l = m[d]; l > s; l--) {
    var Q = a && m[d] - s - a[d] <= 0;
    Q ? (V("m = 1 / (" + w([d, l - s + m[d] - 1]) + " - " + w([d, l - 1]) + ");"), _ && (V("a = (" + P(d) + " - " + w([d, l - 1]) + ") * m;"), V("b = 1 - a;"))) : (V("a = (" + P(d) + " - " + w([d, l - 1]) + ") / (" + w([d, l - s + m[d] - 1]) + " - " + w([d, l - 1]) + ");"), V("b = 1 - a;")), _ && ndloop(c, function(e2) {
      var t2 = e2.slice(), n2 = e2.slice();
      t2[d] = l, n2[d] = l - 1, Q && _ && V("h = " + L(t2) + ";"), V(L(t2) + " = b * " + L(n2) + " + a * " + L(t2) + ";");
    }), ndloop(c, function(e2) {
      var t2, n2, o2, r2 = e2.slice(), a2 = e2.slice();
      if (r2[d] = l, a2[d] = l - 1, Q) {
        var c2 = s + 1;
        if (i) t2 = _ ? "h * " + L(a2) + " / " + L(r2) + " * " : "", n2 = R(r2) + (_ ? " / h" : ""), o2 = R(a2) + (_ ? " / " + L(a2) : ""), V(R(r2) + " = " + c2 + " * " + t2 + "(" + n2 + " - " + o2 + ") * m;");
        else {
          var h2 = r2.slice(), p2 = a2.slice();
          for (u = 0; u < v; u++) h2[f] = p2[f] = u, t2 = _ ? "h * " + L(a2) + " / " + L(r2) + " * " : "", n2 = R(h2) + (_ ? " / h" : ""), o2 = R(p2) + (_ ? " / " + L(a2) : ""), V(R(h2) + " = " + c2 + " * " + t2 + "(" + n2 + " - " + o2 + ") * m;");
        }
      } else if (i) V(R(r2) + " = b * " + R(a2) + " + a * " + R(r2) + ";");
      else for (u = 0; u < v; u++) r2[f] = a2[f] = u, V(R(r2) + " = b * " + R(a2) + " + a * " + R(r2) + ";");
    }), U("\n");
  }
  if (o && V(_ ? "\n  // Project back from homogeneous coordinates and return final output\n" : "\n  // Return final output\n"), i) V(_ ? "return " + R(m) + " / " + L(m) + ";" : "return " + R(m) + ";");
  else for (d = 0; d < v; d++) V(_ ? "out[" + d + "] = " + R(m.concat([d])) + " / " + L(m) + ";" : "out[" + d + "] = " + R(m.concat([d])) + ";");
  if (i || V("return out;"), S.push("}"), o) {
    var H = S.join("\n");
    C(H), codeCache[e] = H;
  }
  const X = new Function([S.join("\n"), "; return ", M].join(""))();
  return evaluatorCache[e] = X, X.bind(t);
};
var transformerCache = {};
var createTransform = function(e, t, n, o) {
  var r, i, a, s, l, c, u, d, h = transformerCache[e];
  if (h) return h.bind(t);
  var f = [], p = "transform" + e;
  f.push("function " + p + "(m) {"), f.push("let i, w;"), f.push(accessorPreamble(0, "x", "this.points", t.points));
  var m = createVariable(o ? "size" : "s");
  for (r = 0; r < t.splineDimension; r++) f.push("let " + m(r) + " = " + sizeGetter(t.points, "this.points", r) + ";");
  for (s = [], r = 0; r < t.splineDimension; r++) a = "i" + r, s.push(a), f.push("for (" + a + " = " + m(r) + "- 1; " + a + " >= 0; " + a + "--) {");
  for (r = 0; r < t.dimension; r++) f.push("x" + r + " = " + n.point(s.concat([r])));
  for (l = [], r = 0; r < t.dimension; r++) l.push("m[" + ((t.dimension + 1) * (r + 1) - 1) + "] * x" + r);
  for (l.push("m[" + ((t.dimension + 1) * (t.dimension + 1) - 1) + "]"), f.push("const w = (" + l.join(" + ") + ") || 1.0;"), r = 0; r < t.dimension; r++) {
    for (l = [], c = t.dimension, i = 0; i < c; i++) l.push("m[" + (i * (c + 1) + r) + "] * x" + i);
    l.push("m[" + (i * (c + 1) + r) + "]"), d = n.point(s.concat([r])), u = "(" + l.join(" + ") + ") / w", f.push(d + " = " + u + ";");
  }
  for (r = t.splineDimension - 1; r >= 0; r--) f.push("}");
  f.push("return this;"), f.push("}");
  const g = new Function([f.join("\n"), "; return ", p].join(""))();
  return o && console.log(f.join("\n")), transformerCache[e] = g, g.bind(t);
};
var supportCache = {};
var createSupport = function(e, t, n, o, r) {
  var i = supportCache[e];
  if (i) return i.bind(t);
  var a, s, l, c = t.degree, u = t.knots, d = t.splineDimension, h = t.boundary, f = [], p = "support" + e, m = n.knot, g = createVariable("t"), _ = o ? "domain" : "d", A = createVariable(o ? "size" : "s"), v = createVariable(o ? "knotIndex" : "i"), x = true;
  for (l = 0; l < d; l++) isArrayLike(u) && isArrayLike(u[l]) && (x = false);
  function y(e2) {
    f.push("  " + (e2 || ""));
  }
  var b = [];
  for (a = 0; a < d; a++) b.push(g([a]));
  f.push("function " + p + " (out, " + b.join(", ") + ") {");
  var C = 0;
  function S(e2, t2) {
    y(void 0 === t2 ? "out[" + C++ + "] = " + e2.join(" + ") + ";" : "out[" + C++ + "] = (" + e2.join(" + ") + " + " + t2 + ") % " + t2 + ";");
  }
  for (y("let h, m;"), y("let c = 0;"), r && (y("const " + _ + " = this.domain;"), y("for (let i = 0; i < this.splineDimension; i++) {"), y("  a = arguments[i + 1];"), y("  if (a < " + _ + "[i][0] || a > " + _ + "[i][1] || a === undefined || isNaN(a)) {"), y("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + _ + "[i][0]+', '+" + _ + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');"), y("  }"), y("}")), l = 0; l < d; l++) y("let " + A(l) + " = " + sizeGetter(t.points, "this.points", l) + ";");
  x || f.push(accessorPreamble(0, "k", "this.knots", u));
  var M = [];
  for (l = 0; l < d; l++) switch (inferType(u)) {
    case inferType.NDARRAY:
      M[l] = true;
      break;
    case inferType.ARRAY_OF_ARRAYS:
      M[l] = isArrayLike(u[l]);
  }
  for (l = 0; l < d; l++) M[l] ? (y("let " + v(l) + " = 0;"), y("h = " + A(l) + ";"), y("while(h > " + v(l) + " + 1) {"), y("  m = 0.5 * (h + " + v(l) + ") | 0;"), y("  if (" + m([l, "m"]) + " > " + g(l) + ") h = m;"), y("  else " + v(l) + " = m;"), y("}")) : "closed" === h[l] ? y(v(l) + " = (" + g(l) + " | 0) % " + A(l) + ";") : (y(v(l) + " = (" + g(l) + " | 0);"), y("if (" + v(l) + " < " + c[l] + ") " + v(l) + " = " + c[l] + ";"), y("if (" + v(l) + " > " + A(l) + " - 1) " + v(l) + " = " + A(l) + " - 1;"));
  for (l = 0, s = []; l < d; l++) s[l] = c[l] + 1;
  ndloop(s, function(e2) {
    for (var t2 = [], n2 = [], o2 = 0; o2 < d; o2++) t2[o2] = [v(o2), e2[o2] - c[o2]], "closed" === h[o2] && e2[o2] - c[o2] < 0 && (n2[o2] = A(o2));
    for (o2 = 0; o2 < d; o2++) S(t2[o2], n2[o2]);
  }), y("out.length = " + C + ";"), y("return out;"), f.push("}"), o && console.log(f.join("\n"));
  const E = new Function([f.join("\n"), "; return ", p].join(""))();
  return supportCache[e] = E, E.bind(t);
};
var BOUNDARY_TYPES = { open: "open", closed: "closed", clamped: "clamped" };
function isBlank(e) {
  return null == e;
}
function parseNURBS(e, t, n, o, r, i) {
  var a, s;
  !e || isArrayLike(e) || isNdarray(e) ? (i = i || {}, this.weights = o, this.knots = n, this.degree = t, this.points = e, this.boundary = r, this.debug = i.debug, this.checkBounds = !!i.checkBounds, Object.defineProperty(this, "size", { value: i.size, writable: true, configurable: true })) : (i = e, this.debug = e.debug, this.checkBounds = !!e.checkBounds, this.weights = e.weights, this.knots = e.knots, this.degree = e.degree, this.boundary = e.boundary, this.points = e.points, Object.defineProperty(this, "size", { value: i.size, writable: true, configurable: true }));
  var l = inferType(this.points), c = inferType(this.weights), u = inferType(this.knots);
  if (this.points) switch (l) {
    case inferType.GENERIC_NDARRAY:
    case inferType.NDARRAY:
      Object.defineProperties(this, { splineDimension: { value: this.points.shape.length - 1, writable: false, configurable: true }, dimension: { value: this.points.shape[this.points.shape.length - 1], writable: false, configurable: true }, size: { get: function() {
        return this.points.shape.slice(0, this.points.shape.length - 1);
      }, set: function() {
        throw new Error("Cannot assign to read only property 'size'");
      }, configurable: true } });
      break;
    case inferType.ARRAY_OF_ARRAYS:
      var d = 0, h = this.size || [];
      h.length = 0;
      for (var f = this.points; isArrayLike(f[0]); f = f[0]) d++, h.push(f.length);
      if (0 === d) throw new Error("Expected an array of points");
      Object.defineProperties(this, { splineDimension: { value: d, writable: false, configurable: true }, dimension: { value: f.length, writable: false, configurable: true }, size: { get: function() {
        var e2 = [];
        e2.length = 0;
        for (var t2 = 0, n2 = this.points; t2 < this.splineDimension; t2++, n2 = n2[0]) e2[t2] = n2.length;
        return e2;
      }, set: function() {
        throw new Error("Cannot assign to read only property 'size'");
      }, configurable: true } });
      break;
    case inferType.PACKED:
    default:
      throw new Error("Expected either a packed array, array of arrays, or ndarray of points");
  }
  else {
    if (void 0 === this.size || null === this.size) throw new Error("Either points or a control hull size must be provided.");
    if (isArrayLike(this.size) || Object.defineProperty(this, "size", { value: [this.size], writable: true, configurable: true }), 0 === this.size.length) throw new Error("`size` must be a number or an array of length at least one.");
    Object.defineProperties(this, { splineDimension: { value: this.size.length, writable: false, configurable: true }, dimension: { value: 0, writable: false, configurable: true } });
  }
  if (isArrayLike(this.degree)) {
    for (a = 0; a < this.splineDimension; a++) if (isBlank(this.degree[a])) throw new Error("Missing degree in dimension " + (a + 1));
  } else {
    var p = !isBlank(this.degree), m = isBlank(this.degree) ? 2 : this.degree;
    for (this.degree = [], a = 0; a < this.splineDimension; a++) if (this.size[a] <= m) {
      if (p) throw new Error("Expected at least " + (m + 1) + " points for degree " + m + " spline in dimension " + (a + 1) + " but got only " + this.size[a]);
      this.degree[a] = this.size[a] - 1;
    } else this.degree[a] = m;
  }
  if (s = "string" != typeof this.boundary ? "open" : this.boundary, !BOUNDARY_TYPES[s]) throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + s);
  for (this.boundary = isArrayLike(this.boundary) ? this.boundary : [], this.boundary.length = this.splineDimension, a = 0; a < this.splineDimension; a++) if (this.boundary[a] = isBlank(this.boundary[a]) ? s : this.boundary[a], !BOUNDARY_TYPES[s]) throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + s + " for dimension " + (a + 1));
  if (u === inferType.ARRAY_OF_ARRAYS) for (isArrayLike(this.knots) && this.knots.length > 0 && !isArrayLike(this.knots[0]) && (this.knots = [this.knots]), a = 0; a < this.splineDimension; a++) {
    if (this.size[a] <= this.degree[a]) throw new Error("Expected at least " + (this.degree[a] + 1) + " points in dimension " + (a + 1) + " but got " + this.size[a] + ".");
    if (isArrayLike(this.knots[a])) {
      if ("closed" !== this.boundary[a] && this.knots[a].length !== this.degree[a] + this.size[a] + 1) throw new Error("Expected " + (this.degree[a] + this.size[a] + 1) + " knots in dimension " + (a + 1) + " but got " + this.knots[a].length + ".");
      if ("closed" === this.boundary[a] && this.knots[a].length !== this.size[a] + 1 && !(this.knots[a].length === this.size[a] + this.degree[a] + 1)) throw new Error("Expected " + (this.size[a] + 1) + " knots for closed spline in dimension " + (a + 1) + " but got " + this.knots[a].length + ".");
    }
  }
  var g = computeCacheKey(this, this.debug, this.checkBounds, l, c, u);
  if (g !== this.__cacheKey) {
    this.__cacheKey = g;
    var _ = createAccessors(this);
    this.evaluate = createEvaluator(this.__cacheKey, this, _, this.debug, this.checkBounds, false), this.transform = createTransform(this.__cacheKey, this, _, this.debug), this.support = createSupport(this.__cacheKey, this, _, this.debug, this.checkBounds), this.evaluator = function(e2, t2) {
      return createEvaluator(this.__cacheKey, this, _, this.debug, this.checkBounds, t2, e2);
    };
  }
  return this.numericalDerivative = numericalDerivative.bind(this), this;
}
function domainGetter() {
  var e, t = [], n = this.points;
  n ? isNdarrayLike(n) && (e = n.shape) : e = this.size;
  for (var o = 0; o < this.splineDimension; o++) {
    var r = e ? e[o] : n.length, i = this.degree[o], a = "closed" === this.boundary[o];
    if (this.knots && this.knots[o]) {
      var s = this.knots[o];
      t[o] = [s[a ? 0 : i], s[r]];
    } else t[o] = [a ? 0 : i, r];
    n && (n = n[0]);
  }
  return t;
}
function nurbs(e, t, n, o, r, i) {
  const a = function(e2, t2, n2, o2, r2, i2) {
    return s(e2, t2, n2, o2, r2, i2), a;
  }, s = parseNURBS.bind(a);
  return Object.defineProperty(a, "domain", { get: domainGetter }), s(e, t, n, o, r, i), a;
}
var QUAT_90_MX$1 = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var DIR_VECS = { X: new Vector3(1, 0, 0), Y: new Vector3(0, 1, 0), Z: new Vector3(0, 0, 1), "-X": new Vector3(-1, 0, 0), "-Y": new Vector3(0, -1, 0), "-Z": new Vector3(0, 0, -1) };
var UP_WORLD = new Vector3(0, 1, 0);
var FRONT_WORLD = new Vector3(0, 0, 1);
var OFFSET_MODE = { DEFAULT: 0, MATRIX: 1 };
var OFFSET_ROT_MODE = { ONLY_CONSTRAINT: 0, CONSTRAINT_FIRST: 1 };
var _pos$1 = new Vector3();
var _quat$1 = new Quaternion();
var _scale$1 = new Vector3();
var _tmpVec$1 = new Vector3();
var _tmpVec1 = new Vector3();
var _tmpVec2$1 = new Vector3();
var _tmpVecF = new Vector3();
var _tmpVecF1 = new Vector3();
var _tmpVecF2 = new Vector3();
var _tmpMat4 = new Matrix4();
var _tmpQuat$1 = new Quaternion();
var _tmpArray3 = [0, 0, 0];
var MotionPathConstraint = class extends Constraint {
  constructor() {
    super(), this.isMotionPathConstraint = true, this.type = "MotionPathConstraint", this.curve = null, this.firstDerivativeEvaluator = null, this.secondDerivativeEvaluatorForNonUniformBSplines = null, this.derivativeEvaluatorForWeights0 = null, this.derivativeEvaluatorForWeights1 = null, this.derivativeEvaluatorForWeights2 = null, this.degree = 3, this.cvs = [], this.knots = [], this.weights = [], this.value = 0, this.follow = true, this.frontAxis = "Z", this.upAxis = "Y", this.worldUpVector = new Vector3(0, 1, 0), this.useChordLength = false, this.chordsNum = 0, this.chordLengths = [], this.bank = false, this.bankScale = 1, this.bankLimit = 1 / 0, this.useFixedLocation = false, this.fixedValue = 0, this.usePointsTilt = false, this.pointsTilt = [], this.pointsTiltEvaluator = null, this.offsetValue = 0, this.useClampValue = false, this.useCyclic = false, this.useObjOffset = false, this.useRelative = false, this.usePosOffset = true, this.objOffsetMode = OFFSET_MODE.DEFAULT, this.objOffsetRotMode = OFFSET_ROT_MODE.ONLY_CONSTRAINT, this.influence = 1, this.fixCameraLightRotation = false, this._firstIteration = true, this._objMatrixWorldInit = new Matrix4(), this._objPosWorldInit = new Vector3(), this._objRotWorldInit = new Quaternion();
  }
  copy(e) {
    super.copy(e), this.degree = e.degree, this.cvs = [];
    for (let t = 0; t < e.cvs.length; ++t) this.cvs.push(e.cvs[t]);
    this.knots = [];
    for (let t = 0; t < e.knots.length; ++t) this.knots.push(e.knots[t]);
    this.weights = [];
    for (let t = 0; t < e.weights.length; ++t) this.weights.push(e.weights[t]);
    this.value = e.value, this.follow = e.follow, this.frontAxis = e.frontAxis, this.upAxis = e.upAxis, this.worldUpVector.copy(e.worldUpVector), this.useChordLength = e.useChordLength, this.chordsNum = e.chordsNum, this.bank = e.bank, this.bankScale = e.bankScale, this.bankLimit = e.bankLimit, this.useFixedLocation = e.useFixedLocation, this.fixedValue = e.fixedValue, this.usePointsTilt = e.usePointsTilt, this.pointsTilt = [];
    for (let t = 0; t < e.pointsTilt.length; ++t) this.pointsTilt.push(e.pointsTilt[t]);
    return this.offsetValue = e.offsetValue, this.useClampValue = e.useClampValue, this.useCyclic = e.useCyclic, this.useObjOffset = e.useObjOffset, this.useRelative = e.useRelative, this.usePosOffset = e.usePosOffset, this.objOffsetMode = e.objOffsetMode, this.objOffsetRotMode = e.objOffsetRotMode, this.influence = e.influence, this.fixCameraLightRotation = e.fixCameraLightRotation, this._firstIteration = true, this;
  }
  init() {
    const e = [], t = this.cvs;
    for (let n2 = 0; n2 < t.length; n2 += 3) e.push([t[n2], t[n2 + 1], t[n2 + 2]]);
    this.curve = nurbs({ points: e, knots: this.knots, weights: this.weights, degree: this.degree }), this.firstDerivativeEvaluator = this.curve.evaluator(1);
    let n = nurbs({ points: e, knots: this.knots, degree: this.degree });
    this.secondDerivativeEvaluatorForNonUniformBSplines = n.evaluator(2);
    const o = [];
    for (let e2 = 0; e2 < this.weights.length; ++e2) o.push([this.weights[e2]]);
    let r = nurbs({ points: o, knots: this.knots, degree: this.degree });
    if (this.derivativeEvaluatorForWeights0 = r.evaluator(0), this.derivativeEvaluatorForWeights1 = r.evaluator(1), this.derivativeEvaluatorForWeights2 = r.evaluator(2), this.usePointsTilt) {
      const e2 = [];
      for (let t3 = 0; t3 < this.pointsTilt.length; ++t3) e2.push([this.pointsTilt[t3]]);
      const t2 = nurbs({ points: e2, knots: this.knots, weights: this.weights, degree: this.degree });
      this.pointsTiltEvaluator = t2.evaluator(0);
    } else this.pointsTiltEvaluator = null;
    if (this.useChordLength) if (this.chordLengths = [], this.chordsNum <= 0) {
      let e2 = 1 == this.degree ? 1 : 32;
      this._calcChordLengths(this.chordLengths, this.cvs.length / 3 * e2);
    } else this._calcChordLengths(this.chordLengths, this.chordsNum);
  }
  update(e) {
    if (super.update(e), this.mute) return;
    this._firstIteration && (this._updateObjMatrixWorld(e), e.matrixWorld.decompose(this._objPosWorldInit, this._objRotWorldInit, _scale$1), this._objMatrixWorldInit.copy(e.matrixWorld), this.useRelative && (this._calcPosition(_pos$1, 0), this._objPosWorldInit.sub(_pos$1), this._objMatrixWorldInit.setPosition(this._objPosWorldInit)), this.usePosOffset || (this._objPosWorldInit.set(0, 0, 0), this._objMatrixWorldInit.setPosition(this._objPosWorldInit)), this._firstIteration = false);
    let t = this.useFixedLocation ? this.fixedValue : this.value + this.offsetValue;
    this.useCyclic ? t -= Math.floor(t) : t = this.useClampValue ? clamp(t, 0, 1) : Math.max(0, t), this.useChordLength && (t = this._convertParamToChordLength(t, this.chordLengths));
    const n = this.curve.domain, o = t * (n[0][1] - n[0][0]) + n[0][0];
    if (this._calcPosition(e.position, o), !this.follow && this.useObjOffset && (_tmpVec$1.addVectors(e.position, this._objPosWorldInit), e.position.lerpVectors(this._objPosWorldInit, _tmpVec$1, this.influence)), this.follow && 1 != Math.abs(DIR_VECS[this.frontAxis].dot(DIR_VECS[this.upAxis]))) {
      const t2 = this._calcTangent(_tmpVec$1, o), n2 = _tmpVec1.copy(t2).normalize();
      if (this._calcCurveRotMat(_tmpMat4, n2, this.worldUpVector), this._calcFrontAndUpVecsRotQuat(_quat$1, DIR_VECS[this.frontAxis], DIR_VECS[this.upAxis]), e.quaternion.setFromRotationMatrix(_tmpMat4).multiply(_quat$1), this.bank) {
        const n3 = this._calcSecondDerivative(_tmpVec1, o, e.position, t2), r = this._calcCurvature(t2, n3), i = _tmpVec2$1.copy(DIR_VECS[this.upAxis]).applyQuaternion(e.quaternion);
        let a = this._calcBankAngle(r, t2, n3, i);
        a = this._limitAngle(a * this.bankScale, this.bankLimit), _quat$1.setFromAxisAngle(DIR_VECS[this.frontAxis], a), e.quaternion.multiply(_quat$1);
      } else if (this.usePointsTilt) {
        this.pointsTiltEvaluator(_tmpArray3, o);
        let t3 = _tmpArray3[0];
        _quat$1.setFromAxisAngle(DIR_VECS[this.frontAxis], t3), e.quaternion.multiply(_quat$1);
      }
      if (this.useObjOffset) {
        if (this.objOffsetMode == OFFSET_MODE.MATRIX) {
          const t3 = _tmpVec$1.setScalar(1);
          _tmpMat4.compose(e.position, e.quaternion, t3), this.objOffsetRotMode == OFFSET_ROT_MODE.CONSTRAINT_FIRST && _tmpMat4.multiply(this._objMatrixWorldInit), _tmpMat4.decompose(_pos$1, _quat$1, _scale$1);
        } else this.objOffsetMode == OFFSET_MODE.DEFAULT && (_pos$1.addVectors(e.position, this._objPosWorldInit), this.objOffsetRotMode == OFFSET_ROT_MODE.ONLY_CONSTRAINT ? _quat$1.copy(e.quaternion) : this.objOffsetRotMode == OFFSET_ROT_MODE.CONSTRAINT_FIRST && _quat$1.multiplyQuaternions(e.quaternion, this._objRotWorldInit));
        e.position.lerpVectors(this._objPosWorldInit, _pos$1, this.influence), e.quaternion.slerpQuaternions(this._objRotWorldInit, _quat$1, this.influence);
      }
      this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX$1);
    }
  }
  _calcPosition(e, t) {
    return this.curve.evaluate(_tmpArray3, t), e.fromArray(_tmpArray3);
  }
  _calcTangent(e, t) {
    return this.firstDerivativeEvaluator(_tmpArray3, t), e.fromArray(_tmpArray3);
  }
  _calcCurveRotMat(e, t, n) {
    const o = _tmpVecF.copy(n), r = _tmpVecF1.crossVectors(o, t).normalize();
    return o.crossVectors(t, r), e.makeBasis(r, o, t), e;
  }
  _calcFrontAndUpVecsRotQuat(e, t, n) {
    e.setFromUnitVectors(t, FRONT_WORLD);
    const o = _tmpVecF.copy(UP_WORLD), r = _tmpVecF1.copy(n).applyQuaternion(e), i = r.dot(o);
    if (1 != Math.abs(i)) {
      const n2 = _tmpVecF2.crossVectors(r, o).dot(FRONT_WORLD) > 0 ? 1 : -1;
      _tmpQuat$1.setFromAxisAngle(t, r.angleTo(o) * n2), e.multiply(_tmpQuat$1);
    } else i < 0 && (_tmpQuat$1.setFromAxisAngle(t, Math.PI), e.multiply(_tmpQuat$1));
    return e;
  }
  _calcBankAngle(e, t, n, o) {
    const r = _tmpVecF.copy(t).add(n).normalize();
    return e * (_tmpVecF1.crossVectors(r, t).normalize().dot(o) > 0 ? 1 : -1);
  }
  _calcCurvature(e, t) {
    return _tmpVecF.crossVectors(e, t).length() / Math.pow(e.length(), 3);
  }
  _calcSecondDerivative(e, t, n, o) {
    this.secondDerivativeEvaluatorForNonUniformBSplines(_tmpArray3, t);
    const r = _tmpVecF.fromArray(_tmpArray3);
    this.derivativeEvaluatorForWeights1(_tmpArray3, t);
    const i = _tmpArray3[0];
    this.derivativeEvaluatorForWeights2(_tmpArray3, t);
    const a = _tmpArray3[0];
    this.derivativeEvaluatorForWeights0(_tmpArray3, t);
    const s = _tmpArray3[0];
    return e.copy(r).sub(_tmpVecF1.copy(o).multiplyScalar(2 * i)), e.sub(_tmpVecF1.copy(n).multiplyScalar(a)), e.divideScalar(s), e;
  }
  _limitAngle(e, t) {
    return e > 0 ? Math.min(e, t) : Math.max(e, -t);
  }
  _calcChordLengths(e, t) {
    let n = 1 / Math.max(1, t - 1), o = 0, r = 0;
    const i = this.curve.domain;
    let a = i[0][0], s = i[0][1] - i[0][0];
    const l = _tmpVecF, c = _tmpVecF1;
    this._calcPosition(l, a);
    for (let i2 = 0; i2 < t; ++i2) this._calcPosition(c, o * s + a), r += l.subVectors(c, l).length(), e.push(r), l.copy(c), o += n;
    return e;
  }
  _convertParamToChordLength(e, t) {
    if (e <= 0) return 0;
    if (e >= 1) return 1;
    let n = e * t[t.length - 1], o = 0, r = 0, i = t.length - 1;
    for (; o < i; ) r = o + Math.floor((i - o) / 2), n > t[r] ? o = r + 1 : i = r - 1;
    return n > t[i] ? i += (n - t[i]) / (t[i + 1] - t[i]) : i -= 1 - (n - t[i - 1]) / (t[i] - t[i - 1]), i / (t.length - 1);
  }
};
var QUAT_90_MX = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
var _pos = new Vector3();
var _quat = new Quaternion();
var _scale = new Vector3();
var _rot = new Euler();
var _mat4Tmp = new Matrix4();
var _mat4Tmp2 = new Matrix4();
var AXIS_INDEX = { X: 0, Y: 1, Z: 2, "-X": 0, "-Y": 1, "-Z": 2 };
var COMP_LIST = ["x", "y", "z"];
var _vec3Tmp$1 = new Vector3();
var _vec3Tmp2 = new Vector3();
var _vec3Tmp3 = new Vector3();
var _eulerTmp = new Euler();
function transformCoordsSpace(e, t, n, o = false) {
  if (t === n) return e;
  const r = e.y, i = e.z;
  return "Z_UP_RIGHT" === t && "Y_UP_RIGHT" === n ? (e.y = i, e.z = o ? r : -r) : "Y_UP_RIGHT" === t && "Z_UP_RIGHT" === n ? (e.y = o ? i : -i, e.z = r) : console.error("transformCoordsSpace: Unsupported coordinate space"), e;
}
var transformEulerV3dToBlenderShortest = function() {
  const e = new Euler(), t = new Euler(), n = new Vector3();
  return function(o, r) {
    const i = e.copy(o).reorder("YZX"), a = t.copy(i).makeAlternative(), s = n.setFromEuler(i).lengthSq(), l = n.setFromEuler(a).lengthSq();
    return r.copy(s < l ? i : a), transformCoordsSpace(r, "Y_UP_RIGHT", "Z_UP_RIGHT");
  };
}();
var TransformationConstraint = class extends TargetConstraint {
  constructor(e) {
    super(e), this.isTransformationConstraint = true, this.type = "TransformationConstraint", this.coordSystem = "Y_UP_RIGHT", this.fromMin = new Vector3(), this.fromMax = new Vector3(), this.toMin = new Vector3(), this.toMax = new Vector3(), this.mapFrom = "POSITION", this.mapTo = "POSITION", this.mapToAxisFromAxis = ["X", "Y", "Z"], this.mixMode = "REPLACE", this.ownerSpaceObj = null, this.targetSpaceObj = null, this.ownerSpace = 0, this.targetSpace = 0, this.useMotionExtrapolate = false, this.influence = 1, this.fixCameraLightRotation = false, this._firstIteration = true, this._objMatrixWorldInit = new Matrix4(), this._objMatrixInit = new Matrix4();
  }
  copy(e) {
    return super.copy(e), this.coordSystem = e.coordSystem, this.fromMin.copy(e.fromMin), this.fromMax.copy(e.fromMax), this.toMin.copy(e.toMin), this.toMax.copy(e.toMax), this.mapFrom = e.mapFrom, this.mapTo = e.mapTo, this.mapToAxisFromAxis = e.mapToAxisFromAxis, this.mixMode = e.mixMode, this.ownerSpaceObj = e.ownerSpaceObj, this.targetSpaceObj = e.targetSpaceObj, this.ownerSpace = e.ownerSpace, this.targetSpace = e.targetSpace, this.useMotionExtrapolate = e.useMotionExtrapolate, this.influence = e.influence, this.fixCameraLightRotation = e.fixCameraLightRotation, this._firstIteration = true, this;
  }
  update(e) {
    if (super.update(e), this.mute) return;
    this._firstIteration && (this._updateObjMatrixWorld(e), this._objMatrixWorldInit.copy(e.matrixWorld), this._objMatrixInit.copy(e.matrix), this._firstIteration = false);
    const t = _mat4Tmp;
    if (0 == this.targetSpace) t.copy(this.target.matrixWorld);
    else if (2 == this.targetSpace) t.copy(this.target.matrix);
    else if (1 == this.targetSpace) {
      if (!this.targetSpaceObj) return;
      t.copy(this.targetSpaceObj.matrixWorld).invert(), t.multiply(this.target.matrixWorld);
    }
    if (t.decomposeE(_pos, _rot, _scale), 0 == this.ownerSpace && e.parent) this._objMatrixWorldInit.decomposeE(e.position, e.rotation, e.scale);
    else if (2 == this.ownerSpace) this._objMatrixInit.decomposeE(e.position, e.rotation, e.scale);
    else if (1 == this.ownerSpace) {
      if (!this.ownerSpaceObj) return;
      _mat4Tmp2.copy(this.ownerSpaceObj.matrixWorld).invert(), _mat4Tmp2.multiply(this._objMatrixWorldInit), _mat4Tmp2.decomposeE(e.position, e.rotation, e.scale);
    }
    const n = _vec3Tmp$1;
    if ("POSITION" == this.mapFrom) n.copy(_pos);
    else if ("ROTATION" == this.mapFrom) if ("Z_UP_RIGHT" == this.coordSystem) {
      const e2 = transformEulerV3dToBlenderShortest(_rot, _eulerTmp);
      transformCoordsSpace(e2, this.coordSystem, "Y_UP_RIGHT"), n.copy(e2);
    } else n.copy(_rot);
    else "SCALE" == this.mapFrom && n.copy(_scale);
    const o = _vec3Tmp2.set(0, 0, 0), r = n, i = this.fromMin, a = this.fromMax;
    for (const e2 of COMP_LIST) a[e2] - i[e2] != 0 && (this.useMotionExtrapolate || (r[e2] = Math.min(Math.max(r[e2], i[e2]), a[e2])), o[e2] = (r[e2] - i[e2]) / (a[e2] - i[e2]));
    const s = this.toMin, l = this.toMax, c = _vec3Tmp3;
    for (let e2 = 0; e2 < 3; e2++) {
      const t2 = COMP_LIST[e2];
      this.mapToAxisFromAxis[e2].indexOf("-") > -1 ? c[t2] = s[t2] + (1 - o[COMP_LIST[AXIS_INDEX[this.mapToAxisFromAxis[e2]]]]) * (l[t2] - s[t2]) : c[t2] = s[t2] + o[COMP_LIST[AXIS_INDEX[this.mapToAxisFromAxis[e2]]]] * (l[t2] - s[t2]);
    }
    if ("POSITION" == this.mapTo) "ADD" == this.mixMode ? c.add(e.position) : this.mixMode, e.position.lerp(c, this.influence);
    else if ("ROTATION" == this.mapTo) {
      const t2 = _quat;
      if ("ADD" == this.mixMode) {
        const n2 = _eulerTmp.set(0, 0, 0, "XYZ");
        "Z_UP_RIGHT" == this.coordSystem ? (transformEulerV3dToBlenderShortest(e.rotation, n2), transformCoordsSpace(n2, this.coordSystem, "Y_UP_RIGHT"), n2.x += c.x, n2.y += c.y, n2.z += c.z, n2.order = "YZX") : n2.set(e.rotation.x + c.x, e.rotation.y + c.y, e.rotation.z + c.z), t2.setFromEuler(n2);
      } else {
        const n2 = _eulerTmp.setFromVector3(c);
        "Z_UP_RIGHT" == this.coordSystem && (n2.order = "YZX"), t2.setFromEuler(n2), "AFTER" == this.mixMode ? t2.premultiply(e.quaternion) : "BEFORE" == this.mixMode ? t2.multiply(e.quaternion) : this.mixMode;
      }
      e.quaternion.slerp(t2, this.influence);
    } else "SCALE" == this.mapTo && ("REPLACE" == this.mixMode || "MULTIPLY" == this.mixMode && c.multiply(e.scale), e.scale.lerp(c, this.influence));
    if (0 == this.ownerSpace && e.parent) e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrix.multiplyMatrices(_mat4Tmp.copy(e.parent.matrixWorld).invert(), e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale);
    else if (1 == this.ownerSpace) {
      if (!this.ownerSpaceObj) return;
      e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorld.premultiply(_mat4Tmp.copy(this.ownerSpaceObj.matrixWorld)), e.matrix.copy(e.matrixWorld), e.parent && e.matrix.premultiply(_mat4Tmp.copy(e.parent.matrixWorld).invert()), e.matrix.decompose(e.position, e.quaternion, e.scale);
    }
    "ROTATION" == this.mapTo && this.fixCameraLightRotation && (e.isCamera || e.isLight) && e.quaternion.multiply(QUAT_90_MX);
  }
};
var TEXTURE_NODES = ["IMAGE_AR", "SKYDOME_LIGHT_AR", "TEXTURE_BL", "TEX_IMAGE_BL", "TEX_ENVIRONMENT_BL", "BITMAP_MX", "BITMAP_ENV_MX", "REFLECT_REFRACT_MX", "FILE_MY", "AI_SKYDOME_LIGHT_MY", "OSL_NODE"];
var GLTFLoader = class extends Loader {
  constructor(e) {
    super(e), this.ktx2Loader = null, this.pluginCallbacks = [], this.register(function(e2) {
      return new GLTFTextureBasisUExtension(e2);
    }), this.register(function(e2) {
      return new GLTFTextureWebPExtension(e2);
    }), this.register(function(e2) {
      return new V3DLightsExtension(e2);
    }), this.register(function(e2) {
      return new V3DLightProbesExtension(e2);
    }), this.register(function(e2) {
      return new V3DCurvesExtension(e2);
    }), this.register(function(e2) {
      return new V3DClippingPlanesExtension(e2);
    }), this.register(function(e2) {
      return new V3DSceneExtension(e2);
    }), this.register(function(e2) {
      return new V3DNodeExtension(e2);
    }), this.register(function(e2) {
      return new V3DCameraExtension(e2);
    }), this.register(function(e2) {
      return new V3DMaterialExtension(e2);
    }), this.register(function(e2) {
      return new V3DTextureExtension(e2);
    }), this.onProgress = null;
  }
  load(e, t, n, o) {
    const r = this;
    let i;
    r.onProgress = n || function() {
    }, i = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : LoaderUtils.extractUrlBase(e);
    const a = -1 != e.indexOf(".xz", e.length - 3);
    let s;
    a ? s = new XZLoader(r.manager) : (s = new FileLoader(r.manager), s.setResponseType("arraybuffer"));
    const l = function(e2) {
      r.onProgress && r.onProgress(0.3 * e2 * 100);
    };
    let c = l;
    s instanceof FileLoader && (c = function(e2) {
      const t2 = e2.lengthComputable ? e2.loaded / e2.total : 1;
      l(t2);
    }), s.load(e, function(e2) {
      try {
        r.parse(e2, i, t, o, a);
      } catch (e3) {
        void 0 !== o && o(e3.constructor === Error ? e3 : new Error("v3d.GLTFLoader: Unable to parse model."));
      }
    }, c, o);
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder() {
    return console.error("v3d.GLTFLoader: Mesh optimization is not supported, please use LZMA compression."), this;
  }
  setDRACOLoader() {
    return console.error("v3d.GLTFLoader: Draco compression is not supported, please use LZMA compression."), this;
  }
  register(e) {
    return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, o, r) {
    let i;
    const a = {}, s = {};
    if ("string" == typeof e) i = e;
    else {
      if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          a[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e);
        } catch (e2) {
          return void (o && o(e2));
        }
        i = a[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else i = LoaderUtils.decodeText(new Uint8Array(e));
    }
    const l = JSON.parse(i);
    if (void 0 === l.asset || l.asset.version[0] < 2) return void (o && o(new Error("v3d.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
    const c = this, u = new GLTFParser(l, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, loadBinXZ: r, onProgress: function(e2) {
      c.onProgress && c.onProgress(e2);
    } });
    for (let e2 = 0; e2 < this.pluginCallbacks.length; e2++) {
      const t2 = this.pluginCallbacks[e2](u);
      s[t2.name] = t2, a[t2.name] = true;
    }
    if (l.extensionsUsed) for (let e2 = 0; e2 < l.extensionsUsed.length; ++e2) {
      const t2 = l.extensionsUsed[e2], n2 = l.extensionsRequired || [];
      if (t2 === EXTENSIONS.KHR_MATERIALS_UNLIT) a[t2] = new GLTFMaterialsUnlitExtension();
      else n2.indexOf(t2) >= 0 && void 0 === s[t2] && console.warn('v3d.GLTFLoader: Unknown extension "' + t2 + '".');
    }
    u.setExtensions(a), u.setPlugins(s), u.parse(function(e2) {
      c.onProgress && c.onProgress(100), n(e2);
    }, o);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(o, r) {
      n.parse(e, t, o, r);
    });
  }
};
function GLTFRegistry() {
  let e = {};
  return { get: function(t) {
    return e[t];
  }, add: function(t, n) {
    e[t] = n;
  }, remove: function(t) {
    delete e[t];
  }, removeAll: function() {
    e = {};
  } };
}
var EXTENSIONS = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", EXT_TEXTURE_WEBP: "EXT_texture_webp", S8S_V3D_ANIMATION: "S8S_v3d_animation", S8S_V3D_CAMERA: "S8S_v3d_camera", S8S_V3D_MATERIALS: "S8S_v3d_materials", S8S_V3D_MESH: "S8S_v3d_mesh", S8S_V3D_NODE: "S8S_v3d_node", S8S_V3D_SCENE: "S8S_v3d_scene", S8S_V3D_TEXTURE: "S8S_v3d_texture", S8S_V3D_LIGHTS: "S8S_v3d_lights", S8S_V3D_LIGHT_PROBES: "S8S_v3d_light_probes", S8S_V3D_CURVES: "S8S_v3d_curves", S8S_V3D_CLIPPING_PLANES: "S8S_v3d_clipping_planes" };
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(e, t, n) {
    const o = [];
    e.color = new Color(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const t2 = r.baseColorFactor;
        e.color.fromArray(t2), e.opacity = t2[3];
      }
      void 0 !== r.baseColorTexture && o.push(n.assignTexture(e, "map", r.baseColorTexture, 3001));
    }
    return Promise.all(o);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, o = n.textures[e];
    if (!o.extensions || !o.extensions[this.name]) return null;
    const r = o.extensions[this.name], i = t.options.ktx2Loader;
    if (!i) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("v3d.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, i);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, o = n.json, r = o.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const i = r.extensions[t], a = o.images[i.source];
    let s = n.textureLoader;
    if (a.uri) {
      const e2 = n.options.manager.getHandler(a.uri);
      null !== e2 && (s = e2);
    }
    return this.detectSupport().then(function(r2) {
      if (r2) return n.loadTextureImage(e, i.source, s);
      if (o.extensionsRequired && o.extensionsRequired.indexOf(t) >= 0) throw new Error("v3d.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(1 === t.height);
      };
    })), this.isSupported;
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(e) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, 12);
    if (this.header = { magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, true), length: t.getUint32(8, true) }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw new Error("v3d.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2) throw new Error("v3d.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - 12, o = new DataView(e, 12);
    let r = 0;
    for (; r < n; ) {
      const t2 = o.getUint32(r, true);
      r += 4;
      const n2 = o.getUint32(r, true);
      if (r += 4, n2 === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const n3 = new Uint8Array(e, 12 + r, t2);
        this.content = LoaderUtils.decodeText(n3);
      } else if (n2 === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const n3 = 12 + r;
        this.body = e.slice(n3, n3 + t2);
      }
      r += t2;
    }
    if (null === this.content) throw new Error("v3d.GLTFLoader: JSON content not found.");
  }
};
var V3DLightsExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.S8S_V3D_LIGHTS, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, o = t.length; n < o; n++) {
      const o2 = t[n];
      o2.extensions && o2.extensions[this.name] && void 0 !== o2.extensions[this.name].light && e._addNodeRef(this.cache, o2.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let o = t.cache.get(n);
    if (o) return o;
    const r = t.json, i = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let a;
    const s = new Color().fromArray(i.color), l = i.intensity ?? 1;
    switch (i.type) {
      case "point":
        a = new PointLight(s, l);
        break;
      case "directional":
        a = new DirectionalLight(s, l);
        break;
      case "spot":
        a = new SpotLight(s, l);
        break;
      case "area":
        a = new RectAreaLight(s, l, i.width, i.height);
        break;
      case "ambient":
        a = new AmbientLight(s, l);
        break;
      default:
        console.error("v3d.GLTFLoader: Invalid light type", i.type);
    }
    let c;
    return isDef(i.distance) && (a.distance = i.distance), isDef(i.decay) && (a.decay = i.decay, "blender" != i.profile || isDef(i.power) || (a.userData.usePowerUnits = true, a.power = l)), isDef(i.power) && (a.userData.usePowerUnits = true, a.power = i.power), isDef(i.angle) && (a.angle = i.angle), isDef(i.penumbra) && (a.penumbra = i.penumbra), a.isRectAreaLight && RectAreaLightUniformsLib.init(i.ltcMat1, i.ltcMat2), isDef(i.shadow) ? (isDef(i.shadow.enabled) || (i.shadow.enabled = true), a.castShadow = i.shadow.enabled, a.shadow.bias = i.shadow.bias, isDef(i.shadow.expBias) && (a.shadow.expBias = i.shadow.expBias), isDef(i.shadow.slopeScaledBias) && (a.shadow.slopeScaledBias = i.shadow.slopeScaledBias), a.shadow.radius = i.shadow.radius, a.shadow.mapSize.width = i.shadow.mapSize, a.shadow.mapSize.height = i.shadow.mapSize, a.shadow.camera.near = i.shadow.cameraNear, a.shadow.camera.far = i.shadow.cameraFar, a.isSpotLight ? (a.shadow.camera.fov = radToDeg(i.shadow.cameraFov), a.shadow.useMinFov90 = "blender" === i.profile) : a.isDirectionalLight && (isDef(i.shadow.cameraOrthoLeft) && isDef(i.shadow.cameraOrthoRight) && isDef(i.shadow.cameraOrthoBottom) && isDef(i.shadow.cameraOrthoTop) && (a.shadow.camera.left = i.shadow.cameraOrthoLeft, a.shadow.camera.right = i.shadow.cameraOrthoRight, a.shadow.camera.bottom = i.shadow.cameraOrthoBottom, a.shadow.camera.top = i.shadow.cameraOrthoTop), a.shadow.maxDistance = i.shadow.cameraFar, isDef(i.shadow.csm) && (isDef(i.shadow.csm.count) && (a.shadow.numCascades = i.shadow.csm.count), isDef(i.shadow.csm.maxDistance) && (a.shadow.maxDistance = i.shadow.csm.maxDistance), isDef(i.shadow.csm.fade) && (a.shadow.fade = i.shadow.csm.fade), isDef(i.shadow.csm.exponent) && (a.shadow.exponent = i.shadow.csm.exponent), isDef(i.shadow.csm.lightMargin) && (a.shadow.lightMargin = i.shadow.csm.lightMargin)), a.shadow.createCascades()), a.shadow.camera.updateProjectionMatrix()) : a.castShadow = false, a.name = i.name ? t.createUniqueName(i.name) : "", (a.isDirectionalLight || a.isSpotLight) && isDef(i.target) ? (a.isFreeLight = false, c = t.getDependency("node", i.target)) : a.isDirectionalLight || a.isSpotLight ? (a.isFreeLight = true, c = Promise.resolve()) : c = Promise.resolve(), c.then((e2) => (e2 && (a.target = e2), o = Promise.resolve(a), t.cache.add(n, o), o));
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, o = n.json.nodes[e], r = (o.extensions && o.extensions[this.name] || {}).light;
    return void 0 === r ? null : this._loadLight(r).then(function(e2) {
      return n._getNodeRef(t.cache, r, e2);
    });
  }
};
var V3DLightProbesExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.S8S_V3D_LIGHT_PROBES, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, o = t.length; n < o; n++) {
      const o2 = t[n];
      o2.extensions && o2.extensions[this.name] && void 0 !== o2.extensions[this.name].lightProbe && e._addNodeRef(this.cache, o2.extensions[this.name].lightProbe);
    }
  }
  _loadLightProbe(e) {
    const t = this.parser, n = "lightProbe:" + e;
    let o = t.cache.get(n);
    if (o) return o;
    const r = t.json, i = ((r.extensions && r.extensions[this.name] || {}).lightProbes || [])[e];
    let a;
    const s = i.type || "CUBEMAP";
    if ("CUBEMAP" == s || "SPHERE" == s) {
      switch (a = new CubeReflectionProbe(), i.influenceType) {
        case "ELIPSOID":
          a.influenceType = 1;
          break;
        case "BOX":
          a.influenceType = 2;
      }
      switch (i.parallaxType) {
        case "ELIPSOID":
          a.parallaxType = 1;
          break;
        case "BOX":
          a.parallaxType = 2;
      }
      a.parallaxDistance = i.parallaxDistance, a.probeClipEnd = i.clipEnd, a.probeIntensity = i.intensity, isDef(i.influenceGroup) && (a.influenceGroup = i.influenceGroup), isDef(i.influenceGroupInv) && (a.influenceGroupInv = i.influenceGroupInv);
    } else a = new PlaneReflectionProbe(), a.falloff = i.falloff, isDef(i.planeSize) && a.planeSize.set(i.planeSize[0], i.planeSize[1]);
    return a.influenceDistance = i.influenceDistance, a.probeClipStart = i.clipStart, a.visibilityGroup = i.visibilityGroup, a.visibilityGroupInv = i.visibilityGroupInv, a.name = t.createUniqueName(i.name || "lightProbe_" + e), o = Promise.resolve(a), t.cache.add(n, o), o;
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, o = n.json.nodes[e], r = (o.extensions && o.extensions[this.name] || {}).lightProbe;
    return void 0 === r ? null : this._loadLightProbe(r).then(function(e2) {
      return n._getNodeRef(t.cache, r, e2);
    });
  }
};
var V3DCurvesExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.S8S_V3D_CURVES, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, o = t.length; n < o; n++) {
      const o2 = t[n];
      o2.extensions && o2.extensions[this.name] && void 0 !== o2.extensions[this.name].curve && e._addNodeRef(this.cache, o2.extensions[this.name].curve);
    }
  }
  _loadOpenType() {
    return new Promise(function(e) {
      loadModule("opentype.js", function() {
        e();
      }, function() {
        console.error("GLTFLoader: opentype.js module not found, please copy it to your app directory"), e();
      });
    });
  }
  _loadFont(e) {
    const t = this.parser, n = "font:" + e;
    let o = t.cache.get(n);
    if (o) return o;
    const r = t.json, i = ((r.extensions && r.extensions[this.name] || {}).fonts || [])[e];
    let a = i.uri, s = false;
    return void 0 !== i.bufferView && (a = t.getDependency("bufferView", i.bufferView).then(function(e2) {
      s = true;
      const t2 = new Blob([e2], { type: i.mimeType });
      return a = URL.createObjectURL(t2), a;
    })), Promise.all([this._loadOpenType(), a]).then(function(e2) {
      if (a = e2[1], "undefined" == typeof opentype) return null;
      const n2 = new TTFLoader();
      return n2.setCrossOrigin(t.options.crossOrigin), new Promise(function(e3, o2) {
        n2.load(LoaderUtils.resolveURL(a, t.options.path), e3, void 0, o2);
      }).then(function(e3) {
        return new Font(e3);
      }, function(e3) {
        return null;
      });
    }).then(function(e2) {
      return true === s && URL.revokeObjectURL(a), o = Promise.resolve(e2), t.cache.add(n, o), o;
    });
  }
  _loadCurve(e) {
    const t = this.parser, n = "curve:" + e;
    let o = t.cache.get(n);
    if (o) return o;
    const r = t.json, i = ((r.extensions && r.extensions[this.name] || {}).curves || [])[e];
    let a, s = i.type;
    const l = [];
    return l.push(this._loadFont(i.font)), void 0 !== i.material ? l.push(t.getDependency("material", i.material)) : l.push(createDefaultMaterial(t.cache)), Promise.all(l).then(function(r2) {
      const l2 = r2[0], c = r2[1];
      if (null === l2 && (s = "empty"), "font" === s) {
        const e2 = i.bevelSize > 0 || i.bevelThickness > 0, t2 = new TextGeometry(i.text, { font: l2, size: i.size, height: i.height, curveSegments: i.curveSegments, bevelEnabled: e2, bevelThickness: i.bevelThickness, bevelSize: i.bevelSize, bevelSegments: i.bevelSegments, alignX: i.alignX, alignY: i.alignY, lineHeight: i.lineHeight, scaledEmSize: i.scaledEmSize });
        a = new Mesh(t2, c);
      } else a = new Object3D();
      return a.name = t.createUniqueName(i.name || "curve_" + e), o = Promise.resolve(a), t.cache.add(n, o), o;
    });
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, o = n.json.nodes[e], r = (o.extensions && o.extensions[this.name] || {}).curve;
    return void 0 === r ? null : this._loadCurve(r).then(function(e2) {
      return n._getNodeRef(t.cache, r, e2);
    });
  }
};
var V3DClippingPlanesExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.S8S_V3D_CLIPPING_PLANES, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, o = t.length; n < o; n++) {
      const o2 = t[n];
      o2.extensions && o2.extensions[this.name] && void 0 !== o2.extensions[this.name].clippingPlane && e._addNodeRef(this.cache, o2.extensions[this.name].clippingPlane);
    }
  }
  _loadClippingPlane(e) {
    const t = this.parser, n = "clippingPlane:" + e;
    let o = t.cache.get(n);
    if (o) return o;
    const r = t.json, i = ((r.extensions && r.extensions[this.name] || {}).clippingPlanes || [])[e], a = new ClippingPlaneObject();
    return a.clippingGroup = i.clippingGroup, a.clipShadows = i.clipShadows, a.negated = i.negated, a.clipIntersection = i.clipIntersection, a.crossSection = i.crossSection, a.crossSectionColor = new Color().fromArray(i.color), a.crossSectionOpacity = i.opacity, a.crossSectionSize = i.size, isDef(i.renderSide) && (a.crossSectionRenderSide = RENDER_SIDES[i.renderSide]), a.name = t.createUniqueName(i.name || "clippingPlane_" + e), o = Promise.resolve(a), t.cache.add(n, o), o;
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, o = n.json.nodes[e], r = (o.extensions && o.extensions[this.name] || {}).clippingPlane;
    return void 0 === r ? null : this._loadClippingPlane(r).then(function(e2) {
      return n._getNodeRef(t.cache, r, e2);
    });
  }
};
var V3DSceneExtension = class {
  constructor(e) {
    this.name = EXTENSIONS.S8S_V3D_SCENE, this.parser = e;
  }
  beforeRoot() {
    let e = this.parser.json.asset.generator || "";
    e.indexOf("Verge3D") > -1 && (e.match(/(\d+).(\d+).(\d+)/) || (e += " v0.0.0"), engineVersionCmp(e, "4.9.2", 2) < 0 && console.warn("Loading glTF asset in older version of Verge3D runtime. Please update your application."));
  }
  afterRoot(e) {
    const t = this.parser, n = t.json, o = n.scenes[n.scene || 0], r = e.scene, i = isDef(o.extensions) ? o.extensions[EXTENSIONS.S8S_V3D_SCENE] : void 0, a = [], s = [], l = [];
    let c;
    return c = o && i && isDef(i.worldMaterial) ? t.getDependency("material", i.worldMaterial) : Promise.resolve(), c.then((t2) => {
      const n2 = {};
      t2 && (n2.material = t2), e.world = n2;
    }).then(() => (t.assignedMaterials.forEach(function(e2) {
      e2.isMeshNodeMaterial && e2.traverseNodes(function(n2) {
        "TEX_COORD_BL" === n2.originData.type && isDef(n2.originData.object) && n2.originData.object > -1 && (a.push(t.getDependency("node", n2.originData.object)), s.push(n2), l.push(e2));
      });
    }), Promise.all(a))).then((t2) => {
      for (let e2 = 0; e2 < t2.length; e2++) {
        const n3 = t2[e2], o2 = s[e2], r2 = l[e2], i3 = r2.nodeTexCoordObjectMap[o2.originData.name];
        r2.nodeTexCoordObject[i3] = n3;
      }
      const n2 = [];
      for (let t3 = 0; t3 < e.cameras.length; t3++) {
        const o2 = e.cameras[t3];
        let i3 = false;
        o2.traverseAncestors(function(e2) {
          e2 == r && (i3 = true);
        }), i3 && n2.push(o2);
      }
      e.cameras = n2;
      for (let t3 = 0; t3 < e.animations.length; t3++) {
        const n3 = e.animations[t3];
        n3.clip && void 0 !== n3.clip.name && (n3.clip.name = n3.clip.name);
      }
      const i2 = {};
      if (o) {
        const e2 = isDef(o.extensions) ? o.extensions[EXTENSIONS.S8S_V3D_SCENE] : void 0;
        if (e2) {
          if (isDef(e2.shadowMap)) {
            switch (i2.shadowMap = { enabled: true }, e2.shadowMap.type) {
              case "BASIC":
                i2.shadowMap.type = 0;
                break;
              case "BILINEAR":
                i2.shadowMap.type = 1;
                break;
              case "PCFSOFT":
                console.warn("v3d.GLTFLoader: PCF Bilinear shadows deprecated since Verge3D 4.7, using PCF (with poisson disk sampling) instead"), i2.shadowMap.type = 2;
                break;
              case "PCF":
              case "PCFPOISSON":
                i2.shadowMap.type = 2;
                break;
              case "ESM":
                i2.shadowMap.type = 3;
            }
            let t3;
            t3 = e2.shadowMap.renderSingleSided ? e2.shadowMap.renderReverseSided ? 1 : 0 : 2, r.traverse(function(e3) {
              const n3 = e3.material;
              n3 && (n3.shadowSide = t3);
            }), i2.esmDistanceScale = e2.shadowMap.esmDistanceScale;
          }
          if (isDef(e2.aaMethod) && (i2.aaMethod = e2.aaMethod), isDef(e2.useHDR) && (i2.useHDR = e2.useHDR), isDef(e2.useOIT) && (i2.useOIT = e2.useOIT), isDef(e2.unitsScaleFactor) && (i2.unitsScaleFactor = e2.unitsScaleFactor), isDef(e2.toneMapping)) {
            switch (e2.toneMapping.type) {
              case "logarithmicMax":
                i2.toneMapping = 6, i2.toneMappingBrightness = e2.toneMapping.brightness, i2.toneMappingContrast = e2.toneMapping.contrast, i2.toneMappingMidTones = e2.toneMapping.midTones, i2.toneMappingPhysicalScale = e2.toneMapping.physicalScale, i2.toneMappingChromaticAdaptation = e2.toneMapping.chromaticAdaptation, i2.toneMappingWhiteColor = new Color().fromArray(e2.toneMapping.whiteColor), i2.toneMappingColorDifferentiation = e2.toneMapping.colorDifferentiation, i2.toneMappingExteriorDaylight = e2.toneMapping.exteriorDaylight;
                break;
              case "physicalMax":
                i2.toneMapping = 7, i2.toneMappingWhiteBalance = new Color().fromArray(e2.toneMapping.whiteBalance), i2.toneMappingHighlights = e2.toneMapping.highlights, i2.toneMappingMidTones = e2.toneMapping.midTones, i2.toneMappingShadows = e2.toneMapping.shadows, i2.toneMappingSaturation = e2.toneMapping.saturation, i2.toneMappingPhysicalScale = e2.toneMapping.physicalScale, i2.toneMappingAperture = e2.toneMapping.aperture, i2.toneMappingShutter = e2.toneMapping.shutter, i2.toneMappingISO = e2.toneMapping.iso, i2.toneMappingVignetting = e2.toneMapping.vignetting;
                break;
              case "filmicBlender":
                i2.toneMapping = 8;
                break;
              case "agxBlender":
                i2.toneMapping = 9;
                break;
              case "pbrNeutral":
                i2.toneMapping = 10;
            }
            switch (e2.toneMapping.look) {
              case "NONE":
                i2.toneMappingLook = 0;
                break;
              case "AGX_PUNCHY":
                i2.toneMappingLook = 1;
                break;
              default:
                "agxBlender" === e2.toneMapping.type && console.warn(`v3d.GLTFLoader: ${e2.toneMapping.look} look is not supported, fallback to None`), i2.toneMappingLook = 0;
            }
          }
          if (isDef(e2.pmremMaxTileSize) && (i2.pmremMaxTileSize = e2.pmremMaxTileSize), isDef(e2.iblEnvironmentMode)) switch (e2.iblEnvironmentMode) {
            case "PMREM":
            default:
              i2.iblEnvironmentMode = 0;
              break;
            case "PROBE_CUBEMAP":
              console.warn("v3d.GLTFLoader: Cubemap probes deprecated since Verge3D 4.3, using PMREM instead"), i2.iblEnvironmentMode = 0;
              break;
            case "PROBE":
              i2.iblEnvironmentMode = 1;
              break;
            case "NONE":
              i2.iblEnvironmentMode = 2;
          }
          isDef(e2.postprocessing) && (r.postprocessing = e2.postprocessing);
        }
      }
      e.renderer = i2;
    });
  }
};
var V3DNodeExtension = class {
  constructor(e) {
    this.name = EXTENSIONS.S8S_V3D_NODE, this.parser = e;
  }
  extendNodeParams(e, t) {
    const n = t.extensions && t.extensions[this.name];
    if (!n) return e;
    if (n.hidden && (e.visible = false), e.isMesh && (isDef(n.useCastShadows) ? e.castShadow = n.useCastShadows : isDef(e.material.castShadow) && (e.castShadow = e.material.castShadow), isDef(n.useShadows) ? e.receiveShadow = n.useShadows : isDef(e.material.receiveShadow) && (e.receiveShadow = e.material.receiveShadow)), isDef(n.objectIndex) && (e.objectIndex = n.objectIndex), isDef(n.objectColor) && (e.objectColor = new Color().fromArray(n.objectColor), e.objectAlpha = isDef(n.objectColor[3]) ? n.objectColor[3] : 1), e.renderOrder = n.renderOrder, e.frustumCulled = n.frustumCulling, isDef(n.groupNames) && (e.groupNames = n.groupNames), isDef(n.hidpiCompositing) && (e.hidpiCompositing = n.hidpiCompositing), e.isMesh && e.material.isMeshNodeMaterial) {
      const t2 = e.material;
      (t2.hasNode("MATTE_SHADOW_MX") || t2.hasNode("SHADOW_MATTE_AR") || t2.hasNode("AI_SHADOW_MATTE_MY")) && (t2.transparent = false, t2.premultipliedAlpha = true, assignDefaultBlending(t2), e.renderOrder -= 1e3, e.castShadow = false, e.receiveShadow = true);
    }
    return this.processConstraints(e, n.constraints);
  }
  processConstraints(e, t = []) {
    if (e.isMaterialGeneratedMesh) return e;
    const n = this.parser, o = [];
    for (let e2 = 0; e2 < t.length; e2++) {
      const r = t[e2];
      isDef(r.target) ? o.push(n.getDependency("node", r.target)) : o.push(Promise.resolve(null));
    }
    return Promise.all(o).then(function(o2) {
      for (let r = 0; r < t.length; r++) {
        const i = t[r], a = o2[r];
        let s;
        switch (i.type) {
          case "copyLocation":
            s = new CopyLocationConstraint(a), s.useX = !isDef(i.useX) || i.useX, s.useY = !isDef(i.useY) || i.useY, s.useZ = !isDef(i.useZ) || i.useZ, s.invertX = !!isDef(i.invertX) && i.invertX, s.invertY = !!isDef(i.invertY) && i.invertY, s.invertZ = !!isDef(i.invertZ) && i.invertZ, s.useOffset = !isDef(i.useOffset) || i.useOffset, s.influence = isDef(i.influence) ? i.influence : 1;
            break;
          case "copyRotation":
            s = new CopyRotationConstraint(a), s.useX = !isDef(i.useX) || i.useX, s.useY = !isDef(i.useY) || i.useY, s.useZ = !isDef(i.useZ) || i.useZ, s.invertX = !!isDef(i.invertX) && i.invertX, s.invertY = !!isDef(i.invertY) && i.invertY, s.invertZ = !!isDef(i.invertZ) && i.invertZ, s.mixMode = isDef(i.mixMode) ? i.mixMode : "REPLACE", s.influence = isDef(i.influence) ? i.influence : 1, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
            break;
          case "copyScale":
            s = new CopyScaleConstraint(a), s.useX = !isDef(i.useX) || i.useX, s.useY = !isDef(i.useY) || i.useY, s.useZ = !isDef(i.useZ) || i.useZ, s.power = isDef(i.power) ? i.power : 1, s.useMakeUniform = !!isDef(i.useMakeUniform) && i.useMakeUniform, s.useOffset = !!isDef(i.useOffset) && i.useOffset, s.useAdd = !!isDef(i.useAdd) && i.useAdd, s.influence = isDef(i.influence) ? i.influence : 1;
            break;
          case "copyTransforms":
            s = new CopyTransformsConstraint(a), s.mixMode = isDef(i.mixMode) ? i.mixMode : "REPLACE", s.influence = isDef(i.influence) ? i.influence : 1, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
            break;
          case "dampedTrack":
            s = new DampedTrackConstraint(a), s.trackAxis = i.trackAxis, s.influence = isDef(i.influence) ? i.influence : 1, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
            break;
          case "limitDistance":
            s = new LimitDistanceConstraint(a), s.distance = isDef(i.distance) ? i.distance : 0, s.limitMode = isDef(i.limitMode) ? i.limitMode : "LIMITDIST_INSIDE", s.useTransformLimit = !!isDef(i.useTransformLimit) && i.useTransformLimit, s.influence = isDef(i.influence) ? i.influence : 1;
            break;
          case "limitLocation":
            switch (s = new LimitLocationConstraint(a), i.space) {
              case "CUSTOM":
                s.space = 1;
                break;
              case "WORLD":
                s.space = 0;
                break;
              default:
                s.space = 2;
            }
            s.min.set(Number(i.minX), Number(i.minY), Number(i.minZ)), s.max.set(Number(i.maxX), Number(i.maxY), Number(i.maxZ));
            break;
          case "limitRotation":
            s = new LimitRotationConstraint(), s.axis = i.axis, s.min = i.min, s.max = i.max;
            break;
          case "limitScale":
            s = new LimitScaleConstraint(), s.min.set(Number(i.minX), Number(i.minY), Number(i.minZ)), s.max.set(Number(i.maxX), Number(i.maxY), Number(i.maxZ));
            break;
          case "lockedTrack":
            s = new LockedTrackConstraint(a), s.trackAxis = i.trackAxis, s.lockAxis = i.lockAxis, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
            break;
          case "trackTo":
            s = new TrackToConstraint(a), s.trackAxis = i.trackAxis, s.upAxis = i.upAxis, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
            break;
          case "childOf":
            s = new ChildOfConstraint(a), s.offsetMatrix = new Matrix4().fromArray(i.offsetMatrix), s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
            break;
          case "floor":
            s = new FloorConstraint(a), s.floorLocation = i.floorLocation, s.offset = i.offset, s.useRotation = !!isDef(i.useRotation) && i.useRotation;
            break;
          case "fixOrthoZoom":
            s = new FixOrthoZoomConstraint(a);
            break;
          case "canvasFit":
            s = new CanvasFitConstraint(a), s.edgeH = i.edgeH, s.edgeV = i.edgeV, s.fitShape = i.fitShape, s.offset = i.offset, "SPHERE" == i.fitShape && e.resolveMultiMaterial().forEach(function(e2) {
              e2.geometry && e2.geometry.computeBoundingSphere();
            });
            break;
          case "canvasBreakpoints":
            s = new CanvasBreakpointsConstraint(), s.minWidth = Number(i.minWidth), s.maxWidth = Number(i.maxWidth), s.minHeight = Number(i.minHeight), s.maxHeight = Number(i.maxHeight), s.orientation = i.orientation;
            break;
          case "motionPath":
            s = new MotionPathConstraint(), s.degree = i.degree, s.cvs = [];
            for (let e2 = 0; e2 < i.cvs.length; ++e2) s.cvs.push(Number(i.cvs[e2]));
            s.knots = [];
            for (let e2 = 0; e2 < i.knots.length; ++e2) s.knots.push(Number(i.knots[e2]));
            s.weights = [];
            for (let e2 = 0; e2 < i.weights.length; ++e2) s.weights.push(Number(i.weights[e2]));
            if (s.value = isDef(i.value) ? i.value : 0, s.follow = !!isDef(i.follow) && i.follow, s.frontAxis = isDef(i.frontAxis) ? i.frontAxis : "Z", s.upAxis = isDef(i.upAxis) ? i.upAxis : "Y", s.worldUpVector = isDef(i.worldUpVector) ? new Vector3().fromArray(i.worldUpVector).normalize() : new Vector3(0, 1, 0), s.useChordLength = !!isDef(i.useChordLength) && i.useChordLength, s.bank = !!isDef(i.bank) && i.bank, s.bankScale = isDef(i.bankScale) ? i.bankScale : 1, s.bankLimit = isDef(i.bankLimit) ? i.bankLimit : 1 / 0, s.useFixedLocation = !!isDef(i.useFixedLocation) && i.useFixedLocation, s.fixedValue = isDef(i.fixedValue) ? i.fixedValue : 0, s.usePointsTilt = !!isDef(i.usePointsTilt) && i.usePointsTilt, s.pointsTilt = [], isDef(i.pointsTilt)) for (let e2 = 0; e2 < i.pointsTilt.length; ++e2) s.pointsTilt.push(Number(i.pointsTilt[e2]));
            s.offsetValue = isDef(i.offsetValue) ? i.offsetValue : 0, s.useClampValue = !!isDef(i.useClampValue) && i.useClampValue, s.useCyclic = !!isDef(i.useCyclic) && i.useCyclic, s.useObjOffset = !!isDef(i.useObjOffset) && i.useObjOffset, s.useRelative = !!isDef(i.useRelative) && i.useRelative, s.usePosOffset = !isDef(i.usePosOffset) || i.usePosOffset, s.objOffsetMode = isDef(i.objOffsetMode) ? i.objOffsetMode : 0, s.objOffsetRotMode = isDef(i.objOffsetRotMode) ? i.objOffsetRotMode : 0, s.influence = isDef(i.influence) ? i.influence : 1, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation, s.init();
            break;
          case "transformation":
            switch (s = new TransformationConstraint(a), s.fromMin.set(Number(i.fromMin[0]), Number(i.fromMin[1]), Number(i.fromMin[2])), s.fromMax.set(Number(i.fromMax[0]), Number(i.fromMax[1]), Number(i.fromMax[2])), s.toMin.set(Number(i.toMin[0]), Number(i.toMin[1]), Number(i.toMin[2])), s.toMax.set(Number(i.toMax[0]), Number(i.toMax[1]), Number(i.toMax[2])), s.mapToAxisFromAxis = i.mapToAxisFromAxis, s.mapFrom = i.mapFrom, s.mapTo = i.mapTo, i.ownerSpace) {
              case "CUSTOM":
                s.ownerSpace = 1;
                break;
              case "LOCAL":
                s.ownerSpace = 2;
                break;
              default:
                s.ownerSpace = 0;
            }
            switch (i.targetSpace) {
              case "CUSTOM":
                s.targetSpace = 1;
                break;
              case "LOCAL":
                s.targetSpace = 2;
                break;
              default:
                s.targetSpace = 0;
            }
            isDef(i.ownerSpaceObj) && n.getDependency("node", i.ownerSpaceObj).then((e2) => {
              s.ownerSpaceObj = e2;
            }), isDef(i.targetSpaceObj) && n.getDependency("node", i.targetSpaceObj).then((e2) => {
              s.targetSpaceObj = e2;
            }), s.useMotionExtrapolate = i.useMotionExtrapolate, s.mixMode = i.mixMode, s.influence = i.influence, s.fixCameraLightRotation = !!isDef(i.fixCameraLightRotation) && i.fixCameraLightRotation;
        }
        s && (s.name = i.name, s.mute = i.mute, e.constraints.push(s));
      }
      return e;
    });
  }
};
var V3DCameraExtension = class {
  constructor(e) {
    this.name = EXTENSIONS.S8S_V3D_CAMERA, this.parser = e;
  }
  extendCameraParams(e, t) {
    const n = this.parser, o = t.extensions && t.extensions[this.name];
    if (!o) return Promise.resolve(e);
    if (e.controlSettings = new ControlSettings(o.controls, o.enablePan, o.rotateSpeed, o.moveSpeed), e.viewportFit.type = 3, isDef(o.viewportFitType)) switch (o.viewportFitType) {
      case "VERTICAL":
        e.viewportFit.type = 1;
        break;
      case "HORIZONTAL":
        e.viewportFit.type = 2;
        break;
      case "AUTO":
        e.viewportFit.type = 3;
        break;
      case "FILL":
        e.viewportFit.type = 4;
        break;
      case "OVERSCAN":
        e.viewportFit.type = 5;
    }
    isDef(o.viewportFitInitialAspect) && (e.viewportFit.initialAspect = o.viewportFitInitialAspect), isDef(o.orbitMinDistance) && (e.controlSettings.orbitMinDistance = o.orbitMinDistance), isDef(o.orbitMaxDistance) && (e.controlSettings.orbitMaxDistance = o.orbitMaxDistance), isDef(o.orbitMinZoom) && (e.controlSettings.orbitMinZoom = o.orbitMinZoom), isDef(o.orbitMaxZoom) && (e.controlSettings.orbitMaxZoom = o.orbitMaxZoom), isDef(o.orbitMinPolarAngle) && (e.controlSettings.orbitMinPolarAngle = o.orbitMinPolarAngle), isDef(o.orbitMaxPolarAngle) && (e.controlSettings.orbitMaxPolarAngle = o.orbitMaxPolarAngle), isDef(o.orbitMinAzimuthAngle) && (e.controlSettings.orbitMinAzimuthAngle = o.orbitMinAzimuthAngle), isDef(o.orbitMaxAzimuthAngle) && (e.controlSettings.orbitMaxAzimuthAngle = o.orbitMaxAzimuthAngle);
    const r = [];
    if (isDef(o.orbitTarget)) if (o.orbitTarget instanceof Array) {
      const e2 = new Object3D();
      e2.position.fromArray(o.orbitTarget), r.push(Promise.resolve(e2));
    } else r.push(n.getDependency("node", o.orbitTarget));
    else r.push(Promise.resolve());
    return isDef(o.fpsCollisionMaterial) ? r.push(n.getDependency("material", o.fpsCollisionMaterial)) : r.push(Promise.resolve()), isDef(o.fpsGazeLevel) && (e.controlSettings.gazeLevel = o.fpsGazeLevel), isDef(o.fpsStoryHeight) && (e.controlSettings.storyHeight = o.fpsStoryHeight), isDef(o.enablePointerLock) && (e.controlSettings.enablePointerLock = o.enablePointerLock), Promise.all(r).then((t2) => (t2[0] && (e.controlSettings.orbitTarget = t2[0]), t2[1] && (e.controlSettings.collisionMaterial = t2[1]), e));
  }
};
var V3DMaterialExtension = class {
  constructor(e) {
    this.name = EXTENSIONS.S8S_V3D_MATERIALS, this.parser = e;
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? MeshNodeMaterial : null;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json, o = n.materials[e];
    if (!o.extensions || !o.extensions[this.name]) return Promise.resolve();
    const r = o.extensions[this.name], i = [];
    if (isDef(r.nodeGraph)) {
      const e2 = MeshNodeMaterial.nodeGraphFromExtGraph(r.nodeGraph);
      t.nodeGraph = e2, MeshNodeMaterial.nodeGraphTraverse(e2, (e3) => {
        const t2 = e3.originData;
        TEXTURE_NODES.indexOf(t2.type) > -1 && isDef(t2.texture) ? i.push(this.assignTextureNode(t2)) : "RAMP_MY" == t2.type && (t2.wrapS = WEBGL_WRAPPINGS[t2.wrapS] || 1e3, t2.wrapT = WEBGL_WRAPPINGS[t2.wrapT] || 1e3);
      });
      const o2 = n.extensions && n.extensions[this.name] || {};
      if (o2 && o2.nodeGraphs) {
        t.additionalNodeGraphs = {};
        for (let e3 in o2.nodeGraphs) {
          const n2 = MeshNodeMaterial.nodeGraphFromExtGraph(o2.nodeGraphs[e3]);
          t.additionalNodeGraphs[e3] = n2, MeshNodeMaterial.nodeGraphTraverse(n2, (e4) => {
            const t2 = e4.originData;
            TEXTURE_NODES.indexOf(t2.type) > -1 && i.push(this.assignTextureNode(t2));
          });
        }
      }
    }
    return isDef(r.profile) && (t.profile = r.profile), isDef(r.renderSide) && (t.side = RENDER_SIDES[r.renderSide]), isDef(r.useShadows) && (t.receiveShadow = r.useShadows), isDef(r.useCastShadows) && (t.castShadow = r.useCastShadows), isDef(r.depthWrite) && (t.depthWrite = r.depthWrite), isDef(r.depthPrepass) && (t.depthPrepass = r.depthPrepass), isDef(r.depthTest) && (t.depthTest = r.depthTest), isDef(r.dithering) && (t.dithering = r.dithering), isDef(r.materialIndex) && (t.materialIndex = r.materialIndex), true === r.alphaToCoverage && (t.alphaToCoverage = true), isDef(r.gtaoVisible) && (t.gtaoVisible = r.gtaoVisible), delete t.metalness, delete t.roughness, Promise.all(i);
  }
  assignTextureNode(e) {
    return this.parser.getDependency("texture", e.texture).then(function(t) {
      e.texture = t;
    });
  }
  assignTransparency(e, t, n) {
    const o = t.extensions[this.name] || {};
    if (e.premultipliedAlpha = n == ALPHA_MODES.BLEND, n == ALPHA_MODES.BLEND) if (isDef(o.blendMode)) {
      const t2 = o.blendMode;
      e.blending = 5, isDef(t2.blendEquation) && (e.blendEquation = WEBGL_BLEND_EQUATIONS[t2.blendEquation]), isDef(t2.blendEquationAlpha) && (e.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[t2.blendEquationAlpha]), isDef(t2.srcRGB) && (e.blendSrc = WEBGL_BLEND_FUNCS[t2.srcRGB]), isDef(t2.dstRGB) && (e.blendDst = WEBGL_BLEND_FUNCS[t2.dstRGB]), isDef(t2.srcAlpha) && (e.blendSrcAlpha = WEBGL_BLEND_FUNCS[t2.srcAlpha]), isDef(t2.dstAlpha) && (e.blendDstAlpha = WEBGL_BLEND_FUNCS[t2.dstAlpha]);
    } else e.useAddTransparency() ? e.blending = 2 : assignDefaultBlending(e);
  }
};
var V3DTextureExtension = class {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.S8S_V3D_TEXTURE, this.textureLoaderRGBE = new RGBELoader(), this.textureLoaderRGBE.setCrossOrigin(this.parser.options.crossOrigin), this.textureLoaderRGBE.setRequestHeader(this.parser.options.requestHeader);
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, o = n.json, r = o.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const i = r.extensions[t];
    if (!isDef(i.source)) return null;
    const a = o.images[i.source];
    let s = n.textureLoader;
    if ("hdr" == (a.uri || "").split(".").pop() || "image/vnd.radiance" == a.mimeType ? s = this.textureLoaderRGBE : "xz" != (a.uri || "").split(".").pop() && "application/x-xz" != a.mimeType || (s = new XZLoader()), a.uri) {
      const e2 = n.options.manager.getHandler(a.uri);
      null !== e2 && (s = e2);
    }
    return n.loadTextureImage(e, i.source, s);
  }
  extendTextureParams(e, t, n) {
    const o = this.name;
    if (!t.extensions || !t.extensions[o]) return null;
    const r = t.extensions[o], i = r.colorSpace.startsWith("linear") || "non-color" == r.colorSpace ? 3e3 : 3001;
    e.encoding = i, (n instanceof RGBELoader || n instanceof XZLoader) && (e.minFilter = 1006), isDef(r.anisotropy) && (e.anisotropy = r.anisotropy), isDef(r.uvTransform) && (e.matrix = new Matrix3().fromArray(r.uvTransform), e.matrixAutoUpdate = false);
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(e, t, n, o) {
    super(e, t, n, o);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, o = this.valueSize, r = e * o * 3 + o;
    for (let e2 = 0; e2 !== o; e2++) t[e2] = n[r + e2];
    return t;
  }
  interpolate_(e, t, n, o) {
    const r = this.resultBuffer, i = this.sampleValues, a = this.valueSize, s = 2 * a, l = 3 * a, c = o - t, u = (n - t) / c, d = u * u, h = d * u, f = e * l, p = f - l, m = -2 * h + 3 * d, g = h - d, _ = 1 - m, A = g - d + u;
    for (let e2 = 0; e2 !== a; e2++) {
      const t2 = i[p + e2 + a], n2 = i[p + e2 + s] * c, o2 = i[f + e2 + a], l2 = i[f + e2] * c;
      r[e2] = _ * t2 + A * n2 + m * o2 + g * l2;
    }
    return r;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(e, t, n, o) {
    const r = super.interpolate_(e, t, n, o);
    return _q.fromArray(r).normalize().toArray(r), r;
  }
};
var WEBGL_CONSTANTS = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 };
var WEBGL_COMPONENT_TYPES = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
var WEBGL_FILTERS = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 };
var WEBGL_WRAPPINGS = { 33071: 1001, 33648: 1002, 10497: 1e3 };
var WEBGL_BLEND_EQUATIONS = { 32774: 100, 32778: 101, 32779: 102 };
var WEBGL_BLEND_FUNCS = { 0: 200, 1: 201, 768: 202, 769: 203, 770: 204, 771: 205, 772: 206, 773: 207, 774: 208, 775: 209, 776: 210 };
var WEBGL_TYPE_SIZES = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var ATTRIBUTES = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" };
var PATH_PROPERTIES = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences", intensity: "intensity", power: "power" };
var INTERPOLATION = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 };
var ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
var RENDER_SIDES = { FRONT: 0, BACK: 1, DOUBLE: 2, TWO_PASS_DOUBLE: 3 };
function createDefaultMaterial(e) {
  return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: 0, receiveShadow: true, castShadow: true })), e.DefaultMaterial;
}
function addUnknownExtensionsToUserData(e, t, n) {
  for (const o in n.extensions) void 0 === e[o] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[o] = n.extensions[o]);
}
function assignExtrasToUserData(e, t) {
  void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("v3d.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
}
function addMorphTargets(e, t, n) {
  let o = false, r = false, i = false;
  for (let e2 = 0, n2 = t.length; e2 < n2; e2++) {
    const n3 = t[e2];
    if (void 0 !== n3.POSITION && (o = true), void 0 !== n3.NORMAL && (r = true), void 0 !== n3.COLOR_0 && (i = true), o && r && i) break;
  }
  if (!o && !r && !i) return Promise.resolve(e);
  const a = [], s = [], l = [];
  for (let c = 0, u = t.length; c < u; c++) {
    const u2 = t[c];
    if (o) {
      const t2 = void 0 !== u2.POSITION ? n.getDependency("accessor", u2.POSITION) : e.attributes.position;
      a.push(t2);
    }
    if (r) {
      const t2 = void 0 !== u2.NORMAL ? n.getDependency("accessor", u2.NORMAL) : e.attributes.normal;
      s.push(t2);
    }
    if (i) {
      const t2 = void 0 !== u2.COLOR_0 ? n.getDependency("accessor", u2.COLOR_0) : e.attributes.color;
      l.push(t2);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(s), Promise.all(l)]).then(function(t2) {
    const n2 = t2[0], a2 = t2[1], s2 = t2[2];
    return o && (e.morphAttributes.position = n2), r && (e.morphAttributes.normal = a2), i && (e.morphAttributes.color = s2), e.morphTargetsRelative = true, e;
  });
}
function updateMorphTargets(e, t) {
  if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, o = t.weights.length; n < o; n++) e.morphTargetInfluences[n] = t.weights[n];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const n = t.extras.targetNames;
    if (e.morphTargetInfluences.length === n.length) {
      e.morphTargetDictionary = {};
      for (let t2 = 0, o = n.length; t2 < o; t2++) e.morphTargetDictionary[n[t2]] = t2;
    } else console.warn("v3d.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function createPrimitiveKey(e) {
  return e.indices + ":" + createAttributesKey(e.attributes) + ":" + e.mode;
}
function createAttributesKey(e) {
  let t = "";
  const n = Object.keys(e).sort();
  for (let o = 0, r = n.length; o < r; o++) t += n[o] + ":" + e[n[o]] + ";";
  return t;
}
function getNormalizedComponentScale(e) {
  switch (e) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("v3d.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(e) {
  return e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png";
}
new Matrix4();
var GLTFParser = class {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.onProgress = t.onProgress || function() {
    }, this.cache = new GLTFRegistry(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = false, o = false, r = -1;
    "undefined" != typeof navigator && (n = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), o = navigator.userAgent.indexOf("Firefox") > -1, r = o ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || o && r < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true), this.assignedMaterials = [];
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, o = this.json, r = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(e2) {
      return e2._markDefs && e2._markDefs();
    }), Promise.all(this._invokeAll(function(e2) {
      return e2.beforeRoot && e2.beforeRoot();
    })).then(function() {
      return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]);
    }).then(function(t2) {
      const i = { scene: t2[0][o.scene || 0], scenes: t2[0], animations: t2[1], cameras: t2[2], asset: o.asset, parser: n, userData: {} };
      addUnknownExtensionsToUserData(r, i, o), assignExtrasToUserData(i, o), Promise.all(n._invokeAll(function(e2) {
        return e2.afterRoot && e2.afterRoot(i);
      })).then(function() {
        e(i);
      });
    }).catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let n2 = 0, o = t.length; n2 < o; n2++) {
      const o2 = t[n2].joints;
      for (let t2 = 0, n3 = o2.length; t2 < n3; t2++) e[o2[t2]].isBone = true;
    }
    for (let t2 = 0, o = e.length; t2 < o; t2++) {
      const o2 = e[t2];
      void 0 !== o2.mesh && (this._addNodeRef(this.meshCache, o2.mesh), void 0 !== o2.skin && (n[o2.mesh].isSkinnedMesh = true)), void 0 !== o2.camera && this._addNodeRef(this.cameraCache, o2.camera);
    }
  }
  _addNodeRef(e, t) {
    void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const o = n.clone(), r = (e2, t2) => {
      const n2 = this.associations.get(e2);
      null != n2 && this.associations.set(t2, n2);
      for (const [n3, o2] of e2.children.entries()) r(o2, t2.children[n3]);
    };
    return r(n, o), o.name += "_instance_" + e.uses[t]++, o;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const o = e(t[n]);
      if (o) return o;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let o = 0; o < t.length; o++) {
      const r = e(t[o]);
      r && n.push(r);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let o = this.cache.get(n);
    if (!o) {
      switch (e) {
        case "scene":
          o = this.loadScene(t);
          break;
        case "node":
          o = this.loadNode(t);
          break;
        case "mesh":
          o = this._invokeOne(function(e2) {
            return e2.loadMesh && e2.loadMesh(t);
          });
          break;
        case "accessor":
          o = this.loadAccessor(t);
          break;
        case "bufferView":
          o = this._invokeOne(function(e2) {
            return e2.loadBufferView && e2.loadBufferView(t);
          });
          break;
        case "buffer":
          o = this.loadBuffer(t);
          break;
        case "material":
          o = this._invokeOne(function(e2) {
            return e2.loadMaterial && e2.loadMaterial(t);
          });
          break;
        case "texture":
          o = this._invokeOne(function(e2) {
            return e2.loadTexture && e2.loadTexture(t);
          });
          break;
        case "skin":
          o = this.loadSkin(t);
          break;
        case "animation":
          o = this.loadAnimation(t);
          break;
        case "camera":
          o = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(n, o);
    }
    return o;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, o = this.json[e + ("mesh" === e ? "es" : "s")] || [];
      t = Promise.all(o.map(function(t2, o2) {
        return n.getDependency(e, o2);
      })), this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this, n = this.json.buffers[e];
    if (n.type && "arraybuffer" !== n.type) throw new Error("v3d.GLTFLoader: " + n.type + " buffer type is not supported.");
    if (void 0 === n.uri && 0 === e) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const o = this.options;
    return new Promise(function(e2) {
      let r, i;
      o.loadBinXZ ? (r = LoaderUtils.resolveURL(n.uri, o.path) + ".xz", i = new XZLoader()) : (r = LoaderUtils.resolveURL(n.uri, o.path), i = t.fileLoader);
      const a = function(e3) {
        if (t.onProgress) {
          const n2 = 100 * (0.3 + 0.7 * e3);
          t.onProgress(n2);
        }
      };
      let s = a;
      i instanceof FileLoader && (s = function(e3) {
        const t2 = e3.lengthComputable ? e3.loaded / e3.total : 1;
        a(t2);
      }), i.load(r, e2, s);
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(e2) {
      const n = t.byteLength || 0, o = t.byteOffset || 0;
      return e2.slice(o, o + n);
    });
  }
  loadAccessor(e) {
    const t = this, n = this.json, o = this.json.accessors[e];
    if (void 0 === o.bufferView && void 0 === o.sparse) {
      const e2 = WEBGL_TYPE_SIZES[o.type], t2 = WEBGL_COMPONENT_TYPES[o.componentType], n2 = true === o.normalized, r2 = new t2(o.count * e2);
      return Promise.resolve(new BufferAttribute(r2, e2, n2));
    }
    const r = [];
    return void 0 !== o.bufferView ? r.push(this.getDependency("bufferView", o.bufferView)) : r.push(null), void 0 !== o.sparse && (r.push(this.getDependency("bufferView", o.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", o.sparse.values.bufferView))), Promise.all(r).then(function(e2) {
      const r2 = e2[0], i = WEBGL_TYPE_SIZES[o.type], a = WEBGL_COMPONENT_TYPES[o.componentType], s = a.BYTES_PER_ELEMENT, l = s * i, c = o.byteOffset || 0, u = void 0 !== o.bufferView ? n.bufferViews[o.bufferView].byteStride : void 0, d = true === o.normalized;
      let h, f;
      if (u && u !== l) {
        const e3 = Math.floor(c / u), n2 = "InterleavedBuffer:" + o.bufferView + ":" + o.componentType + ":" + e3 + ":" + o.count;
        let l2 = t.cache.get(n2);
        l2 || (h = new a(r2, e3 * u, o.count * u / s), l2 = new InterleavedBuffer(h, u / s), t.cache.add(n2, l2)), f = new InterleavedBufferAttribute(l2, i, c % u / s, d);
      } else h = null === r2 ? new a(o.count * i) : new a(r2, c, o.count * i), f = new BufferAttribute(h, i, d);
      if (void 0 !== o.sparse) {
        const t2 = WEBGL_TYPE_SIZES.SCALAR, n2 = WEBGL_COMPONENT_TYPES[o.sparse.indices.componentType], s2 = o.sparse.indices.byteOffset || 0, l2 = o.sparse.values.byteOffset || 0, c2 = new n2(e2[1], s2, o.sparse.count * t2), u2 = new a(e2[2], l2, o.sparse.count * i);
        null !== r2 && (f = new BufferAttribute(f.array.slice(), f.itemSize, f.normalized));
        for (let e3 = 0, t3 = c2.length; e3 < t3; e3++) {
          const t4 = c2[e3];
          if (f.setX(t4, u2[e3 * i]), i >= 2 && f.setY(t4, u2[e3 * i + 1]), i >= 3 && f.setZ(t4, u2[e3 * i + 2]), i >= 4 && f.setW(t4, u2[e3 * i + 3]), i >= 5) throw new Error("v3d.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return f;
    });
  }
  loadTexture(e) {
    const t = this.json, n = this.options, o = t.textures[e].source, r = t.images[o];
    let i = this.textureLoader;
    if (r.uri) {
      const e2 = n.manager.getHandler(r.uri);
      null !== e2 && (i = e2);
    }
    return this.loadTextureImage(e, o, i);
  }
  loadTextureImage(e, t, n) {
    const o = this, r = this.json, i = r.textures[e], a = r.images[t], s = (a.uri || a.bufferView) + ":" + i.sampler;
    if (this.textureCache[s]) return this.textureCache[s];
    const l = this.loadImageSource(t, n).then(function(t2) {
      t2.flipY = false, t2.name = i.name || a.name || "";
      const s2 = (r.samplers || {})[i.sampler] || {};
      return t2.magFilter = WEBGL_FILTERS[s2.magFilter] || 1006, t2.minFilter = WEBGL_FILTERS[s2.minFilter] || 1008, t2.wrapS = WEBGL_WRAPPINGS[s2.wrapS] || 1e3, t2.wrapT = WEBGL_WRAPPINGS[s2.wrapT] || 1e3, o._invokeAll(function(e2) {
        return e2.extendTextureParams && e2.extendTextureParams(t2, i, n);
      }), o.associations.set(t2, { textures: e }), t2;
    }).catch(function() {
      return null;
    });
    return this.textureCache[s] = l, l;
  }
  loadImageSource(e, t) {
    const n = this, o = this.json, r = this.options;
    if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e2) => e2.clone());
    const i = o.images[e], a = self.URL || self.webkitURL;
    let s = i.uri || "", l = false;
    if (void 0 !== i.bufferView) s = n.getDependency("bufferView", i.bufferView).then(function(e2) {
      l = true;
      const t2 = new Blob([e2], { type: i.mimeType });
      return s = a.createObjectURL(t2), s;
    });
    else if (void 0 === i.uri) throw new Error("v3d.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const c = Promise.resolve(s).then(function(e2) {
      return new Promise(function(n2, o2) {
        let i2 = n2;
        true === t.isImageBitmapLoader && (i2 = function(e3) {
          const t2 = new Texture(e3);
          t2.needsUpdate = true, n2(t2);
        }), t.load(LoaderUtils.resolveURL(e2, r.path), i2, void 0, o2);
      });
    }).then(function(e2) {
      if (e2 instanceof ArrayBuffer) {
        return n.plugins[EXTENSIONS.S8S_V3D_TEXTURE].textureLoaderRGBE.loadAsync(a.createObjectURL(new Blob([e2], { type: "image/vnd.radiance" })));
      }
      return Promise.resolve(e2);
    }).then(function(e2) {
      return true === l && a.revokeObjectURL(s), e2.userData.mimeType = i.mimeType || getImageURIMimeType(i.uri), e2;
    }).catch(function(e2) {
      return console.error("v3d.GLTFLoader: Couldn't load texture", s), new Texture();
    });
    return this.sourceCache[e] = c, c;
  }
  assignTexture(e, t, n, o) {
    return this.getDependency("texture", n.index).then(function(r) {
      return r ? (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("v3d.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), void 0 !== o && (r.encoding = o), e[t] = r, r) : null;
    });
  }
  assignFinalMaterial(e, t, n) {
    const o = e.geometry;
    let r = e.material;
    const i = void 0 === o.attributes.tangent, a = void 0 !== o.attributes.color && !r.isMeshNodeMaterial, s = void 0 === o.attributes.normal, l = r.isMeshNodeMaterial && (r.nodeValue.length || r.nodeRGB.length), c = r.isMeshNodeMaterial && r.hasNode("TEX_COORD_BL"), u = r.isMeshNodeMaterial && Object.getOwnPropertyNames(t).length > 0 && r.hasNode("UVMAP_BL"), d = r.isMeshNodeMaterial && Object.getOwnPropertyNames(n).length > 0 && (r.hasNode("ATTRIBUTE_BL") || r.hasNode("VERTEX_COLOR_BL"));
    if (e.isPoints) {
      const e2 = "PointsMaterial:" + r.uuid;
      let t2 = this.cache.get(e2);
      t2 || (t2 = new PointsMaterial(), Material.prototype.copy.call(t2, r), t2.color.copy(r.color), t2.map = r.map, t2.sizeAttenuation = false, this.cache.add(e2, t2)), r = t2;
    } else if (e.isLine) {
      const e2 = "LineBasicMaterial:" + r.uuid;
      let t2 = this.cache.get(e2);
      t2 || (t2 = new LineBasicMaterial(), Material.prototype.copy.call(t2, r), t2.color.copy(r.color), this.cache.add(e2, t2)), r = t2;
    }
    if (i || a || s || l || c || u || d) {
      let e2 = "ClonedMaterial:" + r.uuid + ":";
      i && (e2 += "derivative-tangents:"), a && (e2 += "vertex-colors:"), s && (e2 += "flat-shading:");
      const o2 = generateUUID();
      l && (e2 = o2), c && (e2 = o2), u && (e2 = o2), d && (e2 = o2);
      let h = this.cache.get(e2);
      h || (h = r.clone(), a && (h.vertexColors = true), s && (h.flatShading = true), i && (h.normalScale && (h.normalScale.y *= -1), h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)), h.isMeshNodeMaterial && (Object.assign(h.nodeUVAliases, t), Object.assign(h.nodeVCAliases, n), h.updateNodeGraph()), this.cache.add(e2, h), this.associations.set(h, this.associations.get(r))), r = h;
    }
    r.aoMap && void 0 === o.attributes.uv2 && void 0 !== o.attributes.uv && o.setAttribute("uv2", o.attributes.uv), e.material = r, this.assignedMaterials.includes(r) || this.assignedMaterials.push(r);
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(e) {
    const t = this, n = this.json, o = this.extensions, r = n.materials[e];
    let i;
    const a = {}, s = r.extensions || {}, l = [];
    if (true === r.doubleSided && (a.side = 2), s[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const e2 = o[EXTENSIONS.KHR_MATERIALS_UNLIT];
      i = e2.getMaterialType(), l.push(e2.extendParams(a, r, t));
    } else {
      const n2 = r.pbrMetallicRoughness || {};
      if (a.color = new Color(1, 1, 1), a.opacity = 1, Array.isArray(n2.baseColorFactor)) {
        const e2 = n2.baseColorFactor;
        a.color.fromArray(e2), a.opacity = e2[3];
      }
      void 0 !== n2.baseColorTexture && l.push(t.assignTexture(a, "map", n2.baseColorTexture, 3001)), a.metalness = void 0 !== n2.metallicFactor ? n2.metallicFactor : 1, a.roughness = void 0 !== n2.roughnessFactor ? n2.roughnessFactor : 1, void 0 !== n2.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n2.metallicRoughnessTexture)), l.push(t.assignTexture(a, "roughnessMap", n2.metallicRoughnessTexture))), i = this._invokeOne(function(t2) {
        return t2.getMaterialType && t2.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(t2) {
        return t2.extendMaterialParams && t2.extendMaterialParams(e, a);
      })));
    }
    const c = r.alphaMode || ALPHA_MODES.OPAQUE;
    if (c === ALPHA_MODES.BLEND ? (a.transparent = true, i !== MeshNodeMaterial && (a.depthWrite = false)) : (a.transparent = false, c === ALPHA_MODES.MASK && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)), void 0 !== r.normalTexture && i !== MeshBasicMaterial && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new Vector2(1, 1), void 0 !== r.normalTexture.scale)) {
      const e2 = r.normalTexture.scale;
      a.normalScale.set(e2, e2);
    }
    return void 0 !== r.occlusionTexture && i !== MeshBasicMaterial && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && i !== MeshBasicMaterial && (a.emissive = new Color().fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && i !== MeshBasicMaterial && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, 3001)), Promise.all(l).then(function() {
      const n2 = new i(a);
      r.name && (n2.name = r.name), n2.map && (n2.map.encoding = 3001), n2.emissiveMap && (n2.emissiveMap.encoding = 3001);
      const s2 = t.plugins[EXTENSIONS.S8S_V3D_MATERIALS];
      return n2.isMeshNodeMaterial && s2.assignTransparency(n2, r, c), n2.isMeshStandardMaterial && n2.normalScale && s2 && isDef(s2.profile) && "max" == s2.profile && (n2.normalScale.y = -n2.normalScale.y), assignExtrasToUserData(n2, r), t.associations.set(n2, { materials: e }), r.extensions && addUnknownExtensionsToUserData(o, n2, r), n2;
    });
  }
  createUniqueName(e) {
    const t = e;
    let n = t;
    for (let e2 = 1; this.nodeNamesUsed[n]; ++e2) n = t + "_" + e2;
    return this.nodeNamesUsed[n] = true, n;
  }
  loadGeometries(e) {
    const t = this;
    this.extensions;
    const n = this.primitiveCache, o = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const i2 = e[r], a = createPrimitiveKey(i2), s = n[a];
      if (s) o.push(s.promise);
      else {
        let e2 = addPrimitiveAttributes(new BufferGeometry(), i2, t);
        n[a] = { primitive: i2, promise: e2 }, o.push(e2);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this, n = this.json, o = this.extensions, r = n.meshes[e], i = r.primitives, a = [], s = isDef(r.extensions) ? r.extensions[EXTENSIONS.S8S_V3D_MESH] : void 0;
    for (let e2 = 0, t2 = i.length; e2 < t2; e2++) {
      const t3 = void 0 === i[e2].material ? createDefaultMaterial(this.cache) : this.getDependency("material", i[e2].material);
      a.push(t3);
    }
    return a.push(t.loadGeometries(i)), Promise.all(a).then(function(n2) {
      const a2 = n2.slice(0, n2.length - 1), l = n2[n2.length - 1], c = [];
      for (let n3 = 0, u2 = l.length; n3 < u2; n3++) {
        const u3 = l[n3], d = i[n3];
        let h;
        const f = a2[n3];
        if (d.mode === WEBGL_CONSTANTS.TRIANGLES || d.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || d.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || void 0 === d.mode) h = true === r.isSkinnedMesh ? new SkinnedMesh(u3, f) : new Mesh(u3, f), true !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), d.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? h.geometry = toTrianglesDrawMode(h.geometry, 1) : d.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (h.geometry = toTrianglesDrawMode(h.geometry, 2));
        else if (d.mode === WEBGL_CONSTANTS.LINES) if (s) {
          const e2 = new MeshLineIndexed();
          e2.fromBufferGeometry(u3);
          const t2 = new MeshLineMaterial({ color: isDef(s.lineColor) ? new Color().fromArray(s.lineColor) : new Color(1, 1, 1), lineWidth: isDef(s.lineWidth) ? s.lineWidth : 1, sizeAttenuation: 0 });
          h = new Mesh(e2.geometry, t2), h.userData.originalLineGeom = u3;
        } else h = new LineSegments(u3, f);
        else if (d.mode === WEBGL_CONSTANTS.LINE_STRIP) h = new Line(u3, f);
        else if (d.mode === WEBGL_CONSTANTS.LINE_LOOP) h = new LineLoop(u3, f);
        else {
          if (d.mode !== WEBGL_CONSTANTS.POINTS) throw new Error("v3d.GLTFLoader: Primitive mode unsupported: " + d.mode);
          h = new Points(u3, f);
        }
        Object.keys(h.geometry.morphAttributes).length > 0 && updateMorphTargets(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), assignExtrasToUserData(h, r), d.extensions && addUnknownExtensionsToUserData(o, h, d);
        const p = {}, m = {};
        if (h.material.isMeshNodeMaterial && s) {
          if (s.uvLayers) for (let e2 in s.uvLayers) p[e2] = texcoordToAttrName(s.uvLayers[e2]);
          if (s.colorLayers) for (let e2 in s.colorLayers) m[e2] = colorToAttrName(s.colorLayers[e2]);
        }
        t.assignFinalMaterial(h, p, m), c.push(h);
      }
      for (let n3 = 0, o2 = c.length; n3 < o2; n3++) t.associations.set(c[n3], { meshes: e, primitives: n3 });
      if (1 === c.length) return c[0];
      const u = new Group();
      t.associations.set(u, { meshes: e });
      for (let e2 = 0, t2 = c.length; e2 < t2; e2++) c[e2].name += "_" + e2, c[e2].isMaterialGeneratedMesh = true, u.add(c[e2]);
      return u;
    });
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], o = n[n.type];
    if (o) return "perspective" === n.type ? t = new PerspectiveCamera(radToDeg(o.yfov), o.aspectRatio || 1, o.znear || 1, o.zfar || 2e6) : "orthographic" === n.type && (t = new OrthographicCamera(-o.xmag, o.xmag, o.ymag, -o.ymag, o.znear, o.zfar)), n.name && (t.name = n.name), assignExtrasToUserData(t, n), this._invokeOne(function(e2) {
      return e2.extendCameraParams && e2.extendCameraParams(t, n);
    });
    console.warn("v3d.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let e2 = 0, o = t.joints.length; e2 < o; e2++) n.push(this.getDependency("node", t.joints[e2]));
    return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(e2) {
      const n2 = e2.pop(), o = e2, r = [], i = [];
      for (let e3 = 0, a = o.length; e3 < a; e3++) {
        const a2 = o[e3];
        if (a2) {
          r.push(a2);
          const t2 = new Matrix4();
          null !== n2 && t2.fromArray(n2.array, 16 * e3), i.push(t2);
        } else console.warn('v3d.GLTFLoader: Joint "%s" could not be found.', t.joints[e3]);
      }
      return new Skeleton(r, i);
    });
  }
  loadAnimation(e) {
    const t = this.json.animations[e], n = [], o = [], r = [], i = [], a = [];
    for (let e2 = 0, s = t.channels.length; e2 < s; e2++) {
      const s2 = t.channels[e2], l = t.samplers[s2.sampler], c = s2.target, u = c.node, d = void 0 !== t.parameters ? t.parameters[l.input] : l.input, h = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
      n.push(this.getDependency("node", u)), o.push(this.getDependency("accessor", d)), r.push(this.getDependency("accessor", h)), i.push(l), a.push(c);
    }
    return Promise.all([Promise.all(n), Promise.all(o), Promise.all(r), Promise.all(i), Promise.all(a), this.getDependencies("material")]).then(function(n2) {
      const o2 = n2[0], r2 = n2[1], i2 = n2[2], a2 = n2[3], s = n2[4], l = [];
      for (let e2 = 0, t2 = o2.length; e2 < t2; e2++) {
        const t3 = o2[e2], c2 = r2[e2], u2 = i2[e2], d2 = a2[e2], h = s[e2];
        if (void 0 === t3) continue;
        let f;
        t3.updateMatrix();
        let p = "";
        switch (PATH_PROPERTIES[h.path]) {
          case PATH_PROPERTIES.weights:
            f = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            f = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.translation:
          case PATH_PROPERTIES.scale:
            f = VectorKeyframeTrack;
            break;
          case PATH_PROPERTIES.intensity:
            f = NumberKeyframeTrack;
            break;
          default:
            if (h.path.indexOf("constraint") > -1) {
              f = NumberKeyframeTrack, p = "constraints[" + h.path.match(/".*"/g)[0] + "]." + h.path.match(/[^\\.]*$/g)[0];
            } else {
              let e3;
              f = VectorKeyframeTrack, h.path.indexOf("nodeValue") > -1 ? (e3 = h.path.match(/".*"/g)[0], p = "material.nodeValue[" + e3 + "]") : h.path.indexOf("nodeRGB") > -1 && (e3 = h.path.match(/".*"/g)[0], p = "material.nodeRGB[" + e3 + "]");
            }
        }
        const m = t3.name ? t3.name : t3.uuid, g = void 0 !== d2.interpolation ? INTERPOLATION[d2.interpolation] : 2301, _ = [];
        if (PATH_PROPERTIES[h.path] === PATH_PROPERTIES.weights) t3.traverse(function(e3) {
          e3.morphTargetInfluences && _.push(e3.name ? e3.name : e3.uuid);
        });
        else if (h.path.indexOf("material") > -1) {
          const e3 = n2[5];
          t3.traverse(function(t4) {
            if (!t4.isMesh) return;
            if (!t4.material.isMeshNodeMaterial) return;
            let n3 = false;
            if (h.extras) {
              n3 = e3[h.extras.material].name === t4.material.name;
              const o3 = h.path.match(/\["(.*)"\]/);
              n3 = n3 && null !== o3 && null !== t4.material.findNodeByName(o3[1]);
            } else n3 = true;
            n3 && _.push(t4.name ? t4.name : t4.uuid);
          });
        } else _.push(m);
        let A = u2.array;
        if (u2.normalized) {
          const e3 = getNormalizedComponentScale(A.constructor), t4 = new Float32Array(A.length);
          for (let n3 = 0, o3 = A.length; n3 < o3; n3++) t4[n3] = A[n3] * e3;
          A = t4;
        }
        for (let e3 = 0, t4 = _.length; e3 < t4; e3++) {
          const t5 = new f(_[e3] + "." + ("" !== p ? p : PATH_PROPERTIES[h.path]), c2.array, A, g);
          "CUBICSPLINE" === d2.interpolation && (t5.createInterpolant = function(e4) {
            return new (this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant)(this.times, this.values, this.getValueSize() / 3, e4);
          }, t5.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l.push(t5);
        }
      }
      const c = t.name ? t.name : "animation_" + e, u = { clip: new AnimationClip(c, void 0, l), nodeId: o2[0].id, auto: true, loop: 2201, repetitions: 1 / 0, startAt: 0 }, d = isDef(t.extensions) ? t.extensions[EXTENSIONS.S8S_V3D_ANIMATION] : void 0;
      if (d) {
        u.auto = d.auto;
        const e2 = d.repeatInfinite ? 1 / 0 : d.repeatCount;
        switch (d.loop) {
          case "ONCE":
            u.loop = 2200;
            break;
          case "REPEAT":
            u.loop = 2201, u.repetitions = e2;
            break;
          case "PING_PONG":
            u.loop = 2202, u.repetitions = e2;
        }
        u.startAt = d.offset;
      }
      return u;
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, o = t.nodes[e];
    return void 0 === o.mesh ? null : n.getDependency("mesh", o.mesh).then(function(e2) {
      const t2 = n._getNodeRef(n.meshCache, o.mesh, e2);
      return void 0 !== o.weights && t2.traverse(function(e3) {
        if (e3.isMesh) for (let t3 = 0, n2 = o.weights.length; t3 < n2; t3++) e3.morphTargetInfluences[t3] = o.weights[t3];
      }), t2;
    });
  }
  loadNode(e) {
    const t = this.json, n = this.extensions, o = this, r = t.nodes[e], i = r.name ? o.createUniqueName(r.name) : "";
    return function() {
      const t2 = [], n2 = o._invokeOne(function(t3) {
        return t3.createNodeMesh && t3.createNodeMesh(e);
      });
      return n2 && t2.push(n2), void 0 !== r.camera && t2.push(o.getDependency("camera", r.camera).then(function(e2) {
        return o._getNodeRef(o.cameraCache, r.camera, e2);
      })), o._invokeAll(function(t3) {
        return t3.createNodeAttachment && t3.createNodeAttachment(e);
      }).forEach(function(e2) {
        t2.push(e2);
      }), Promise.all(t2);
    }().then(function(t2) {
      let a;
      if (a = true === r.isBone ? new Bone() : t2.length > 1 ? new Group() : 1 === t2.length ? t2[0] : new Object3D(), a !== t2[0]) for (let e2 = 0, n2 = t2.length; e2 < n2; e2++) a.add(t2[e2]);
      if (r.name && (a.userData.name = r.name, a.name = i), assignExtrasToUserData(a, r), r.extensions && addUnknownExtensionsToUserData(n, a, r), void 0 !== r.matrix) {
        const e2 = new Matrix4();
        e2.fromArray(r.matrix), a.applyMatrix4(e2);
      } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
      return o.associations.has(a) || o.associations.set(a, {}), o.associations.get(a).nodes = e, a;
    }).then(function(e2) {
      return e2.resolveMultiMaterial().forEach((t2) => {
        o._invokeOne(function(n2) {
          if (t2 !== e2) return n2.extendNodeParams && n2.extendNodeParams(t2, r);
        });
      }), o._invokeOne(function(t2) {
        return t2.extendNodeParams && t2.extendNodeParams(e2, r);
      });
    });
  }
  loadScene(e) {
    const t = this.json, n = this.extensions, o = this.json.scenes[e], r = this, i = new Scene();
    o.name && (i.name = r.createUniqueName(o.name)), assignExtrasToUserData(i, o), o.extensions && addUnknownExtensionsToUserData(n, i, o);
    const a = o.nodes || [], s = [];
    for (let e2 = 0, n2 = a.length; e2 < n2; e2++) s.push(buildNodeHierarchy(a[e2], i, t, r));
    return Promise.all(s).then(function() {
      return r.associations = ((e2) => {
        const t2 = /* @__PURE__ */ new Map();
        for (const [e3, n2] of r.associations) (e3 instanceof Material || e3 instanceof Texture) && t2.set(e3, n2);
        return e2.traverse((e3) => {
          const n2 = r.associations.get(e3);
          null != n2 && t2.set(e3, n2);
        }), t2;
      })(i), i;
    });
  }
};
function buildNodeHierarchy(e, t, n, o) {
  const r = n.nodes[e];
  return o.getDependency("node", e).then(function(e2) {
    return void 0 === r.skin ? e2 : o.getDependency("skin", r.skin).then(function(t2) {
      return e2.traverse(function(e3) {
        e3.isSkinnedMesh && e3.bind(t2, e3.matrixWorld);
      }), e2;
    });
  }).then(function(e2) {
    t.add(e2), (e2.isDirectionalLight || e2.isSpotLight) && e2.isFreeLight && t.add(e2.target);
    const i = [];
    if (r.children) {
      const t2 = r.children;
      for (let r2 = 0, a = t2.length; r2 < a; r2++) {
        const a2 = t2[r2];
        i.push(buildNodeHierarchy(a2, e2, n, o));
      }
    }
    return Promise.all(i);
  });
}
function computeBounds(e, t, n) {
  const o = t.attributes, r = new Box3();
  if (void 0 === o.POSITION) return;
  {
    const e2 = n.json.accessors[o.POSITION], t2 = e2.min, i2 = e2.max;
    if (void 0 === t2 || void 0 === i2) return void console.warn("v3d.GLTFLoader: Missing min/max properties for accessor POSITION.");
    if (r.set(new Vector3(t2[0], t2[1], t2[2]), new Vector3(i2[0], i2[1], i2[2])), e2.normalized) {
      const t3 = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[e2.componentType]);
      r.min.multiplyScalar(t3), r.max.multiplyScalar(t3);
    }
  }
  const i = t.targets;
  if (void 0 !== i) {
    const e2 = new Vector3(), t2 = new Vector3();
    for (let o2 = 0, r2 = i.length; o2 < r2; o2++) {
      const r3 = i[o2];
      if (void 0 !== r3.POSITION) {
        const o3 = n.json.accessors[r3.POSITION], i2 = o3.min, a2 = o3.max;
        if (void 0 !== i2 && void 0 !== a2) {
          if (t2.setX(Math.max(Math.abs(i2[0]), Math.abs(a2[0]))), t2.setY(Math.max(Math.abs(i2[1]), Math.abs(a2[1]))), t2.setZ(Math.max(Math.abs(i2[2]), Math.abs(a2[2]))), o3.normalized) {
            const e3 = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[o3.componentType]);
            t2.multiplyScalar(e3);
          }
          e2.max(t2);
        } else console.warn("v3d.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    r.expandByVector(e2);
  }
  e.boundingBox = r;
  const a = new Sphere();
  r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a;
}
function addPrimitiveAttributes(e, t, n) {
  const o = t.attributes, r = [];
  function i(t2, o2) {
    return n.getDependency("accessor", t2).then(function(t3) {
      e.setAttribute(o2, t3);
    });
  }
  for (const t2 in o) {
    const n2 = ATTRIBUTES[t2] || extraAttrName(t2) || t2.toLowerCase();
    n2 in e.attributes || r.push(i(o[t2], n2));
  }
  if (void 0 !== t.indices && !e.index) {
    const o2 = n.getDependency("accessor", t.indices).then(function(t2) {
      e.setIndex(t2);
    });
    r.push(o2);
  }
  return assignExtrasToUserData(e, t), computeBounds(e, t, n), Promise.all(r).then(function() {
    return void 0 !== t.targets ? addMorphTargets(e, t.targets, n) : e;
  });
}
function toTrianglesDrawMode(e, t) {
  let n = e.getIndex();
  if (null === n) {
    const t2 = [], o2 = e.getAttribute("position");
    if (void 0 === o2) return console.error("v3d.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
    for (let e2 = 0; e2 < o2.count; e2++) t2.push(e2);
    e.setIndex(t2), n = e.getIndex();
  }
  const o = n.count - 2, r = [];
  if (2 === t) for (let e2 = 1; e2 <= o; e2++) r.push(n.getX(0)), r.push(n.getX(e2)), r.push(n.getX(e2 + 1));
  else for (let e2 = 0; e2 < o; e2++) e2 % 2 == 0 ? (r.push(n.getX(e2)), r.push(n.getX(e2 + 1)), r.push(n.getX(e2 + 2))) : (r.push(n.getX(e2 + 2)), r.push(n.getX(e2 + 1)), r.push(n.getX(e2)));
  r.length / 3 !== o && console.error("v3d.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const i = e.clone();
  return i.setIndex(r), i;
}
function extraAttrName(e) {
  return e.indexOf("TEXCOORD_") > -1 ? texcoordToAttrName(e) : e.indexOf("COLOR_") > -1 ? colorToAttrName(e) : "";
}
function texcoordToAttrName(e) {
  return "TEXCOORD_0" == e ? "uv" : "uv" + String(Number(e.split("TEXCOORD_")[1]) + 1);
}
function colorToAttrName(e) {
  return "COLOR_0" == e ? "color" : "color" + String(Number(e.split("COLOR_")[1]) + 1);
}
function assignDefaultBlending(e) {
  e.blending = 5, e.blendEquation = 100, e.blendSrc = 201, e.blendDst = 205;
}
var _clearColor = new Color();
var GTAOMapGenerator = class extends EventDispatcher {
  constructor(e, t, n = 512, o = 512) {
    super(), this.scene = e, this.camera = t, this.width = n, this.height = o, this.distance = 0.1, this.factor = 1, this.precision = 1, this.bentNormals = false, this.noiseTexture = this.createNoiseTexture(), this.fsQuad = new FullScreenQuad(null);
    const r = new DepthTexture();
    r.type = 1014, this.renderTargetNormalDepth = new WebGLRenderTarget(this.width, this.height, { format: 1023, depthTexture: r, depthBuffer: true }), this.renderTargetNormalDepth.texture.name = "GTAO.normal", this.renderTargetNormalDepth.depthTexture.name = "GTAO.depth", this.renderTargetGTAO = new WebGLRenderTarget(this.width, this.height), this.renderTargetGTAO.texture.name = "GTAO.gtao", this.renderTargetBlurX = new WebGLRenderTarget(this.width, this.height), this.renderTargetBlurX.texture.name = "GTAO.blur", this.renderTarget = new WebGLRenderTarget(this.width, this.height), this.renderTarget.texture.name = "GTAO.rt", this.materialNormal = new MeshNormalMaterial({}), this.materialGTAO = new ShaderMaterial({ type: "GTAO", defines: { ORTHO_CAMERA: 0, CALC_BENT_NORMALS: 0 }, extensions: { derivatives: true }, uniforms: { tNormal: { value: null }, tDepth: { value: null }, tNoise: { value: null }, occlDistance: { value: 0.1 }, factor: { value: 1 }, occlPrecision: { value: 1 }, mainCameraProjMat: { value: new Matrix4() }, resolution: { value: new Vector2() } }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_gtao_frag }), this.materialBlur = new ShaderMaterial({ type: "GTAOBlur", defines: {}, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, direction: { value: new Vector2() }, resolution: { value: new Vector2() } }, customPrepTokens: { BLUR_RADIUS_PX: 2 }, vertexShader: ShaderChunk.pp_plane_vert, fragmentShader: ShaderChunk.pp_gtao_blur_frag }), this._layerMasks = {};
  }
  setCamera(e) {
    this.camera = e;
  }
  setSize(e, t) {
    this.width = e, this.height = t, this.renderTargetNormalDepth.setSize(e, t), this.renderTargetGTAO.setSize(e, t), this.renderTargetBlurX.setSize(e, t), this.renderTarget.setSize(e, t), this.materialGTAO.uniforms.mainCameraProjMat.value.copy(this.camera.projectionMatrix), this.materialGTAO.uniforms.resolution.value.set(this.renderTargetGTAO.width, this.renderTargetGTAO.height), this.materialBlur.uniforms.resolution.value.set(this.renderTargetGTAO.width, this.renderTargetGTAO.height);
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" }), this.renderTargetNormalDepth.dispose(), this.renderTargetGTAO.dispose(), this.renderTargetBlurX.dispose(), this.renderTarget.dispose(), this.materialNormal.dispose(), this.materialGTAO.dispose(), this.materialBlur.dispose(), this.noiseTexture.dispose();
  }
  _saveLayers() {
    this.scene.traverse((e) => this._layerMasks[e.id] = e.layers.mask);
  }
  _setupLayers() {
    this.scene.traverse((e) => {
      e.layers.disableAll();
      const t = e instanceof Mesh && e.material && !e.material.gtaoVisible, n = e instanceof Mesh && e.material && e.material.isMeshNodeMaterial && (e.material.alphaTest > 0 || e.material.alphaToCoverage);
      t ? e.layers.enable(0) : n ? e.layers.enable(1) : e.layers.enable(2);
    });
  }
  _restoreLayers() {
    this.scene.traverse((e) => e.layers.mask = this._layerMasks[e.id]);
  }
  _setupNodeAlphaClipHashMaterials() {
    this.scene.traverse((e) => {
      e instanceof Mesh && e.material && e.material.isMeshNodeMaterial && (e.material.defines.NORMAL_OUTPUT = Number(e.material.alphaTest > 0 || e.material.alphaToCoverage), e.material.needsUpdate = true);
    });
  }
  _restoreNodeAlphaClipHashMaterials() {
    this.scene.traverse((e) => {
      e instanceof Mesh && e.material && e.material.isMeshNodeMaterial && (e.material.defines.NORMAL_OUTPUT = 0, e.material.needsUpdate = true);
    });
  }
  render(e) {
    this._saveLayers(), this._setupLayers(), this.camera.layers.disableAll(), this.camera.layers.enable(1), this._setupNodeAlphaClipHashMaterials(), this._renderOverride(e, null, this.renderTargetNormalDepth, 8355839, 1, true), this._restoreNodeAlphaClipHashMaterials(), this.camera.layers.disableAll(), this.camera.layers.enable(2), this._renderOverride(e, this.materialNormal, this.renderTargetNormalDepth, null, null, true), this._restoreLayers(), this.materialGTAO.defines.ORTHO_CAMERA = this.camera.isOrthographicCamera ? 1 : 0, this.materialGTAO.defines.CALC_BENT_NORMALS = this.bentNormals ? 1 : 0, this.materialGTAO.needsUpdate = true, this.materialGTAO.uniforms.tNormal.value = this.renderTargetNormalDepth.texture, this.materialGTAO.uniforms.tDepth.value = this.renderTargetNormalDepth.depthTexture, this.materialGTAO.uniforms.tNoise.value = this.noiseTexture, this.materialGTAO.uniforms.occlDistance.value = this.distance, this.materialGTAO.uniforms.factor.value = this.factor, this.materialGTAO.uniforms.occlPrecision.value = this.precision, this.materialGTAO.uniforms.mainCameraProjMat.value.copy(this.camera.projectionMatrix), this.materialGTAO.uniforms.resolution.value.set(this.renderTargetGTAO.width, this.renderTargetGTAO.height), this._renderPass(e, this.materialGTAO, this.renderTargetGTAO), this.materialBlur.uniforms.tDiffuse.value = this.renderTargetGTAO.texture, this.materialBlur.map = this.renderTargetGTAO.texture, this.materialBlur.uniforms.tNormal.value = this.renderTargetNormalDepth.texture, this.materialBlur.uniforms.direction.value.set(1, 0), this.materialBlur.uniforms.resolution.value.set(this.renderTargetGTAO.width, this.renderTargetGTAO.height), this._renderPass(e, this.materialBlur, this.renderTargetBlurX), this.materialBlur.uniforms.tDiffuse.value = this.renderTargetBlurX.texture, this.materialBlur.map = this.renderTargetBlurX.texture, this.materialBlur.uniforms.direction.value.set(0, 1), this.materialBlur.uniforms.resolution.value.set(this.renderTargetBlurX.width, this.renderTargetBlurX.height), this._renderPass(e, this.materialBlur, this.renderTarget);
  }
  _renderOverride(e, t, n, o, r, i) {
    const a = e.getRenderTarget(), s = e.getClearColor(_clearColor), l = e.getClearAlpha(), c = e.autoClear, u = this.scene.background;
    e.setRenderTarget(n), null != o && (e.setClearColor(o), e.setClearAlpha(r ?? 0), e.clear()), e.autoClear = false, i && (this.scene.background = null), t && (this.scene.overrideMaterial = t), e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.setRenderTarget(a), e.setClearColor(s), e.setClearAlpha(l), e.autoClear = c, this.scene.background = u;
  }
  _renderPass(e, t, n, o, r) {
    const i = e.getRenderTarget(), a = e.getClearColor(_clearColor), s = e.getClearAlpha(), l = e.autoClear;
    e.setRenderTarget(n), null != o && (e.setClearColor(o), e.setClearAlpha(r ?? 0), e.clear()), e.autoClear = false, this.fsQuad.material = t, this.fsQuad.render(e), e.setRenderTarget(i), e.setClearColor(a), e.setClearAlpha(s), e.autoClear = l;
  }
  createNoiseTexture() {
    const e = new Uint8Array([101, 192, 145, 80, 53, 136, 86, 207, 229, 131, 240, 6, 58, 41, 171, 13, 199, 63, 175, 128, 113, 55, 246, 66, 115, 213, 157, 59, 243, 114, 68, 169, 255, 60, 216, 5, 200, 37, 250, 65, 170, 48, 153, 108, 125, 211, 137, 29, 120, 82, 38, 213, 25, 198, 15, 150, 33, 131, 173, 16, 140, 180, 9, 206, 134, 20, 117, 176, 99, 222, 124, 190, 95, 33, 198, 221, 86, 68, 241, 157, 227, 142, 253, 96, 72, 135, 169, 102, 204, 253, 89, 195, 50, 233, 94, 38, 185, 86, 235, 72, 149, 163, 25, 2, 146, 75, 254, 14, 164, 189, 0, 100, 49, 187, 162, 8, 181, 222, 240, 52, 7, 73, 41, 109, 210, 123, 76, 150, 226, 161, 44, 11, 242, 51, 107, 232, 212, 116, 177, 54, 141, 37, 207, 77, 115, 19, 59, 235, 110, 42, 83, 122, 160, 184, 224, 148, 2, 164, 248, 24, 203, 109, 129, 192, 208, 138, 83, 182, 61, 132, 28, 229, 96, 121, 224, 173, 248, 197, 88, 127, 147, 29, 193, 210, 139, 96, 237, 30, 63, 191, 102, 54, 69, 178, 32, 93, 63, 170, 36, 247, 17, 201, 80, 155, 245, 18, 60, 133, 151, 32, 219, 206, 165, 67, 230, 20, 57, 12, 171, 128, 84, 221, 139, 13, 236, 146, 220, 252, 20, 120, 222, 150, 99, 166, 43, 108, 196, 183, 89, 45, 9, 107, 74, 49, 4, 100, 175, 117, 246, 71, 198, 113, 241, 39, 174, 119, 46, 82, 1, 157, 105, 195, 72, 9, 127, 239, 217, 6, 69, 145, 211, 166, 230, 181, 240, 136, 190, 251, 87, 155, 35, 219, 143, 50, 22, 159, 213, 92, 191, 127, 212, 41, 135, 237, 50, 206, 88, 58, 176, 118, 36, 234, 27, 114, 64, 93, 157, 119, 21, 214, 45, 129, 187, 105, 92, 208, 182, 66, 6, 249, 27, 167, 62, 185, 78, 172, 29, 160, 188, 25, 139, 249, 161, 84, 130, 254, 203, 14, 37, 226, 59, 143, 77, 238, 0, 166, 18, 254, 79, 133, 103, 153, 205, 113, 94, 246, 12, 216, 100, 116, 227, 76, 209, 48, 97, 186, 1, 53, 144, 192, 82, 169, 108, 179, 28, 198, 65, 228, 42, 151, 122, 197, 233, 53, 74, 222, 24, 146, 123, 56, 141, 255, 3, 151, 106, 20, 200, 220, 73, 174, 104, 216, 131, 248, 7, 209, 156, 86, 112, 136, 177, 58, 223, 11, 36, 140, 241, 8, 195, 178, 232, 85, 200, 43, 65, 180, 240, 133, 61, 149, 120, 231, 22, 46, 71, 30, 92, 230, 121, 52, 242, 215, 97, 26, 110, 186, 89, 172, 158, 102, 50, 70, 34, 156, 15, 189, 126, 91, 34, 168, 10, 245, 39, 91, 163, 243, 152, 202, 140, 42, 188, 17, 163, 8, 203, 77, 156, 237, 63, 118, 32, 130, 251, 165, 112, 208, 98, 235, 161, 213, 228, 81, 110, 194, 178, 14, 125, 185, 111, 61, 173, 103, 253, 71, 144, 39, 125, 250, 45, 207, 15, 217, 177, 202, 88, 1, 226, 132, 75, 26, 56, 12, 119, 203, 46, 137, 66, 209, 77, 220, 3, 238, 19, 80, 129, 218, 179, 90, 193, 168, 132, 98, 146, 81, 19, 235, 142, 59, 183, 44, 250, 174, 104, 144, 69, 155, 251, 97, 230, 145, 33, 99, 49, 159, 212, 196, 31, 56, 110, 225, 22, 62, 2, 183, 245, 55, 123, 40, 106, 215, 17, 150, 116, 218, 194, 238, 31, 186, 0, 23, 55, 162, 241, 194, 135, 87, 118, 147, 236, 4, 158, 244, 75, 117, 228, 35, 109, 194, 67, 155, 78, 168, 199, 91, 64, 8, 135, 47, 88, 169, 212, 129, 181, 111, 11, 65, 170, 227, 40, 68, 176, 95, 201, 46, 142, 209, 154, 90, 165, 218, 255, 188, 232, 27, 121, 244, 35, 163, 79, 206, 124, 242, 103, 72, 223, 83, 204, 123, 25, 247, 10, 191, 111, 136, 26, 85, 187, 18, 236, 51, 134, 7, 144, 13, 99, 48, 138, 227, 190, 101, 223, 24, 153, 60, 41, 149, 30, 255, 45, 152, 184, 103, 78, 162, 51, 252, 217, 128, 171, 104, 70, 197, 30, 84, 114, 57, 176, 205, 70, 4, 148, 54, 253, 181, 113, 6, 231, 191, 134, 172, 95, 220, 56, 211, 141, 233, 205, 16, 66, 40, 224, 5, 122, 243, 179, 211, 226, 127, 247, 158, 85, 111, 174, 126, 15, 73, 202, 167, 87, 215, 17, 116, 3, 71, 130, 19, 35, 90, 124, 154, 182, 98, 248, 148, 57, 156, 96, 43, 73, 196, 34, 16, 218, 237, 42, 208, 94, 143, 38, 247, 122, 67, 52, 201, 234, 164, 249, 177, 199, 61, 1, 108, 76, 167, 31, 204, 80, 231, 22, 170, 0, 147, 93, 120, 183, 64, 28, 161, 239, 57, 185, 105, 28, 159, 139, 184, 106, 40, 81, 114, 145, 242, 219, 190, 239, 53, 138, 112, 11, 187, 133, 107, 204, 239, 168, 54, 141, 102, 193, 81, 221, 134, 9, 216, 78, 229, 244, 90, 23, 153, 225, 10, 95, 160, 43, 132, 23, 214, 195, 89, 47, 215, 252, 62, 38, 82, 228, 21, 214, 251, 2, 151, 109, 21, 175, 197, 149, 44, 5, 173, 64, 210, 52, 196, 69, 29, 172, 83, 118, 13, 154, 236, 175, 119, 26, 159, 137, 112, 189, 44, 131, 75, 171, 121, 49, 232, 92, 126, 62, 101, 205, 130, 117, 250, 138, 180, 125, 207, 254, 58, 225, 97, 67, 37, 142, 74, 98, 182, 210, 7, 68, 152, 202, 94, 34, 243, 200, 70, 39, 252, 166, 16, 224, 188, 32, 84, 21, 100, 231, 12, 106, 148, 199, 178, 249, 164, 5, 229, 55, 245, 87, 165, 234, 105, 14, 225, 60, 184, 140, 158, 214, 27, 115, 143, 74, 51, 162, 147, 238, 47, 76, 167, 36, 137, 3, 48, 126, 104, 201, 189, 128, 18, 47, 124, 31, 244, 180, 160, 115, 23, 10, 101, 79, 179, 193, 233, 93, 246, 107, 217, 4, 192, 154, 221, 91, 186, 234, 79, 24, 219, 85, 33, 152, 223]), t = new Uint8Array([7, 87, 145, 233, 57, 15, 124, 219, 7, 163, 132, 35, 222, 160, 41, 99, 10, 23, 228, 253, 53, 207, 65, 214, 94, 146, 248, 134, 214, 15, 97, 230, 201, 181, 41, 105, 189, 206, 171, 100, 146, 78, 188, 106, 177, 87, 141, 232, 198, 122, 70, 178, 149, 26, 124, 174, 16, 55, 115, 35, 70, 179, 158, 111, 74, 241, 122, 159, 29, 90, 47, 242, 23, 229, 213, 16, 245, 72, 26, 183, 58, 136, 205, 43, 86, 239, 139, 226, 77, 188, 203, 86, 224, 144, 50, 30, 135, 62, 11, 218, 255, 68, 156, 185, 59, 121, 91, 49, 199, 152, 219, 109, 243, 162, 14, 221, 113, 192, 3, 100, 42, 152, 233, 168, 22, 123, 251, 210, 153, 191, 99, 173, 139, 114, 2, 133, 201, 32, 169, 135, 64, 118, 1, 47, 89, 31, 102, 76, 154, 35, 63, 164, 255, 127, 9, 62, 106, 187, 4, 91, 44, 222, 17, 80, 39, 209, 237, 82, 107, 251, 148, 11, 231, 174, 208, 130, 194, 171, 234, 184, 248, 121, 216, 199, 110, 28, 212, 137, 240, 77, 164, 232, 25, 128, 247, 150, 57, 193, 20, 160, 44, 211, 75, 191, 96, 37, 81, 254, 147, 66, 8, 140, 54, 21, 177, 89, 74, 51, 175, 93, 39, 199, 55, 115, 84, 202, 104, 179, 230, 124, 97, 222, 64, 177, 27, 111, 239, 158, 17, 57, 105, 219, 42, 209, 95, 132, 231, 13, 144, 244, 194, 157, 226, 18, 143, 180, 66, 166, 48, 5, 74, 32, 169, 142, 7, 241, 128, 52, 216, 137, 185, 228, 26, 124, 84, 166, 189, 71, 38, 158, 221, 115, 1, 65, 123, 102, 250, 216, 34, 242, 140, 113, 212, 188, 249, 85, 118, 197, 156, 89, 5, 70, 116, 167, 202, 153, 240, 114, 4, 246, 203, 100, 46, 185, 84, 31, 209, 173, 6, 130, 196, 22, 225, 91, 155, 61, 16, 49, 103, 229, 36, 206, 173, 249, 46, 92, 12, 73, 33, 223, 142, 60, 172, 126, 22, 234, 135, 246, 151, 75, 52, 97, 161, 79, 182, 12, 235, 132, 207, 150, 184, 20, 78, 143, 101, 28, 196, 235, 134, 178, 53, 195, 24, 108, 82, 215, 150, 55, 168, 110, 43, 189, 233, 144, 207, 59, 125, 44, 168, 108, 34, 220, 69, 166, 244, 58, 225, 125, 149, 63, 213, 104, 253, 93, 155, 184, 11, 250, 73, 96, 201, 8, 218, 88, 14, 117, 223, 105, 247, 193, 71, 88, 254, 122, 3, 132, 191, 113, 10, 181, 40, 83, 0, 162, 127, 41, 210, 235, 122, 36, 195, 18, 228, 65, 131, 176, 253, 38, 19, 165, 0, 146, 27, 203, 178, 54, 96, 234, 43, 159, 90, 218, 245, 112, 191, 229, 18, 79, 66, 137, 51, 160, 180, 141, 118, 164, 30, 101, 154, 71, 137, 94, 217, 56, 238, 134, 17, 153, 200, 80, 29, 204, 67, 23, 155, 52, 172, 33, 145, 198, 175, 7, 223, 103, 87, 244, 41, 79, 236, 204, 51, 186, 81, 199, 176, 112, 77, 224, 40, 110, 170, 223, 144, 251, 174, 131, 98, 205, 73, 121, 247, 97, 238, 116, 29, 204, 62, 2, 213, 183, 145, 24, 125, 241, 228, 45, 31, 129, 160, 92, 188, 246, 62, 6, 102, 50, 116, 15, 240, 140, 10, 218, 59, 45, 151, 83, 167, 255, 130, 157, 107, 55, 92, 219, 110, 5, 61, 147, 252, 8, 212, 51, 12, 140, 75, 126, 183, 215, 83, 194, 43, 226, 88, 165, 109, 187, 21, 215, 68, 39, 192, 20, 239, 198, 12, 68, 174, 159, 99, 121, 192, 70, 231, 177, 119, 209, 237, 19, 154, 33, 232, 163, 65, 180, 29, 200, 129, 4, 231, 135, 182, 98, 147, 76, 118, 165, 136, 248, 40, 211, 14, 85, 169, 107, 25, 151, 100, 36, 164, 197, 92, 58, 136, 2, 123, 106, 148, 252, 75, 210, 162, 53, 120, 9, 233, 217, 46, 28, 226, 83, 128, 195, 245, 224, 38, 141, 205, 61, 249, 86, 48, 227, 114, 255, 186, 207, 77, 236, 16, 56, 39, 102, 85, 30, 247, 203, 60, 87, 179, 103, 186, 56, 152, 22, 180, 131, 53, 236, 81, 15, 190, 134, 175, 8, 72, 147, 24, 99, 48, 215, 192, 172, 139, 240, 196, 149, 108, 168, 17, 127, 157, 252, 1, 206, 114, 74, 161, 98, 3, 186, 156, 120, 221, 27, 108, 211, 129, 40, 170, 242, 158, 131, 91, 115, 225, 20, 178, 71, 45, 222, 142, 197, 36, 66, 145, 93, 234, 34, 198, 67, 217, 109, 243, 45, 67, 161, 237, 54, 195, 224, 85, 112, 6, 32, 69, 155, 9, 64, 123, 212, 3, 94, 242, 76, 113, 214, 25, 170, 49, 220, 119, 148, 28, 170, 90, 10, 200, 143, 80, 95, 153, 18, 64, 202, 175, 220, 250, 42, 208, 96, 163, 254, 133, 185, 21, 52, 230, 190, 126, 244, 138, 13, 86, 254, 58, 138, 211, 125, 179, 251, 34, 2, 183, 248, 126, 143, 54, 187, 78, 136, 235, 193, 50, 32, 82, 117, 173, 161, 98, 9, 82, 63, 105, 187, 19, 205, 37, 230, 76, 21, 104, 60, 167, 119, 214, 106, 37, 227, 13, 101, 120, 167, 25, 109, 146, 227, 201, 60, 238, 38, 148, 206, 181, 42, 163, 236, 176, 128, 107, 154, 184, 50, 225, 208, 133, 232, 49, 73, 165, 90, 239, 152, 204, 0, 89, 182, 72, 11, 156, 101, 217, 14, 130, 252, 111, 227, 5, 72, 95, 47, 196, 0, 245, 94, 149, 13, 84, 27, 150, 193, 19, 181, 68, 30, 48, 243, 61, 221, 127, 246, 24, 138, 190, 69, 88, 57, 26, 141, 210, 151, 220, 249, 67, 117, 166, 35, 194, 112, 176, 202, 95, 237, 139, 208, 111, 129, 216, 190, 142, 37, 171, 197, 81, 47, 119, 229, 159, 200, 171, 79, 120, 33, 133, 169, 23, 213, 80, 138, 238, 69, 44, 253, 63, 117, 4, 56, 250, 172, 78, 157, 93, 116, 6, 104, 162, 241, 31, 182, 1, 103, 46, 243, 189, 59]), n = new Uint8Array(4096);
    for (let o2 = 0; o2 < 1024; o2++) n[4 * o2] = e[o2], n[4 * o2 + 1] = t[o2], n[4 * o2 + 2] = 0, n[4 * o2 + 3] = 0;
    const o = new DataTexture(n, 32, 32, 1023, 1009);
    return o.name = "GTAO.noise", o.wrapS = 1e3, o.wrapT = 1e3, o.needsUpdate = true, o;
  }
};
var WorkerPool = class {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++) if (!(this.workerStatus & 1 << e)) return e;
    return -1;
  }
  _onMessage(e, t) {
    const n = this.workersResolve[e];
    if (n && n(t), this.queue.length) {
      const { resolve: t2, msg: n2, transfer: o } = this.queue.shift();
      this.workersResolve[e] = t2, this.workers[e].postMessage(n2, o);
    } else this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((n) => {
      const o = this._getIdleWorker();
      -1 !== o ? (this._initWorker(o), this.workerStatus |= 1 << o, this.workersResolve[o] = n, this.workers[o].postMessage(e, t)) : this.queue.push({ resolve: n, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
};
var _taskCache = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var KTX2Loader = class _KTX2Loader extends Loader {
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new WorkerPool(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('v3d.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
  }
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  detectSupport(e) {
    return this.workerConfig = { astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc") && e.extensions.has("WEBGL_compressed_texture_s3tc_srgb"), bptcSupported: e.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = false), this;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this;
  }
  init() {
    if (!this.transcoderPending) {
      const e = new FileLoader(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), n = new FileLoader(this.manager);
      n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
      const o = n.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, o]).then(([e2, t2]) => {
        const n2 = _KTX2Loader.BasisWorker.toString(), o2 = ["/* constants */", "let _EngineFormat = " + JSON.stringify(_KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(_KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(_KTX2Loader.BasisFormat), "/* basis_transcoder.js */", e2, "/* worker */", n2.substring(n2.indexOf("{") + 1, n2.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([o2])), this.transcoderBinary = t2, this.workerPool.setWorkerCreator(() => {
          const e3 = new Worker(this.workerSourceURL), t3 = this.transcoderBinary.slice(0);
          return e3.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: t3 }, [t3]), e3;
        });
      }), _activeLoaders > 0 && console.warn("v3d.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(e, t, n, o) {
    if (null === this.workerConfig) throw new Error("v3d.KTX2Loader: Missing initialization with `.detectSupport(renderer)`.");
    const r = new FileLoader(this.manager);
    r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials);
    const i = new CompressedTexture();
    return r.load(e, (e2) => {
      if (_taskCache.has(e2)) {
        return _taskCache.get(e2).promise.then(t).catch(o);
      }
      this._createTexture([e2]).then(function(e3) {
        i.copy(e3), i.needsUpdate = true, t && t(i);
      }).catch(o);
    }, n, o), i;
  }
  _createTextureFrom(e) {
    const { mipmaps: t, width: n, height: o, format: r, type: i, error: a, dfdTransferFn: s, dfdFlags: l } = e;
    if ("error" === i) return Promise.reject(a);
    const c = new CompressedTexture(t, n, o, r, 1009);
    return c.minFilter = 1 === t.length ? 1006 : 1008, c.magFilter = 1006, c.generateMipmaps = false, c.needsUpdate = true, c.encoding = 2 === s ? 3001 : 3e3, c.premultiplyAlpha = !!(1 & l), c;
  }
  _createTexture(e, t = {}) {
    const n = t, o = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffers: e, taskConfig: n }, e)).then((e2) => this._createTextureFrom(e2.data));
    return _taskCache.set(e[0], { promise: o }), o;
  }
  dispose() {
    return URL.revokeObjectURL(this.workerSourceURL), this.workerPool.dispose(), _activeLoaders--, this;
  }
};
KTX2Loader.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, KTX2Loader.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, KTX2Loader.EngineFormat = { RGBAFormat: 1023, RGBA_ASTC_4x4_Format: 37808, RGBA_BPTC_Format: 36492, RGBA_ETC2_EAC_Format: 37496, RGBA_PVRTC_4BPPV1_Format: 35842, RGBA_S3TC_DXT5_Format: 33779, RGB_ETC1_Format: 36196, RGB_ETC2_Format: 37492, RGB_PVRTC_4BPPV1_Format: 35840, RGB_S3TC_DXT1_Format: 33776 }, KTX2Loader.BasisWorker = function() {
  let e, t, n;
  const o = _EngineFormat, r = _TranscoderFormat, i = _BasisFormat;
  self.addEventListener("message", function(a2) {
    const u = a2.data;
    switch (u.type) {
      case "init":
        e = u.config, d = u.transcoderBinary, t = new Promise((e2) => {
          n = { wasmBinary: d, onRuntimeInitialized: e2 }, BASIS(n);
        }).then(() => {
          n.initializeBasis(), void 0 === n.KTX2File && console.warn("v3d.KTX2Loader: Please update Basis Universal transcoder.");
        });
        break;
      case "transcode":
        t.then(() => {
          try {
            const { width: t2, height: a3, hasAlpha: d2, mipmaps: h, format: f, dfdTransferFn: p, dfdFlags: m } = function(t3) {
              const a4 = new n.KTX2File(new Uint8Array(t3));
              function u2() {
                a4.close(), a4.delete();
              }
              if (!a4.isValid()) throw u2(), new Error("v3d.KTX2Loader:    Invalid or unsupported .ktx2 file");
              const d3 = a4.isUASTC() ? i.UASTC_4x4 : i.ETC1S, h2 = a4.getWidth(), f2 = a4.getHeight(), p2 = a4.getLevels(), m2 = a4.getHasAlpha(), g2 = a4.getDFDTransferFunc(), _ = a4.getDFDFlags(), { transcoderFormat: A, engineFormat: v } = function(t4, n2, a5, u3) {
                let d4, h3;
                const f3 = t4 === i.ETC1S ? s : l;
                for (let o2 = 0; o2 < f3.length; o2++) {
                  const r2 = f3[o2];
                  if (e[r2.if] && (r2.basisFormat.includes(t4) && !(u3 && r2.transcoderFormat.length < 2) && (!r2.needsPowerOfTwo || c(n2) && c(a5)))) return d4 = r2.transcoderFormat[u3 ? 1 : 0], h3 = r2.engineFormat[u3 ? 1 : 0], { transcoderFormat: d4, engineFormat: h3 };
                }
                return console.warn("v3d.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), d4 = r.RGBA32, h3 = o.RGBAFormat, { transcoderFormat: d4, engineFormat: h3 };
              }(d3, h2, f2, m2);
              if (!h2 || !f2 || !p2) throw u2(), new Error("v3d.KTX2Loader:    Invalid texture");
              if (!a4.startTranscoding()) throw u2(), new Error("v3d.KTX2Loader: .startTranscoding failed");
              const x = [];
              for (let e2 = 0; e2 < p2; e2++) {
                const t4 = a4.getImageLevelInfo(e2, 0, 0), n2 = t4.origWidth, o2 = t4.origHeight, r2 = new Uint8Array(a4.getImageTranscodedSizeInBytes(e2, 0, 0, A));
                if (!a4.transcodeImage(r2, e2, 0, 0, A, 0, -1, -1)) throw u2(), new Error("v3d.KTX2Loader: .transcodeImage failed.");
                x.push({ data: r2, width: n2, height: o2 });
              }
              return u2(), { width: h2, height: f2, hasAlpha: m2, mipmaps: x, format: v, dfdTransferFn: g2, dfdFlags: _ };
            }(u.buffers[0]), g = [];
            for (let e2 = 0; e2 < h.length; ++e2) g.push(h[e2].data.buffer);
            self.postMessage({ type: "transcode", id: u.id, width: t2, height: a3, hasAlpha: d2, mipmaps: h, format: f, dfdTransferFn: p, dfdFlags: m }, g);
          } catch (e2) {
            console.error(e2), self.postMessage({ type: "error", id: u.id, error: e2.message });
          }
        });
    }
    var d;
  });
  const a = [{ if: "astcSupported", basisFormat: [i.UASTC_4x4], transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4], engineFormat: [o.RGBA_ASTC_4x4_Format, o.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: false }, { if: "bptcSupported", basisFormat: [i.ETC1S, i.UASTC_4x4], transcoderFormat: [r.BC7_M5, r.BC7_M5], engineFormat: [o.RGBA_BPTC_Format, o.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: false }, { if: "dxtSupported", basisFormat: [i.ETC1S, i.UASTC_4x4], transcoderFormat: [r.BC1, r.BC3], engineFormat: [o.RGB_S3TC_DXT1_Format, o.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: false }, { if: "etc2Supported", basisFormat: [i.ETC1S, i.UASTC_4x4], transcoderFormat: [r.ETC1, r.ETC2], engineFormat: [o.RGB_ETC2_Format, o.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: false }, { if: "etc1Supported", basisFormat: [i.ETC1S, i.UASTC_4x4], transcoderFormat: [r.ETC1], engineFormat: [o.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: false }, { if: "pvrtcSupported", basisFormat: [i.ETC1S, i.UASTC_4x4], transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA], engineFormat: [o.RGB_PVRTC_4BPPV1_Format, o.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: true }], s = a.sort(function(e2, t2) {
    return e2.priorityETC1S - t2.priorityETC1S;
  }), l = a.sort(function(e2, t2) {
    return e2.priorityUASTC - t2.priorityUASTC;
  });
  function c(e2) {
    return e2 <= 2 || !(e2 & e2 - 1) && 0 !== e2;
  }
};
var LightProbeGenerator = class {
  static fromCubeTexture(e) {
    let t = 0;
    const n = new Vector3(), o = new Vector3(), r = new Color(), i = [0, 0, 0, 0, 0, 0, 0, 0, 0], a = new SphericalHarmonics3(), s = a.coefficients;
    for (let a2 = 0; a2 < 6; a2++) {
      const l2 = e.image[a2], c = l2.width, u = l2.height, d = document.createElement("canvas");
      d.width = c, d.height = u;
      const h = d.getContext("2d");
      h.drawImage(l2, 0, 0, c, u);
      const f = h.getImageData(0, 0, c, u), p = f.data, m = f.width, g = 2 / m;
      for (let l3 = 0, c2 = p.length; l3 < c2; l3 += 4) {
        r.setRGB(p[l3] / 255, p[l3 + 1] / 255, p[l3 + 2] / 255), convertColorToLinear(r, e.encoding);
        const c3 = l3 / 4, u2 = (c3 % m + 0.5) * g - 1, d2 = 1 - (Math.floor(c3 / m) + 0.5) * g;
        switch (a2) {
          case 0:
            n.set(-1, d2, -u2);
            break;
          case 1:
            n.set(1, d2, u2);
            break;
          case 2:
            n.set(-u2, 1, -d2);
            break;
          case 3:
            n.set(-u2, -1, d2);
            break;
          case 4:
            n.set(-u2, d2, 1);
            break;
          case 5:
            n.set(u2, d2, -1);
        }
        const h2 = n.lengthSq(), f2 = 4 / (Math.sqrt(h2) * h2);
        t += f2, o.copy(n).normalize(), SphericalHarmonics3.getBasisAt(o, i);
        for (let e2 = 0; e2 < 9; e2++) s[e2].x += i[e2] * r.r * f2, s[e2].y += i[e2] * r.g * f2, s[e2].z += i[e2] * r.b * f2;
      }
    }
    const l = 4 * Math.PI / t;
    for (let e2 = 0; e2 < 9; e2++) s[e2].x *= l, s[e2].y *= l, s[e2].z *= l;
    return new LightProbe(a);
  }
  static fromCubeRenderTarget(e, t) {
    let n = 0;
    const o = new Vector3(), r = new Vector3(), i = new Color(), a = [0, 0, 0, 0, 0, 0, 0, 0, 0], s = new SphericalHarmonics3(), l = s.coefficients, c = t.texture.type;
    for (let s2 = 0; s2 < 6; s2++) {
      const u2 = t.width, d = new (1016 === c ? Uint16Array : 1015 === c ? Float32Array : Uint8Array)(u2 * u2 * 4);
      e.readRenderTargetPixels(t, 0, 0, u2, u2, d, s2);
      const h = 2 / u2;
      for (let e2 = 0, f = d.length; e2 < f; e2 += 4) {
        1016 === c ? i.setRGB(fromHalfFloat(d[e2]), fromHalfFloat(d[e2 + 1]), fromHalfFloat(d[e2 + 2])) : 1015 === c ? i.setRGB(d[e2], d[e2 + 1], d[e2 + 2]) : i.setRGB(d[e2] / 255, d[e2 + 1] / 255, d[e2 + 2] / 255), convertColorToLinear(i, t.texture.encoding);
        const f2 = e2 / 4, p = (f2 % u2 + 0.5) * h - 1, m = 1 - (Math.floor(f2 / u2) + 0.5) * h;
        switch (s2) {
          case 0:
            o.set(1, m, -p);
            break;
          case 1:
            o.set(-1, m, p);
            break;
          case 2:
            o.set(p, 1, -m);
            break;
          case 3:
            o.set(p, -1, m);
            break;
          case 4:
            o.set(p, m, 1);
            break;
          case 5:
            o.set(-p, m, -1);
        }
        const g = o.lengthSq(), _ = 4 / (Math.sqrt(g) * g);
        n += _, r.copy(o).normalize(), SphericalHarmonics3.getBasisAt(r, a);
        for (let e3 = 0; e3 < 9; e3++) l[e3].x += a[e3] * i.r * _, l[e3].y += a[e3] * i.g * _, l[e3].z += a[e3] * i.b * _;
      }
    }
    const u = 4 * Math.PI / n;
    for (let e2 = 0; e2 < 9; e2++) l[e2].x *= u, l[e2].y *= u, l[e2].z *= u;
    return new LightProbe(s);
  }
};
function convertColorToLinear(e, t) {
  switch (t) {
    case 3001:
      e.convertSRGBToLinear();
      break;
    case 3e3:
      break;
    default:
      console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.");
  }
  return e;
}
var RectAreaLightHelper = class extends Line {
  constructor(e, t) {
    const n = new BufferGeometry();
    n.setAttribute("position", new Float32BufferAttribute([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), n.computeBoundingSphere();
    super(n, new LineBasicMaterial({ fog: false })), this.light = e, this.color = t, this.type = "RectAreaLightHelper";
    const o = new BufferGeometry();
    o.setAttribute("position", new Float32BufferAttribute([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), o.computeBoundingSphere(), this.add(new Mesh(o, new MeshBasicMaterial({ side: 1, fog: false })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const e = this.material.color, t = Math.max(e.r, e.g, e.b);
      t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
};
var Stats = function() {
  var e = 0, t = document.createElement("div");
  function n(e2) {
    return t.appendChild(e2.dom), e2;
  }
  function o(n2) {
    for (var o2 = 0; o2 < t.children.length; o2++) t.children[o2].style.display = o2 === n2 ? "block" : "none";
    e = n2;
  }
  t.style.cssText = "position:absolute;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", t.addEventListener("click", function(n2) {
    n2.preventDefault(), o(++e % t.children.length);
  }, false);
  var r = (performance || Date).now(), i = r, a = 0, s = n(new Stats.Panel("FPS", "#0ff", "#002")), l = n(new Stats.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) var c = n(new Stats.Panel("MB", "#f08", "#201"));
  return o(0), { REVISION: 16, dom: t, addPanel: n, showPanel: o, begin: function() {
    r = (performance || Date).now();
  }, end: function() {
    a++;
    var e2 = (performance || Date).now();
    if (l.update(e2 - r, 200), e2 >= i + 1e3 && (s.update(1e3 * a / (e2 - i), 100), i = e2, a = 0, c)) {
      var t2 = performance.memory;
      c.update(t2.usedJSHeapSize / 1048576, t2.jsHeapSizeLimit / 1048576);
    }
    return e2;
  }, update: function() {
    r = this.end();
  }, domElement: t, setMode: o };
};
Stats.Panel = function(e, t, n) {
  var o = 1 / 0, r = 0, i = Math.round, a = i(window.devicePixelRatio || 1), s = 80 * a, l = 48 * a, c = 3 * a, u = 2 * a, d = 3 * a, h = 15 * a, f = 74 * a, p = 30 * a, m = document.createElement("canvas");
  m.width = s, m.height = l, m.style.cssText = "width:80px;height:48px";
  var g = m.getContext("2d");
  return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, s, l), g.fillStyle = t, g.fillText(e, c, u), g.fillRect(d, h, f, p), g.fillStyle = n, g.globalAlpha = 0.9, g.fillRect(d, h, f, p), { dom: m, update: function(l2, _) {
    o = Math.min(o, l2), r = Math.max(r, l2), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, s, h), g.fillStyle = t, g.fillText(i(l2) + " " + e + " (" + i(o) + "-" + i(r) + ")", c, u), g.drawImage(m, d + a, h, f - a, p, d, h, f - a, p), g.fillRect(d + f - a, h, a, p), g.fillStyle = n, g.globalAlpha = 0.9, g.fillRect(d + f - a, h, a, i((1 - l2 / _) * p));
  } };
};
var _v1 = new Vector3();
var _v2 = new Vector3();
var VertexNormalsHelper = class extends LineSegments {
  constructor(e, t = 1, n = 16711680) {
    var _a2;
    const o = new BufferGeometry(), r = (_a2 = e.geometry) == null ? void 0 : _a2.attributes.normal;
    if (r) {
      const t2 = e.geometry.attributes.normal.count, n2 = new Float32BufferAttribute(2 * t2 * 3, 3);
      o.setAttribute("position", n2);
    }
    super(o, new LineBasicMaterial({ color: n, toneMapped: false })), this.object = e, this.size = t, this.type = "VertexNormalsHelper", this.matrixAutoUpdate = false, this.update();
  }
  update() {
    var _a2, _b;
    const e = this.geometry.attributes.position, t = (_a2 = this.object.geometry) == null ? void 0 : _a2.attributes.position, n = (_b = this.object.geometry) == null ? void 0 : _b.attributes.normal;
    if (e && t && n) {
      let o = 0;
      for (let r = 0, i = t.count; r < i; r++) _v1.fromBufferAttribute(t, r), _v2.fromBufferAttribute(n, r), _v2.normalize().multiplyScalar(this.size).add(_v1), e.setXYZ(o, _v1.x, _v1.y, _v1.z), o += 1, e.setXYZ(o, _v2.x, _v2.y, _v2.z), o += 1;
      e.needsUpdate = true;
    }
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var WireframeHelper = class extends LineSegments {
  constructor(e, t = "white") {
    super(new WireframeGeometry(e.geometry), new LineBasicMaterial({ color: t })), this.type = "WireframeHelper", this.matrixAutoUpdate = false;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var VRReticleImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIQXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHja7ZhZltw2DEX/uYosQSQ4LofjOdlBlp8LSqquHt12nD+X3JIKYpEg3sMDZDP/+XuZv/iIOGd8SDmWGA8+vvjiKjf5OD91n+3h93l//PWI76/s5vHAYRKucn7N8bJP7I7x7rL3a56KPTxNVOb1oL1+UK+JXL4WuOz3QmLPBY5rYlOvicRdK18utnNbRyw5PW+hX+PX9XyHgT+jJy/JxRBt8py9O1KKhfvsDp+I21BHV3dFfxfaNdGb7+Ye6vDJTbFycM7qoeC+FKmi93rGaSzCvUjY53J6ClrOHIn7csf1689Xnpvb9QvyV5A+7uwn9iekzQ7o/UDeIBQf1w/tNrzYzTOkG7enlWN8rPzKnufRXu35Rk3/1hp5rXnurvrIluO1qXsr+45xTaO1fxU5En/hyBpsPQpHJiU6PBqQrHF0W6wDxmW9HbbaZee+dttx0bvpElfnuhPbDcYMGMX1DbfXwy6XAH5IBvgOHQSre/hi97JlL9dtZuFhs4E9lsksP/lPh/nOoLU0oaw98iNW+OU00/BCkbPWHJZhIGLXFdSwA3wfbz+Kq4Bg2GHObLAeTWcA/hbsC7lkAy0MDFzPBLZpXBMQIjwIOGMFBI5oJdhoj4SwJWsJZAagiutOvGvAYkNwAyedF4mAQxawNr9Jdg91wZ1mhBAggkQjCWxITcDyPsCf5DMcqkGCDyHEkEIOJdQoUTMsxhRVUWuS5FNIMaWUU0nVZMk+hxxzyjmXXIsrguKGQj6WXEqplUUrM1d+XRlQa3NNmm+hxZZabqXV7kyX7nvosaeee+l1uCGDPB5xpJFHGXXaCZWmn2HGmWaeZdYF1ZYsv8KKK628iln1gdoF67vjJ1CzF2puI6UD0wM1rCndU1iVk6CYgZjzFsCTImDFOKeYHdl67xQ5xewoTkXQ4WRQcIZVxEDQT+vCsg/sXpALRuLvwc0AhPsdyBmF7hvIvcftI9RG3YVONkKahhrUQ8i+VdbM1eWqlfLLq/nRgO9e/0z0Z6LfNtEKlJIcBGEJdi4Y3YtQv/vMn9hbb2uO2qngQp1HkExeIqtF6sbqOjSLnimwjeScNfUo89iTZO/b7GHNot9iXc1v+ypRmpg4x9DZbZ/owSyht5CoP3X52YZQTUprFa0ItmIdx22xPvAvogdcVPyXdoNjrZpJ4+lZTtdDaj62hxnWigOhXduzQx+mQvaPZrNbk99ZfVDsDIMlgtBQLro75kMVI3Xb63P8HRXr6s2O0hI7YuI8TZLWlq8z1NZmxkfWRLdoCMcQIVAj5kCbeFkOhcg11PO8o7M6r+Z4Y/iJq4KdFVJt3w261qI9nXagWtvw6cKp96g4ZMIw/NZERidb2NYSDUzpabXiF3EzpaKqdZNqZSuTXqnN0CtBntdNmZYJStprx7kgxZCka/XWsc9qwzRVdkRnFEWjy8mRQDknXhkExoYgj6QNm96PWsKsM8EoejmdKOblTRMIQOt3ucsgJUigEUldCH5vJRCMcd1I1wWdMmKMNfyqcepalKOCefgzY9iGzOJ/Jd3Mhw9aLbrhTCyntQ44IOYBgdocpAPBbbGP1siF1bRxHYNyFKjJcD0EaAQs0EU0zcCEBBDNiuQn3CFPANTv3epZWd+CRs2zU7Og7coEZKcArFQGA8BOU5faUL/I3J0OuVAw2xqHzAHbywZiudFiNEM9XIMa3edcw7USP5WUzT5RLsA6JZ9SD/K07JoZAFUiPmdQak0CPlGYa/MptVDJT20yYguxkIT0DXQKexSrkjpz8QhlimYmdYF13enoS7Lj9CkCxcXzCa7Esl8AQBq6rDabFASNxDfMWcgaRzTRgIFeBRmje5n4GAJmnGIHE2qUtOBqhOpzOhnrHtCJiJnTPoAA9FmVwgzCETw7yqmHPwbBfIbCOxC6jSogCHVjYzWhLEk1KTQonoYhUIEbIQd4p42Wliu5ngJtT8Le6LXS6CdV5xIA+p3l6GY+dKCrHMp8mK0bSBPGK/WJ/d4U1PdiM3WhDiU9dQCRH6o4sxerpKcUyJGASZrjLVvTQ/XiJ0sAAj9ayPYW+8IbpLzW/3KkLUIvEnQKEG6FLW3OF3aksFMFtoZp+I0+giNUtd4xUutm3LTnZxLXmFQ5el3WkFEIPtPMorRGG2sfslIJ8NIaqxnbBKp7ckpOgDThLLn1kBGbnmRkvcgIlH+WkbLIoOC1LCAksc5RuviYqfE0yZeFd/2vomk+DSfceh1PLZ5k35uI3vXUvC+oKlTrUVBJ56eSyhJ5flhTzS8U1Q+v5ptF9aXK7ZuWNaXDJshY1S4xofutu27qtutxVSPSrffPqhGj39Ujan+5K9IXxXq+FPp3UhsAdw3TwQG5G3aWmEBohrt4qthpkCbBz4ntlcQXXreum5R1sbAXHs2QldBo9LOroE+gIaj52mBwabjzC2+lX17NjwbodeuhtFsPof1Q0UMOyTI0EO45g2lqG8k2i809EsB4quEkUrK1cKgW8mZb+UkcIAdcUXKyI9scHR1MY6I3jzUIZ2ODum6EgoaiEIrp9/YJmYP0QbMBnHLaCW2meqzsfm6AyYtX7S+id3W/vKle3e/OPRojdI/oDyOdRFVlrAORRx/igFKtQDte/oV654VGuvIKzMM2eCFuVB4SbD3CppXcXFE7i8guPY8i0l5XcpVqGsNjp1bjzGyCNLRgySyT5TY9R2fu2joo2cRhR6bsdCYa8P8MEJnzEqJpHiH6KEA6wXcCRHzMrwRovzykVEY/b/U/r81981+vfyb6M9H/MBF5RKaafwEjmLcIrlR0mgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+MCAwojJyJFeN4AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAd0lEQVR42u3YUQqAIBAFwLUDdf9zdCH7lwwEI2VnPkWQfWCvigAAAAAAgDTK1wecNWq7dpX+uaP7lw7gaZi3oUb3z3BkvwICEIAW+KcFRte3DWBGO7gCAhCAAHZ9FY6IpC3QG963gGeAAASgBRb6IwQAAAAAQCY34QUtIL9dJTwAAAAASUVORK5CYII=";
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = Symbol("SKIP_GENERATION");
function getVertexCount(e) {
  return e.index ? e.index.count : e.attributes.position.count;
}
function getTriCount(e) {
  return getVertexCount(e) / 3;
}
function getIndexArray(e, t = ArrayBuffer) {
  return e > 65535 ? new Uint32Array(new t(4 * e)) : new Uint16Array(new t(2 * e));
}
function ensureIndex(e, t) {
  if (!e.index) {
    const n = e.attributes.position.count, o = getIndexArray(n, t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
    e.setIndex(new BufferAttribute(o, 1));
    for (let e2 = 0; e2 < n; e2++) o[e2] = e2;
  }
}
function getFullGeometryRange(e, t) {
  const n = getTriCount(e), o = t || e.drawRange, r = o.start / 3, i = (o.start + o.count) / 3, a = Math.max(0, r), s = Math.min(n, i) - a;
  return [{ offset: Math.floor(a), count: Math.floor(s) }];
}
function getRootIndexRanges(e, t) {
  if (!e.groups || !e.groups.length) return getFullGeometryRange(e, t);
  const n = [], o = /* @__PURE__ */ new Set(), r = t || e.drawRange, i = r.start / 3, a = (r.start + r.count) / 3;
  for (const t2 of e.groups) {
    const e2 = t2.start / 3, n2 = (t2.start + t2.count) / 3;
    o.add(Math.max(i, e2)), o.add(Math.min(a, n2));
  }
  const s = Array.from(o.values()).sort((e2, t2) => e2 - t2);
  for (let e2 = 0; e2 < s.length - 1; e2++) {
    const t2 = s[e2], o2 = s[e2 + 1];
    n.push({ offset: Math.floor(t2), count: Math.floor(o2 - t2) });
  }
  return n;
}
function hasGroupGaps(e, t) {
  const n = getTriCount(e), o = getRootIndexRanges(e, t).sort((e2, t2) => e2.offset - t2.offset), r = o[o.length - 1];
  r.count = Math.min(n - r.offset, r.count);
  let i = 0;
  return o.forEach(({ count: e2 }) => i += e2), n !== i;
}
function getBounds(e, t, n, o, r) {
  let i = 1 / 0, a = 1 / 0, s = 1 / 0, l = -1 / 0, c = -1 / 0, u = -1 / 0, d = 1 / 0, h = 1 / 0, f = 1 / 0, p = -1 / 0, m = -1 / 0, g = -1 / 0;
  for (let o2 = 6 * t, r2 = 6 * (t + n); o2 < r2; o2 += 6) {
    const t2 = e[o2 + 0], n2 = e[o2 + 1], r3 = t2 - n2, _ = t2 + n2;
    r3 < i && (i = r3), _ > l && (l = _), t2 < d && (d = t2), t2 > p && (p = t2);
    const A = e[o2 + 2], v = e[o2 + 3], x = A - v, y = A + v;
    x < a && (a = x), y > c && (c = y), A < h && (h = A), A > m && (m = A);
    const b = e[o2 + 4], C = e[o2 + 5], S = b - C, M = b + C;
    S < s && (s = S), M > u && (u = M), b < f && (f = b), b > g && (g = b);
  }
  o[0] = i, o[1] = a, o[2] = s, o[3] = l, o[4] = c, o[5] = u, r[0] = d, r[1] = h, r[2] = f, r[3] = p, r[4] = m, r[5] = g;
}
function computeTriangleBounds(e, t = null, n = null, o = null) {
  const r = e.attributes.position, i = e.index ? e.index.array : null, a = getTriCount(e), s = r.normalized;
  let l;
  null === t ? (l = new Float32Array(6 * a), n = 0, o = a) : (l = t, n = n || 0, o = o || a);
  const c = r.array, u = r.offset || 0;
  let d = 3;
  r.isInterleavedBufferAttribute && (d = r.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let e2 = n; e2 < n + o; e2++) {
    const t2 = 3 * e2, n2 = 6 * e2;
    let o2 = t2 + 0, a2 = t2 + 1, f = t2 + 2;
    i && (o2 = i[o2], a2 = i[a2], f = i[f]), s || (o2 = o2 * d + u, a2 = a2 * d + u, f = f * d + u);
    for (let e3 = 0; e3 < 3; e3++) {
      let t3, i2, u2;
      s ? (t3 = r[h[e3]](o2), i2 = r[h[e3]](a2), u2 = r[h[e3]](f)) : (t3 = c[o2 + e3], i2 = c[a2 + e3], u2 = c[f + e3]);
      let d2 = t3;
      i2 < d2 && (d2 = i2), u2 < d2 && (d2 = u2);
      let p = t3;
      i2 > p && (p = i2), u2 > p && (p = u2);
      const m = (p - d2) / 2, g = 2 * e3;
      l[n2 + g + 0] = d2 + m, l[n2 + g + 1] = m + (Math.abs(d2) + m) * FLOAT32_EPSILON;
    }
  }
  return l;
}
function arrayToBox(e, t, n) {
  return n.min.x = t[e], n.min.y = t[e + 1], n.min.z = t[e + 2], n.max.x = t[e + 3], n.max.y = t[e + 4], n.max.z = t[e + 5], n;
}
function getLongestEdgeIndex(e) {
  let t = -1, n = -1 / 0;
  for (let o = 0; o < 3; o++) {
    const r = e[o + 3] - e[o];
    r > n && (n = r, t = o);
  }
  return t;
}
function copyBounds(e, t) {
  t.set(e);
}
function unionBounds(e, t, n) {
  let o, r;
  for (let i = 0; i < 3; i++) {
    const a = i + 3;
    o = e[i], r = t[i], n[i] = o < r ? o : r, o = e[a], r = t[a], n[a] = o > r ? o : r;
  }
}
function expandByTriangleBounds(e, t, n) {
  for (let o = 0; o < 3; o++) {
    const r = t[e + 2 * o], i = t[e + 2 * o + 1], a = r - i, s = r + i;
    a < n[o] && (n[o] = a), s > n[o + 3] && (n[o + 3] = s);
  }
}
function computeSurfaceArea(e) {
  const t = e[3] - e[0], n = e[4] - e[1], o = e[5] - e[2];
  return 2 * (t * n + n * o + o * t);
}
var binsSort = (e, t) => e.candidate - t.candidate;
var sahBins = new Array(32).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 }));
var leftBounds = new Float32Array(6);
function getOptimalSplit(e, t, n, o, r, i) {
  let a = -1, s = 0;
  if (0 === i) a = getLongestEdgeIndex(t), -1 !== a && (s = (t[a] + t[a + 3]) / 2);
  else if (1 === i) a = getLongestEdgeIndex(e), -1 !== a && (s = getAverage(n, o, r, a));
  else if (2 === i) {
    const i2 = computeSurfaceArea(e);
    let l = 1.25 * r;
    const c = 6 * o, u = 6 * (o + r);
    for (let e2 = 0; e2 < 3; e2++) {
      const o2 = t[e2], d = (t[e2 + 3] - o2) / 32;
      if (r < 8) {
        const t2 = [...sahBins];
        t2.length = r;
        let o3 = 0;
        for (let r2 = c; r2 < u; r2 += 6, o3++) {
          const i3 = t2[o3];
          i3.candidate = n[r2 + 2 * e2], i3.count = 0;
          const { bounds: a2, leftCacheBounds: s2, rightCacheBounds: l2 } = i3;
          for (let e3 = 0; e3 < 3; e3++) l2[e3] = 1 / 0, l2[e3 + 3] = -1 / 0, s2[e3] = 1 / 0, s2[e3 + 3] = -1 / 0, a2[e3] = 1 / 0, a2[e3 + 3] = -1 / 0;
          expandByTriangleBounds(r2, n, a2);
        }
        t2.sort(binsSort);
        let d2 = r;
        for (let e3 = 0; e3 < d2; e3++) {
          const n2 = t2[e3];
          for (; e3 + 1 < d2 && t2[e3 + 1].candidate === n2.candidate; ) t2.splice(e3 + 1, 1), d2--;
        }
        for (let o4 = c; o4 < u; o4 += 6) {
          const r2 = n[o4 + 2 * e2];
          for (let e3 = 0; e3 < d2; e3++) {
            const i3 = t2[e3];
            r2 >= i3.candidate ? expandByTriangleBounds(o4, n, i3.rightCacheBounds) : (expandByTriangleBounds(o4, n, i3.leftCacheBounds), i3.count++);
          }
        }
        for (let n2 = 0; n2 < d2; n2++) {
          const o4 = t2[n2], c2 = o4.count, u2 = r - o4.count, d3 = o4.leftCacheBounds, h = o4.rightCacheBounds;
          let f = 0;
          0 !== c2 && (f = computeSurfaceArea(d3) / i2);
          let p = 0;
          0 !== u2 && (p = computeSurfaceArea(h) / i2);
          const m = 1 + 1.25 * (f * c2 + p * u2);
          m < l && (a = e2, l = m, s = o4.candidate);
        }
      } else {
        for (let e3 = 0; e3 < 32; e3++) {
          const t3 = sahBins[e3];
          t3.count = 0, t3.candidate = o2 + d + e3 * d;
          const n2 = t3.bounds;
          for (let e4 = 0; e4 < 3; e4++) n2[e4] = 1 / 0, n2[e4 + 3] = -1 / 0;
        }
        for (let t3 = c; t3 < u; t3 += 6) {
          let r2 = ~~((n[t3 + 2 * e2] - o2) / d);
          r2 >= 32 && (r2 = 31);
          const i3 = sahBins[r2];
          i3.count++, expandByTriangleBounds(t3, n, i3.bounds);
        }
        const t2 = sahBins[31];
        copyBounds(t2.bounds, t2.rightCacheBounds);
        for (let e3 = 30; e3 >= 0; e3--) {
          const t3 = sahBins[e3], n2 = sahBins[e3 + 1];
          unionBounds(t3.bounds, n2.rightCacheBounds, t3.rightCacheBounds);
        }
        let h = 0;
        for (let t3 = 0; t3 < 31; t3++) {
          const n2 = sahBins[t3], o3 = n2.count, c2 = n2.bounds, u2 = sahBins[t3 + 1].rightCacheBounds;
          0 !== o3 && (0 === h ? copyBounds(c2, leftBounds) : unionBounds(c2, leftBounds, leftBounds)), h += o3;
          let d2 = 0, f = 0;
          0 !== h && (d2 = computeSurfaceArea(leftBounds) / i2);
          const p = r - h;
          0 !== p && (f = computeSurfaceArea(u2) / i2);
          const m = 1 + 1.25 * (d2 * h + f * p);
          m < l && (a = e2, l = m, s = n2.candidate);
        }
      }
    }
  } else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);
  return { axis: a, pos: s };
}
function getAverage(e, t, n, o) {
  let r = 0;
  for (let i = t, a = t + n; i < a; i++) r += e[6 * i + 2 * o];
  return r / n;
}
var MeshBVHNode = class {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
};
function partition(e, t, n, o, r, i) {
  let a = o, s = o + r - 1;
  const l = i.pos, c = 2 * i.axis;
  for (; ; ) {
    for (; a <= s && n[6 * a + c] < l; ) a++;
    for (; a <= s && n[6 * s + c] >= l; ) s--;
    if (!(a < s)) return a;
    for (let e2 = 0; e2 < 3; e2++) {
      let n2 = t[3 * a + e2];
      t[3 * a + e2] = t[3 * s + e2], t[3 * s + e2] = n2;
    }
    for (let e2 = 0; e2 < 6; e2++) {
      let t2 = n[6 * a + e2];
      n[6 * a + e2] = n[6 * s + e2], n[6 * s + e2] = t2;
    }
    a++, s--;
  }
}
function partition_indirect(e, t, n, o, r, i) {
  let a = o, s = o + r - 1;
  const l = i.pos, c = 2 * i.axis;
  for (; ; ) {
    for (; a <= s && n[6 * a + c] < l; ) a++;
    for (; a <= s && n[6 * s + c] >= l; ) s--;
    if (!(a < s)) return a;
    {
      let t2 = e[a];
      e[a] = e[s], e[s] = t2;
      for (let e2 = 0; e2 < 6; e2++) {
        let t3 = n[6 * a + e2];
        n[6 * a + e2] = n[6 * s + e2], n[6 * s + e2] = t3;
      }
      a++, s--;
    }
  }
}
function IS_LEAF(e, t) {
  return 65535 === t[e + 15];
}
function OFFSET(e, t) {
  return t[e + 6];
}
function COUNT(e, t) {
  return t[e + 14];
}
function LEFT_NODE(e) {
  return e + 8;
}
function RIGHT_NODE(e, t) {
  return t[e + 6];
}
function SPLIT_AXIS(e, t) {
  return t[e + 7];
}
function BOUNDING_DATA_INDEX(e) {
  return e;
}
var float32Array;
var uint32Array;
var uint16Array;
var uint8Array;
var MAX_POINTER = Math.pow(2, 32);
function countNodes(e) {
  return "count" in e ? 1 : 1 + countNodes(e.left) + countNodes(e.right);
}
function populateBuffer(e, t, n) {
  return float32Array = new Float32Array(n), uint32Array = new Uint32Array(n), uint16Array = new Uint16Array(n), uint8Array = new Uint8Array(n), _populateBuffer(e, t);
}
function _populateBuffer(e, t) {
  const n = e / 4, o = e / 2, r = "count" in t, i = t.boundingData;
  for (let e2 = 0; e2 < 6; e2++) float32Array[n + e2] = i[e2];
  if (r) {
    if (t.buffer) {
      const o2 = t.buffer;
      uint8Array.set(new Uint8Array(o2), e);
      for (let t2 = e, r2 = e + o2.byteLength; t2 < r2; t2 += 32) {
        IS_LEAF(t2 / 2, uint16Array) || (uint32Array[t2 / 4 + 6] += n);
      }
      return e + o2.byteLength;
    }
    {
      const r2 = t.offset, i2 = t.count;
      return uint32Array[n + 6] = r2, uint16Array[o + 14] = i2, uint16Array[o + 15] = 65535, e + 32;
    }
  }
  {
    const o2 = t.left, r2 = t.right, i2 = t.splitAxis;
    let a;
    if (a = _populateBuffer(e + 32, o2), a / 4 > MAX_POINTER) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    return uint32Array[n + 6] = a / 4, a = _populateBuffer(a, r2), uint32Array[n + 7] = i2, a;
  }
}
function generateIndirectBuffer(e, t) {
  const n = (e.index ? e.index.count : e.attributes.position.count) / 3, o = n > 65536, r = o ? 4 : 2, i = t ? new SharedArrayBuffer(n * r) : new ArrayBuffer(n * r), a = o ? new Uint32Array(i) : new Uint16Array(i);
  for (let e2 = 0, t2 = a.length; e2 < t2; e2++) a[e2] = e2;
  return a;
}
function buildTree(e, t, n, o, r) {
  const { maxDepth: i, verbose: a, maxLeafTris: s, strategy: l, onProgress: c, indirect: u } = r, d = e._indirectBuffer, h = e.geometry, f = h.index ? h.index.array : null, p = u ? partition_indirect : partition, m = getTriCount(h), g = new Float32Array(6);
  let _ = false;
  const A = new MeshBVHNode();
  return getBounds(t, n, o, A.boundingData, g), function e2(n2, o2, r2, c2 = null, u2 = 0) {
    !_ && u2 >= i && (_ = true, a && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(h)));
    if (r2 <= s || u2 >= i) return v(o2 + r2), n2.offset = o2, n2.count = r2, n2;
    const m2 = getOptimalSplit(n2.boundingData, c2, t, o2, r2, l);
    if (-1 === m2.axis) return v(o2 + r2), n2.offset = o2, n2.count = r2, n2;
    const A2 = p(d, f, t, o2, r2, m2);
    if (A2 === o2 || A2 === o2 + r2) v(o2 + r2), n2.offset = o2, n2.count = r2;
    else {
      n2.splitAxis = m2.axis;
      const i2 = new MeshBVHNode(), a2 = o2, s2 = A2 - o2;
      n2.left = i2, getBounds(t, a2, s2, i2.boundingData, g), e2(i2, a2, s2, g, u2 + 1);
      const l2 = new MeshBVHNode(), c3 = A2, d2 = r2 - s2;
      n2.right = l2, getBounds(t, c3, d2, l2.boundingData, g), e2(l2, c3, d2, g, u2 + 1);
    }
    return n2;
  }(A, n, o, g), A;
  function v(e2) {
    c && c(e2 / m);
  }
}
function buildPackedTree(e, t) {
  const n = e.geometry;
  t.indirect && (e._indirectBuffer = generateIndirectBuffer(n, t.useSharedArrayBuffer), hasGroupGaps(n, t.range) && !t.verbose && console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), e._indirectBuffer || ensureIndex(n, t);
  const o = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, r = computeTriangleBounds(n), i = t.indirect ? getFullGeometryRange(n, t.range) : getRootIndexRanges(n, t.range);
  e._roots = i.map((n2) => {
    const i2 = buildTree(e, r, n2.offset, n2.count, t), a = countNodes(i2), s = new o(32 * a);
    return populateBuffer(0, i2, s), s;
  });
}
var SeparatingAxisBounds = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(e, t) {
    let n = 1 / 0, o = -1 / 0;
    for (let r = 0, i = e.length; r < i; r++) {
      const i2 = e[r][t];
      n = i2 < n ? i2 : n, o = i2 > o ? i2 : o;
    }
    this.min = n, this.max = o;
  }
  setFromPoints(e, t) {
    let n = 1 / 0, o = -1 / 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const i2 = t[r], a = e.dot(i2);
      n = a < n ? a : n, o = a > o ? a : o;
    }
    this.min = n, this.max = o;
  }
  isSeparated(e) {
    return this.min > e.max || e.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const e = new Vector3();
  return function(t, n) {
    const o = n.min, r = n.max;
    let i = 1 / 0, a = -1 / 0;
    for (let n2 = 0; n2 <= 1; n2++) for (let s = 0; s <= 1; s++) for (let l = 0; l <= 1; l++) {
      e.x = o.x * n2 + r.x * (1 - n2), e.y = o.y * s + r.y * (1 - s), e.z = o.z * l + r.z * (1 - l);
      const c = t.dot(e);
      i = Math.min(c, i), a = Math.max(c, a);
    }
    this.min = i, this.max = a;
  };
}();
var closestPointLineToLine = function() {
  const e = new Vector3(), t = new Vector3(), n = new Vector3();
  return function(o, r, i) {
    const a = o.start, s = e, l = r.start, c = t;
    n.subVectors(a, l), e.subVectors(o.end, o.start), t.subVectors(r.end, r.start);
    const u = n.dot(c), d = c.dot(s), h = c.dot(c), f = n.dot(s), p = s.dot(s) * h - d * d;
    let m, g;
    m = 0 !== p ? (u * d - f * h) / p : 0, g = (u + m * d) / h, i.x = m, i.y = g;
  };
}();
var closestPointsSegmentToSegment = function() {
  const e = new Vector2(), t = new Vector3(), n = new Vector3();
  return function(o, r, i, a) {
    closestPointLineToLine(o, r, e);
    let s = e.x, l = e.y;
    if (s >= 0 && s <= 1 && l >= 0 && l <= 1) return o.at(s, i), void r.at(l, a);
    if (s >= 0 && s <= 1) return l < 0 ? r.at(0, a) : r.at(1, a), void o.closestPointToPoint(a, true, i);
    if (l >= 0 && l <= 1) return s < 0 ? o.at(0, i) : o.at(1, i), void r.closestPointToPoint(i, true, a);
    {
      let e2, c;
      e2 = s < 0 ? o.start : o.end, c = l < 0 ? r.start : r.end;
      const u = t, d = n;
      return o.closestPointToPoint(c, true, t), r.closestPointToPoint(e2, true, n), u.distanceToSquared(c) <= d.distanceToSquared(e2) ? (i.copy(u), void a.copy(c)) : (i.copy(e2), void a.copy(d));
    }
  };
}();
var sphereIntersectTriangle = function() {
  const e = new Vector3(), t = new Vector3(), n = new Plane(), o = new Line3();
  return function(r, i) {
    const { radius: a, center: s } = r, { a: l, b: c, c: u } = i;
    o.start = l, o.end = c;
    if (o.closestPointToPoint(s, true, e).distanceTo(s) <= a) return true;
    o.start = l, o.end = u;
    if (o.closestPointToPoint(s, true, e).distanceTo(s) <= a) return true;
    o.start = c, o.end = u;
    if (o.closestPointToPoint(s, true, e).distanceTo(s) <= a) return true;
    const d = i.getPlane(n);
    if (Math.abs(d.distanceToPoint(s)) <= a) {
      const e2 = d.projectPoint(s, t);
      if (i.containsPoint(e2)) return true;
    }
    return false;
  };
}();
function isNearZero(e) {
  return Math.abs(e) < 1e-15;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...e) {
    super(...e), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(e) {
    return sphereIntersectTriangle(e, this);
  }
  update() {
    const e = this.a, t = this.b, n = this.c, o = this.points, r = this.satAxes, i = this.satBounds, a = r[0], s = i[0];
    this.getNormal(a), s.setFromPoints(a, o);
    const l = r[1], c = i[1];
    l.subVectors(e, t), c.setFromPoints(l, o);
    const u = r[2], d = i[2];
    u.subVectors(t, n), d.setFromPoints(u, o);
    const h = r[3], f = i[3];
    h.subVectors(n, e), f.setFromPoints(h, o), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(a, e), this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const e = new Vector3(), t = new Vector3(), n = new Line3();
  return function(o, r = null, i = null) {
    const { start: a, end: s } = o, l = this.points;
    let c, u = 1 / 0;
    for (let a2 = 0; a2 < 3; a2++) {
      const s2 = (a2 + 1) % 3;
      n.start.copy(l[a2]), n.end.copy(l[s2]), closestPointsSegmentToSegment(n, o, e, t), c = e.distanceToSquared(t), c < u && (u = c, r && r.copy(e), i && i.copy(t));
    }
    return this.closestPointToPoint(a, e), c = a.distanceToSquared(e), c < u && (u = c, r && r.copy(e), i && i.copy(a)), this.closestPointToPoint(s, e), c = s.distanceToSquared(e), c < u && (u = c, r && r.copy(e), i && i.copy(s)), Math.sqrt(u);
  };
}(), ExtendedTriangle.prototype.intersectsTriangle = function() {
  const e = new ExtendedTriangle(), t = new Array(3), n = new Array(3), o = new SeparatingAxisBounds(), r = new SeparatingAxisBounds(), i = new Vector3(), a = new Vector3(), s = new Vector3(), l = new Vector3(), c = new Vector3(), u = new Line3(), d = new Line3(), h = new Line3(), f = new Vector3();
  function p(e2, t2, n2) {
    const o2 = e2.points;
    let r2 = 0, i2 = -1;
    for (let e3 = 0; e3 < 3; e3++) {
      const { start: s2, end: l2 } = u;
      s2.copy(o2[e3]), l2.copy(o2[(e3 + 1) % 3]), u.delta(a);
      const c2 = isNearZero(t2.distanceToPoint(s2));
      if (isNearZero(t2.normal.dot(a)) && c2) {
        n2.copy(u), r2 = 2;
        break;
      }
      const d2 = t2.intersectLine(u, f);
      if (!d2 && c2 && f.copy(s2), (d2 || c2) && !isNearZero(f.distanceTo(l2))) {
        if (r2 <= 1) {
          (1 === r2 ? n2.start : n2.end).copy(f), c2 && (i2 = r2);
        } else if (r2 >= 2) {
          (1 === i2 ? n2.start : n2.end).copy(f), r2 = 2;
          break;
        }
        if (r2++, 2 === r2 && -1 === i2) break;
      }
    }
    return r2;
  }
  return function(a2, u2 = null, f2 = false) {
    this.needsUpdate && this.update(), a2.isExtendedTriangle ? a2.needsUpdate && a2.update() : (e.copy(a2), e.update(), a2 = e);
    const m = this.plane, g = a2.plane;
    if (Math.abs(m.normal.dot(g.normal)) > 1 - 1e-10) {
      const e2 = this.satBounds, s2 = this.satAxes;
      n[0] = a2.a, n[1] = a2.b, n[2] = a2.c;
      for (let t2 = 0; t2 < 4; t2++) {
        const r2 = e2[t2], i2 = s2[t2];
        if (o.setFromPoints(i2, n), r2.isSeparated(o)) return false;
      }
      const l2 = a2.satBounds, c2 = a2.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let e3 = 0; e3 < 4; e3++) {
        const n2 = l2[e3], r2 = c2[e3];
        if (o.setFromPoints(r2, t), n2.isSeparated(o)) return false;
      }
      for (let e3 = 0; e3 < 4; e3++) {
        const a3 = s2[e3];
        for (let e4 = 0; e4 < 4; e4++) {
          const s3 = c2[e4];
          if (i.crossVectors(a3, s3), o.setFromPoints(i, t), r.setFromPoints(i, n), o.isSeparated(r)) return false;
        }
      }
      return u2 && (f2 || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), u2.start.set(0, 0, 0), u2.end.set(0, 0, 0)), true;
    }
    {
      const e2 = p(this, g, d);
      if (1 === e2 && a2.containsPoint(d.end)) return u2 && (u2.start.copy(d.end), u2.end.copy(d.end)), true;
      if (2 !== e2) return false;
      const t2 = p(a2, m, h);
      if (1 === t2 && this.containsPoint(h.end)) return u2 && (u2.start.copy(h.end), u2.end.copy(h.end)), true;
      if (2 !== t2) return false;
      if (d.delta(s), h.delta(l), s.dot(l) < 0) {
        let e3 = h.start;
        h.start = h.end, h.end = e3;
      }
      const n2 = d.start.dot(s), o2 = d.end.dot(s), r2 = h.start.dot(s), i2 = h.end.dot(s);
      return (n2 === i2 || r2 === o2 || o2 < r2 !== n2 < i2) && (u2 && (c.subVectors(d.start, h.start), c.dot(s) > 0 ? u2.start.copy(d.start) : u2.start.copy(h.start), c.subVectors(d.end, h.end), c.dot(s) < 0 ? u2.end.copy(d.end) : u2.end.copy(h.end)), true);
    }
  };
}(), ExtendedTriangle.prototype.distanceToPoint = function() {
  const e = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, e), t.distanceTo(e);
  };
}(), ExtendedTriangle.prototype.distanceToTriangle = function() {
  const e = new Vector3(), t = new Vector3(), n = ["a", "b", "c"], o = new Line3(), r = new Line3();
  return function(i, a = null, s = null) {
    const l = a || s ? o : null;
    if (this.intersectsTriangle(i, l)) return (a || s) && (a && l.getCenter(a), s && l.getCenter(s)), 0;
    let c = 1 / 0;
    for (let t2 = 0; t2 < 3; t2++) {
      let o2;
      const r2 = n[t2], l2 = i[r2];
      this.closestPointToPoint(l2, e), o2 = l2.distanceToSquared(e), o2 < c && (c = o2, a && a.copy(e), s && s.copy(l2));
      const u = this[r2];
      i.closestPointToPoint(u, e), o2 = u.distanceToSquared(e), o2 < c && (c = o2, a && a.copy(u), s && s.copy(e));
    }
    for (let l2 = 0; l2 < 3; l2++) {
      const u = n[l2], d = n[(l2 + 1) % 3];
      o.set(this[u], this[d]);
      for (let l3 = 0; l3 < 3; l3++) {
        const u2 = n[l3], d2 = n[(l3 + 1) % 3];
        r.set(i[u2], i[d2]), closestPointsSegmentToSegment(o, r, e, t);
        const h = e.distanceToSquared(t);
        h < c && (c = h, a && a.copy(e), s && s.copy(t));
      }
    }
    return Math.sqrt(c);
  };
}();
var OrientedBox = class {
  constructor(e, t, n) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds()), this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds()), this.needsUpdate = false, e && this.min.copy(e), t && this.max.copy(t), n && this.matrix.copy(n);
  }
  set(e, t, n) {
    this.min.copy(e), this.max.copy(t), this.matrix.copy(n), this.needsUpdate = true;
  }
  copy(e) {
    this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = function() {
  const e = this.matrix, t = this.min, n = this.max, o = this.points;
  for (let r2 = 0; r2 <= 1; r2++) for (let i2 = 0; i2 <= 1; i2++) for (let a2 = 0; a2 <= 1; a2++) {
    const s2 = o[1 * r2 | 2 * i2 | 4 * a2];
    s2.x = r2 ? n.x : t.x, s2.y = i2 ? n.y : t.y, s2.z = a2 ? n.z : t.z, s2.applyMatrix4(e);
  }
  const r = this.satBounds, i = this.satAxes, a = o[0];
  for (let e2 = 0; e2 < 3; e2++) {
    const t2 = i[e2], n2 = r[e2], s2 = o[1 << e2];
    t2.subVectors(a, s2), n2.setFromPoints(t2, o);
  }
  const s = this.alignedSatBounds;
  s[0].setFromPointsField(o, "x"), s[1].setFromPointsField(o, "y"), s[2].setFromPointsField(o, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
}, OrientedBox.prototype.intersectsBox = function() {
  const e = new SeparatingAxisBounds();
  return function(t) {
    this.needsUpdate && this.update();
    const n = t.min, o = t.max, r = this.satBounds, i = this.satAxes, a = this.alignedSatBounds;
    if (e.min = n.x, e.max = o.x, a[0].isSeparated(e)) return false;
    if (e.min = n.y, e.max = o.y, a[1].isSeparated(e)) return false;
    if (e.min = n.z, e.max = o.z, a[2].isSeparated(e)) return false;
    for (let n2 = 0; n2 < 3; n2++) {
      const o2 = i[n2], a2 = r[n2];
      if (e.setFromBox(o2, t), a2.isSeparated(e)) return false;
    }
    return true;
  };
}(), OrientedBox.prototype.intersectsTriangle = function() {
  const e = new ExtendedTriangle(), t = new Array(3), n = new SeparatingAxisBounds(), o = new SeparatingAxisBounds(), r = new Vector3();
  return function(i) {
    this.needsUpdate && this.update(), i.isExtendedTriangle ? i.needsUpdate && i.update() : (e.copy(i), e.update(), i = e);
    const a = this.satBounds, s = this.satAxes;
    t[0] = i.a, t[1] = i.b, t[2] = i.c;
    for (let e2 = 0; e2 < 3; e2++) {
      const o2 = a[e2], r2 = s[e2];
      if (n.setFromPoints(r2, t), o2.isSeparated(n)) return false;
    }
    const l = i.satBounds, c = i.satAxes, u = this.points;
    for (let e2 = 0; e2 < 3; e2++) {
      const t2 = l[e2], o2 = c[e2];
      if (n.setFromPoints(o2, u), t2.isSeparated(n)) return false;
    }
    for (let e2 = 0; e2 < 3; e2++) {
      const i2 = s[e2];
      for (let e3 = 0; e3 < 4; e3++) {
        const a2 = c[e3];
        if (r.crossVectors(i2, a2), n.setFromPoints(r, t), o.setFromPoints(r, u), n.isSeparated(o)) return false;
      }
    }
    return true;
  };
}(), OrientedBox.prototype.closestPointToPoint = function(e, t) {
  return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
}, OrientedBox.prototype.distanceToPoint = function() {
  const e = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, e), t.distanceTo(e);
  };
}(), OrientedBox.prototype.distanceToBox = function() {
  const e = ["x", "y", "z"], t = new Array(12).fill().map(() => new Line3()), n = new Array(12).fill().map(() => new Line3()), o = new Vector3(), r = new Vector3();
  return function(i, a = 0, s = null, l = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(i)) return (s || l) && (i.getCenter(r), this.closestPointToPoint(r, o), i.closestPointToPoint(o, r), s && s.copy(o), l && l.copy(r)), 0;
    const c = a * a, u = i.min, d = i.max, h = this.points;
    let f = 1 / 0;
    for (let e2 = 0; e2 < 8; e2++) {
      const t2 = h[e2];
      r.copy(t2).clamp(u, d);
      const n2 = t2.distanceToSquared(r);
      if (n2 < f && (f = n2, s && s.copy(t2), l && l.copy(r), n2 < c)) return Math.sqrt(n2);
    }
    let p = 0;
    for (let o2 = 0; o2 < 3; o2++) for (let r2 = 0; r2 <= 1; r2++) for (let i2 = 0; i2 <= 1; i2++) {
      const a2 = (o2 + 1) % 3, s2 = (o2 + 2) % 3, l2 = 1 << o2 | r2 << a2 | i2 << s2, c2 = h[r2 << a2 | i2 << s2], f2 = h[l2];
      t[p].set(c2, f2);
      const m = e[o2], g = e[a2], _ = e[s2], A = n[p], v = A.start, x = A.end;
      v[m] = u[m], v[g] = r2 ? u[g] : d[g], v[_] = i2 ? u[_] : d[g], x[m] = d[m], x[g] = r2 ? u[g] : d[g], x[_] = i2 ? u[_] : d[g], p++;
    }
    for (let e2 = 0; e2 <= 1; e2++) for (let t2 = 0; t2 <= 1; t2++) for (let n2 = 0; n2 <= 1; n2++) {
      r.x = e2 ? d.x : u.x, r.y = t2 ? d.y : u.y, r.z = n2 ? d.z : u.z, this.closestPointToPoint(r, o);
      const i2 = r.distanceToSquared(o);
      if (i2 < f && (f = i2, s && s.copy(o), l && l.copy(r), i2 < c)) return Math.sqrt(i2);
    }
    for (let e2 = 0; e2 < 12; e2++) {
      const i2 = t[e2];
      for (let e3 = 0; e3 < 12; e3++) {
        const t2 = n[e3];
        closestPointsSegmentToSegment(i2, t2, o, r);
        const a2 = o.distanceToSquared(r);
        if (a2 < f && (f = a2, s && s.copy(o), l && l.copy(r), a2 < c)) return Math.sqrt(a2);
      }
    }
    return Math.sqrt(f);
  };
}();
var PrimitivePool = class {
  constructor(e) {
    this._getNewPrimitive = e, this._primitives = [];
  }
  getPrimitive() {
    const e = this._primitives;
    return 0 === e.length ? this._getNewPrimitive() : e.pop();
  }
  releasePrimitive(e) {
    this._primitives.push(e);
  }
};
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();
var _BufferStack = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const e = [];
    let t = null;
    this.setBuffer = (n) => {
      t && e.push(t), t = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, 0 !== e.length && this.setBuffer(e.pop());
    };
  }
};
var BufferStack = new _BufferStack();
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box3());
function shapecast(e, t, n, o, r, i) {
  _box1 = boxPool.getPrimitive(), _box2 = boxPool.getPrimitive(), boxStack.push(_box1, _box2), BufferStack.setBuffer(e._roots[t]);
  const a = shapecastTraverse(0, e.geometry, n, o, r, i);
  BufferStack.clearBuffer(), boxPool.releasePrimitive(_box1), boxPool.releasePrimitive(_box2), boxStack.pop(), boxStack.pop();
  const s = boxStack.length;
  return s > 0 && (_box2 = boxStack[s - 1], _box1 = boxStack[s - 2]), a;
}
function shapecastTraverse(e, t, n, o, r = null, i = 0, a = 0) {
  const { float32Array: s, uint16Array: l, uint32Array: c } = BufferStack;
  let u = 2 * e;
  if (IS_LEAF(u, l)) {
    const f = OFFSET(e, c), p = COUNT(u, l);
    return arrayToBox(BOUNDING_DATA_INDEX(e), s, _box1), o(f, p, false, a, i + e, _box1);
  }
  {
    let d = function(e2) {
      const { uint16Array: t2, uint32Array: n2 } = BufferStack;
      let o2 = 2 * e2;
      for (; !IS_LEAF(o2, t2); ) o2 = 2 * (e2 = LEFT_NODE(e2));
      return OFFSET(e2, n2);
    }, h = function(e2) {
      const { uint16Array: t2, uint32Array: n2 } = BufferStack;
      let o2 = 2 * e2;
      for (; !IS_LEAF(o2, t2); ) o2 = 2 * (e2 = RIGHT_NODE(e2, n2));
      return OFFSET(e2, n2) + COUNT(o2, t2);
    };
    const m = LEFT_NODE(e), g = RIGHT_NODE(e, c);
    let _, A, v, x, y = m, b = g;
    if (r && (v = _box1, x = _box2, arrayToBox(BOUNDING_DATA_INDEX(y), s, v), arrayToBox(BOUNDING_DATA_INDEX(b), s, x), _ = r(v), A = r(x), A < _)) {
      y = g, b = m;
      const T = _;
      _ = A, A = T, v = x;
    }
    v || (v = _box1, arrayToBox(BOUNDING_DATA_INDEX(y), s, v));
    const C = n(v, IS_LEAF(2 * y, l), _, a + 1, i + y);
    let S;
    if (2 === C) {
      const I = d(y);
      S = o(I, h(y) - I, true, a + 1, i + y, v);
    } else S = C && shapecastTraverse(y, t, n, o, r, i, a + 1);
    if (S) return true;
    x = _box2, arrayToBox(BOUNDING_DATA_INDEX(b), s, x);
    const M = n(x, IS_LEAF(2 * b, l), A, a + 1, i + b);
    let E;
    if (2 === M) {
      const w = d(b);
      E = o(w, h(b) - w, true, a + 1, i + b, x);
    } else E = M && shapecastTraverse(b, t, n, o, r, i, a + 1);
    return !!E;
  }
}
var temp = new Vector3();
var temp1$2 = new Vector3();
function closestPointToPoint(e, t, n = {}, o = 0, r = 1 / 0) {
  const i = o * o, a = r * r;
  let s = 1 / 0, l = null;
  if (e.shapecast({ boundsTraverseOrder: (e2) => (temp.copy(t).clamp(e2.min, e2.max), temp.distanceToSquared(t)), intersectsBounds: (e2, t2, n2) => n2 < s && n2 < a, intersectsTriangle: (e2, n2) => {
    e2.closestPointToPoint(t, temp);
    const o2 = t.distanceToSquared(temp);
    return o2 < s && (temp1$2.copy(temp), s = o2, l = n2), o2 < i;
  } }), s === 1 / 0) return null;
  const c = Math.sqrt(s);
  return n.point ? n.point.copy(temp1$2) : n.point = temp1$2.clone(), n.distance = c, n.faceIndex = l, n;
}
var IS_GT_REVISION_169 = parseInt("4.9.2") >= 169;
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
function checkIntersection(e, t, n, o, r, i, a, s) {
  let l;
  if (l = 1 === i ? e.intersectTriangle(o, n, t, true, r) : e.intersectTriangle(t, n, o, 2 !== i, r), null === l) return null;
  const c = e.origin.distanceTo(r);
  return c < a || c > s ? null : { distance: c, point: r.clone() };
}
function checkBufferGeometryIntersection(e, t, n, o, r, i, a, s, l, c, u) {
  _vA.fromBufferAttribute(t, i), _vB.fromBufferAttribute(t, a), _vC.fromBufferAttribute(t, s);
  const d = checkIntersection(e, _vA, _vB, _vC, _intersectionPoint, l, c, u);
  if (d) {
    const t2 = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA, _vB, _vC, t2), o && (_uvA.fromBufferAttribute(o, i), _uvB.fromBufferAttribute(o, a), _uvC.fromBufferAttribute(o, s), d.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2())), r && (_uvA.fromBufferAttribute(r, i), _uvB.fromBufferAttribute(r, a), _uvC.fromBufferAttribute(r, s), d.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2())), n && (_normalA.fromBufferAttribute(n, i), _normalB.fromBufferAttribute(n, a), _normalC.fromBufferAttribute(n, s), d.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3()), d.normal.dot(e.direction) > 0 && d.normal.multiplyScalar(-1));
    const l2 = { a: i, b: a, c: s, normal: new Vector3(), materialIndex: 0 };
    Triangle.getNormal(_vA, _vB, _vC, l2.normal), d.face = l2, d.faceIndex = i, IS_GT_REVISION_169 && (d.barycoord = t2);
  }
  return d;
}
function intersectTri(e, t, n, o, r, i, a) {
  const s = 3 * o;
  let l = s + 0, c = s + 1, u = s + 2;
  const d = e.index;
  e.index && (l = d.getX(l), c = d.getX(c), u = d.getX(u));
  const { position: h, normal: f, uv: p, uv1: m } = e.attributes, g = checkBufferGeometryIntersection(n, h, f, p, m, l, c, u, t, i, a);
  return g ? (g.faceIndex = o, r && r.push(g), g) : null;
}
function setTriangle(e, t, n, o) {
  const r = e.a, i = e.b, a = e.c;
  let s = t, l = t + 1, c = t + 2;
  n && (s = n.getX(s), l = n.getX(l), c = n.getX(c)), r.x = o.getX(s), r.y = o.getY(s), r.z = o.getZ(s), i.x = o.getX(l), i.y = o.getY(l), i.z = o.getZ(l), a.x = o.getX(c), a.y = o.getY(c), a.z = o.getZ(c);
}
function intersectTris(e, t, n, o, r, i, a, s) {
  const { geometry: l, _indirectBuffer: c } = e;
  for (let e2 = o, c2 = o + r; e2 < c2; e2++) intersectTri(l, t, n, e2, i, a, s);
}
function intersectClosestTri(e, t, n, o, r, i, a) {
  const { geometry: s, _indirectBuffer: l } = e;
  let c = 1 / 0, u = null;
  for (let e2 = o, l2 = o + r; e2 < l2; e2++) {
    let o2;
    o2 = intersectTri(s, t, n, e2, null, i, a), o2 && o2.distance < c && (u = o2, c = o2.distance);
  }
  return u;
}
function iterateOverTriangles(e, t, n, o, r, i, a) {
  const { geometry: s } = n, { index: l } = s, c = s.attributes.position;
  for (let n2 = e, s2 = t + e; n2 < s2; n2++) {
    let e2;
    if (e2 = n2, setTriangle(a, 3 * e2, l, c), a.needsUpdate = true, o(a, e2, r, i)) return true;
  }
  return false;
}
function refit(e, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const n = e.geometry, o = n.index ? n.index.array : null, r = n.attributes.position;
  let i, a, s, l, c = 0;
  const u = e._roots;
  for (let e2 = 0, t2 = u.length; e2 < t2; e2++) i = u[e2], a = new Uint32Array(i), s = new Uint16Array(i), l = new Float32Array(i), d(0, c), c += i.byteLength;
  function d(e2, n2, i2 = false) {
    const c2 = 2 * e2;
    if (65535 === s[c2 + 15]) {
      const t2 = a[e2 + 6];
      let n3 = 1 / 0, i3 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, h = -1 / 0, f = -1 / 0;
      for (let e3 = 3 * t2, a2 = 3 * (t2 + s[c2 + 14]); e3 < a2; e3++) {
        let t3 = o[e3];
        const a3 = r.getX(t3), s2 = r.getY(t3), l2 = r.getZ(t3);
        a3 < n3 && (n3 = a3), a3 > d2 && (d2 = a3), s2 < i3 && (i3 = s2), s2 > h && (h = s2), l2 < u2 && (u2 = l2), l2 > f && (f = l2);
      }
      return (l[e2 + 0] !== n3 || l[e2 + 1] !== i3 || l[e2 + 2] !== u2 || l[e2 + 3] !== d2 || l[e2 + 4] !== h || l[e2 + 5] !== f) && (l[e2 + 0] = n3, l[e2 + 1] = i3, l[e2 + 2] = u2, l[e2 + 3] = d2, l[e2 + 4] = h, l[e2 + 5] = f, true);
    }
    {
      const o2 = e2 + 8, r2 = a[e2 + 6], s2 = o2 + n2, c3 = r2 + n2;
      let u2 = i2, h = false, f = false;
      t ? u2 || (h = t.has(s2), f = t.has(c3), u2 = !h && !f) : (h = true, f = true);
      const p = u2 || f;
      let m = false;
      (u2 || h) && (m = d(o2, n2, u2));
      let g = false;
      p && (g = d(r2, n2, u2));
      const _ = m || g;
      if (_) for (let t2 = 0; t2 < 3; t2++) {
        const n3 = o2 + t2, i3 = r2 + t2, a2 = l[n3], s3 = l[n3 + 3], c4 = l[i3], u3 = l[i3 + 3];
        l[e2 + t2] = a2 < c4 ? a2 : c4, l[e2 + t2 + 3] = s3 > u3 ? s3 : u3;
      }
      return _;
    }
  }
}
function intersectRay(e, t, n, o, r) {
  let i, a, s, l, c, u;
  const d = 1 / n.direction.x, h = 1 / n.direction.y, f = 1 / n.direction.z, p = n.origin.x, m = n.origin.y, g = n.origin.z;
  let _ = t[e], A = t[e + 3], v = t[e + 1], x = t[e + 3 + 1], y = t[e + 2], b = t[e + 3 + 2];
  return d >= 0 ? (i = (_ - p) * d, a = (A - p) * d) : (i = (A - p) * d, a = (_ - p) * d), h >= 0 ? (s = (v - m) * h, l = (x - m) * h) : (s = (x - m) * h, l = (v - m) * h), !(i > l || s > a) && ((s > i || isNaN(i)) && (i = s), (l < a || isNaN(a)) && (a = l), f >= 0 ? (c = (y - g) * f, u = (b - g) * f) : (c = (b - g) * f, u = (y - g) * f), !(i > u || c > a) && ((c > i || i != i) && (i = c), (u < a || a != a) && (a = u), i <= r && a >= o));
}
function intersectTris_indirect(e, t, n, o, r, i, a, s) {
  const { geometry: l, _indirectBuffer: c } = e;
  for (let e2 = o, u = o + r; e2 < u; e2++) {
    intersectTri(l, t, n, c ? c[e2] : e2, i, a, s);
  }
}
function intersectClosestTri_indirect(e, t, n, o, r, i, a) {
  const { geometry: s, _indirectBuffer: l } = e;
  let c = 1 / 0, u = null;
  for (let e2 = o, d = o + r; e2 < d; e2++) {
    let o2;
    o2 = intersectTri(s, t, n, l ? l[e2] : e2, null, i, a), o2 && o2.distance < c && (u = o2, c = o2.distance);
  }
  return u;
}
function iterateOverTriangles_indirect(e, t, n, o, r, i, a) {
  const { geometry: s } = n, { index: l } = s, c = s.attributes.position;
  for (let s2 = e, u = t + e; s2 < u; s2++) {
    let e2;
    if (e2 = n.resolveTriangleIndex(s2), setTriangle(a, 3 * e2, l, c), a.needsUpdate = true, o(a, e2, r, i)) return true;
  }
  return false;
}
function raycast(e, t, n, o, r, i, a) {
  BufferStack.setBuffer(e._roots[t]), _raycast$1(0, e, n, o, r, i, a), BufferStack.clearBuffer();
}
function _raycast$1(e, t, n, o, r, i, a) {
  const { float32Array: s, uint16Array: l, uint32Array: c } = BufferStack, u = 2 * e;
  if (IS_LEAF(u, l)) {
    intersectTris(t, n, o, OFFSET(e, c), COUNT(u, l), r, i, a);
  } else {
    const l2 = LEFT_NODE(e);
    intersectRay(l2, s, o, i, a) && _raycast$1(l2, t, n, o, r, i, a);
    const u2 = RIGHT_NODE(e, c);
    intersectRay(u2, s, o, i, a) && _raycast$1(u2, t, n, o, r, i, a);
  }
}
var _xyzFields$1 = ["x", "y", "z"];
function raycastFirst(e, t, n, o, r, i) {
  BufferStack.setBuffer(e._roots[t]);
  const a = _raycastFirst$1(0, e, n, o, r, i);
  return BufferStack.clearBuffer(), a;
}
function _raycastFirst$1(e, t, n, o, r, i) {
  const { float32Array: a, uint16Array: s, uint32Array: l } = BufferStack;
  let c = 2 * e;
  if (IS_LEAF(c, s)) {
    return intersectClosestTri(t, n, o, OFFSET(e, l), COUNT(c, s), r, i);
  }
  {
    const s2 = SPLIT_AXIS(e, l), c2 = _xyzFields$1[s2], u = o.direction[c2] >= 0;
    let d, h;
    u ? (d = LEFT_NODE(e), h = RIGHT_NODE(e, l)) : (d = RIGHT_NODE(e, l), h = LEFT_NODE(e));
    const f = intersectRay(d, a, o, r, i) ? _raycastFirst$1(d, t, n, o, r, i) : null;
    if (f) {
      const e2 = f.point[c2];
      if (u ? e2 <= a[h + s2] : e2 >= a[h + s2 + 3]) return f;
    }
    const p = intersectRay(h, a, o, r, i) ? _raycastFirst$1(h, t, n, o, r, i) : null;
    return f && p ? f.distance <= p.distance ? f : p : f || p || null;
  }
}
var boundingBox$1 = new Box3();
var triangle$1 = new ExtendedTriangle();
var triangle2$1 = new ExtendedTriangle();
var invertedMat$1 = new Matrix4();
var obb$4 = new OrientedBox();
var obb2$3 = new OrientedBox();
function intersectsGeometry(e, t, n, o) {
  BufferStack.setBuffer(e._roots[t]);
  const r = _intersectsGeometry$1(0, e, n, o);
  return BufferStack.clearBuffer(), r;
}
function _intersectsGeometry$1(e, t, n, o, r = null) {
  const { float32Array: i, uint16Array: a, uint32Array: s } = BufferStack;
  let l = 2 * e;
  null === r && (n.boundingBox || n.computeBoundingBox(), obb$4.set(n.boundingBox.min, n.boundingBox.max, o), r = obb$4);
  if (!IS_LEAF(l, a)) {
    const a2 = e + 8, l2 = s[e + 6];
    arrayToBox(BOUNDING_DATA_INDEX(a2), i, boundingBox$1);
    if (r.intersectsBox(boundingBox$1) && _intersectsGeometry$1(a2, t, n, o, r)) return true;
    arrayToBox(BOUNDING_DATA_INDEX(l2), i, boundingBox$1);
    return !!(r.intersectsBox(boundingBox$1) && _intersectsGeometry$1(l2, t, n, o, r));
  }
  {
    const r2 = t.geometry, c = r2.index, u = r2.attributes.position, d = n.index, h = n.attributes.position, f = OFFSET(e, s), p = COUNT(l, a);
    if (invertedMat$1.copy(o).invert(), n.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(e), i, obb2$3), obb2$3.matrix.copy(invertedMat$1), obb2$3.needsUpdate = true;
      const t2 = n.boundsTree.shapecast({ intersectsBounds: (e2) => obb2$3.intersectsBox(e2), intersectsTriangle: (e2) => {
        e2.a.applyMatrix4(o), e2.b.applyMatrix4(o), e2.c.applyMatrix4(o), e2.needsUpdate = true;
        for (let t3 = 3 * f, n2 = 3 * (p + f); t3 < n2; t3 += 3) if (setTriangle(triangle2$1, t3, c, u), triangle2$1.needsUpdate = true, e2.intersectsTriangle(triangle2$1)) return true;
        return false;
      } });
      return t2;
    }
    for (let e2 = 3 * f, t2 = 3 * (p + f); e2 < t2; e2 += 3) {
      setTriangle(triangle$1, e2, c, u), triangle$1.a.applyMatrix4(invertedMat$1), triangle$1.b.applyMatrix4(invertedMat$1), triangle$1.c.applyMatrix4(invertedMat$1), triangle$1.needsUpdate = true;
      for (let e3 = 0, t3 = d.count; e3 < t3; e3 += 3) if (setTriangle(triangle2$1, e3, d, h), triangle2$1.needsUpdate = true, triangle$1.intersectsTriangle(triangle2$1)) return true;
    }
  }
}
var tempMatrix$1 = new Matrix4();
var obb$3 = new OrientedBox();
var obb2$2 = new OrientedBox();
var temp1$1 = new Vector3();
var temp2$1 = new Vector3();
var temp3$1 = new Vector3();
var temp4$1 = new Vector3();
function closestPointToGeometry(e, t, n, o = {}, r = {}, i = 0, a = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), obb$3.set(t.boundingBox.min, t.boundingBox.max, n), obb$3.needsUpdate = true;
  const s = e.geometry, l = s.attributes.position, c = s.index, u = t.attributes.position, d = t.index, h = ExtendedTrianglePool.getPrimitive(), f = ExtendedTrianglePool.getPrimitive();
  let p = temp1$1, m = temp2$1, g = null, _ = null;
  r && (g = temp3$1, _ = temp4$1);
  let A = 1 / 0, v = null, x = null;
  return tempMatrix$1.copy(n).invert(), obb2$2.matrix.copy(tempMatrix$1), e.shapecast({ boundsTraverseOrder: (e2) => obb$3.distanceToBox(e2), intersectsBounds: (e2, t2, n2) => n2 < A && n2 < a && (t2 && (obb2$2.min.copy(e2.min), obb2$2.max.copy(e2.max), obb2$2.needsUpdate = true), true), intersectsRange: (e2, o2) => {
    if (t.boundsTree) {
      return t.boundsTree.shapecast({ boundsTraverseOrder: (e3) => obb2$2.distanceToBox(e3), intersectsBounds: (e3, t2, n2) => n2 < A && n2 < a, intersectsRange: (t2, r2) => {
        for (let a2 = t2, s2 = t2 + r2; a2 < s2; a2++) {
          setTriangle(f, 3 * a2, d, u), f.a.applyMatrix4(n), f.b.applyMatrix4(n), f.c.applyMatrix4(n), f.needsUpdate = true;
          for (let t3 = e2, n2 = e2 + o2; t3 < n2; t3++) {
            setTriangle(h, 3 * t3, c, l), h.needsUpdate = true;
            const e3 = h.distanceToTriangle(f, p, g);
            if (e3 < A && (m.copy(p), _ && _.copy(g), A = e3, v = t3, x = a2), e3 < i) return true;
          }
        }
      } });
    }
    for (let r2 = 0, a2 = getTriCount(t); r2 < a2; r2++) {
      setTriangle(f, 3 * r2, d, u), f.a.applyMatrix4(n), f.b.applyMatrix4(n), f.c.applyMatrix4(n), f.needsUpdate = true;
      for (let t2 = e2, n2 = e2 + o2; t2 < n2; t2++) {
        setTriangle(h, 3 * t2, c, l), h.needsUpdate = true;
        const e3 = h.distanceToTriangle(f, p, g);
        if (e3 < A && (m.copy(p), _ && _.copy(g), A = e3, v = t2, x = r2), e3 < i) return true;
      }
    }
  } }), ExtendedTrianglePool.releasePrimitive(h), ExtendedTrianglePool.releasePrimitive(f), A === 1 / 0 ? null : (o.point ? o.point.copy(m) : o.point = m.clone(), o.distance = A, o.faceIndex = v, r && (r.point ? r.point.copy(_) : r.point = _.clone(), r.point.applyMatrix4(tempMatrix$1), m.applyMatrix4(tempMatrix$1), r.distance = m.sub(r.point).length(), r.faceIndex = x), o);
}
function refit_indirect(e, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const n = e.geometry, o = n.index ? n.index.array : null, r = n.attributes.position;
  let i, a, s, l, c = 0;
  const u = e._roots;
  for (let e2 = 0, t2 = u.length; e2 < t2; e2++) i = u[e2], a = new Uint32Array(i), s = new Uint16Array(i), l = new Float32Array(i), d(0, c), c += i.byteLength;
  function d(n2, i2, c2 = false) {
    const u2 = 2 * n2;
    if (65535 === s[u2 + 15]) {
      const t2 = a[n2 + 6];
      let i3 = 1 / 0, c3 = 1 / 0, d2 = 1 / 0, h = -1 / 0, f = -1 / 0, p = -1 / 0;
      for (let n3 = t2, a2 = t2 + s[u2 + 14]; n3 < a2; n3++) {
        const t3 = 3 * e.resolveTriangleIndex(n3);
        for (let e2 = 0; e2 < 3; e2++) {
          let n4 = t3 + e2;
          n4 = o ? o[n4] : n4;
          const a3 = r.getX(n4), s2 = r.getY(n4), l2 = r.getZ(n4);
          a3 < i3 && (i3 = a3), a3 > h && (h = a3), s2 < c3 && (c3 = s2), s2 > f && (f = s2), l2 < d2 && (d2 = l2), l2 > p && (p = l2);
        }
      }
      return (l[n2 + 0] !== i3 || l[n2 + 1] !== c3 || l[n2 + 2] !== d2 || l[n2 + 3] !== h || l[n2 + 4] !== f || l[n2 + 5] !== p) && (l[n2 + 0] = i3, l[n2 + 1] = c3, l[n2 + 2] = d2, l[n2 + 3] = h, l[n2 + 4] = f, l[n2 + 5] = p, true);
    }
    {
      const e2 = n2 + 8, o2 = a[n2 + 6], r2 = e2 + i2, s2 = o2 + i2;
      let u3 = c2, h = false, f = false;
      t ? u3 || (h = t.has(r2), f = t.has(s2), u3 = !h && !f) : (h = true, f = true);
      const p = u3 || f;
      let m = false;
      (u3 || h) && (m = d(e2, i2, u3));
      let g = false;
      p && (g = d(o2, i2, u3));
      const _ = m || g;
      if (_) for (let t2 = 0; t2 < 3; t2++) {
        const r3 = e2 + t2, i3 = o2 + t2, a2 = l[r3], s3 = l[r3 + 3], c3 = l[i3], u4 = l[i3 + 3];
        l[n2 + t2] = a2 < c3 ? a2 : c3, l[n2 + t2 + 3] = s3 > u4 ? s3 : u4;
      }
      return _;
    }
  }
}
function raycast_indirect(e, t, n, o, r, i, a) {
  BufferStack.setBuffer(e._roots[t]), _raycast(0, e, n, o, r, i, a), BufferStack.clearBuffer();
}
function _raycast(e, t, n, o, r, i, a) {
  const { float32Array: s, uint16Array: l, uint32Array: c } = BufferStack, u = 2 * e;
  if (IS_LEAF(u, l)) {
    intersectTris_indirect(t, n, o, OFFSET(e, c), COUNT(u, l), r, i, a);
  } else {
    const l2 = LEFT_NODE(e);
    intersectRay(l2, s, o, i, a) && _raycast(l2, t, n, o, r, i, a);
    const u2 = RIGHT_NODE(e, c);
    intersectRay(u2, s, o, i, a) && _raycast(u2, t, n, o, r, i, a);
  }
}
var _xyzFields = ["x", "y", "z"];
function raycastFirst_indirect(e, t, n, o, r, i) {
  BufferStack.setBuffer(e._roots[t]);
  const a = _raycastFirst(0, e, n, o, r, i);
  return BufferStack.clearBuffer(), a;
}
function _raycastFirst(e, t, n, o, r, i) {
  const { float32Array: a, uint16Array: s, uint32Array: l } = BufferStack;
  let c = 2 * e;
  if (IS_LEAF(c, s)) {
    return intersectClosestTri_indirect(t, n, o, OFFSET(e, l), COUNT(c, s), r, i);
  }
  {
    const s2 = SPLIT_AXIS(e, l), c2 = _xyzFields[s2], u = o.direction[c2] >= 0;
    let d, h;
    u ? (d = LEFT_NODE(e), h = RIGHT_NODE(e, l)) : (d = RIGHT_NODE(e, l), h = LEFT_NODE(e));
    const f = intersectRay(d, a, o, r, i) ? _raycastFirst(d, t, n, o, r, i) : null;
    if (f) {
      const e2 = f.point[c2];
      if (u ? e2 <= a[h + s2] : e2 >= a[h + s2 + 3]) return f;
    }
    const p = intersectRay(h, a, o, r, i) ? _raycastFirst(h, t, n, o, r, i) : null;
    return f && p ? f.distance <= p.distance ? f : p : f || p || null;
  }
}
var boundingBox = new Box3();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix4();
var obb$2 = new OrientedBox();
var obb2$1 = new OrientedBox();
function intersectsGeometry_indirect(e, t, n, o) {
  BufferStack.setBuffer(e._roots[t]);
  const r = _intersectsGeometry(0, e, n, o);
  return BufferStack.clearBuffer(), r;
}
function _intersectsGeometry(e, t, n, o, r = null) {
  const { float32Array: i, uint16Array: a, uint32Array: s } = BufferStack;
  let l = 2 * e;
  null === r && (n.boundingBox || n.computeBoundingBox(), obb$2.set(n.boundingBox.min, n.boundingBox.max, o), r = obb$2);
  if (!IS_LEAF(l, a)) {
    const a2 = e + 8, l2 = s[e + 6];
    arrayToBox(BOUNDING_DATA_INDEX(a2), i, boundingBox);
    if (r.intersectsBox(boundingBox) && _intersectsGeometry(a2, t, n, o, r)) return true;
    arrayToBox(BOUNDING_DATA_INDEX(l2), i, boundingBox);
    return !!(r.intersectsBox(boundingBox) && _intersectsGeometry(l2, t, n, o, r));
  }
  {
    const r2 = t.geometry, c = r2.index, u = r2.attributes.position, d = n.index, h = n.attributes.position, f = OFFSET(e, s), p = COUNT(l, a);
    if (invertedMat.copy(o).invert(), n.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(e), i, obb2$1), obb2$1.matrix.copy(invertedMat), obb2$1.needsUpdate = true;
      const r3 = n.boundsTree.shapecast({ intersectsBounds: (e2) => obb2$1.intersectsBox(e2), intersectsTriangle: (e2) => {
        e2.a.applyMatrix4(o), e2.b.applyMatrix4(o), e2.c.applyMatrix4(o), e2.needsUpdate = true;
        for (let n2 = f, o2 = p + f; n2 < o2; n2++) if (setTriangle(triangle2, 3 * t.resolveTriangleIndex(n2), c, u), triangle2.needsUpdate = true, e2.intersectsTriangle(triangle2)) return true;
        return false;
      } });
      return r3;
    }
    for (let e2 = f, n2 = p + f; e2 < n2; e2++) {
      const n3 = t.resolveTriangleIndex(e2);
      setTriangle(triangle, 3 * n3, c, u), triangle.a.applyMatrix4(invertedMat), triangle.b.applyMatrix4(invertedMat), triangle.c.applyMatrix4(invertedMat), triangle.needsUpdate = true;
      for (let e3 = 0, t2 = d.count; e3 < t2; e3 += 3) if (setTriangle(triangle2, e3, d, h), triangle2.needsUpdate = true, triangle.intersectsTriangle(triangle2)) return true;
    }
  }
}
var tempMatrix = new Matrix4();
var obb$1 = new OrientedBox();
var obb2 = new OrientedBox();
var temp1 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
function closestPointToGeometry_indirect(e, t, n, o = {}, r = {}, i = 0, a = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), obb$1.set(t.boundingBox.min, t.boundingBox.max, n), obb$1.needsUpdate = true;
  const s = e.geometry, l = s.attributes.position, c = s.index, u = t.attributes.position, d = t.index, h = ExtendedTrianglePool.getPrimitive(), f = ExtendedTrianglePool.getPrimitive();
  let p = temp1, m = temp2, g = null, _ = null;
  r && (g = temp3, _ = temp4);
  let A = 1 / 0, v = null, x = null;
  return tempMatrix.copy(n).invert(), obb2.matrix.copy(tempMatrix), e.shapecast({ boundsTraverseOrder: (e2) => obb$1.distanceToBox(e2), intersectsBounds: (e2, t2, n2) => n2 < A && n2 < a && (t2 && (obb2.min.copy(e2.min), obb2.max.copy(e2.max), obb2.needsUpdate = true), true), intersectsRange: (o2, r2) => {
    if (t.boundsTree) {
      const s2 = t.boundsTree;
      return s2.shapecast({ boundsTraverseOrder: (e2) => obb2.distanceToBox(e2), intersectsBounds: (e2, t2, n2) => n2 < A && n2 < a, intersectsRange: (t2, a2) => {
        for (let y = t2, b = t2 + a2; y < b; y++) {
          const t3 = s2.resolveTriangleIndex(y);
          setTriangle(f, 3 * t3, d, u), f.a.applyMatrix4(n), f.b.applyMatrix4(n), f.c.applyMatrix4(n), f.needsUpdate = true;
          for (let t4 = o2, n2 = o2 + r2; t4 < n2; t4++) {
            const n3 = e.resolveTriangleIndex(t4);
            setTriangle(h, 3 * n3, c, l), h.needsUpdate = true;
            const o3 = h.distanceToTriangle(f, p, g);
            if (o3 < A && (m.copy(p), _ && _.copy(g), A = o3, v = t4, x = y), o3 < i) return true;
          }
        }
      } });
    }
    for (let a2 = 0, s2 = getTriCount(t); a2 < s2; a2++) {
      setTriangle(f, 3 * a2, d, u), f.a.applyMatrix4(n), f.b.applyMatrix4(n), f.c.applyMatrix4(n), f.needsUpdate = true;
      for (let t2 = o2, n2 = o2 + r2; t2 < n2; t2++) {
        const n3 = e.resolveTriangleIndex(t2);
        setTriangle(h, 3 * n3, c, l), h.needsUpdate = true;
        const o3 = h.distanceToTriangle(f, p, g);
        if (o3 < A && (m.copy(p), _ && _.copy(g), A = o3, v = t2, x = a2), o3 < i) return true;
      }
    }
  } }), ExtendedTrianglePool.releasePrimitive(h), ExtendedTrianglePool.releasePrimitive(f), A === 1 / 0 ? null : (o.point ? o.point.copy(m) : o.point = m.clone(), o.distance = A, o.faceIndex = v, r && (r.point ? r.point.copy(_) : r.point = _.clone(), r.point.applyMatrix4(tempMatrix), m.applyMatrix4(tempMatrix), r.distance = m.sub(r.point).length(), r.faceIndex = x), o);
}
function isSharedArrayBufferSupported() {
  return "undefined" != typeof SharedArrayBuffer;
}
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box3());
var _leftBox1 = new Box3();
var _rightBox1 = new Box3();
var _leftBox2 = new Box3();
var _rightBox2 = new Box3();
var _active = false;
function bvhcast(e, t, n, o) {
  if (_active) throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  _active = true;
  const r = e._roots, i = t._roots;
  let a, s = 0, l = 0;
  const c = new Matrix4().copy(n).invert();
  for (let e2 = 0, t2 = r.length; e2 < t2; e2++) {
    _bufferStack1.setBuffer(r[e2]), l = 0;
    const t3 = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, t3), t3.applyMatrix4(c);
    for (let e3 = 0, r2 = i.length; e3 < r2 && (_bufferStack2.setBuffer(i[e3]), a = _traverse(0, 0, n, c, o, s, l, 0, 0, t3), _bufferStack2.clearBuffer(), l += i[e3].length, !a); e3++) ;
    if (_boxPool.releasePrimitive(t3), _bufferStack1.clearBuffer(), s += r[e2].length, a) break;
  }
  return _active = false, a;
}
function _traverse(e, t, n, o, r, i = 0, a = 0, s = 0, l = 0, c = null, u = false) {
  let d, h;
  u ? (d = _bufferStack2, h = _bufferStack1) : (d = _bufferStack1, h = _bufferStack2);
  const f = d.float32Array, p = d.uint32Array, m = d.uint16Array, g = h.float32Array, _ = h.uint32Array, A = h.uint16Array, v = 2 * t, x = IS_LEAF(2 * e, m), y = IS_LEAF(v, A);
  let b = false;
  if (y && x) b = u ? r(OFFSET(t, _), COUNT(2 * t, A), OFFSET(e, p), COUNT(2 * e, m), l, a + t, s, i + e) : r(OFFSET(e, p), COUNT(2 * e, m), OFFSET(t, _), COUNT(2 * t, A), s, i + e, l, a + t);
  else if (y) {
    const c2 = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(t), g, c2), c2.applyMatrix4(n);
    const d2 = LEFT_NODE(e), h2 = RIGHT_NODE(e, p);
    arrayToBox(BOUNDING_DATA_INDEX(d2), f, _leftBox1), arrayToBox(BOUNDING_DATA_INDEX(h2), f, _rightBox1);
    const m2 = c2.intersectsBox(_leftBox1), _2 = c2.intersectsBox(_rightBox1);
    b = m2 && _traverse(t, d2, o, n, r, a, i, l, s + 1, c2, !u) || _2 && _traverse(t, h2, o, n, r, a, i, l, s + 1, c2, !u), _boxPool.releasePrimitive(c2);
  } else {
    const d2 = LEFT_NODE(t), h2 = RIGHT_NODE(t, _);
    arrayToBox(BOUNDING_DATA_INDEX(d2), g, _leftBox2), arrayToBox(BOUNDING_DATA_INDEX(h2), g, _rightBox2);
    const m2 = c.intersectsBox(_leftBox2), A2 = c.intersectsBox(_rightBox2);
    if (m2 && A2) b = _traverse(e, d2, n, o, r, i, a, s, l + 1, c, u) || _traverse(e, h2, n, o, r, i, a, s, l + 1, c, u);
    else if (m2) if (x) b = _traverse(e, d2, n, o, r, i, a, s, l + 1, c, u);
    else {
      const t2 = _boxPool.getPrimitive();
      t2.copy(_leftBox2).applyMatrix4(n);
      const c2 = LEFT_NODE(e), h3 = RIGHT_NODE(e, p);
      arrayToBox(BOUNDING_DATA_INDEX(c2), f, _leftBox1), arrayToBox(BOUNDING_DATA_INDEX(h3), f, _rightBox1);
      const m3 = t2.intersectsBox(_leftBox1), g2 = t2.intersectsBox(_rightBox1);
      b = m3 && _traverse(d2, c2, o, n, r, a, i, l, s + 1, t2, !u) || g2 && _traverse(d2, h3, o, n, r, a, i, l, s + 1, t2, !u), _boxPool.releasePrimitive(t2);
    }
    else if (A2) if (x) b = _traverse(e, h2, n, o, r, i, a, s, l + 1, c, u);
    else {
      const t2 = _boxPool.getPrimitive();
      t2.copy(_rightBox2).applyMatrix4(n);
      const c2 = LEFT_NODE(e), d3 = RIGHT_NODE(e, p);
      arrayToBox(BOUNDING_DATA_INDEX(c2), f, _leftBox1), arrayToBox(BOUNDING_DATA_INDEX(d3), f, _rightBox1);
      const m3 = t2.intersectsBox(_leftBox1), g2 = t2.intersectsBox(_rightBox1);
      b = m3 && _traverse(h2, c2, o, n, r, a, i, l, s + 1, t2, !u) || g2 && _traverse(h2, d3, o, n, r, a, i, l, s + 1, t2, !u), _boxPool.releasePrimitive(t2);
    }
  }
  return b;
}
var obb = new OrientedBox();
var tempBox = new Box3();
var DEFAULT_OPTIONS = { strategy: 0, maxDepth: 40, maxLeafTris: 10, useSharedArrayBuffer: false, setBoundingBox: true, onProgress: null, indirect: false, verbose: true, range: null };
var MeshBVH = class _MeshBVH {
  static serialize(e, t = {}) {
    t = { cloneBuffers: true, ...t };
    const n = e.geometry, o = e._roots, r = e._indirectBuffer, i = n.getIndex();
    let a;
    return a = t.cloneBuffers ? { roots: o.map((e2) => e2.slice()), index: i ? i.array.slice() : null, indirectBuffer: r ? r.slice() : null } : { roots: o, index: i ? i.array : null, indirectBuffer: r }, a;
  }
  static deserialize(e, t, n = {}) {
    n = { setIndex: true, indirect: Boolean(e.indirectBuffer), ...n };
    const { index: o, roots: r, indirectBuffer: i } = e, a = new _MeshBVH(t, { ...n, [SKIP_GENERATION]: true });
    if (a._roots = r, a._indirectBuffer = i || null, n.setIndex) {
      const n2 = t.getIndex();
      if (null === n2) {
        const n3 = new BufferAttribute(e.index, 1, false);
        t.setIndex(n3);
      } else n2.array !== o && (n2.array.set(o), n2.needsUpdate = true);
    }
    return a;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(e, t = {}) {
    if (!e.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    if ((t = Object.assign({ ...DEFAULT_OPTIONS, [SKIP_GENERATION]: false }, t)).useSharedArrayBuffer && !isSharedArrayBufferSupported()) throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = e, this._roots = null, this._indirectBuffer = null, t[SKIP_GENERATION] || (buildPackedTree(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new Box3()))), this.resolveTriangleIndex = t.indirect ? (e2) => this._indirectBuffer[e2] : (e2) => e2;
  }
  refit(e = null) {
    return (this.indirect ? refit_indirect : refit)(this, e);
  }
  traverse(e, t = 0) {
    const n = this._roots[t], o = new Uint32Array(n), r = new Uint16Array(n);
    !function t2(i, a = 0) {
      const s = 2 * i, l = 65535 === r[s + 15];
      if (l) {
        const t3 = o[i + 6], c = r[s + 14];
        e(a, l, new Float32Array(n, 4 * i, 6), t3, c);
      } else {
        const r2 = i + 8, s2 = o[i + 6], c = o[i + 7];
        e(a, l, new Float32Array(n, 4 * i, 6), c) || (t2(r2, a + 1), t2(s2, a + 1));
      }
    }(0);
  }
  raycast(e, t = 0, n = 0, o = 1 / 0) {
    const r = this._roots, i = this.geometry, a = [], s = t.isMaterial, l = Array.isArray(t), c = i.groups, u = s ? t.side : t, d = this.indirect ? raycast_indirect : raycast;
    for (let i2 = 0, s2 = r.length; i2 < s2; i2++) {
      const r2 = l ? t[c[i2].materialIndex].side : u, s3 = a.length;
      if (d(this, i2, r2, e, a, n, o), l) {
        const e2 = c[i2].materialIndex;
        for (let t2 = s3, n2 = a.length; t2 < n2; t2++) a[t2].face.materialIndex = e2;
      }
    }
    return a;
  }
  raycastFirst(e, t = 0, n = 0, o = 1 / 0) {
    const r = this._roots, i = this.geometry, a = t.isMaterial, s = Array.isArray(t);
    let l = null;
    const c = i.groups, u = a ? t.side : t, d = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i2 = 0, a2 = r.length; i2 < a2; i2++) {
      const r2 = d(this, i2, s ? t[c[i2].materialIndex].side : u, e, n, o);
      null != r2 && (null == l || r2.distance < l.distance) && (l = r2, s && (r2.face.materialIndex = c[i2].materialIndex));
    }
    return l;
  }
  intersectsGeometry(e, t) {
    let n = false;
    const o = this._roots, r = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, a = o.length; i < a && (n = r(this, i, e, t), !n); i++) ;
    return n;
  }
  shapecast(e) {
    const t = ExtendedTrianglePool.getPrimitive(), n = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let { boundsTraverseOrder: o, intersectsBounds: r, intersectsRange: i, intersectsTriangle: a } = e;
    if (i && a) {
      const e2 = i;
      i = (o2, r2, i2, s2, l2) => !!e2(o2, r2, i2, s2, l2) || n(o2, r2, this, a, i2, s2, t);
    } else i || (i = a ? (e2, o2, r2, i2) => n(e2, o2, this, a, r2, i2, t) : (e2, t2, n2) => n2);
    let s = false, l = 0;
    const c = this._roots;
    for (let e2 = 0, t2 = c.length; e2 < t2; e2++) {
      const t3 = c[e2];
      if (s = shapecast(this, e2, r, i, o, l), s) break;
      l += t3.byteLength;
    }
    return ExtendedTrianglePool.releasePrimitive(t), s;
  }
  bvhcast(e, t, n) {
    let { intersectsRanges: o, intersectsTriangles: r } = n;
    const i = ExtendedTrianglePool.getPrimitive(), a = this.geometry.index, s = this.geometry.attributes.position, l = this.indirect ? (e2) => {
      const t2 = this.resolveTriangleIndex(e2);
      setTriangle(i, 3 * t2, a, s);
    } : (e2) => {
      setTriangle(i, 3 * e2, a, s);
    }, c = ExtendedTrianglePool.getPrimitive(), u = e.geometry.index, d = e.geometry.attributes.position, h = e.indirect ? (t2) => {
      const n2 = e.resolveTriangleIndex(t2);
      setTriangle(c, 3 * n2, u, d);
    } : (e2) => {
      setTriangle(c, 3 * e2, u, d);
    };
    if (r) {
      const e2 = (e3, n2, o2, a2, s2, u2, d2, f) => {
        for (let p = o2, m = o2 + a2; p < m; p++) {
          h(p), c.a.applyMatrix4(t), c.b.applyMatrix4(t), c.c.applyMatrix4(t), c.needsUpdate = true;
          for (let t2 = e3, o3 = e3 + n2; t2 < o3; t2++) if (l(t2), i.needsUpdate = true, r(i, c, t2, p, s2, u2, d2, f)) return true;
        }
        return false;
      };
      if (o) {
        const t2 = o;
        o = function(n2, o2, r2, i2, a2, s2, l2, c2) {
          return !!t2(n2, o2, r2, i2, a2, s2, l2, c2) || e2(n2, o2, r2, i2, a2, s2, l2, c2);
        };
      } else o = e2;
    }
    return bvhcast(this, e, t, o);
  }
  intersectsBox(e, t) {
    return obb.set(e.min, e.max, t), obb.needsUpdate = true, this.shapecast({ intersectsBounds: (e2) => obb.intersectsBox(e2), intersectsTriangle: (e2) => obb.intersectsTriangle(e2) });
  }
  intersectsSphere(e) {
    return this.shapecast({ intersectsBounds: (t) => e.intersectsBox(t), intersectsTriangle: (t) => t.intersectsSphere(e) });
  }
  closestPointToGeometry(e, t, n = {}, o = {}, r = 0, i = 1 / 0) {
    return (this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry)(this, e, t, n, o, r, i);
  }
  closestPointToPoint(e, t = {}, n = 0, o = 1 / 0) {
    return closestPointToPoint(this, e, t, n, o);
  }
  getBoundingBox(e) {
    e.makeEmpty();
    return this._roots.forEach((t) => {
      arrayToBox(0, new Float32Array(t), tempBox), e.union(tempBox);
    }), e;
  }
};
var BatchedMesh = class extends Mesh {
};
function convertRaycastIntersect(e, t, n) {
  return null === e ? null : (e.point.applyMatrix4(t.matrixWorld), e.distance = e.point.distanceTo(n.ray.origin), e.object = t, e);
}
var ray = new Ray();
var direction = new Vector3();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;
var origBatchedRaycastFunc = BatchedMesh.prototype.raycast;
var _worldScale = new Vector3();
var _mesh = new Mesh();
var _batchIntersects = [];
function acceleratedRaycast(e, t) {
  this.isBatchedMesh ? acceleratedBatchedMeshRaycast.call(this, e, t) : acceleratedMeshRaycast.call(this, e, t);
}
function acceleratedBatchedMeshRaycast(e, t) {
  if (this.boundsTrees) {
    const n = this.boundsTrees, o = this._drawInfo || this._instanceInfo, r = this._drawRanges || this._geometryInfo, i = this.matrixWorld;
    _mesh.material = this.material, _mesh.geometry = this.geometry;
    const a = _mesh.geometry.boundsTree, s = _mesh.geometry.drawRange;
    null === _mesh.geometry.boundingSphere && (_mesh.geometry.boundingSphere = new Sphere());
    for (let a2 = 0, s2 = o.length; a2 < s2; a2++) {
      if (!this.getVisibleAt(a2)) continue;
      const s3 = o[a2].geometryIndex;
      if (_mesh.geometry.boundsTree = n[s3], this.getMatrixAt(a2, _mesh.matrixWorld).premultiply(i), !_mesh.geometry.boundsTree) {
        this.getBoundingBoxAt(s3, _mesh.geometry.boundingBox), this.getBoundingSphereAt(s3, _mesh.geometry.boundingSphere);
        const e2 = r[s3];
        _mesh.geometry.setDrawRange(e2.start, e2.count);
      }
      _mesh.raycast(e, _batchIntersects);
      for (let e2 = 0, n2 = _batchIntersects.length; e2 < n2; e2++) {
        const n3 = _batchIntersects[e2];
        n3.object = this, n3.batchId = a2, t.push(n3);
      }
      _batchIntersects.length = 0;
    }
    _mesh.geometry.boundsTree = a, _mesh.geometry.drawRange = s, _mesh.material = null, _mesh.geometry = null;
  } else origBatchedRaycastFunc.call(this, e, t);
}
function acceleratedMeshRaycast(e, t) {
  if (this.geometry.boundsTree) {
    if (this.isAuxClippingMesh) return;
    if (void 0 === this.material) return;
    try {
      tmpInverseMatrix.copy(this.matrixWorld).invert();
    } catch (e2) {
      return;
    }
    ray.copy(e.ray).applyMatrix4(tmpInverseMatrix), _worldScale.setFromMatrixScale(this.matrixWorld), direction.copy(ray.direction).multiply(_worldScale);
    const n = direction.length(), o = e.near / n, r = e.far / n, i = this.geometry.boundsTree;
    if (true === e.firstHitOnly) {
      const n2 = convertRaycastIntersect(i.raycastFirst(ray, this.material, o, r), this, e);
      n2 && t.push(n2);
    } else {
      const n2 = i.raycast(ray, this.material, o, r);
      for (let o2 = 0, r2 = n2.length; o2 < r2; o2++) {
        const r3 = convertRaycastIntersect(n2[o2], this, e);
        r3 && t.push(r3);
      }
    }
  } else origMeshRaycastFunc.call(this, e, t);
}
function computeBoundsTree(e = {}) {
  return this.boundsTree = new MeshBVH(this, e), this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}
var TONE_MAP_PARS = ["toneMapping", "toneMappingLook", "toneMappingMidTones", "toneMappingPhysicalScale", "toneMappingBrightness", "toneMappingContrast", "toneMappingChromaticAdaptation", "toneMappingWhiteColor", "toneMappingColorDifferentiation", "toneMappingExteriorDaylight", "toneMappingWhiteBalance", "toneMappingHighlights", "toneMappingShadows", "toneMappingSaturation", "toneMappingAperture", "toneMappingShutter", "toneMappingISO", "toneMappingVignetting"];
var _afterFirstRenderEvent = { type: "afterFirstRender" };
var _afterRenderEvent = { type: "afterRender" };
var _beforeRenderEvent = { type: "beforeRender" };
var _disposeEvent = { type: "dispose" };
var _pauseEvent = { type: "pause" };
var _resumeEvent = { type: "resume" };
var _sceneLoadEvent = { type: "sceneLoad" };
function recalcVerticalFov(e, t, n) {
  return 2 * RAD2DEG * Math.atan(Math.tan(DEG2RAD * e / 2) * t / n);
}
var App = class extends EventDispatcher {
  constructor(e, t = {}, n = null) {
    if (super(), this.container = e instanceof HTMLElement ? e : document.getElementById(e), this.scene = null, this.camera = null, this.clock = new Clock(), this.mixer = null, this.renderCallbacks = [], this.compileCallbacks = [], this.elapsed = 0, this.frame = 0, this.preloader = n, this.worldCubemapRes = 1024, this._pmremMaxTileSize = 256, this._lightProbeCubemapRes = 64, this._debugHelpers = [], this._debugModes = /* @__PURE__ */ new Set(), this.xrSession = null, this.xrCameraParent = null, this.xrControllers = [], t = t || {}, !Detector.checkWebGL()) {
      const e2 = t.webglErrorMsg || 'Ouch! Your device does not support WebGL.<br>Find out how to fix this <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.';
      return void Detector.showWebGLErrorMessage(this.container, e2);
    }
    ColorManagement.legacyMode = false;
    const o = {};
    o.alpha = !!isDef(t.alpha) && t.alpha, o.depth = !isDef(t.depth) || t.depth, o.stencil = !isDef(t.stencil) || t.stencil, o.antialias = !isDef(t.antialias) || t.antialias, o.premultipliedAlpha = !isDef(t.premultipliedAlpha) || t.premultipliedAlpha, o.preserveDrawingBuffer = !!isDef(t.preserveDrawingBuffer) && t.preserveDrawingBuffer, Detector.isSafariWithMultisamplingBug() && (console.warn("v3d.App: disabling buggy context AA on Safari 15.4"), o.antialias = false), this.renderer = new WebGLRenderer(o), Compat.prepareRenderer(this.renderer), this.clearBkgOnLoad = false, this.registerServiceKeys = true, this.frameRateDivider = 1, this.enableRender = true, this.disableRenderTrigger = 0, this.ssaaOnPause = false, this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight), this.renderer.outputEncoding = 3001, this.container.appendChild(this.renderer.domElement), this.container.classList.add("v3d-container"), this.renderer.domElement.classList.add("v3d-canvas"), this.container.setAttribute("translate", "no"), this._onContextRestoreCb = () => {
      this._onContextRestore();
    }, this.renderer.domElement.addEventListener("webglcontextrestored", this._onContextRestoreCb), this.loader = new GLTFLoader();
    const r = new KTX2Loader().setTranscoderPath(findModulePath()).detectSupport(this.renderer);
    this.loader.setKTX2Loader(r), BufferGeometry.prototype.computeBoundsTree = computeBoundsTree, BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree, Mesh.prototype.raycast = acceleratedRaycast, this.actions = [], this._envIBLMode = 0, this._envLightProbe = null, this._resizeCb = null, this._loadSceneURL = "", this._loadingTime = 0, this._webxrSave = { background: null, postprocessing: null, useOIT: false }, this.stats = null, AppUtils.drawWatermark(this), AppUtils.addToAppList(this), this.worldMaterial = null;
  }
  _updateRendererFromGLTF(e) {
    const t = this, n = Detector.checkHalfFloatTex(this.renderer, true);
    if (e.renderer.shadowMap && (this.renderer.shadowMap.enabled = e.renderer.shadowMap.enabled, this.renderer.shadowMap.type = e.renderer.shadowMap.type, n || 3 !== this.renderer.shadowMap.type || (this.renderer.shadowMap.type = 2, e.scene.traverse(function(e2) {
      e2.isLight && e2.castShadow && e2.shadow && (e2.shadow.bias /= 100);
    }))), this.aaMethod = e.renderer.aaMethod || "AUTO", this.useHDR = Boolean(e.renderer.useHDR && n), this.renderer.useOIT = e.renderer.useOIT ?? false, this.renderer.unitsScaleFactor = e.renderer.unitsScaleFactor ?? 1, e.renderer.toneMapping) for (let t2 = 0; t2 < TONE_MAP_PARS.length; t2++) {
      const n2 = TONE_MAP_PARS[t2];
      isDef(e.renderer[n2]) && (this.renderer[n2] = e.renderer[n2]);
    }
    void 0 !== e.renderer.pmremMaxTileSize && (this._pmremMaxTileSize = e.renderer.pmremMaxTileSize), void 0 !== e.renderer.iblEnvironmentMode && (this._envIBLMode = e.renderer.iblEnvironmentMode), void 0 !== e.renderer.esmDistanceScale && (this.renderer.shadowMap.esmDistanceScale = e.renderer.esmDistanceScale), e.scene.traverse(function(e2) {
      e2.hidpiCompositing && (e2.traverse((t2) => {
        e2.isMesh && (t2.layers.set(7), t2.isMaterialGeneratedMesh && e2.parent.layers.set(7));
      }), t.useHiDPIRenderPass = true, t.renderer.setPixelRatio(window.devicePixelRatio));
    }), t.useHiDPIRenderPass && e.scene.traverse(function(e2) {
      e2.isLight && e2.layers.enable(7);
    });
  }
  _updateMeshesRaycastFromGLTF(e) {
    e.scene && e.scene.traverse(function(e2) {
      const t = e2.geometry;
      e2.isMesh && (!t.computeBoundsTree || 0 !== Object.keys(t.morphAttributes).length || t.attributes.position.isInterleavedBufferAttribute || t.index && t.index.isInterleavedBufferAttribute || t.computeBoundsTree({ verbose: false }));
    });
  }
  _prepareReflProbesFromGLTF(e) {
    e.scene && e.scene.traverse((e2) => {
      if (e2.isCubeReflectionProbe) this._prepareEnvMapProbe(e2);
      else if (e2.isPlaneReflectionProbe) {
        let t = this._checkMSAA(this.renderer, 4);
        t > 0 && e2.makeMultisampleRenderTarget(t);
      }
    });
  }
  _prepareEnvMapProbe(e) {
    switch (e.setSize(this._pmremMaxTileSize), this._envIBLMode) {
      case 0:
        e.onUpdate = (e2) => this.generateRTargetPMREM(e2);
        break;
      case 1:
      case 2:
        e.onUpdate = () => null;
    }
  }
  _prepareReflProbesEncoding(e, t) {
    e.traverse((e2) => {
      (e2.isCubeReflectionProbe || e2.isPlaneReflectionProbe) && e2.setEncoding(t);
    });
  }
  _prepareEnvMapProbeWorld() {
    if (2 == this._envIBLMode) return;
    const e = new Scene();
    e.worldMaterial = this.scene.worldMaterial, null === this.scene.worldEnvMapProbe && (this.scene.worldEnvMapProbe = new CubeReflectionProbe(this._pmremMaxTileSize), this.scene.worldEnvMapProbe.influenceType = 0, this.scene.worldEnvMapProbe.parallaxType = 0);
    const t = this.scene.worldEnvMapProbe;
    switch (this._envIBLMode) {
      case 0:
        t.onUpdate = (e2) => this.generateRTargetPMREM(e2);
        break;
      case 1:
        t.onUpdate = (e2) => {
          const t2 = e2.clone();
          t2.setSize(this._lightProbeCubemapRes, this._lightProbeCubemapRes), Detector.checkHalfFloatReadPixels(this.renderer) ? t2.texture.type = 1016 : Detector.checkFloatReadPixels(this.renderer) ? t2.texture.type = 1015 : (console.warn("v3d.App: Target platform does not support reading pixels in float format, expect quality loss."), t2.texture.type = 1009), t2.texture.format = 1023, t2.texture.encoding = 3e3;
          const n = new CubeCopy(e2.texture);
          return n.render(this.renderer, t2), n.dispose(), this._disposeEnvLightProbe(), this._envLightProbe = LightProbeGenerator.fromCubeRenderTarget(this.renderer, t2), this.scene.add(this._envLightProbe), t2.dispose(), null;
        };
    }
    t.update(e, this.renderer);
  }
  _updateMaterialsFromGLTF(e) {
    const t = this;
    e.scene && e.scene.traverse(function(e2) {
      const n = e2.material;
      n && t.useHDR && (n.toneMapped = false, n.useFloatTex = Detector.checkFloatTex(t.renderer, true), n.isMeshNodeMaterial && n.updateNodeGraph(true));
    });
  }
  _updateAnimationsFromGLTF(e, t) {
    const n = this;
    !n.mixer && e.animations && e.animations.length && (n.mixer = new AnimationMixer(n.scene)), (e.animations || []).forEach(function(e2) {
      const o = t.getObjectById(e2.nodeId);
      if (o) {
        let r;
        r = o.id == t.id || "" !== o.name && "root" !== o.name && "." !== o.name && o.name !== t.name && o.name !== t.uuid ? n.mixer.clipAction(e2.clip, t) : n.mixer.clipAction(e2.clip, o), r.setLoop(e2.loop, e2.repetitions), r.startAt(e2.startAt + n.mixer.time), r.clampWhenFinished = true, e2.auto ? r.play() : (r.stop(), r.paused = true), n.actions.push(r);
      }
    });
  }
  _traverseSceneForTexUniforms(e, t) {
    e.traverse(function(e2) {
      if (e2.material) {
        (Array.isArray(e2.material) ? e2.material : [e2.material]).forEach(function(n) {
          void 0 !== n.program && t(e2, n, n.program.getTexUniformCount());
        });
      }
    });
  }
  _checkMSAA(e, t) {
    return Math.min(t, e.capabilities.maxSamples);
  }
  _precompileSceneAsync(e, t, n, o) {
    const r = this, i = r.compileCallbacks;
    for (let e2 = 0; e2 < i.length; e2++) i[e2](r);
    const a = r.renderer.getRenderTarget();
    r.renderer.setRenderTarget(n), r.renderer.compileAsync(e, t, function(e2) {
      e2 >= 1 && r.renderer.setRenderTarget(a), o && o(100 * e2);
    });
  }
  _handleAlphaToCoverage(e) {
    this.scene.traverse(function(t) {
      const n = t.material;
      n && n.alphaToCoverage && (e > 0 ? (n.transparent = false, n.premultipliedAlpha = false, n.blending = 0) : n.alphaToCoverage = false);
    });
  }
  _onContextRestore(e) {
    this.scene && this.scene.worldMaterial && (this.updateEnvironment(this.scene.worldMaterial), this.updateReflectionProbes(this.scene));
  }
  assignClippingPlanes(e) {
    const t = this;
    let n = [], o = [], r = [], i = -1e3;
    e.traverse(function(t2) {
      t2.isClippingPlaneObject && (n.push(t2), o.push(t2.plane), e.traverse(function(e2) {
        t2.needsClippingPlane(e2) && t2.assignToObject(e2, i++);
      }), r.push(i++));
    });
    for (let e2 = 0; e2 < n.length; e2++) {
      const t2 = n[e2];
      t2.crossSection && t2.createCrossSectionPlane(o, r[e2]);
    }
    n.length && (t.renderer.localClippingEnabled = true, t.postprocessing && t.postprocessing.composer.setStencil(true));
  }
  updateConstraints(e) {
    const t = this;
    e.traverse(function(n) {
      for (let o = 0; o < n.constraints.length; o++) {
        const r = n.constraints[o];
        r.isCanvasBreakpointsConstraint && (r.appInstance = t), r.isCanvasFitConstraint && (r.xr = t.renderer.xr), e.userData && e.userData.coordSystem && r.coordSystem && (r.coordSystem = e.userData.coordSystem);
      }
    });
  }
  loadScene(e, t, n, o) {
    const r = this;
    r.renderer ? (r._loadSceneURL = e, r._loadingTime = performance.now(), r.preloader && r.preloader.onUpdate(0), this.loader.load(e, function(e2) {
      r.scene = e2.scene || new Scene();
      let o2 = null;
      e2.cameras && e2.cameras.length ? r.camera = e2.cameras[0] : (o2 = calcSceneBox(r.scene), r.camera = createDefaultCamera(o2, r.container.offsetWidth / r.container.offsetHeight), r.scene.add(r.camera)), r.camera.controlSettings || (o2 = o2 || calcSceneBox(r.scene), assignDefaultControls(r.camera, calcSceneBox(r.scene)), r.camera.viewportFit.type = 1), r._updateRendererFromGLTF(e2), r._prepareReflProbesFromGLTF(e2), r._updateMaterialsFromGLTF(e2), r._updateAnimationsFromGLTF(e2, r.scene);
      const i = e2.world.material;
      i && (r.scene.background = new Color(), r.scene.worldMaterial = i, r.updateEnvironment(i), r.worldMaterial = i), r.initPostprocessing(), r.assignClippingPlanes(r.scene), r.updateConstraints(r.scene), r.onResize && r.onResize(), r.scene.updateWorldMatrix(false, true), r.scene.matrixWorldAutoUpdate = false, r.scene.visible = false, r.scene.disableChildRendering = true;
      const a = function() {
        r.scene && r._traverseSceneForTexUniforms(r.scene, function(e3, t2, n2) {
          n2 > 8 && console.warn(`v3d.App: Material "${t2.name}" on object "${e3.name}" exceeds iOS limit of 8 textures (has ${n2}).`);
        }), r.removeEventListener("afterFirstRender", a);
      }, s = r.postprocessing ? r.postprocessing.composer.renderTarget1 : null;
      r._precompileSceneAsync(r.scene, r.camera, s, function(o3) {
        const i2 = (60 + 0.4 * o3) / 1;
        n && n(i2), r.preloader && r.preloader.onUpdate(i2), i2 >= 100 && (r._updateMeshesRaycastFromGLTF(e2), r.addEventListener("afterFirstRender", a), t && setTimeout(function() {
          r.scene.visible = true, r.scene.disableChildRendering = false, r.updateReflectionProbes(r.scene), r._loadingTime = performance.now() - r._loadingTime, r.dispatchEvent({ ..._sceneLoadEvent }), t(r.scene);
        }, 16), e2 = null);
      }), r.clearBkgOnLoad && (r.scene.background = null), r.registerServiceKeys && AppUtils.registerServiceKeys(r);
    }, function(e2) {
      const t2 = 0.6 * e2 / 1;
      n && n(t2), r.preloader && r.preloader.onUpdate(t2);
    }, function(e2) {
      console.error(e2), o && o(e2);
    }), window.removeEventListener("resize", this._resizeCb, false), this._resizeCb = function() {
      r.onResize && r.onResize();
    }, window.addEventListener("resize", this._resizeCb, false)) : o && o("WebGL not found");
  }
  appendScene(e, t, n, o, r, i) {
    const a = this;
    a.renderer ? (void 0 === r && (r = true), void 0 === i && (i = true), a.preloader && a.preloader.onUpdate(0), this.loader.load(e, function(e2) {
      const o2 = e2.scene || new Scene(), s = [];
      o2.traverse(function(e3) {
        (e3.isCamera && !r || e3.isLight && !i) && s.push(e3);
      }), s.forEach(function(e3) {
        a.unload(e3);
      }), a.scene && (a.scene.add(o2), a._prepareReflProbesFromGLTF(e2), a._updateMaterialsFromGLTF(e2), a._updateAnimationsFromGLTF(e2, o2), a.scene.updateWorldMatrix(false, true));
      const l = a.postprocessing ? a.postprocessing.composer.renderTarget1 : null, c = a.scene || o2;
      a.assignClippingPlanes(c), a.updateConstraints(c), o2.visible = false, o2.disableChildRendering = true, a._precompileSceneAsync(c, a.camera || new Camera(), l, function(r2) {
        const i2 = (60 + 0.4 * r2) / 1;
        n && n(i2), a.preloader && a.preloader.onUpdate(i2), i2 >= 100 && (a._updateMeshesRaycastFromGLTF(e2), a._traverseSceneForTexUniforms(o2, function(e3, t2, n2) {
          n2 > 8 && console.warn(`v3d.App: Material "${t2.name}" on object "${e3.name}" exceeds iOS limit of 8 textures (has ${n2}).`);
        }), t && setTimeout(function() {
          o2.visible = true, o2.disableChildRendering = false, a.updateReflectionProbes(a.scene), t(o2);
        }, 16), e2 = null);
      });
    }, function(e2) {
      const t2 = 0.6 * e2 / 1;
      n && n(t2), a.preloader && a.preloader.onUpdate(t2);
    }, function(e2) {
      console.error(e2), o && o(e2);
    })) : o && o("WebGL not found");
  }
  unload(e) {
    const t = this;
    function n(e2) {
      if (e2.isAnnotation) e2.dispose();
      else if (e2.isLight && e2.shadow && e2.shadow.isLightShadow) e2.shadow.dispose();
      else if (e2.isCamera && e2.controlSettings && e2.controlSettings.orbitTarget) n(e2.controlSettings.orbitTarget);
      else if (e2.isScene) {
        const t2 = e2.worldMaterial;
        null !== t2 && (disposeTextures(t2), t2.dispose()), null !== e2.worldEnvMapProbe && (e2.worldEnvMapProbe.dispose(), e2.worldEnvMapProbe = null);
      } else if (e2.isMesh) {
        e2.geometry.dispose(), e2.geometry.disposeBoundsTree && e2.geometry.disposeBoundsTree();
        const t2 = e2.material;
        disposeTextures(t2), t2.dispose();
      }
    }
    if (e || (e = t.scene), e === t.scene) {
      if (t.scene && (t.scene.traverse(n), t.disposeEnvironment(), t.worldMaterial = null), t.scene = null, t.disableControls(), t.camera = null, t.mixer && (t.mixer.stopAllAction(), t.actions.forEach(function(e2) {
        t.mixer.uncacheAction(e2.getClip(), e2.getRoot());
      })), t.mixer = null, t.actions = [], t.postprocessing) {
        if (t.postprocessing.composer) for (let e2 in t.postprocessing) {
          const n2 = t.postprocessing[e2];
          (n2 instanceof Pass || n2 instanceof EffectComposer) && n2.dispose();
        }
        t.disablePostprocessing();
      }
      t.postprocessing = null, FullScreenQuad.dispose(), t.renderer && t.renderer.disposeInternalCaches(), AppUtils.unregisterServiceKeys(t), t.useHiDPIRenderPass = false, t.renderer.setPixelRatio(1);
    } else if (t.scene && (e.traverse(n), e.parent && e.parent.remove(e)), t.mixer) for (let e2 = t.actions.length - 1; e2 >= 0; e2--) {
      const n2 = t.actions[e2];
      checkActionIsUsed(t.scene, n2) || (n2.stop(), t.mixer.uncacheAction(n2.getClip(), n2.getRoot()), t.actions.splice(e2, 1));
    }
  }
  dispose() {
    this.scene && this.unload(), this.renderer && (this.renderer.forceContextLoss(), this.renderer.dispose(), this.renderer.domElement.removeEventListener("webglcontextrestored", this._onContextRestoreCb), this._onContextRestoreCb = null, this.renderer.domElement.parentElement === this.container && this.container.removeChild(this.renderer.domElement)), this.renderer = null, this.loader = null, window.removeEventListener("resize", this._resizeCb, false), this._resizeCb = null, this.renderCallbacks.length = 0, this.compileCallbacks.length = 0, AppUtils.removeFromAppList(this), Cache.clear(), this.dispatchEvent({ ..._disposeEvent }), delete this._listeners;
  }
  getWidth() {
    return this.container.offsetWidth;
  }
  getHeight() {
    return this.container.offsetHeight;
  }
  onResize() {
    if (!this.renderer) return;
    this.enableRender && !this.ssaaOnPause || (this.enableRendering(), this.disableRendering(1));
    const e = this.getWidth(), t = this.getHeight();
    if (this.renderer.setSize(e, t), this.postprocessing && (this.postprocessing.gtaoGenerator && this.postprocessing.gtaoGenerator.setSize(e, t), this.postprocessing.composer.setSize(e, t)), this.scene) {
      this.scene.traverse((n2) => {
        n2.isPlaneReflectionProbe && n2.setSize(e, t);
      });
      const n = e / t, o = this.camera;
      if (o.isPerspectiveCamera) {
        const e2 = o.aspect < o.viewportFit.initialAspect, t2 = n < o.viewportFit.initialAspect;
        switch (o.viewportFit.type) {
          case 1:
            o.aspect = n;
            break;
          case 2:
            o.fov = recalcVerticalFov(o.fov, o.aspect, n), o.aspect = n;
            break;
          case 3:
            e2 && t2 ? o.fov = recalcVerticalFov(o.fov, o.aspect, n) : e2 && !t2 ? o.fov = recalcVerticalFov(o.fov, o.aspect, o.viewportFit.initialAspect) : !e2 && t2 && (o.fov = recalcVerticalFov(o.fov, o.viewportFit.initialAspect, n)), o.aspect = n;
            break;
          case 5:
            e2 && t2 ? o.fov = recalcVerticalFov(o.fov, o.aspect, n) : e2 && !t2 ? o.fov = recalcVerticalFov(o.fov, o.viewportFit.initialAspect, n) : !e2 && t2 && (o.fov = recalcVerticalFov(o.fov, o.aspect, n)), o.aspect = n;
            break;
          case 4:
            e2 || t2 ? e2 && !t2 ? o.fov = recalcVerticalFov(o.fov, o.viewportFit.initialAspect, n) : !e2 && t2 && (o.fov = recalcVerticalFov(o.fov, o.aspect, o.viewportFit.initialAspect)) : o.fov = recalcVerticalFov(o.fov, o.aspect, n), o.aspect = n;
        }
      } else if (o.isOrthographicCamera) {
        let e2, t2;
        switch (o.viewportFit.type) {
          case 1:
          case 5:
            e2 = o.top * n, o.left = -e2, o.right = e2;
            break;
          case 2:
          case 4:
            t2 = o.right / n, o.bottom = -t2, o.top = t2;
            break;
          case 3:
            const r = (o.right - o.left) / (o.top - o.bottom) < o.viewportFit.initialAspect, i = n < o.viewportFit.initialAspect;
            e2 = r && i ? o.right : r && !i ? o.right * n / o.viewportFit.initialAspect : !r && i ? o.top * o.viewportFit.initialAspect : o.top * n, o.left = -e2, o.right = e2, o.bottom = -e2 / n, o.top = e2 / n;
        }
      }
      o.updateProjectionMatrix();
    }
  }
  run() {
    this.preloader && (this.preloader.onFinish(), this.preloader = null), this.animate();
  }
  animate() {
    const e = this;
    e.renderer.setAnimationLoop(function() {
      e.stats && e.stats.begin();
      const t = e.clock.getDelta();
      e.elapsed = t, e.mixer && e.mixer.update(t), e.controls && !e.xrSession && e.controls.update(t);
      const n = e.renderCallbacks;
      for (let o = 0; o < n.length; o++) n[o](t, e.clock.elapsedTime);
      e.frame % e.frameRateDivider == 0 && e.enableRender && (e.render(), 0 === e.frame && e.dispatchEvent({ ..._afterFirstRenderEvent })), e.frame++, e.disableRenderTrigger && 0 == --e.disableRenderTrigger && (e.enableRender = false), e.stats && e.stats.end();
    });
  }
  enableRendering() {
    this.disableRenderTrigger = 0, this.enableRender = true, this.ssaaOnPause && this.enableSSAA(0, true);
  }
  disableRendering(e) {
    this.xrSession || (((e = e || 0) || this.ssaaOnPause) && this.enableRender && 0 == this.disableRenderTrigger ? (this.disableRenderTrigger = this.ssaaOnPause ? 32 : e, this.ssaaOnPause && this.enableSSAA(4, true)) : 0 == e && (this.enableRender = false));
  }
  pause() {
    this.renderer.setAnimationLoop(null), this.clock.stop(), this.dispatchEvent({ ..._pauseEvent });
  }
  resume() {
    this.animate(), this.clock.start(), this.dispatchEvent({ ..._resumeEvent });
  }
  setFrameRateDivider(e) {
    this.frameRateDivider = e;
  }
  render() {
    this.dispatchEvent({ ..._beforeRenderEvent });
    const e = !!this.scene && !!this.camera;
    if (e && (this.scene.updateMatrixWorld(), this.scene.traverse((e2) => {
      e2.isPlaneReflectionProbe && e2.update(this.scene, this.camera, this.renderer);
    })), this.renderer.gtaoMapEnabled = true, this.postprocessing) {
      const e2 = this.postprocessing.gtaoGenerator;
      e2 && e2.render(this.renderer);
      this.postprocessing.composer.render(this.elapsed);
    } else e && this.renderer.render(this.scene, this.camera);
    if (e && this.useHiDPIRenderPass) {
      const e2 = this.camera.layers.mask, t = this.scene.background, n = this.renderer.autoClear, o = this.renderer.useOIT;
      this.camera.layers.set(7), this.scene.background = null, this.renderer.autoClear = false, this.renderer.useOIT = false, this.renderer.clearDepth(), this.renderer.render(this.scene, this.camera), this.camera.layers.mask = e2, this.scene.background = t, this.renderer.autoClear = n, this.renderer.useOIT = o;
    }
    this.renderer.gtaoMapEnabled = false, this.dispatchEvent({ ..._afterRenderEvent });
  }
  enableControls(e) {
    const t = this.camera;
    if (!t.controlSettings) return;
    const n = t.controlSettings.type;
    if (this.controls && t === this.controls.object && (this.controls instanceof OrbitControls && "ORBIT" === n || this.controls instanceof FlyingControls && "FLYING" === n || this.controls instanceof FirstPersonControls && "FIRST_PERSON" === n)) ;
    else switch (this.disableControls(), n) {
      case "ORBIT":
        this.controls = new OrbitControls(t, e || this.renderer.domElement);
        break;
      case "FLYING":
        this.controls = new FlyingControls(t, this.renderer.domElement);
        break;
      case "FIRST_PERSON":
        this.controls = new FirstPersonControls(t, this.renderer.domElement);
        break;
      default:
        this.controls = null;
    }
    this.controls && (t.controlSettings.assignToControls(this.controls, this.scene), this.controls.update());
  }
  disableControls() {
    this.controls && (this.controls.dispose(), this.controls = null);
  }
  setCamera(e) {
    let t = [];
    if (this.camera) for (let e2 = this.camera.children.length - 1; e2 >= 0; e2--) {
      const n = this.camera.children[e2];
      n instanceof AudioListener && (t.push(n), n.removeFromParent());
    }
    if (this.camera = e, this.postprocessing) {
      const t2 = this.postprocessing.composer.passes;
      for (let n = 0; n < t2.length; n++) t2[n].setCamera(e);
      this.postprocessing.renderPass && this.postprocessing.renderPass.setCamera(e), this.postprocessing.ssaaRenderPass && this.postprocessing.ssaaRenderPass.setCamera(e), this.postprocessing.gtaoGenerator && this.postprocessing.gtaoGenerator.setCamera(e);
    }
    e.controlSettings ? this.enableControls() : this.disableControls();
    for (let n = 0; n < t.length; n++) e.add(t[n]);
    this.onResize();
  }
  getCamera(e = false) {
    return e && this.camera && this.renderer && this.renderer.xr.enabled && this.renderer.xr.isPresenting ? this.renderer.xr.getCamera() : this.camera;
  }
  initPostprocessing() {
    (this.scene.postprocessing && this.scene.postprocessing.length || this.useHDR || this.useHiDPIRenderPass || "AUTO" != this.aaMethod || this.renderer.useOIT) && this.enablePostprocessing(this.scene.postprocessing || []), this.renderer.useOIT && (this.useHiDPIRenderPass ? console.warn("v3d.App: Order-Independent Transparency is not compatible with HiDPI Compositing, disabling OIT") : this.renderer.setOIT(1, this.postprocessing.composer.writeBuffer.samples)), this.postprocessing || this._handleAlphaToCoverage(this.renderer.getContextAttributes().antialias ? 4 : 0);
  }
  enablePostprocessing(e) {
    if (this.xrSession) return;
    const t = { format: 1023, stencilBuffer: false };
    let n;
    if (this.useHDR ? (t.type = 1016, t.encoding = 3e3) : (t.type = 1009, t.encoding = 3001), this._prepareReflProbesEncoding(this.scene, t.encoding), this.postprocessing) n = this.postprocessing.composer;
    else {
      this.postprocessing = {};
      const e2 = new RenderPass(this.scene, this.camera);
      this.postprocessing.renderPass = e2;
      let o = 0;
      switch (this.aaMethod) {
        case "AUTO":
        case "MSAA4":
          o = this._checkMSAA(this.renderer, 4);
          break;
        case "MSAA8":
          o = this._checkMSAA(this.renderer, 8);
          break;
        case "MSAA16":
          o = this._checkMSAA(this.renderer, 16);
      }
      Detector.checkSwiftShader(this.renderer) && (console.warn("v3d.App: disabling buggy multisampling on SwiftShader renderer"), o = 0), Detector.isSafariWithMultisamplingBug() && (console.warn("v3d.App: disabling buggy multisampling on Safari 15.4"), o = 0);
      const r = new WebGLRenderTarget(this.getWidth(), this.getHeight(), t);
      r.texture.name = "EffectComposer.rt1", r.samples = o, n = new EffectComposer(this.renderer, r), n.addPass(e2), this.postprocessing.composer = n;
      const i = this.renderer.getContextAttributes().alpha, a = 0 == o && "NONE" != this.aaMethod, s = new ToneMapPass();
      if (a && !i && (s.material.defines.ALPHA_AS_LUMA = 1), this.useHDR || (s.material.toneMapped = false), n.addPass(s), this.postprocessing.toneMapPass = s, a) {
        const e3 = new FXAAPass(this.scene, this.camera);
        this.useHDR && !i && (e3.material.defines.FXAA_GREEN_AS_LUMA = 0), n.addPass(e3), this.postprocessing.fxaaPass = e3;
      }
      this._handleAlphaToCoverage(o);
    }
    e.length && this.postprocessing.copyPass && (n.passes.splice(n.passes.indexOf(this.postprocessing.copyPass), 1), this.postprocessing.copyPass = null);
    for (let o = 0; o < e.length; o++) {
      const r = e[o];
      let i = n.passes.length - 1;
      switch (n.passes[i] instanceof FXAAPass && i--, r.type) {
        case "afterimage":
          const e2 = r.damp;
          let o2;
          this.postprocessing.afterimagePass ? (o2 = this.postprocessing.afterimagePass, o2.damp = e2) : (o2 = new AfterimagePass(new Vector2(this.getWidth(), this.getHeight()), e2, t), n.insertPass(o2, i), this.postprocessing.afterimagePass = o2);
          break;
        case "bloom":
          const a = r.strength, s = r.radius, l = r.threshold;
          let c;
          this.postprocessing.bloomPass ? (c = this.postprocessing.bloomPass, c.strength = a, c.radius = s, c.threshold = l) : (c = new BloomPass(new Vector2(this.getWidth(), this.getHeight()), a, s, l, t), n.insertPass(c, i), this.postprocessing.bloomPass = c);
          break;
        case "brightnessContrast":
          let u;
          this.postprocessing.brightnessContrastPass ? u = this.postprocessing.brightnessContrastPass : (u = new BrightnessContrastPass(), n.insertPass(u, i), this.postprocessing.brightnessContrastPass = u), u.brightness = r.brightness, u.contrast = r.contrast;
          break;
        case "dof":
          let d;
          this.postprocessing.bokehPass ? d = this.postprocessing.bokehPass : (d = new BokehPass(this.scene, this.camera, { width: this.getWidth(), height: this.getHeight() }), n.insertPass(d, i), this.postprocessing.bokehPass = d), d.focus = r.focus, d.aperture = r.aperture, d.maxblur = r.maxblur, d.depthLeakThreshold = r.depthLeakThreshold;
          break;
        case "grayscale":
          if (!this.postprocessing.grayscalePass) {
            const e3 = new GrayscalePass();
            n.insertPass(e3, i), this.postprocessing.grayscalePass = e3;
          }
          break;
        case "gtao":
          if (!Detector.checkDepthTex(this.renderer)) {
            console.warn("v3d.App: disabling GTAO since your hardware does not support depth textures");
            break;
          }
          if ("ARM" === Detector.getGPUVendor(this.renderer) && Detector.getGPUModel(this.renderer).startsWith("Mali-")) {
            console.warn("v3d.App: disabling buggy GTAO on Mali devices");
            break;
          }
          let h = this.postprocessing.gtaoGenerator;
          if (!h) {
            h = this.postprocessing.gtaoGenerator = new GTAOMapGenerator(this.scene, this.camera, this.getWidth(), this.getHeight());
            const e3 = (t2) => {
              h.removeEventListener("dispose", e3), this.renderer.disposeGTAO();
            };
            h.addEventListener("dispose", e3), this.renderer.gtaoMap = h.renderTarget.texture;
          }
          h.distance = r.distance, h.factor = r.factor, h.precision = r.precision, h.bentNormals = r.bentNormals ?? false;
          break;
        case "outline":
          let f;
          this.postprocessing.outlinePass ? f = this.postprocessing.outlinePass : (f = new OutlinePass(new Vector2(this.getWidth(), this.getHeight()), this.scene, this.camera), n.insertPass(f, i), this.postprocessing.outlinePass = f), f.edgeStrength = r.edgeStrength, f.edgeGlow = r.edgeGlow, f.edgeThickness = r.edgeThickness, f.pulsePeriod = r.pulsePeriod, f.visibleEdgeColor.fromArray(r.visibleEdgeColor), f.hiddenEdgeColor.fromArray(r.hiddenEdgeColor), f.hiddenEdgeColor.setW(Number(r.renderHiddenEdge));
          break;
        case "ssr":
          if (!Detector.checkHalfFloatTex(this.renderer, false)) {
            console.warn("v3d.App: disabling SSR since your hardware does not support half float textures");
            break;
          }
          const p = isDef(r.useRefract) && r.useRefract, m = isDef(r.simpleRefraction) && r.simpleRefraction;
          let g;
          g = p && !m ? this.postprocessing.ssrPassRefract : p && m ? this.postprocessing.ssrPassSimpleRefract : this.postprocessing.ssrPassReflect, g || (g = new SSRPass(this.scene, this.camera), n.insertPassAfter(g, [this.postprocessing.renderPass, this.postprocessing.ssrPassRefract, this.postprocessing.ssrPassReflect, this.postprocessing.ssrPassSimpleRefract]), p && !m ? this.postprocessing.ssrPassRefract = g : p && m ? this.postprocessing.ssrPassSimpleRefract = g : this.postprocessing.ssrPassReflect = g), g.useRefract = p, g.simpleRefraction = m, isDef(r.objects) && (g.objects = r.objects), isDef(r.intensity) && (g.intensity = r.intensity), isDef(r.steps) && (g.steps = r.steps), isDef(r.stride) && (g.stride = r.stride), isDef(r.binarySearchSteps) && (g.binarySearchSteps = r.binarySearchSteps), isDef(r.renderTargetScale) && (g.renderTargetScale = r.renderTargetScale), isDef(r.thickness) && (g.thickness = r.thickness), isDef(r.maxDistance) && (g.maxDistance = r.maxDistance), isDef(r.jitter) && (g.jitter = r.jitter), isDef(r.renderAfter) && (g.renderAfter = r.renderAfter), this.onResize && this.onResize();
          break;
        default:
          console.error(`v3d.App: wrong postprocessing effect "${r.type}"`);
      }
    }
    if (1 == n.passes.length) {
      const e2 = new ShaderPass(ShaderLib.copy);
      n.passes.push(e2), this.postprocessing.copyPass = e2;
    }
  }
  disablePostprocessing(e, t) {
    if (!this.postprocessing) return;
    const n = this.postprocessing.gtaoGenerator;
    !t && n && (n.dispose(), this.postprocessing.gtaoGenerator = null);
    const o = ["afterimagePass", "bloomPass", "brightnessContrastPass", "bokehPass", "grayscalePass", "ssrPassReflect", "ssrPassRefract", "ssrPassSimpleRefract"];
    e || o.push("outlinePass");
    const r = this.postprocessing.composer;
    for (let e2 = 0; e2 < o.length; e2++) {
      const t2 = o[e2];
      this.postprocessing[t2] && (r.passes.splice(r.passes.indexOf(this.postprocessing[t2]), 1), this.postprocessing[t2].dispose(), this.postprocessing[t2] = null);
    }
    if ("AUTO" != this.aaMethod || 1 != r.passes.length || this.postprocessing.gtaoGenerator) {
      if (1 == r.passes.length) {
        const e2 = new ShaderPass(ShaderLib.copy);
        r.passes.push(e2), this.postprocessing.copyPass = e2;
      }
    } else this.postprocessing.renderPass.dispose(), this.postprocessing.composer.dispose(), this.postprocessing = null;
  }
  enableSSAA(e, t) {
    if (this.postprocessing || this.enablePostprocessing([]), !this.postprocessing) return;
    if (e > 0 && (this.postprocessing.ssrPassRefract || this.postprocessing.ssrPassReflect)) return;
    const n = this;
    this.scene.traverse(function(t2) {
      t2.isAnnotationControl && (t2.update(n.camera), t2.doUpdate = !Boolean(e));
    });
    const o = this.postprocessing.composer;
    if (e > 0 && o.passes[0] instanceof RenderPass) {
      let r;
      this.postprocessing.ssaaRenderPass ? r = this.postprocessing.ssaaRenderPass : (r = new SSAARenderPass(this.scene, this.camera), this.postprocessing.ssaaRenderPass = r, t && r.addEventListener("iteration", function(t2) {
        t2.frame == e * e - 1 && (o.enableAllPasses(), o.renderToScreen = true, o.passes[o.passes.length - 1].renderToScreen = true, n.disableRenderTrigger = 1);
      })), r.sampleLevel = e || 4, o.passes[0] = r, this.postprocessing.fxaaPass && o.passes.splice(o.passes.length - 1, 1), t && (r.iterative = true, r.iterativeFrame = 0, o.disableAllPasses(), o.renderToScreen = false, r.enabled = true);
    } else e > 0 ? (o.passes[0].sampleLevel = e || 4, t && (ssaaRenderPass.iterative = true, ssaaRenderPass.iterativeFrame = 0, o.disableAllPasses(), o.renderToScreen = false, ssaaRenderPass.enabled = true)) : 0 == e && o.passes[0] instanceof SSAARenderPass && (o.passes[0] = this.postprocessing.renderPass, this.postprocessing.fxaaPass && o.passes.push(this.postprocessing.fxaaPass), o.enableAllPasses(), o.renderToScreen = true);
  }
  updateEnvironment(e) {
    const t = this.renderer.xr.enabled;
    if (this.renderer.xr.enabled = false, this.disposeEnvironment(), e.toneMapped = false, null !== this.scene.background) {
      const t2 = 0 === this.renderer.toneMapping ? e.worldMaterialColor() : null;
      null !== t2 ? this.scene.background = t2 : (this.scene.background = renderWorldNodeMatToCubemap(this.renderer, e, this.worldCubemapRes, { encoding: 3001, format: 1023, generateMipmaps: true, minFilter: 1008, type: 1016 }).texture, this.scene.backgroundToneMapped = !this.useHDR);
    }
    0 === this._envIBLMode && new PMREMGenerator(this.renderer, this._pmremMaxTileSize, true).compileCubemapShader(), this._prepareEnvMapProbeWorld(), this.renderer.xr.enabled = t;
  }
  disposeEnvironment() {
    this._disposeEnvLightProbe();
    let e = this.scene.background;
    e && e && (e.isTexture || e.isCubeTexture) && e.dispose();
  }
  _disposeEnvLightProbe() {
    null !== this._envLightProbe && (this.scene.remove(this._envLightProbe), this._envLightProbe = null);
  }
  updateReflectionProbes(e) {
    e.traverse((e2) => {
      e2.isCubeReflectionProbe && e2.update(this.scene, this.renderer);
    });
  }
  generateRTargetPMREM(e) {
    if (!e.isWebGLCubeRenderTarget) return null;
    const t = new PMREMGenerator(this.renderer, this._pmremMaxTileSize, true), n = t.fromCubemap(e.texture);
    return t.dispose(), n;
  }
  initWebXR(e, t, n, o, r, i) {
    n = n || function() {
    }, o = o || function() {
    }, r = r || function() {
    }, i = i || {};
    const a = this;
    function s(e2) {
      a.xrSession.removeEventListener("end", s), r();
      for (let e3 = 0; e3 < a.xrControllers.length; e3++) {
        const t2 = a.xrControllers[e3];
        t2.removeEventListener("connected", l), a.scene.remove(t2);
      }
      if (a.xrControllers = [], a.xrCameraParent) {
        const e3 = a.camera;
        e3.removeFromParent(), a.scene.add(e3), a.scene.remove(a.xrCameraParent), a.xrCameraParent = null;
      }
      if (a.xrSession = null, a._webxrSave.background && (a.scene.background = a._webxrSave.background, a._webxrSave.background = null), a.postprocessing = a._webxrSave.postprocessing, a._webxrSave.postprocessing = null, a.postprocessing) {
        const e3 = a.postprocessing.gtaoGenerator;
        e3 && (a.renderer.gtaoMap = e3.renderTarget.texture);
      }
      a.renderer.useOIT = a._webxrSave.useOIT, a._webxrSave.useOIT = false, a.onResize();
    }
    function l(e2) {
      const t2 = e2.data, n2 = e2.target;
      if ("tracked-pointer" == t2.targetRayMode) {
        const e3 = new BufferGeometry().setFromPoints([new Vector3(0, 0, 0), new Vector3(0, 0, -1)]), t3 = new Line(e3);
        t3.name = n2.name + "_RAY", t3.scale.z = 5, n2.add(t3);
      } else if ("gaze" == t2.targetRayMode) {
        const e3 = new TextureLoader().load(VRReticleImage), t3 = new SpriteMaterial({ map: e3, sizeAttenuation: false }), o2 = new Sprite(t3);
        o2.name = n2.name + "_RETICLE", o2.scale.multiplyScalar(0.1), o2.position.z = -5, n2.add(o2);
      }
      n2.userData.inputSource = t2;
    }
    function c(e2) {
      const t2 = e2.target;
      a.xrSession || t2.removeEventListener("disconnected", c);
      for (let e3 = t2.children.length - 1; e3 >= 0; e3--) {
        const n2 = t2.children[e3];
        n2.name.indexOf(t2.name) > -1 && (n2.geometry.dispose(), n2.material.dispose(), t2.remove(n2));
      }
    }
    const u = { optionalFeatures: [t] };
    "immersive-ar" == e && (u.optionalFeatures.push("hit-test"), i.domOverlay && (u.optionalFeatures.push("dom-overlay"), u.domOverlay = { root: a.container })), navigator.xr.requestSession(e, u).then(function(o2) {
      a._webxrSave.postprocessing = a.postprocessing, a.postprocessing = null, a._webxrSave.useOIT = a.renderer.useOIT, a.renderer.useOIT = false, a.renderer.xr.setReferenceSpaceType(t), a.xrSession = o2, o2.addEventListener("end", s);
      const r2 = "immersive-vr" == e ? 2 : 1;
      for (let e2 = 0; e2 < r2; e2++) {
        const t2 = a.renderer.xr.getController(e2);
        a.scene.add(t2), a.xrControllers.push(t2), t2.addEventListener("connected", l), t2.addEventListener("disconnected", c);
      }
      if ("immersive-vr" == e) {
        const e2 = a.camera;
        e2.parent && e2.parent.isScene && (a.xrCameraParent = new Object3D(), a.xrCameraParent.name = "XR_CAMERA_CONTROL_OBJECT", a.scene.add(a.xrCameraParent), e2.removeFromParent(), a.xrCameraParent.add(e2));
      } else a._webxrSave.background = a.scene.background, a.scene.background = null;
      a.renderer.xr.enabled = true, a.renderer.xr.setSession(o2), i.domOverlay && a.renderer.xr.addEventListener("sessionstart", function() {
        setTimeout(function() {
          a.renderer.domElement.style.width = a.getWidth() + "px", a.renderer.domElement.style.height = a.getHeight() + "px";
        }, 300);
      }), n();
    }).catch(o);
  }
  endWebXR() {
    this.xrSession && this.xrSession.end();
  }
  printPerformanceInfo(e) {
    AppUtils.printPerformanceInfo(this, e);
  }
  showFPS() {
    if (this.container) {
      this.hideFPS();
      const e = new Stats();
      e.showPanel(0), this.container.appendChild(e.dom), this.stats = e;
    }
  }
  hideFPS() {
    this.container && this.stats && (this.container.removeChild(this.stats.dom), this.stats = null);
  }
  enableDebugMode(e) {
    this.hasDebugMode(e) && this.disableDebugMode(e), this.scene.traverse((t) => {
      let n = null, o = false;
      if (!this._debugHelpers.includes(t) && !this._debugHelpers.includes(t.parent)) {
        if ("wireframes" == e && t.isMesh) n = new WireframeHelper(t, "white");
        else if ("lights" == e) t.isDirectionalLight ? (n = new DirectionalLightHelper(t, 0.5, "yellow"), o = true) : t.isSpotLight ? (n = new SpotLightHelper(t, "yellow"), o = true) : t.isPointLight ? (n = new PointLightHelper(t, 0.1, "yellow"), o = true) : t.isRectAreaLight && (n = new RectAreaLightHelper(t, "yellow"));
        else if ("skeletons" == e && t.isBone) {
          let e2 = false;
          t.traverseAncestors((t2) => {
            t2.isBone && (e2 = true);
          }), e2 || (n = new SkeletonHelper(t));
        } else "normals" == e && t.isMesh && (n = new VertexNormalsHelper(t, 0.1));
        null !== n && (n.name = t.name + "Helper", n.visible = t.visible, t.add(n), o && n.update(), this._debugHelpers.push(n), this._debugModes.add(e));
      }
    });
  }
  disableDebugMode(e) {
    const t = { wireframes: ["WireframeHelper"], lights: ["DirectionalLightHelper", "SpotLightHelper", "PointLightHelper", "RectAreaLightHelper"], skeletons: ["SkeletonHelper"], normals: ["VertexNormalsHelper"] };
    for (let n = this._debugHelpers.length - 1; n >= 0; n--) {
      const o = this._debugHelpers[n];
      t[e].includes(o.type) && (o.removeFromParent(), this._debugHelpers.splice(n, 1));
    }
    this._debugModes.delete(e);
  }
  hasDebugMode(e) {
    return this._debugModes.has(e);
  }
};
function SSAOPass() {
  console.error("v3d.SSAOPass has been removed, use v3d.GTAOMapGenerator instead");
}
function BlenderTextGeometry() {
  console.error("v3d.BlenderTextGeometry has been removed, use v3d.TextGeometry instead.");
}
function BlenderTextBufferGeometry() {
  console.error("v3d.BlenderTextBufferGeometry has been removed, use v3d.TextGeometry instead.");
}
function AnimationLoader() {
  console.error("v3d.AnimationLoader has been removed, use glTF format for asset loading.");
}
function BufferGeometryLoader() {
  console.error("v3d.BufferGeometryLoader has been removed, use glTF format for asset loading.");
}
function MaterialLoader() {
  console.error("v3d.MaterialLoader has been removed, use glTF format for asset loading.");
}
function ObjectLoader() {
  console.error("v3d.ObjectLoader has been removed, use glTF format for asset loading.");
}
var MeshPhongMaterial = class extends MeshLambertMaterial {
  constructor(e) {
    console.error("v3d.MeshPhongMaterial has been removed, use node-based or standard material instead."), super(e);
  }
};
var MeshToonMaterial = class extends MeshLambertMaterial {
  constructor(e) {
    console.error("v3d.MeshToonMaterial has been removed, use node-based material instead."), super(e);
  }
};
var MeshMatcapMaterial = class extends MeshLambertMaterial {
  constructor(e) {
    console.error("v3d.MeshMatcapMaterial has been removed, use node-based material instead."), super(e);
  }
};
BufferGeometry.prototype.toJSON = function() {
  return console.error("v3d.BufferGeometry.toJSON() has been removed, use glTF format for export."), {};
}, Object3D.prototype.toJSON = function() {
  return console.error("v3d.Object3D.toJSON() has been removed, use glTF format for export."), {};
}, Material.prototype.toJSON = function() {
  return console.error("v3d.Material.toJSON() has been removed, use glTF format for export."), {};
}, Object.defineProperty(MeshPhysicalMaterial.prototype, "iridescence", { get: () => (console.warn("v3d.MeshPhysicalMaterial: iridescence has been removed, use node-based material instead."), 0), set(e) {
  console.warn("v3d.MeshPhysicalMaterial: iridescence has been renamed, use node-based material instead.");
} }), Object.defineProperty(MeshPhysicalMaterial.prototype, "sheen", { get: () => (console.warn("v3d.MeshPhysicalMaterial: sheen has been removed, use node-based material instead."), 0), set(e) {
  console.warn("v3d.MeshPhysicalMaterial: sheen has been renamed, use node-based material instead.");
} }), MeshNodeMaterial.nodeGraphDiffuse = function(e, t, n) {
  console.error("v3d.MeshNodeMaterial.nodeGraphDiffuse has been deprecated. Use v3d.MaterialUtils.createDiffuseMaterial instead.");
  return createDiffuseMaterial("", e, t, n).nodeGraph;
};
var PCFSoftShadowMap = 2;
var PCFShadowMapPoissonDisk = 2;
var CameraUtils = { calcCameraZoomToObjectsParams: function() {
  var e = new Box3(), t = new Sphere();
  return function(n, o, r, i, a) {
    var s = e.makeEmpty();
    o.forEach(function(e2) {
      s.expandByObject(e2);
    });
    var l = s.getBoundingSphere(t);
    CameraUtils.calcCameraZoomToSphereParams(n, l, r, i, a);
  };
}(), calcCameraZoomToSphereParams: function() {
  const e = new Vector3();
  return function(t, n, o, r, i) {
    if (t.isOrthographicCamera) {
      let e2 = Math.min(t.top, t.right);
      i[0] = e2 / n.radius, o.setFromMatrixPosition(t.matrixWorld), r.copy(n.center);
    } else {
      let i2 = degToRad(t.fov / 2);
      t.aspect < 1 && (i2 = Math.atan(t.aspect * Math.tan(i2)));
      let a = n.radius / Math.sin(i2);
      const s = t.getWorldDirection(e);
      o.copy(n.center).addScaledVector(s, -a), r.copy(n.center);
    }
  };
}() };
var CSVParser = { normalizeDialectOptions: function(e) {
  var t = { delimiter: ",", doublequote: true, lineterminator: "\n", quotechar: '"', skipinitialspace: true, skipinitialrows: 0 };
  for (var n in e) t[n.toLowerCase()] = e[n];
  return t;
}, parse: function(e, t) {
  (!t || t && !t.lineterminator) && (e = CSVParser.normalizeLineTerminator(e, t));
  var n = CSVParser.normalizeDialectOptions(t);
  e = CSVParser.chomp(e, n.lineterminator);
  var o, r, i = "", a = false, s = false, l = "", c = [], u = [];
  for (r = function(e2) {
    var t2 = String.prototype.trim ? function(e3) {
      return e3.trim();
    } : function(e3) {
      return e3.replace(/^\s*/, "").replace(/\s*$/, "");
    };
    return true !== s && ("" === e2 ? e2 = null : true === n.skipinitialspace && (e2 = t2(e2)), /^\d+$/.test(e2) ? e2 = parseInt(e2, 10) : /^\d*\.\d+$|^\d+\.\d*$/.test(e2) && (e2 = parseFloat(e2, 10))), e2;
  }, o = 0; o < e.length; o += 1) i = e.charAt(o), false !== a || i !== n.delimiter && i !== n.lineterminator ? i !== n.quotechar ? l += i : a ? e.charAt(o + 1) === n.quotechar ? (l += n.quotechar, o += 1) : a = false : (a = true, s = true) : (l = r(l), c.push(l), i === n.lineterminator && (u.push(c), c = []), l = "", s = false);
  return l = r(l), c.push(l), u.push(c), n.skipinitialrows && (u = u.slice(n.skipinitialrows)), u;
}, normalizeLineTerminator: function(e, t) {
  return (t = t || {}).lineterminator ? e : e.replace(/(\r\n|\n|\r)/gm, "\n");
}, chomp: function(e, t) {
  return e.charAt(e.length - t.length) !== t ? e : e.substring(0, e.length - t.length);
} };
var LINE_DEFAULT_DIR = new Vector3(1, 0, 0);
var _tmpVec = new Vector3();
var _tmpVec2 = new Vector3();
var _tmpQuat = new Quaternion();
var LineHTML = class extends Mesh {
  constructor(e, t) {
    e = void 0 !== e ? e : new Color(1, 0, 0), t = void 0 !== t ? t : 2;
    const n = new MeshLine();
    n.setGeometry([0, 0, 0, LINE_DEFAULT_DIR.x, LINE_DEFAULT_DIR.y, LINE_DEFAULT_DIR.z]);
    const o = new MeshLineMaterial({ color: e, lineWidth: t, sizeAttenuation: 0 });
    super(n.geometry, o), this.isLineHTML = true, this.elemHTML = null, this.offset = 5;
  }
  onBeforeRender(e, t, n, o, r, i) {
    if (super.onBeforeRender(), !this.elemHTML) return;
    const a = e.domElement.offsetWidth, s = e.domElement.offsetHeight, l = this.elemHTML.getBoundingClientRect(), c = e.domElement.getBoundingClientRect(), u = l.left - c.left, d = l.right - c.left, h = l.top - c.top, f = l.bottom - c.top, p = (u + d) / 2, m = (h + f) / 2, g = this.getWorldPosition(_tmpVec).project(n), _ = (g.x + 1) / 2 * a, A = (1 - g.y) / 2 * s, v = (m - A) / (p - _), x = (l.height + 2 * this.offset) / (l.width + 2 * this.offset);
    let y, b;
    Math.abs(v) > x ? (b = A > m ? Math.min(f + this.offset, A) : Math.max(h - this.offset, A), y = (b - A) / v + _) : (y = _ < p ? Math.max(u - this.offset, _) : Math.min(d + this.offset, _), b = (y - _) * v + A);
    const C = 2 * y / a - 1, S = 1 - 2 * b / s, M = _tmpVec2.set(C, S, -1);
    M.unproject(n), this.parent && this.parent.worldToLocal(M);
    const E = M.length();
    this.scale.setScalar(E), M.normalize();
    const T = _tmpQuat.setFromUnitVectors(LINE_DEFAULT_DIR, M);
    this.setRotationFromQuaternion(T), this.updateMatrixWorld();
  }
};
function Preloader() {
}
Object.assign(Preloader.prototype, { onUpdate: function(e) {
}, onFinish: function() {
} });
var SimplePreloader = class extends Preloader {
  constructor(e) {
    super();
    for (let t in e) {
      const n = e[t];
      if ("container" === t) void 0 === n ? this.container = document.body : n instanceof HTMLElement ? this.container = n : this.container = document.getElementById(n);
    }
    this.bar = document.createElement("div"), this.bar.setAttribute("class", "v3d-simple-preloader-bar"), this.logo = document.createElement("div"), this.logo.setAttribute("class", "v3d-simple-preloader-logo"), this.logoCont = document.createElement("div"), this.logoCont.setAttribute("id", "v3d_preloader_container"), this.logoCont.setAttribute("class", "v3d-simple-preloader-container"), this.background = document.createElement("div"), this.background.setAttribute("class", "v3d-simple-preloader-background"), this.background.appendChild(this.logoCont), this.logoCont.appendChild(this.logo), this.logoCont.appendChild(this.bar), this.container.appendChild(this.background), this.clock = new Clock();
  }
  onUpdate(e) {
    super.onUpdate(e), e = Math.round(e), this.bar.style.width = e + "%";
  }
  onFinish() {
    super.onFinish(), this.container.removeChild(this.background);
  }
};
var EDITOR_JS_FILE = "puzzles.min.js";
var PuzzlesLoader = class {
  _logicFileLoadError(e) {
    const t = new Error(e);
    return t.name = "LogicFileLoadError", t;
  }
  _editorLoadError(e) {
    const t = new Error(e);
    return t.name = "EditorLoadError", t;
  }
  async _getLogicPromise(e) {
    var _a2, _b, _c;
    const t = getGlobalScope(), n = new URL(e, document.baseURI).href;
    try {
      const e2 = (_b = (_a2 = await import(
        /* webpackIgnore: true */
        n
      )).createPL) == null ? void 0 : _b.call(_a2);
      return await ((_c = e2 == null ? void 0 : e2.loadPhysics) == null ? void 0 : _c.call(e2)), e2 ?? t.v3d.PL ?? null;
    } catch (e2) {
      throw this._logicFileLoadError(`Unable to load the logic file: '${n}'.`);
    }
  }
  _getEditorPromise(e, t) {
    const n = this;
    return new Promise(function(t2, o) {
      AppUtils.loadScript(e, document.body, function() {
        t2();
      }, function() {
        o(n._editorLoadError("Unable to load the Puzzles Editor: '" + e + "'."));
      });
    });
  }
  async _getLogicViaEditorPromise(e, t) {
    const n = getGlobalScope();
    if (!n.v3d || !n.v3d.PE) throw this._editorLoadError("Unable to load Puzzles' logic. The Puzzles Editor isn't loaded.");
    const o = t.split(".");
    o[o.length - 1] = "xml";
    const r = o.join("."), { PL: i, logicXMLLoaded: a } = await n.v3d.PE.init(e, r);
    if (!a) throw this._logicFileLoadError(`Unable to load the Puzzles Editor's XML logic file: '${r}'.`);
    return i;
  }
  _getAmmoJSPromise() {
    const e = document.getElementsByTagName("script");
    let t = false;
    for (let n = e.length - 1; n >= 0; --n) {
      if (e[n].src.search(/ammo.wasm.js/) > -1) {
        t = true;
        break;
      }
    }
    return new Promise(function(e2, n) {
      if (t && window.Ammo) console.warn("You have ammo.wasm.js assigned in app html, please remove it"), e2();
      else if (t && !window.Ammo) {
        console.warn("You have ammo.wasm.js assigned in app html, please remove it and resave Puzzles");
        const t2 = findModulePath("ammo.wasm.js");
        import(
          /* webpackIgnore: true */
          t2
        ).then((t3) => {
          let o = t3.default;
          o ? new o().then((t4) => {
            window.Ammo = t4, e2();
          }) : n(new Error("Failed to load physics module"));
        });
      } else e2();
    });
  }
  async loadLogic(e, t, n) {
    try {
      const n2 = await this._getLogicPromise(e);
      return await this._getAmmoJSPromise(), t && t(), n2;
    } catch (e2) {
      console.error(e2), n && n(e2);
    }
  }
  async loadEditorWithLogic(e, t, n, o) {
    try {
      let o2 = null;
      await this._getEditorPromise(e + EDITOR_JS_FILE);
      try {
        o2 = await this._getLogicViaEditorPromise(e, t);
      } catch (e2) {
        if ("LogicFileLoadError" !== e2.name) throw e2;
      }
      return await this._getAmmoJSPromise(), n && n(), o2;
    } catch (e2) {
      console.error(e2), o && o(e2);
    }
  }
};
function CubeTextureHelper(e) {
  Mesh.call(this), this.type = "CubeTextureHelper", this.geometry = new BoxGeometry(2, 2, 2, 1, 1, 1), this.geometry.computeBoundingSphere(), this.material = new MeshBasicMaterial(), this.material.envMap = e;
}
CubeTextureHelper.prototype = Object.create(Mesh.prototype), CubeTextureHelper.prototype.constructor = CubeTextureHelper;
var AnnotationControl = class extends Object3D {
  constructor(e) {
    super(), this.isAnnotationControl = true, this.doUpdate = true, this.projected = new Vector3(), this.container = e, this.updatedCallback = null;
  }
  clone() {
    return new this.constructor(this.container).copy(this);
  }
  update(e) {
    if (this.doUpdate) {
      var t = this.projected;
      this.getWorldPosition(t).project(e);
      var n = this.container.offsetWidth, o = this.container.offsetHeight, r = (0.5 + t.x / 2) * n, i = (0.5 - t.y / 2) * o;
      t.x = r, t.y = i;
      var a = t.z <= 1 && r >= 0 && r <= n && i >= 0 && i <= o;
      this.visible = a, this.updatedCallback && this.updatedCallback(t.x, t.y, a);
    }
  }
};
var _raycaster = new Raycaster();
var _camPos = new Vector3();
var _annoPos = new Vector3();
var _dir = new Vector3();
var Annotation = class extends AnnotationControl {
  constructor(e, t, n) {
    super(e), this.isAnnotation = true, this.type = "Annotation", this.character = t, this.dialogContents = n, this.annotation = document.createElement("div"), this.annotation.innerHTML = t, this.annotation.className = "v3d-annotation", this.container.appendChild(this.annotation), this.annotationDialogVisible = false, this.annotationDialog = document.createElement("div"), this.annotationDialog.innerHTML = n, this.annotationDialog.className = "v3d-annotation-dialog", this.annotation.appendChild(this.annotationDialog), this.fadeObscured = true, this.obscured = false;
    var o = false, r = this;
    function i(e2) {
      e2.target == r.annotation ? 0 == r.annotationDialog.innerHTML.length || r.obscured || (r.annotationDialogVisible = !r.annotationDialogVisible, r.annotationDialog.style.visibility = r.annotationDialogVisible ? "visible" : "hidden", r.annotationDialogVisible ? r.annotation.style.zIndex = "2" : r.annotation.style.zIndex = "1") : e2.target.className.indexOf("v3d-annotation") > -1 && (r.annotationDialogVisible = false, r.annotationDialog.style.visibility = "hidden", r.annotation.style.zIndex = r.obscured ? "auto" : "1");
    }
    this._touchstartCb = function(e2) {
      i(e2), o = true;
    }, document.body.addEventListener("touchstart", this._touchstartCb, false), this._mousedownCb = function(e2) {
      o || i(e2), o = false;
    }, document.body.addEventListener("mousedown", this._mousedownCb, false);
  }
  raycast() {
  }
  clone() {
    return new this.constructor(this.container, this.character, this.dialogContents).copy(this);
  }
  update(e) {
    if (super.update(e), this.doUpdate) {
      var t = this.projected, n = this.annotation;
      if (n.style.transform = "translate(" + t.x + "px, " + t.y + "px)", n.style.visibility = this.visible ? "visible" : "hidden", this.annotationDialog.style.visibility = this.visible && this.annotationDialogVisible ? "visible" : "hidden", this.fadeObscured) {
        e.getWorldPositionNU(_camPos), this.getWorldPositionNU(_annoPos), _dir.copy(_annoPos).sub(_camPos).normalize(), _raycaster.set(_camPos, _dir), _raycaster.far = _camPos.distanceTo(_annoPos);
        var o = _raycaster.intersectObject(this.findRoot(), true);
        o.length > 1 || 1 == o.length && o[0].object != this.parent ? (n.classList.add("v3d-annotation-transparent"), this.obscured = true, n.style.zIndex = "auto", this.annotationDialog.style.visibility = "hidden") : (n.classList.remove("v3d-annotation-transparent"), n.style.zIndex = "visible" == this.annotationDialog.style.visibility ? "2" : "1", this.obscured = false);
      }
    }
  }
  setDialogVisibility(e) {
    e ? (this.annotationDialogVisible = true, this.annotationDialog.style.visibility = "visible", this.annotation.style.zIndex = "2") : (this.annotationDialogVisible = false, this.annotationDialog.style.visibility = "hidden", this.annotation.style.zIndex = "1");
  }
  dispose() {
    var e = this.annotation.parentElement;
    e && e.removeChild(this.annotation), document.body.removeEventListener("touchstart", this._touchstartCb, false), document.body.removeEventListener("mousedown", this._mousedownCb, false);
  }
};
var _vec3Tmp = new Vector3();
var _quatTmp = new Quaternion();
var _quatTmp2 = new Quaternion();
function translateVRCamera(e, t, n) {
  const o = e.parent;
  o && !o.isScene && (_vec3Tmp.copy(t).applyQuaternion(e.quaternion).applyQuaternion(o.quaternion), o.position.add(_vec3Tmp.multiplyScalar(n)));
}
function rotateVRCamera(e, t, n) {
  const o = e.parent;
  o && !o.isScene && (_quatTmp.setFromAxisAngle(t, n), _quatTmp.premultiply(e.quaternion), _quatTmp.premultiply(o.quaternion), o.quaternion.multiplyQuaternions(_quatTmp, _quatTmp2.copy(e.quaternion).invert()));
}
var WebXRUtils = Object.freeze({ __proto__: null, rotateVRCamera, translateVRCamera });
var cssText = `.v3d-container {
    
    overflow: hidden;
    z-index: 0;
}
.v3d-canvas {
    
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    
    z-index: -1;
}
.v3d-simple-preloader-background {
    background-color: #fff;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1;
    height: 100%;
    width: 100%;
}
.v3d-simple-preloader-container {
    --v3d-preloader-img-width: 120px;
    --v3d-preloader-img-height: 120px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: calc(var(--v3d-preloader-img-width) + 60px);
    height: calc(var(--v3d-preloader-img-height) + 60px);
}
.v3d-simple-preloader-bar {
    background: linear-gradient(90deg, #1458ae, #4388e0);
    width: 0%;
    height: 3px;
    margin: 15px -1px;
    border: 1px solid;
    border-radius: 50px;
    border-color: #2b70c7;
}
.v3d-simple-preloader-logo {
    width: var(--v3d-preloader-img-width);
    height: var(--v3d-preloader-img-height);
    background-image: url('data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="120" height="120" viewBox="0 0 31.75 31.75" version="1.1" id="svg5409" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns%23" xmlns:cc="http://creativecommons.org/ns%23" xmlns:dc="http://purl.org/dc/elements/1.1/"%3E%3Cdefs id="defs5403"%3E%3ClinearGradient xlink:href="%23linearGradient3077" id="linearGradient4375" gradientUnits="userSpaceOnUse" x1="172.91336" y1="78.689407" x2="193.7847" y2="53.806618" gradientTransform="matrix(1.1562901,0,0,1.1583991,-194.29093,208.80811)" /%3E%3ClinearGradient id="linearGradient3077"%3E%3Cstop style="stop-color:%230048a5;stop-opacity:1" offset="0" id="stop3073" /%3E%3Cstop style="stop-color:%234b86d1;stop-opacity:1" offset="1" id="stop3075" /%3E%3C/linearGradient%3E%3C/defs%3E%3Cmetadata id="metadata5406"%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=""%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cg id="layer1" transform="translate(0,-270.54167)"%3E%3Cpath style="display:inline;fill:url(%23linearGradient4375);fill-opacity:1;stroke:none;stroke-width:0.9171;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="m 15.945207,270.5417 c -1.669933,-0.007 -3.344811,1.1051 -7.2273169,3.32785 -7.76503612,4.4455 -7.2281318,3.52338 -7.2677439,12.48309 -0.03948,8.95973 -0.56829626,8.03286 7.1571159,12.5471 7.7254249,4.51422 6.6598479,4.50948 14.4248479,0.064 7.765036,-4.4455 7.228132,-3.52338 7.267744,-12.48309 0.03948,-8.95973 0.568296,-8.03287 -7.157116,-12.5471 -3.862718,-2.25711 -5.527635,-3.38445 -7.197531,-3.39185 z m -0.0132,2.85167 c 1.6836,0.007 3.363685,0.8128 6.115359,2.4207 5.503323,3.21577 6.107199,4.27438 6.078963,10.65695 -0.02832,6.3826 -0.641388,7.43578 -6.172923,10.60259 -5.531523,3.16682 -6.748576,3.16139 -12.2518993,-0.0544 -5.503299,-3.21578 -6.1071633,-4.27439 -6.0789633,-10.65697 0.02844,-6.38259 0.6413884,-7.43577 6.1729353,-10.6026 2.7657613,-1.5834 4.4529153,-2.37377 6.1365283,-2.3663 z m -0.154249,1.6177 c -2.694169,0.0343 -5.683359,3.07006 -7.236352,6.07548 -1.5776528,3.05311 -2.4803533,5.94456 -2.1086051,9.65753 0.1618801,1.61652 1.6983849,3.67982 3.5378539,4.71425 -0.3909602,-3.2062 -0.1707481,-6.34306 0.5400002,-8.94693 0.71076,-2.60387 2.83223,-6.82883 5.337159,-6.82316 2.504954,0.006 4.626375,4.22704 5.337123,6.83091 0.710725,2.60386 0.930961,5.74073 0.539989,8.94693 1.839481,-1.03442 3.375985,-3.09779 3.537853,-4.71432 0.371749,-3.71296 -0.53082,-6.60428 -2.108485,-9.6574 -1.547604,-2.99499 -4.52153,-6.01988 -7.24846,-6.08267 -0.0426,-9.5e-4 -0.08532,-10e-4 -0.128028,-6.2e-4 z m 0.131713,8.9184 a 2.4731483,2.4776591 0 0 0 -1.188637,0.29153 2.4731483,2.4776591 0 0 0 -1.017889,3.35228 2.4731483,2.4776591 0 0 0 3.34619,1.01974 2.4731483,2.4776591 0 0 0 1.017877,-3.35231 2.4731483,2.4776591 0 0 0 -2.157541,-1.31124 z" id="path4130" /%3E%3C/g%3E%3C/svg%3E');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    margin: 20px auto;
}
.v3d-annotation {
    position: absolute;
    top: -0.7em;
    left: -0.5em;
    width: auto;
    min-width: 1em;
    height: 1.4em;
    padding: 0.3em 0.5em;
    border: 1px solid #fff;
    border-radius: 2em;
    font-size: 16px;
    font-family: sans-serif;
    line-height: 1.4em;
    color: #fff;
    text-align: center;
    user-select: none;
    background: rgba(0, 0, 0, 0.8);
}
.v3d-annotation-transparent {
    opacity: 0.5;
}
.v3d-annotation-dialog {
    position: absolute;
    top: 85%;
    left: 85%;
    font-family: sans-serif;
    user-select: none;
    padding: 1em;
    min-width: 200px;
    color: #fff;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 1em;
    font-size: 12px;
    line-height: 1.2;
    transition: opacity .5s;
    visibility: hidden;
}
.v3d-mobile-forward {
    position: absolute;
    width: 62px;
    height: 62px;
    bottom: 31px;
    left: 50%;
    margin-left: -31px;
    background-image: url('data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="62" height="62" viewBox="0 0 16.404167 16.404167" version="1.1" id="svg2719" sodipodi:docname="move_forward.svg" inkscape:version="1.1.2 (b8e25be833, 2022-02-05)" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns%23" xmlns:cc="http://creativecommons.org/ns%23" xmlns:dc="http://purl.org/dc/elements/1.1/"%3E%3Csodipodi:namedview id="namedview7548" pagecolor="%23505050" bordercolor="%23eeeeee" borderopacity="1" inkscape:pageshadow="0" inkscape:pageopacity="0" inkscape:pagecheckerboard="0" showgrid="false" inkscape:snap-global="false" inkscape:zoom="7.1451613" inkscape:cx="42.266366" inkscape:cy="15.814898" inkscape:window-width="1920" inkscape:window-height="1137" inkscape:window-x="-8" inkscape:window-y="-8" inkscape:window-maximized="1" inkscape:current-layer="svg2719" /%3E%3Cdefs id="defs2713"%3E%3ClinearGradient gradientTransform="translate(-524.2581,-935.78503)" xlink:href="%23linearGradient2768" id="linearGradient2673" x1="501.88306" y1="942.95502" x2="508.08038" y2="935.61182" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient id="linearGradient2768"%3E%3Cstop style="stop-color:%23414141;stop-opacity:1" offset="0" id="stop2764" /%3E%3Cstop style="stop-color:%23767676;stop-opacity:1" offset="1" id="stop2766" /%3E%3C/linearGradient%3E%3ClinearGradient gradientTransform="translate(-521.96226,-941.8579)" xlink:href="%23linearGradient2648" id="linearGradient2665" x1="495.62714" y1="948.00964" x2="508.85629" y2="934.78046" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient id="linearGradient2648"%3E%3Cstop style="stop-color:%23ebebeb;stop-opacity:1" offset="0" id="stop2644" /%3E%3Cstop style="stop-color:%23ffffff;stop-opacity:1" offset="1" id="stop2646" /%3E%3C/linearGradient%3E%3Cfilter style="color-interpolation-filters:sRGB" id="filter2688" x="-0.12" width="1.24" y="-0.12" height="1.24"%3E%3CfeGaussianBlur stdDeviation="0.66145835" id="feGaussianBlur2690" /%3E%3C/filter%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient2768" id="linearGradient7749" x1="6.0107598" y1="11.942085" x2="11.430239" y2="4.0917845" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient2648" id="linearGradient8251" x1="4.2536402" y1="13.238126" x2="12.150527" y2="2.9068334" gradientUnits="userSpaceOnUse" /%3E%3Cfilter inkscape:collect="always" style="color-interpolation-filters:sRGB" id="filter8772" x="-0.10840111" y="-0.10840111" width="1.2168022" height="1.2168022"%3E%3CfeGaussianBlur inkscape:collect="always" stdDeviation="0.59752352" id="feGaussianBlur8774" /%3E%3C/filter%3E%3C/defs%3E%3Cmetadata id="metadata2716"%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=""%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Ccircle style="fill:%23000000;stroke-width:0.230841;stroke-linecap:round;stroke-linejoin:round;fill-opacity:0.5;filter:url(%23filter8772)" id="circle8626" cx="8.2020836" cy="8.2020836" r="6.6145835" /%3E%3Ccircle style="fill:url(%23linearGradient8251);stroke-width:0.230841;stroke-linecap:round;stroke-linejoin:round;fill-opacity:1" id="path7652" cx="8.2020836" cy="8.2020836" r="6.6145835" /%3E%3Cpath d="m 4.2333333,6.7138018 c 0,0.9875367 0.4960933,2.4804692 0.4960933,2.4804692 h 1.984375 c 0,-0.7441408 0.2480473,-1.1782225 0.496094,-1.612305 0.2480467,-0.4340817 0.4960942,-0.8681642 0.4960942,-1.6123037 0,-0.8743657 -0.2480475,-2.7285166 -1.4882817,-2.7285166 -1.240234,0 -1.9843749,1.9843749 -1.9843748,3.4726561 z m 1.4882816,4.4648442 c 0.5472533,0 0.9921867,-0.444934 0.9921867,-0.992188 V 9.6903643 h -1.984375 v 0.4960937 c 0,0.547254 0.4449341,0.992188 0.9921883,0.992188 z M 12.170834,8.6981768 c 0,-1.4882808 -0.744141,-3.4726553 -1.984376,-3.4726553 -1.240234,0 -1.4882807,1.8541503 -1.4882807,2.7285153 0,0.74414 0.2480467,1.1782226 0.4960933,1.6123041 0.2480467,0.4340821 0.4960934,0.8681641 0.4960934,1.6123051 h 1.984376 c 0,0 0.496094,-1.4929325 0.496094,-2.4804692 z m -1.488281,4.4648442 c 0.547253,0 0.992187,-0.444935 0.992187,-0.992188 V 11.674739 H 9.690364 v 0.496094 c 0,0.547253 0.444935,0.992188 0.992189,0.992188 z" id="path7734" style="stroke-width:0.0155029;fill-opacity:1;fill:url(%23linearGradient7749)" /%3E%3C/svg%3E');
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
}
.v3d-webgl-error-container {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -80px;
    margin-left: -200px;
    width: 400px;
    height: 160px;
    text-align: center;
    z-index: 10;
}
.v3d-webgl-error-image {
    width: 160px;
    height: 160px;
    background-repeat: no-repeat;
    margin: 0px auto;
    background-image: url('data:image/svg+xml,%3C%3Fxml version="1.0" encoding="UTF-8" standalone="no"%3F%3E%3Csvg width="160" height="160" viewBox="0 0 42.333332 42.333333" version="1.1" id="svg1" inkscape:version="1.3 (0e150ed6c4, 2023-07-21)" sodipodi:docname="webgl-error.svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"%3E%3Csodipodi:namedview id="namedview1" pagecolor="%23ffffff" bordercolor="%23eeeeee" borderopacity="1" inkscape:showpageshadow="false" inkscape:pageopacity="0" inkscape:pagecheckerboard="false" inkscape:deskcolor="%23d1d1d1" inkscape:document-units="px" labelstyle="default" shape-rendering="auto" inkscape:clip-to-page="false" inkscape:zoom="1.6017536" inkscape:cx="-5.3066837" inkscape:cy="78.97594" inkscape:window-width="1920" inkscape:window-height="1137" inkscape:window-x="-8" inkscape:window-y="-8" inkscape:window-maximized="1" inkscape:current-layer="layer1" /%3E%3Cdefs id="defs1"%3E%3Cfilter inkscape:collect="always" style="color-interpolation-filters:sRGB" id="filter1" x="-0.18167429" y="-0.16562716" width="1.3633486" height="1.3312543"%3E%3CfeGaussianBlur inkscape:collect="always" stdDeviation="2.1910722" id="feGaussianBlur1" /%3E%3C/filter%3E%3ClinearGradient inkscape:collect="always" xlink:href="%23linearGradient3259" id="linearGradient10" x1="863.9444" y1="1424.3892" x2="892.88947" y2="1424.3892" gradientUnits="userSpaceOnUse" /%3E%3ClinearGradient inkscape:collect="always" id="linearGradient3259"%3E%3Cstop style="stop-color:%23c90000;stop-opacity:1" offset="0" id="stop3255" /%3E%3Cstop style="stop-color:%23ff0a0a;stop-opacity:1" offset="1" id="stop3257" /%3E%3C/linearGradient%3E%3C/defs%3E%3Cg inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1"%3E%3Cg id="g2" style="display:inline" transform="translate(-857.25025,-1403.2226)"%3E%3Cpath id="path10" style="fill:%23e40505;fill-opacity:0.4;stroke-width:0.0581876;filter:url(%23filter1)" d="m 878.41691,1413.9426 c 1.49459,-0.033 2.34009,1.1428 2.29362,2.1957 l -0.39169,8.8754 c -0.0465,1.0529 -0.84799,1.9018 -1.90193,1.9018 -1.05394,0 -1.8516,-0.8491 -1.90193,-1.9018 l -0.42433,-8.8754 c -0.0503,-1.0527 0.83167,-2.163 2.32626,-2.1957 z m -0.18948,15.5145 c 1.4715,-0.1102 2.72596,1.0544 2.72522,2.53 0.0257,3.4066 -5.09721,3.4066 -5.07148,0 -6.7e-4,-1.3275 1.02252,-2.4308 2.34626,-2.53 z m 0.26002,-20.9425 c -1.67293,-0.01 -3.35083,1.1046 -7.24038,3.3274 -7.77912,4.4454 -7.24153,3.5234 -7.28121,12.483 -0.0397,8.9596 -0.56935,8.0329 7.17011,12.547 7.73941,4.5142 6.67221,4.5096 14.45131,0.064 7.77911,-4.4455 7.241,-3.5233 7.28069,-12.483 0.0397,-8.9596 0.56933,-8.0328 -7.1701,-12.547 -3.86972,-2.257 -5.53749,-3.384 -7.21042,-3.3915 z m -0.0134,2.8509 v 6e-4 c 1.68666,0.01 3.37009,0.8126 6.12676,2.4205 5.51329,3.2157 6.11834,4.2746 6.09006,10.6572 -0.0283,6.3825 -0.64255,7.4357 -6.18411,10.6025 -5.54155,3.1668 -6.76089,3.161 -12.27419,-0.055 -5.51329,-3.2158 -6.11831,-4.2742 -6.09007,-10.6567 0.0284,-6.3825 0.64255,-7.4357 6.18412,-10.6025 2.77079,-1.5834 4.46077,-2.3737 6.14743,-2.3663 z" sodipodi:nodetypes="zssssszsccssssssssssccsssssssc" /%3E%3Cpath id="path3" style="fill:url(%23linearGradient10);stroke-width:0.0581876" d="m 878.41691,1413.9426 c 1.49459,-0.033 2.34009,1.1428 2.29362,2.1957 l -0.39169,8.8754 c -0.0465,1.0529 -0.84799,1.9018 -1.90193,1.9018 -1.05394,0 -1.8516,-0.8491 -1.90193,-1.9018 l -0.42433,-8.8754 c -0.0503,-1.0527 0.83167,-2.163 2.32626,-2.1957 z m -0.18948,15.5145 c 1.4715,-0.1102 2.72596,1.0544 2.72522,2.53 0.0257,3.4066 -5.09721,3.4066 -5.07148,0 -6.7e-4,-1.3275 1.02252,-2.4308 2.34626,-2.53 z m 0.26002,-20.9425 c -1.67293,-0.01 -3.35083,1.1046 -7.24038,3.3274 -7.77912,4.4454 -7.24153,3.5234 -7.28121,12.483 -0.0397,8.9596 -0.56935,8.0329 7.17011,12.547 7.73941,4.5142 6.67221,4.5096 14.45131,0.064 7.77911,-4.4455 7.241,-3.5233 7.28069,-12.483 0.0397,-8.9596 0.56933,-8.0328 -7.1701,-12.547 -3.86972,-2.257 -5.53749,-3.384 -7.21042,-3.3915 z m -0.0134,2.8509 v 6e-4 c 1.68666,0.01 3.37009,0.8126 6.12676,2.4205 5.51329,3.2157 6.11834,4.2746 6.09006,10.6572 -0.0283,6.3825 -0.64255,7.4357 -6.18411,10.6025 -5.54155,3.1668 -6.76089,3.161 -12.27419,-0.055 -5.51329,-3.2158 -6.11831,-4.2742 -6.09007,-10.6567 0.0284,-6.3825 0.64255,-7.4357 6.18412,-10.6025 2.77079,-1.5834 4.46077,-2.3737 6.14743,-2.3663 z" sodipodi:nodetypes="zssssszsccssssssssssccsssssssc" /%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
    background-size: 100% 100%;
}
.v3d-webgl-error {
    font-family: Arial;
    font-size: 16px;
}
.v3d-webgl-error-link {
    font-style: italic;
    font-weight: bolder;
}
.v3d-webgl-error-link {
    color: #015fb1;
}
.v3d-device-motion-permissions-dialog {
    z-index: 1;
    position: absolute;
    width: 100%;
    background-color: #f00;
    color: #000;
    text-align: center;
    padding: 10px;
}
`;
if ("undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "4.9.2" } })), "undefined" != typeof window && (window.__V3D__ ? console.warn("WARNING: Multiple instances of Verge3D being imported.") : window.__V3D__ = "4.9.2"), "undefined" != typeof document) {
  const e = document.createElement("style");
  e.appendChild(document.createTextNode(cssText)), document.head.insertBefore(e, document.head.firstChild);
}
export {
  ACESFilmicToneMapping,
  AVERAGE,
  AddEquation,
  AddOperation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AgXBlenderToneMapping,
  AlphaFormat,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AmbientLightProbe,
  AnimationClip,
  AnimationLoader,
  AnimationMixer,
  AnimationObjectGroup,
  AnimationUtils,
  Annotation,
  AnnotationControl,
  App,
  AppUtils,
  ArcCurve,
  ArrayCamera,
  ArrowHelper,
  Audio,
  AudioAnalyser,
  AudioContext,
  AudioListener,
  AudioLoader,
  AxesHelper,
  BackSide,
  BasicDepthPacking,
  BasicShadowMap,
  BilinearShadowMap,
  BlenderTextBufferGeometry,
  BlenderTextGeometry,
  BloomPass,
  BokehPass,
  Bone,
  BooleanKeyframeTrack,
  Box2,
  Box3,
  Box3Helper,
  BoxGeometry,
  BoxHelper,
  BrightnessContrastPass,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  BufferGeometryUtils,
  ByteType,
  CENTER,
  CSVParser,
  Cache,
  Camera,
  CameraHelper,
  CameraUtils,
  CanvasBreakpointsConstraint,
  CanvasFitConstraint,
  CanvasTexture,
  CapsuleGeometry,
  CatmullRomCurve3,
  ChildOfConstraint,
  CineonToneMapping,
  CircleGeometry,
  ClampToEdgeWrapping,
  ClearMaskPass,
  Clock,
  Color,
  ColorKeyframeTrack,
  ColorManagement,
  Compat,
  CompressedArrayTexture,
  CompressedTexture,
  CompressedTextureLoader,
  ConeGeometry,
  Constraint,
  ConstraintSpaceCustom,
  ConstraintSpaceLocal,
  ConstraintSpaceWorld,
  ControlSettings,
  CopyLocationConstraint,
  CopyRotationConstraint,
  CopyScaleConstraint,
  CopyTransformsConstraint,
  CubeCamera,
  CubeCopy,
  CubeReflectionMapping,
  CubeReflectionProbe,
  CubeRefractionMapping,
  CubeTexture,
  CubeTextureHelper,
  CubeTextureLoader,
  CubeUVReflectionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CubicInterpolant,
  CullFaceBack,
  CullFaceFront,
  CullFaceFrontBack,
  CullFaceNone,
  Curve,
  CurvePath,
  CustomBlending,
  CustomToneMapping,
  CylinderGeometry,
  Cylindrical,
  DampedTrackConstraint,
  Data3DTexture,
  DataArrayTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  Detector,
  DirectionalLight,
  DirectionalLightCSMHelper,
  DirectionalLightHelper,
  DiscreteInterpolant,
  DodecahedronGeometry,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicCopyUsage,
  DynamicDrawUsage,
  DynamicReadUsage,
  ESMDistancePacking,
  ESMShadowMap,
  EdgesGeometry,
  EffectComposer,
  EllipseCurve,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  ExtrudeGeometry,
  FXAAPass,
  FileLoader,
  FilmicBlenderToneMapping,
  FirstPersonControls,
  FixOrthoZoomConstraint,
  Float16BufferAttribute,
  Float32BufferAttribute,
  Float64BufferAttribute,
  FloatType,
  FloorConstraint,
  FlyingControls,
  Fog,
  FogExp2,
  Font,
  FramebufferTexture,
  FrontSide,
  Frustum,
  GLBufferAttribute,
  GLSL1,
  GLSL3,
  GLTFExporter,
  GLTFLoader,
  GTAOMapGenerator,
  GraphUtils,
  GrayscalePass,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group,
  HalfFloatType,
  HemisphereLight,
  HemisphereLightHelper,
  HemisphereLightProbe,
  IBLEnvironmentNone,
  IBLEnvironmentPMREM,
  IBLEnvironmentProbe,
  IcosahedronGeometry,
  ImageBitmapLoader,
  ImageLoader,
  ImageUtils,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute$1 as InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  Int16BufferAttribute,
  Int32BufferAttribute,
  Int8BufferAttribute,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  InvertStencilOp,
  KeepStencilOp,
  KeyframeTrack,
  Keys,
  LOD,
  LatheGeometry,
  Layers,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Light,
  LightProbe,
  LightProbeGenerator,
  LimitDistanceConstraint,
  LimitLocationConstraint,
  LimitRotationConstraint,
  LimitScaleConstraint,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineDashedMaterial,
  LineHTML,
  LineLoop,
  LineSegments,
  LinearDepthPacking,
  LinearEncoding,
  LinearFilter,
  LinearInterpolant,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  Loader,
  LoaderUtils,
  LoadingManager,
  LockedTrackConstraint,
  LogarithmicMaxToneMapping,
  LoopOnce,
  LoopPingPong,
  LoopRepeat,
  LuminanceAlphaFormat,
  LuminanceFormat,
  MOD_SUITE,
  MOUSE,
  MaskPass,
  Material,
  MaterialLoader,
  MaterialUtils,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBVH,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshLine,
  MeshLineIndexed,
  MeshLineMaterial,
  MeshMaskMaterial,
  MeshMatcapMaterial,
  MeshNodeMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MotionPathConstraint,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace,
  NoOIT,
  NoToneMapping,
  NormalAnimationBlendMode,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  OITWeighted,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronGeometry,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrbitControls,
  OrthographicCamera,
  OutlinePass,
  PCFShadowMap,
  PCFShadowMapPoissonDisk,
  PCFSoftShadowMap,
  PMREMGenerator,
  Pass,
  Path,
  PbrNeutralToneMapping,
  PerspectiveCamera,
  PhysicalMaxToneMapping,
  Plane,
  PlaneGeometry,
  PlaneHelper,
  PointLight,
  PointLightHelper,
  Points,
  PointsMaterial,
  PolarGridHelper,
  PolyhedronGeometry,
  PositionalAudio,
  Preloader,
  PropertyBinding,
  PropertyMixer,
  PuzzlesLoader,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  Quaternion,
  QuaternionKeyframeTrack,
  QuaternionLinearInterpolant,
  REVISION,
  RGBADepthPacking,
  RGBADistancePacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBELoader,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RectAreaLight,
  RectAreaLightUniformsLib,
  RedFormat,
  RedIntegerFormat,
  ReflectionProbeTypeBox,
  ReflectionProbeTypeInfinite,
  ReflectionProbeTypeSphere,
  ReinhardToneMapping,
  RenderPass,
  RenderUtils,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  RingGeometry,
  SAH,
  SRGBColorSpace,
  SSAARenderPass,
  SSAOPass,
  Scene,
  Color as SceneBackground,
  SceneUtils,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShaderPass,
  ShadowMaterial,
  Shape,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  SimplePreloader,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  Source,
  Sphere,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticCopyUsage,
  StaticDrawUsage,
  StaticReadUsage,
  Stats,
  StereoCamera,
  StreamCopyUsage,
  StreamDrawUsage,
  StreamReadUsage,
  StringKeyframeTrack,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TTFLoader,
  TangentSpaceNormalMap,
  TargetConstraint,
  TeapotGeometry,
  TetrahedronGeometry,
  TextGeometry,
  Texture,
  TextureLoader,
  ToneMapPass,
  ToneMappingLookAgXPunchy,
  ToneMappingLookNone,
  TorusGeometry,
  TorusKnotGeometry,
  TrackToConstraint,
  TransformationConstraint,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeGeometry,
  TweenCameraController,
  TweenLinear,
  TweenSpherical,
  TwoPassDoubleSide,
  USDZExporter,
  UVMapping,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  Uint8BufferAttribute,
  Uint8ClampedBufferAttribute,
  Uniform,
  UniformsGroup,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShortType,
  V3DL,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  VideoTexture,
  ViewportFitAuto,
  ViewportFitFill,
  ViewportFitHorizontal,
  ViewportFitNone,
  ViewportFitOverscan,
  ViewportFitVertical,
  WebGL3DRenderTarget,
  WebGLArrayRenderTarget,
  WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets,
  WebGLRenderTarget,
  WebGLRenderer,
  WebGLUtils,
  WebXRUtils,
  WireframeGeometry,
  WrapAroundEnding,
  Module as XZ,
  XZLoader,
  ZeroCurvatureEnding,
  ZeroFactor,
  ZeroSlopeEnding,
  ZeroStencilOp,
  _SRGBAFormat,
  acceleratedRaycast,
  arrayMax,
  arrayMin,
  clampArray,
  computeBoundsTree,
  disposeBoundsTree,
  engineVersionCmp,
  findModulePath,
  getGlobalScope,
  isDef,
  loadModule,
  sRGBEncoding,
  shaderFloatStr
};
//# sourceMappingURL=verge3d.js.map
